// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `econ_gcmessages.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CMsgApplyAutograph)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgApplyAutograph {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyAutograph.autograph_item_id)
    pub autograph_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyAutograph.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyAutograph.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyAutograph {
    fn default() -> &'a CMsgApplyAutograph {
        <CMsgApplyAutograph as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyAutograph {
    pub fn new() -> CMsgApplyAutograph {
        ::std::default::Default::default()
    }

    // optional uint64 autograph_item_id = 1;

    pub fn autograph_item_id(&self) -> u64 {
        self.autograph_item_id.unwrap_or(0)
    }

    pub fn clear_autograph_item_id(&mut self) {
        self.autograph_item_id = ::std::option::Option::None;
    }

    pub fn has_autograph_item_id(&self) -> bool {
        self.autograph_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autograph_item_id(&mut self, v: u64) {
        self.autograph_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_item_id = 2;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgApplyAutograph {
    const NAME: &'static str = "CMsgApplyAutograph";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.autograph_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.autograph_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.autograph_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyAutograph {
        CMsgApplyAutograph::new()
    }

    fn clear(&mut self) {
        self.autograph_item_id = ::std::option::Option::None;
        self.item_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyAutograph {
        static instance: CMsgApplyAutograph = CMsgApplyAutograph {
            autograph_item_id: ::std::option::Option::None,
            item_item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAdjustItemEquippedState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAdjustItemEquippedState {
    // message fields
    // @@protoc_insertion_point(field:CMsgAdjustItemEquippedState.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgAdjustItemEquippedState.new_class)
    pub new_class: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAdjustItemEquippedState.new_slot)
    pub new_slot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAdjustItemEquippedState.style_index)
    pub style_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAdjustItemEquippedState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAdjustItemEquippedState {
    fn default() -> &'a CMsgAdjustItemEquippedState {
        <CMsgAdjustItemEquippedState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgAdjustItemEquippedState {
    pub fn new() -> CMsgAdjustItemEquippedState {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 new_class = 2;

    pub fn new_class(&self) -> u32 {
        self.new_class.unwrap_or(0)
    }

    pub fn clear_new_class(&mut self) {
        self.new_class = ::std::option::Option::None;
    }

    pub fn has_new_class(&self) -> bool {
        self.new_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_class(&mut self, v: u32) {
        self.new_class = ::std::option::Option::Some(v);
    }

    // optional uint32 new_slot = 3;

    pub fn new_slot(&self) -> u32 {
        self.new_slot.unwrap_or(0)
    }

    pub fn clear_new_slot(&mut self) {
        self.new_slot = ::std::option::Option::None;
    }

    pub fn has_new_slot(&self) -> bool {
        self.new_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_slot(&mut self, v: u32) {
        self.new_slot = ::std::option::Option::Some(v);
    }

    // optional uint32 style_index = 4;

    pub fn style_index(&self) -> u32 {
        self.style_index.unwrap_or(255u32)
    }

    pub fn clear_style_index(&mut self) {
        self.style_index = ::std::option::Option::None;
    }

    pub fn has_style_index(&self) -> bool {
        self.style_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_index(&mut self, v: u32) {
        self.style_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgAdjustItemEquippedState {
    const NAME: &'static str = "CMsgAdjustItemEquippedState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.new_class = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.new_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.style_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.new_class {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.new_slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.style_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.new_class {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.new_slot {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.style_index {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAdjustItemEquippedState {
        CMsgAdjustItemEquippedState::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.new_class = ::std::option::Option::None;
        self.new_slot = ::std::option::Option::None;
        self.style_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAdjustItemEquippedState {
        static instance: CMsgAdjustItemEquippedState = CMsgAdjustItemEquippedState {
            item_id: ::std::option::Option::None,
            new_class: ::std::option::Option::None,
            new_slot: ::std::option::Option::None,
            style_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgEconPlayerStrangeCountAdjustment)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgEconPlayerStrangeCountAdjustment {
    // message fields
    // @@protoc_insertion_point(field:CMsgEconPlayerStrangeCountAdjustment.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEconPlayerStrangeCountAdjustment.strange_count_adjustments)
    pub strange_count_adjustments: ::std::vec::Vec<cmsg_econ_player_strange_count_adjustment::CStrangeCountAdjustment>,
    // @@protoc_insertion_point(field:CMsgEconPlayerStrangeCountAdjustment.turbo_mode)
    pub turbo_mode: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgEconPlayerStrangeCountAdjustment.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgEconPlayerStrangeCountAdjustment {
    fn default() -> &'a CMsgEconPlayerStrangeCountAdjustment {
        <CMsgEconPlayerStrangeCountAdjustment as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgEconPlayerStrangeCountAdjustment {
    pub fn new() -> CMsgEconPlayerStrangeCountAdjustment {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional bool turbo_mode = 3;

    pub fn turbo_mode(&self) -> bool {
        self.turbo_mode.unwrap_or(false)
    }

    pub fn clear_turbo_mode(&mut self) {
        self.turbo_mode = ::std::option::Option::None;
    }

    pub fn has_turbo_mode(&self) -> bool {
        self.turbo_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_turbo_mode(&mut self, v: bool) {
        self.turbo_mode = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgEconPlayerStrangeCountAdjustment {
    const NAME: &'static str = "CMsgEconPlayerStrangeCountAdjustment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.strange_count_adjustments.push(is.read_message()?);
                },
                24 => {
                    self.turbo_mode = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.strange_count_adjustments {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.turbo_mode {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.strange_count_adjustments {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.turbo_mode {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgEconPlayerStrangeCountAdjustment {
        CMsgEconPlayerStrangeCountAdjustment::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.strange_count_adjustments.clear();
        self.turbo_mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgEconPlayerStrangeCountAdjustment {
        static instance: CMsgEconPlayerStrangeCountAdjustment = CMsgEconPlayerStrangeCountAdjustment {
            account_id: ::std::option::Option::None,
            strange_count_adjustments: ::std::vec::Vec::new(),
            turbo_mode: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgEconPlayerStrangeCountAdjustment`
pub mod cmsg_econ_player_strange_count_adjustment {
    // @@protoc_insertion_point(message:CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CStrangeCountAdjustment {
        // message fields
        // @@protoc_insertion_point(field:CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment.event_type)
        pub event_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment.item_id)
        pub item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment.adjustment)
        pub adjustment: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CStrangeCountAdjustment {
        fn default() -> &'a CStrangeCountAdjustment {
            <CStrangeCountAdjustment as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CStrangeCountAdjustment {
        pub fn new() -> CStrangeCountAdjustment {
            ::std::default::Default::default()
        }

        // optional uint32 event_type = 1;

        pub fn event_type(&self) -> u32 {
            self.event_type.unwrap_or(0)
        }

        pub fn clear_event_type(&mut self) {
            self.event_type = ::std::option::Option::None;
        }

        pub fn has_event_type(&self) -> bool {
            self.event_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_type(&mut self, v: u32) {
            self.event_type = ::std::option::Option::Some(v);
        }

        // optional uint64 item_id = 2;

        pub fn item_id(&self) -> u64 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: u64) {
            self.item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 adjustment = 3;

        pub fn adjustment(&self) -> u32 {
            self.adjustment.unwrap_or(0)
        }

        pub fn clear_adjustment(&mut self) {
            self.adjustment = ::std::option::Option::None;
        }

        pub fn has_adjustment(&self) -> bool {
            self.adjustment.is_some()
        }

        // Param is passed by value, moved
        pub fn set_adjustment(&mut self, v: u32) {
            self.adjustment = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CStrangeCountAdjustment {
        const NAME: &'static str = "CStrangeCountAdjustment";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    24 => {
                        self.adjustment = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.event_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.item_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.adjustment {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.event_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.item_id {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.adjustment {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CStrangeCountAdjustment {
            CStrangeCountAdjustment::new()
        }

        fn clear(&mut self) {
            self.event_type = ::std::option::Option::None;
            self.item_id = ::std::option::Option::None;
            self.adjustment = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CStrangeCountAdjustment {
            static instance: CStrangeCountAdjustment = CStrangeCountAdjustment {
                event_type: ::std::option::Option::None,
                item_id: ::std::option::Option::None,
                adjustment: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgCraftingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCraftingResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgCraftingResponse.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCraftingResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCraftingResponse {
    fn default() -> &'a CMsgCraftingResponse {
        <CMsgCraftingResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgCraftingResponse {
    pub fn new() -> CMsgCraftingResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgCraftingResponse {
    const NAME: &'static str = "CMsgCraftingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                8 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.item_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCraftingResponse {
        CMsgCraftingResponse::new()
    }

    fn clear(&mut self) {
        self.item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCraftingResponse {
        static instance: CMsgCraftingResponse = CMsgCraftingResponse {
            item_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCRequestStoreSalesData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRequestStoreSalesData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesData.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesData.currency)
    pub currency: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRequestStoreSalesData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestStoreSalesData {
    fn default() -> &'a CMsgGCRequestStoreSalesData {
        <CMsgGCRequestStoreSalesData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestStoreSalesData {
    pub fn new() -> CMsgGCRequestStoreSalesData {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 currency = 2;

    pub fn currency(&self) -> u32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: u32) {
        self.currency = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCRequestStoreSalesData {
    const NAME: &'static str = "CMsgGCRequestStoreSalesData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.currency {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.currency {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestStoreSalesData {
        CMsgGCRequestStoreSalesData::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestStoreSalesData {
        static instance: CMsgGCRequestStoreSalesData = CMsgGCRequestStoreSalesData {
            version: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCRequestStoreSalesDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRequestStoreSalesDataResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesDataResponse.sale_price)
    pub sale_price: ::std::vec::Vec<cmsg_gcrequest_store_sales_data_response::Price>,
    // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesDataResponse.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesDataResponse.expiration_time)
    pub expiration_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRequestStoreSalesDataResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestStoreSalesDataResponse {
    fn default() -> &'a CMsgGCRequestStoreSalesDataResponse {
        <CMsgGCRequestStoreSalesDataResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestStoreSalesDataResponse {
    pub fn new() -> CMsgGCRequestStoreSalesDataResponse {
        ::std::default::Default::default()
    }

    // optional uint32 version = 2;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 expiration_time = 3;

    pub fn expiration_time(&self) -> u32 {
        self.expiration_time.unwrap_or(0)
    }

    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: u32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCRequestStoreSalesDataResponse {
    const NAME: &'static str = "CMsgGCRequestStoreSalesDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sale_price.push(is.read_message()?);
                },
                16 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.expiration_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.sale_price {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.expiration_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.sale_price {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestStoreSalesDataResponse {
        CMsgGCRequestStoreSalesDataResponse::new()
    }

    fn clear(&mut self) {
        self.sale_price.clear();
        self.version = ::std::option::Option::None;
        self.expiration_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestStoreSalesDataResponse {
        static instance: CMsgGCRequestStoreSalesDataResponse = CMsgGCRequestStoreSalesDataResponse {
            sale_price: ::std::vec::Vec::new(),
            version: ::std::option::Option::None,
            expiration_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCRequestStoreSalesDataResponse`
pub mod cmsg_gcrequest_store_sales_data_response {
    // @@protoc_insertion_point(message:CMsgGCRequestStoreSalesDataResponse.Price)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Price {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesDataResponse.Price.item_def)
        pub item_def: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesDataResponse.Price.price)
        pub price: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCRequestStoreSalesDataResponse.Price.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Price {
        fn default() -> &'a Price {
            <Price as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Price {
        pub fn new() -> Price {
            ::std::default::Default::default()
        }

        // optional uint32 item_def = 1;

        pub fn item_def(&self) -> u32 {
            self.item_def.unwrap_or(0)
        }

        pub fn clear_item_def(&mut self) {
            self.item_def = ::std::option::Option::None;
        }

        pub fn has_item_def(&self) -> bool {
            self.item_def.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_def(&mut self, v: u32) {
            self.item_def = ::std::option::Option::Some(v);
        }

        // optional uint32 price = 2;

        pub fn price(&self) -> u32 {
            self.price.unwrap_or(0)
        }

        pub fn clear_price(&mut self) {
            self.price = ::std::option::Option::None;
        }

        pub fn has_price(&self) -> bool {
            self.price.is_some()
        }

        // Param is passed by value, moved
        pub fn set_price(&mut self, v: u32) {
            self.price = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Price {
        const NAME: &'static str = "Price";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.price = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_def {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.price {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item_def {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.price {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Price {
            Price::new()
        }

        fn clear(&mut self) {
            self.item_def = ::std::option::Option::None;
            self.price = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Price {
            static instance: Price = Price {
                item_def: ::std::option::Option::None,
                price: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCRequestStoreSalesDataUpToDateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRequestStoreSalesDataUpToDateResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesDataUpToDateResponse.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesDataUpToDateResponse.expiration_time)
    pub expiration_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRequestStoreSalesDataUpToDateResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestStoreSalesDataUpToDateResponse {
    fn default() -> &'a CMsgGCRequestStoreSalesDataUpToDateResponse {
        <CMsgGCRequestStoreSalesDataUpToDateResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestStoreSalesDataUpToDateResponse {
    pub fn new() -> CMsgGCRequestStoreSalesDataUpToDateResponse {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 expiration_time = 2;

    pub fn expiration_time(&self) -> u32 {
        self.expiration_time.unwrap_or(0)
    }

    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: u32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCRequestStoreSalesDataUpToDateResponse {
    const NAME: &'static str = "CMsgGCRequestStoreSalesDataUpToDateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.expiration_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.expiration_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestStoreSalesDataUpToDateResponse {
        CMsgGCRequestStoreSalesDataUpToDateResponse::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.expiration_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestStoreSalesDataUpToDateResponse {
        static instance: CMsgGCRequestStoreSalesDataUpToDateResponse = CMsgGCRequestStoreSalesDataUpToDateResponse {
            version: ::std::option::Option::None,
            expiration_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCPingRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCPingRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCPingRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCPingRequest {
    fn default() -> &'a CMsgGCToGCPingRequest {
        <CMsgGCToGCPingRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCPingRequest {
    pub fn new() -> CMsgGCToGCPingRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCPingRequest {
    const NAME: &'static str = "CMsgGCToGCPingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCPingRequest {
        CMsgGCToGCPingRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCPingRequest {
        static instance: CMsgGCToGCPingRequest = CMsgGCToGCPingRequest {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCPingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCPingResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCPingResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCPingResponse {
    fn default() -> &'a CMsgGCToGCPingResponse {
        <CMsgGCToGCPingResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCPingResponse {
    pub fn new() -> CMsgGCToGCPingResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCPingResponse {
    const NAME: &'static str = "CMsgGCToGCPingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCPingResponse {
        CMsgGCToGCPingResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCPingResponse {
        static instance: CMsgGCToGCPingResponse = CMsgGCToGCPingResponse {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCGetUserSessionServer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCGetUserSessionServer {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCGetUserSessionServer.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCGetUserSessionServer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetUserSessionServer {
    fn default() -> &'a CMsgGCToGCGetUserSessionServer {
        <CMsgGCToGCGetUserSessionServer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetUserSessionServer {
    pub fn new() -> CMsgGCToGCGetUserSessionServer {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCGetUserSessionServer {
    const NAME: &'static str = "CMsgGCToGCGetUserSessionServer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGetUserSessionServer {
        CMsgGCToGCGetUserSessionServer::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGetUserSessionServer {
        static instance: CMsgGCToGCGetUserSessionServer = CMsgGCToGCGetUserSessionServer {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCGetUserSessionServerResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCGetUserSessionServerResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCGetUserSessionServerResponse.server_steam_id)
    pub server_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToGCGetUserSessionServerResponse.is_online)
    pub is_online: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCGetUserSessionServerResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetUserSessionServerResponse {
    fn default() -> &'a CMsgGCToGCGetUserSessionServerResponse {
        <CMsgGCToGCGetUserSessionServerResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetUserSessionServerResponse {
    pub fn new() -> CMsgGCToGCGetUserSessionServerResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 server_steam_id = 1;

    pub fn server_steam_id(&self) -> u64 {
        self.server_steam_id.unwrap_or(0)
    }

    pub fn clear_server_steam_id(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_steam_id(&self) -> bool {
        self.server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_steam_id(&mut self, v: u64) {
        self.server_steam_id = ::std::option::Option::Some(v);
    }

    // optional bool is_online = 2;

    pub fn is_online(&self) -> bool {
        self.is_online.unwrap_or(false)
    }

    pub fn clear_is_online(&mut self) {
        self.is_online = ::std::option::Option::None;
    }

    pub fn has_is_online(&self) -> bool {
        self.is_online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_online(&mut self, v: bool) {
        self.is_online = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCGetUserSessionServerResponse {
    const NAME: &'static str = "CMsgGCToGCGetUserSessionServerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.is_online = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.is_online {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.server_steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.is_online {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGetUserSessionServerResponse {
        CMsgGCToGCGetUserSessionServerResponse::new()
    }

    fn clear(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
        self.is_online = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGetUserSessionServerResponse {
        static instance: CMsgGCToGCGetUserSessionServerResponse = CMsgGCToGCGetUserSessionServerResponse {
            server_steam_id: ::std::option::Option::None,
            is_online: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCGetUserServerMembers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCGetUserServerMembers {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCGetUserServerMembers.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCGetUserServerMembers.max_spectators)
    pub max_spectators: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCGetUserServerMembers.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetUserServerMembers {
    fn default() -> &'a CMsgGCToGCGetUserServerMembers {
        <CMsgGCToGCGetUserServerMembers as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetUserServerMembers {
    pub fn new() -> CMsgGCToGCGetUserServerMembers {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 max_spectators = 2;

    pub fn max_spectators(&self) -> u32 {
        self.max_spectators.unwrap_or(0)
    }

    pub fn clear_max_spectators(&mut self) {
        self.max_spectators = ::std::option::Option::None;
    }

    pub fn has_max_spectators(&self) -> bool {
        self.max_spectators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_spectators(&mut self, v: u32) {
        self.max_spectators = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCGetUserServerMembers {
    const NAME: &'static str = "CMsgGCToGCGetUserServerMembers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.max_spectators = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.max_spectators {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.max_spectators {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGetUserServerMembers {
        CMsgGCToGCGetUserServerMembers::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.max_spectators = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGetUserServerMembers {
        static instance: CMsgGCToGCGetUserServerMembers = CMsgGCToGCGetUserServerMembers {
            account_id: ::std::option::Option::None,
            max_spectators: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCGetUserServerMembersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCGetUserServerMembersResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCGetUserServerMembersResponse.member_account_id)
    pub member_account_id: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCGetUserServerMembersResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetUserServerMembersResponse {
    fn default() -> &'a CMsgGCToGCGetUserServerMembersResponse {
        <CMsgGCToGCGetUserServerMembersResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetUserServerMembersResponse {
    pub fn new() -> CMsgGCToGCGetUserServerMembersResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCGetUserServerMembersResponse {
    const NAME: &'static str = "CMsgGCToGCGetUserServerMembersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.member_account_id)?;
                },
                8 => {
                    self.member_account_id.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.member_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.member_account_id {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGetUserServerMembersResponse {
        CMsgGCToGCGetUserServerMembersResponse::new()
    }

    fn clear(&mut self) {
        self.member_account_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGetUserServerMembersResponse {
        static instance: CMsgGCToGCGetUserServerMembersResponse = CMsgGCToGCGetUserServerMembersResponse {
            member_account_id: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLookupMultipleAccountNames)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLookupMultipleAccountNames {
    // message fields
    // @@protoc_insertion_point(field:CMsgLookupMultipleAccountNames.accountids)
    pub accountids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLookupMultipleAccountNames.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLookupMultipleAccountNames {
    fn default() -> &'a CMsgLookupMultipleAccountNames {
        <CMsgLookupMultipleAccountNames as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLookupMultipleAccountNames {
    pub fn new() -> CMsgLookupMultipleAccountNames {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLookupMultipleAccountNames {
    const NAME: &'static str = "CMsgLookupMultipleAccountNames";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.accountids)?;
                },
                8 => {
                    self.accountids.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_uint32_size(1, &self.accountids);
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_repeated_packed_uint32(1, &self.accountids)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLookupMultipleAccountNames {
        CMsgLookupMultipleAccountNames::new()
    }

    fn clear(&mut self) {
        self.accountids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLookupMultipleAccountNames {
        static instance: CMsgLookupMultipleAccountNames = CMsgLookupMultipleAccountNames {
            accountids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLookupMultipleAccountNamesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLookupMultipleAccountNamesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgLookupMultipleAccountNamesResponse.accounts)
    pub accounts: ::std::vec::Vec<cmsg_lookup_multiple_account_names_response::Account>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLookupMultipleAccountNamesResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLookupMultipleAccountNamesResponse {
    fn default() -> &'a CMsgLookupMultipleAccountNamesResponse {
        <CMsgLookupMultipleAccountNamesResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLookupMultipleAccountNamesResponse {
    pub fn new() -> CMsgLookupMultipleAccountNamesResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLookupMultipleAccountNamesResponse {
    const NAME: &'static str = "CMsgLookupMultipleAccountNamesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.accounts.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.accounts {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.accounts {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLookupMultipleAccountNamesResponse {
        CMsgLookupMultipleAccountNamesResponse::new()
    }

    fn clear(&mut self) {
        self.accounts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLookupMultipleAccountNamesResponse {
        static instance: CMsgLookupMultipleAccountNamesResponse = CMsgLookupMultipleAccountNamesResponse {
            accounts: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgLookupMultipleAccountNamesResponse`
pub mod cmsg_lookup_multiple_account_names_response {
    // @@protoc_insertion_point(message:CMsgLookupMultipleAccountNamesResponse.Account)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Account {
        // message fields
        // @@protoc_insertion_point(field:CMsgLookupMultipleAccountNamesResponse.Account.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgLookupMultipleAccountNamesResponse.Account.persona)
        pub persona: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgLookupMultipleAccountNamesResponse.Account.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Account {
        fn default() -> &'a Account {
            <Account as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Account {
        pub fn new() -> Account {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional string persona = 2;

        pub fn persona(&self) -> &str {
            match self.persona.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_persona(&mut self) {
            self.persona = ::std::option::Option::None;
        }

        pub fn has_persona(&self) -> bool {
            self.persona.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona(&mut self, v: ::std::string::String) {
            self.persona = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_persona(&mut self) -> &mut ::std::string::String {
            if self.persona.is_none() {
                self.persona = ::std::option::Option::Some(::std::string::String::new());
            }
            self.persona.as_mut().unwrap()
        }

        // Take field
        pub fn take_persona(&mut self) -> ::std::string::String {
            self.persona.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Account {
        const NAME: &'static str = "Account";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.persona = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.persona.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.persona.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Account {
            Account::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.persona = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Account {
            static instance: Account = Account {
                accountid: ::std::option::Option::None,
                persona: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgRequestCrateItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRequestCrateItems {
    // message fields
    // @@protoc_insertion_point(field:CMsgRequestCrateItems.crate_item_def)
    pub crate_item_def: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRequestCrateItems.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestCrateItems {
    fn default() -> &'a CMsgRequestCrateItems {
        <CMsgRequestCrateItems as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestCrateItems {
    pub fn new() -> CMsgRequestCrateItems {
        ::std::default::Default::default()
    }

    // optional uint32 crate_item_def = 1;

    pub fn crate_item_def(&self) -> u32 {
        self.crate_item_def.unwrap_or(0)
    }

    pub fn clear_crate_item_def(&mut self) {
        self.crate_item_def = ::std::option::Option::None;
    }

    pub fn has_crate_item_def(&self) -> bool {
        self.crate_item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crate_item_def(&mut self, v: u32) {
        self.crate_item_def = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgRequestCrateItems {
    const NAME: &'static str = "CMsgRequestCrateItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.crate_item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.crate_item_def {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.crate_item_def {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestCrateItems {
        CMsgRequestCrateItems::new()
    }

    fn clear(&mut self) {
        self.crate_item_def = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestCrateItems {
        static instance: CMsgRequestCrateItems = CMsgRequestCrateItems {
            crate_item_def: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRequestCrateItemsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRequestCrateItemsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgRequestCrateItemsResponse.response)
    pub response: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRequestCrateItemsResponse.item_defs)
    pub item_defs: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgRequestCrateItemsResponse.peek_item_defs)
    pub peek_item_defs: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgRequestCrateItemsResponse.peek_items)
    pub peek_items: ::std::vec::Vec<super::base_gcmessages::CSOEconItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRequestCrateItemsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestCrateItemsResponse {
    fn default() -> &'a CMsgRequestCrateItemsResponse {
        <CMsgRequestCrateItemsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestCrateItemsResponse {
    pub fn new() -> CMsgRequestCrateItemsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 response = 1;

    pub fn response(&self) -> u32 {
        self.response.unwrap_or(0)
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: u32) {
        self.response = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgRequestCrateItemsResponse {
    const NAME: &'static str = "CMsgRequestCrateItemsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.item_defs)?;
                },
                16 => {
                    self.item_defs.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.peek_item_defs)?;
                },
                24 => {
                    self.peek_item_defs.push(is.read_uint32()?);
                },
                34 => {
                    self.peek_items.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.item_defs {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.peek_item_defs {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
        };
        for value in &self.peek_items {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_uint32(1, v)?;
        }
        for v in &self.item_defs {
            os.write_uint32(2, *v)?;
        };
        for v in &self.peek_item_defs {
            os.write_uint32(3, *v)?;
        };
        for v in &self.peek_items {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestCrateItemsResponse {
        CMsgRequestCrateItemsResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.item_defs.clear();
        self.peek_item_defs.clear();
        self.peek_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestCrateItemsResponse {
        static instance: CMsgRequestCrateItemsResponse = CMsgRequestCrateItemsResponse {
            response: ::std::option::Option::None,
            item_defs: ::std::vec::Vec::new(),
            peek_item_defs: ::std::vec::Vec::new(),
            peek_items: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgRequestCrateItemsResponse`
pub mod cmsg_request_crate_items_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgRequestCrateItemsResponse.EResult)
    pub enum EResult {
        // @@protoc_insertion_point(enum_value:CMsgRequestCrateItemsResponse.EResult.k_Succeeded)
        k_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:CMsgRequestCrateItemsResponse.EResult.k_Failed)
        k_Failed = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResult {
        const NAME: &'static str = "EResult";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResult> {
            match value {
                0 => ::std::option::Option::Some(EResult::k_Succeeded),
                1 => ::std::option::Option::Some(EResult::k_Failed),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResult> {
            match str {
                "k_Succeeded" => ::std::option::Option::Some(EResult::k_Succeeded),
                "k_Failed" => ::std::option::Option::Some(EResult::k_Failed),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResult] = &[
            EResult::k_Succeeded,
            EResult::k_Failed,
        ];
    }

    impl ::std::default::Default for EResult {
        fn default() -> Self {
            EResult::k_Succeeded
        }
    }

}

// @@protoc_insertion_point(message:CMsgRequestCrateEscalationLevel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRequestCrateEscalationLevel {
    // message fields
    // @@protoc_insertion_point(field:CMsgRequestCrateEscalationLevel.crate_item_def)
    pub crate_item_def: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRequestCrateEscalationLevel.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestCrateEscalationLevel {
    fn default() -> &'a CMsgRequestCrateEscalationLevel {
        <CMsgRequestCrateEscalationLevel as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestCrateEscalationLevel {
    pub fn new() -> CMsgRequestCrateEscalationLevel {
        ::std::default::Default::default()
    }

    // optional uint32 crate_item_def = 1;

    pub fn crate_item_def(&self) -> u32 {
        self.crate_item_def.unwrap_or(0)
    }

    pub fn clear_crate_item_def(&mut self) {
        self.crate_item_def = ::std::option::Option::None;
    }

    pub fn has_crate_item_def(&self) -> bool {
        self.crate_item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crate_item_def(&mut self, v: u32) {
        self.crate_item_def = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgRequestCrateEscalationLevel {
    const NAME: &'static str = "CMsgRequestCrateEscalationLevel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.crate_item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.crate_item_def {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.crate_item_def {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestCrateEscalationLevel {
        CMsgRequestCrateEscalationLevel::new()
    }

    fn clear(&mut self) {
        self.crate_item_def = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestCrateEscalationLevel {
        static instance: CMsgRequestCrateEscalationLevel = CMsgRequestCrateEscalationLevel {
            crate_item_def: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRequestCrateEscalationLevelResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRequestCrateEscalationLevelResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgRequestCrateEscalationLevelResponse.response)
    pub response: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRequestCrateEscalationLevelResponse.escalation_level0)
    pub escalation_level0: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRequestCrateEscalationLevelResponse.escalation_level1)
    pub escalation_level1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRequestCrateEscalationLevelResponse.escalation_level2)
    pub escalation_level2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRequestCrateEscalationLevelResponse.escalation_level3)
    pub escalation_level3: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRequestCrateEscalationLevelResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestCrateEscalationLevelResponse {
    fn default() -> &'a CMsgRequestCrateEscalationLevelResponse {
        <CMsgRequestCrateEscalationLevelResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestCrateEscalationLevelResponse {
    pub fn new() -> CMsgRequestCrateEscalationLevelResponse {
        ::std::default::Default::default()
    }

    // optional uint32 response = 1;

    pub fn response(&self) -> u32 {
        self.response.unwrap_or(0)
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: u32) {
        self.response = ::std::option::Option::Some(v);
    }

    // optional uint32 escalation_level0 = 2;

    pub fn escalation_level0(&self) -> u32 {
        self.escalation_level0.unwrap_or(0)
    }

    pub fn clear_escalation_level0(&mut self) {
        self.escalation_level0 = ::std::option::Option::None;
    }

    pub fn has_escalation_level0(&self) -> bool {
        self.escalation_level0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_escalation_level0(&mut self, v: u32) {
        self.escalation_level0 = ::std::option::Option::Some(v);
    }

    // optional uint32 escalation_level1 = 3;

    pub fn escalation_level1(&self) -> u32 {
        self.escalation_level1.unwrap_or(0)
    }

    pub fn clear_escalation_level1(&mut self) {
        self.escalation_level1 = ::std::option::Option::None;
    }

    pub fn has_escalation_level1(&self) -> bool {
        self.escalation_level1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_escalation_level1(&mut self, v: u32) {
        self.escalation_level1 = ::std::option::Option::Some(v);
    }

    // optional uint32 escalation_level2 = 4;

    pub fn escalation_level2(&self) -> u32 {
        self.escalation_level2.unwrap_or(0)
    }

    pub fn clear_escalation_level2(&mut self) {
        self.escalation_level2 = ::std::option::Option::None;
    }

    pub fn has_escalation_level2(&self) -> bool {
        self.escalation_level2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_escalation_level2(&mut self, v: u32) {
        self.escalation_level2 = ::std::option::Option::Some(v);
    }

    // optional uint32 escalation_level3 = 5;

    pub fn escalation_level3(&self) -> u32 {
        self.escalation_level3.unwrap_or(0)
    }

    pub fn clear_escalation_level3(&mut self) {
        self.escalation_level3 = ::std::option::Option::None;
    }

    pub fn has_escalation_level3(&self) -> bool {
        self.escalation_level3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_escalation_level3(&mut self, v: u32) {
        self.escalation_level3 = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgRequestCrateEscalationLevelResponse {
    const NAME: &'static str = "CMsgRequestCrateEscalationLevelResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.escalation_level0 = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.escalation_level1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.escalation_level2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.escalation_level3 = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.escalation_level0 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.escalation_level1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.escalation_level2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.escalation_level3 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.escalation_level0 {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.escalation_level1 {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.escalation_level2 {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.escalation_level3 {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestCrateEscalationLevelResponse {
        CMsgRequestCrateEscalationLevelResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.escalation_level0 = ::std::option::Option::None;
        self.escalation_level1 = ::std::option::Option::None;
        self.escalation_level2 = ::std::option::Option::None;
        self.escalation_level3 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestCrateEscalationLevelResponse {
        static instance: CMsgRequestCrateEscalationLevelResponse = CMsgRequestCrateEscalationLevelResponse {
            response: ::std::option::Option::None,
            escalation_level0: ::std::option::Option::None,
            escalation_level1: ::std::option::Option::None,
            escalation_level2: ::std::option::Option::None,
            escalation_level3: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgRequestCrateEscalationLevelResponse`
pub mod cmsg_request_crate_escalation_level_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgRequestCrateEscalationLevelResponse.EResult)
    pub enum EResult {
        // @@protoc_insertion_point(enum_value:CMsgRequestCrateEscalationLevelResponse.EResult.k_Succeeded)
        k_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:CMsgRequestCrateEscalationLevelResponse.EResult.k_Failed)
        k_Failed = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResult {
        const NAME: &'static str = "EResult";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResult> {
            match value {
                0 => ::std::option::Option::Some(EResult::k_Succeeded),
                1 => ::std::option::Option::Some(EResult::k_Failed),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResult> {
            match str {
                "k_Succeeded" => ::std::option::Option::Some(EResult::k_Succeeded),
                "k_Failed" => ::std::option::Option::Some(EResult::k_Failed),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResult] = &[
            EResult::k_Succeeded,
            EResult::k_Failed,
        ];
    }

    impl ::std::default::Default for EResult {
        fn default() -> Self {
            EResult::k_Succeeded
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCToGCCanUseDropRateBonus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCCanUseDropRateBonus {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCCanUseDropRateBonus.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCCanUseDropRateBonus.drop_rate_bonus)
    pub drop_rate_bonus: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGCToGCCanUseDropRateBonus.booster_type)
    pub booster_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCCanUseDropRateBonus.exclusive_item_def)
    pub exclusive_item_def: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCCanUseDropRateBonus.allow_equal_rate)
    pub allow_equal_rate: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCCanUseDropRateBonus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCCanUseDropRateBonus {
    fn default() -> &'a CMsgGCToGCCanUseDropRateBonus {
        <CMsgGCToGCCanUseDropRateBonus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCCanUseDropRateBonus {
    pub fn new() -> CMsgGCToGCCanUseDropRateBonus {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional float drop_rate_bonus = 2;

    pub fn drop_rate_bonus(&self) -> f32 {
        self.drop_rate_bonus.unwrap_or(0.)
    }

    pub fn clear_drop_rate_bonus(&mut self) {
        self.drop_rate_bonus = ::std::option::Option::None;
    }

    pub fn has_drop_rate_bonus(&self) -> bool {
        self.drop_rate_bonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_drop_rate_bonus(&mut self, v: f32) {
        self.drop_rate_bonus = ::std::option::Option::Some(v);
    }

    // optional uint32 booster_type = 3;

    pub fn booster_type(&self) -> u32 {
        self.booster_type.unwrap_or(0)
    }

    pub fn clear_booster_type(&mut self) {
        self.booster_type = ::std::option::Option::None;
    }

    pub fn has_booster_type(&self) -> bool {
        self.booster_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_booster_type(&mut self, v: u32) {
        self.booster_type = ::std::option::Option::Some(v);
    }

    // optional uint32 exclusive_item_def = 4;

    pub fn exclusive_item_def(&self) -> u32 {
        self.exclusive_item_def.unwrap_or(0)
    }

    pub fn clear_exclusive_item_def(&mut self) {
        self.exclusive_item_def = ::std::option::Option::None;
    }

    pub fn has_exclusive_item_def(&self) -> bool {
        self.exclusive_item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exclusive_item_def(&mut self, v: u32) {
        self.exclusive_item_def = ::std::option::Option::Some(v);
    }

    // optional bool allow_equal_rate = 5;

    pub fn allow_equal_rate(&self) -> bool {
        self.allow_equal_rate.unwrap_or(false)
    }

    pub fn clear_allow_equal_rate(&mut self) {
        self.allow_equal_rate = ::std::option::Option::None;
    }

    pub fn has_allow_equal_rate(&self) -> bool {
        self.allow_equal_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_equal_rate(&mut self, v: bool) {
        self.allow_equal_rate = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCCanUseDropRateBonus {
    const NAME: &'static str = "CMsgGCToGCCanUseDropRateBonus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.drop_rate_bonus = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.booster_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.exclusive_item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.allow_equal_rate = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.drop_rate_bonus {
            my_size += 1 + 4;
        }
        if let Some(v) = self.booster_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.exclusive_item_def {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.allow_equal_rate {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.drop_rate_bonus {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.booster_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.exclusive_item_def {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.allow_equal_rate {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCCanUseDropRateBonus {
        CMsgGCToGCCanUseDropRateBonus::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.drop_rate_bonus = ::std::option::Option::None;
        self.booster_type = ::std::option::Option::None;
        self.exclusive_item_def = ::std::option::Option::None;
        self.allow_equal_rate = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCCanUseDropRateBonus {
        static instance: CMsgGCToGCCanUseDropRateBonus = CMsgGCToGCCanUseDropRateBonus {
            account_id: ::std::option::Option::None,
            drop_rate_bonus: ::std::option::Option::None,
            booster_type: ::std::option::Option::None,
            exclusive_item_def: ::std::option::Option::None,
            allow_equal_rate: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSQLAddDropRateBonus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSQLAddDropRateBonus {
    // message fields
    // @@protoc_insertion_point(field:CMsgSQLAddDropRateBonus.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSQLAddDropRateBonus.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSQLAddDropRateBonus.item_def)
    pub item_def: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSQLAddDropRateBonus.drop_rate_bonus)
    pub drop_rate_bonus: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSQLAddDropRateBonus.booster_type)
    pub booster_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSQLAddDropRateBonus.seconds_duration)
    pub seconds_duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSQLAddDropRateBonus.end_time_stamp)
    pub end_time_stamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSQLAddDropRateBonus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSQLAddDropRateBonus {
    fn default() -> &'a CMsgSQLAddDropRateBonus {
        <CMsgSQLAddDropRateBonus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSQLAddDropRateBonus {
    pub fn new() -> CMsgSQLAddDropRateBonus {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 2;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 item_def = 3;

    pub fn item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    // optional float drop_rate_bonus = 4;

    pub fn drop_rate_bonus(&self) -> f32 {
        self.drop_rate_bonus.unwrap_or(0.)
    }

    pub fn clear_drop_rate_bonus(&mut self) {
        self.drop_rate_bonus = ::std::option::Option::None;
    }

    pub fn has_drop_rate_bonus(&self) -> bool {
        self.drop_rate_bonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_drop_rate_bonus(&mut self, v: f32) {
        self.drop_rate_bonus = ::std::option::Option::Some(v);
    }

    // optional uint32 booster_type = 5;

    pub fn booster_type(&self) -> u32 {
        self.booster_type.unwrap_or(0)
    }

    pub fn clear_booster_type(&mut self) {
        self.booster_type = ::std::option::Option::None;
    }

    pub fn has_booster_type(&self) -> bool {
        self.booster_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_booster_type(&mut self, v: u32) {
        self.booster_type = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_duration = 6;

    pub fn seconds_duration(&self) -> u32 {
        self.seconds_duration.unwrap_or(0)
    }

    pub fn clear_seconds_duration(&mut self) {
        self.seconds_duration = ::std::option::Option::None;
    }

    pub fn has_seconds_duration(&self) -> bool {
        self.seconds_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_duration(&mut self, v: u32) {
        self.seconds_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 end_time_stamp = 7;

    pub fn end_time_stamp(&self) -> u32 {
        self.end_time_stamp.unwrap_or(0)
    }

    pub fn clear_end_time_stamp(&mut self) {
        self.end_time_stamp = ::std::option::Option::None;
    }

    pub fn has_end_time_stamp(&self) -> bool {
        self.end_time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time_stamp(&mut self, v: u32) {
        self.end_time_stamp = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSQLAddDropRateBonus {
    const NAME: &'static str = "CMsgSQLAddDropRateBonus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.drop_rate_bonus = ::std::option::Option::Some(is.read_float()?);
                },
                40 => {
                    self.booster_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.seconds_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.end_time_stamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.item_def {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.drop_rate_bonus {
            my_size += 1 + 4;
        }
        if let Some(v) = self.booster_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.seconds_duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.end_time_stamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.item_def {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.drop_rate_bonus {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.booster_type {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.seconds_duration {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.end_time_stamp {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSQLAddDropRateBonus {
        CMsgSQLAddDropRateBonus::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.item_def = ::std::option::Option::None;
        self.drop_rate_bonus = ::std::option::Option::None;
        self.booster_type = ::std::option::Option::None;
        self.seconds_duration = ::std::option::Option::None;
        self.end_time_stamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSQLAddDropRateBonus {
        static instance: CMsgSQLAddDropRateBonus = CMsgSQLAddDropRateBonus {
            account_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            item_def: ::std::option::Option::None,
            drop_rate_bonus: ::std::option::Option::None,
            booster_type: ::std::option::Option::None,
            seconds_duration: ::std::option::Option::None,
            end_time_stamp: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSQLUpgradeBattleBooster)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSQLUpgradeBattleBooster {
    // message fields
    // @@protoc_insertion_point(field:CMsgSQLUpgradeBattleBooster.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSQLUpgradeBattleBooster.item_def)
    pub item_def: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSQLUpgradeBattleBooster.bonus_to_add)
    pub bonus_to_add: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSQLUpgradeBattleBooster.booster_type)
    pub booster_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSQLUpgradeBattleBooster.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSQLUpgradeBattleBooster {
    fn default() -> &'a CMsgSQLUpgradeBattleBooster {
        <CMsgSQLUpgradeBattleBooster as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSQLUpgradeBattleBooster {
    pub fn new() -> CMsgSQLUpgradeBattleBooster {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 item_def = 2;

    pub fn item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    // optional float bonus_to_add = 3;

    pub fn bonus_to_add(&self) -> f32 {
        self.bonus_to_add.unwrap_or(0.)
    }

    pub fn clear_bonus_to_add(&mut self) {
        self.bonus_to_add = ::std::option::Option::None;
    }

    pub fn has_bonus_to_add(&self) -> bool {
        self.bonus_to_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_to_add(&mut self, v: f32) {
        self.bonus_to_add = ::std::option::Option::Some(v);
    }

    // optional uint32 booster_type = 4;

    pub fn booster_type(&self) -> u32 {
        self.booster_type.unwrap_or(0)
    }

    pub fn clear_booster_type(&mut self) {
        self.booster_type = ::std::option::Option::None;
    }

    pub fn has_booster_type(&self) -> bool {
        self.booster_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_booster_type(&mut self, v: u32) {
        self.booster_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSQLUpgradeBattleBooster {
    const NAME: &'static str = "CMsgSQLUpgradeBattleBooster";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.bonus_to_add = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.booster_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_def {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.bonus_to_add {
            my_size += 1 + 4;
        }
        if let Some(v) = self.booster_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_def {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bonus_to_add {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.booster_type {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSQLUpgradeBattleBooster {
        CMsgSQLUpgradeBattleBooster::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.item_def = ::std::option::Option::None;
        self.bonus_to_add = ::std::option::Option::None;
        self.booster_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSQLUpgradeBattleBooster {
        static instance: CMsgSQLUpgradeBattleBooster = CMsgSQLUpgradeBattleBooster {
            account_id: ::std::option::Option::None,
            item_def: ::std::option::Option::None,
            bonus_to_add: ::std::option::Option::None,
            booster_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCRefreshSOCache)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCRefreshSOCache {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCRefreshSOCache.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCRefreshSOCache.reload)
    pub reload: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCRefreshSOCache.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCRefreshSOCache {
    fn default() -> &'a CMsgGCToGCRefreshSOCache {
        <CMsgGCToGCRefreshSOCache as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCRefreshSOCache {
    pub fn new() -> CMsgGCToGCRefreshSOCache {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional bool reload = 2;

    pub fn reload(&self) -> bool {
        self.reload.unwrap_or(false)
    }

    pub fn clear_reload(&mut self) {
        self.reload = ::std::option::Option::None;
    }

    pub fn has_reload(&self) -> bool {
        self.reload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reload(&mut self, v: bool) {
        self.reload = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCRefreshSOCache {
    const NAME: &'static str = "CMsgGCToGCRefreshSOCache";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.reload = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.reload {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reload {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCRefreshSOCache {
        CMsgGCToGCRefreshSOCache::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.reload = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCRefreshSOCache {
        static instance: CMsgGCToGCRefreshSOCache = CMsgGCToGCRefreshSOCache {
            account_id: ::std::option::Option::None,
            reload: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCAddSubscriptionTime)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCAddSubscriptionTime {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCAddSubscriptionTime.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCAddSubscriptionTime.matching_subscription_def_indexes)
    pub matching_subscription_def_indexes: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCAddSubscriptionTime.additional_seconds)
    pub additional_seconds: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCAddSubscriptionTime.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCAddSubscriptionTime {
    fn default() -> &'a CMsgGCToGCAddSubscriptionTime {
        <CMsgGCToGCAddSubscriptionTime as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCAddSubscriptionTime {
    pub fn new() -> CMsgGCToGCAddSubscriptionTime {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 additional_seconds = 3;

    pub fn additional_seconds(&self) -> u32 {
        self.additional_seconds.unwrap_or(0)
    }

    pub fn clear_additional_seconds(&mut self) {
        self.additional_seconds = ::std::option::Option::None;
    }

    pub fn has_additional_seconds(&self) -> bool {
        self.additional_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_seconds(&mut self, v: u32) {
        self.additional_seconds = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCAddSubscriptionTime {
    const NAME: &'static str = "CMsgGCToGCAddSubscriptionTime";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.matching_subscription_def_indexes)?;
                },
                16 => {
                    self.matching_subscription_def_indexes.push(is.read_uint32()?);
                },
                24 => {
                    self.additional_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.matching_subscription_def_indexes {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.additional_seconds {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.matching_subscription_def_indexes {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.additional_seconds {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCAddSubscriptionTime {
        CMsgGCToGCAddSubscriptionTime::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.matching_subscription_def_indexes.clear();
        self.additional_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCAddSubscriptionTime {
        static instance: CMsgGCToGCAddSubscriptionTime = CMsgGCToGCAddSubscriptionTime {
            account_id: ::std::option::Option::None,
            matching_subscription_def_indexes: ::std::vec::Vec::new(),
            additional_seconds: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCGrantAccountRolledItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCGrantAccountRolledItems {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCGrantAccountRolledItems.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCGrantAccountRolledItems.items)
    pub items: ::std::vec::Vec<cmsg_gcto_gcgrant_account_rolled_items::Item>,
    // @@protoc_insertion_point(field:CMsgGCToGCGrantAccountRolledItems.audit_action)
    pub audit_action: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCGrantAccountRolledItems.audit_data)
    pub audit_data: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCGrantAccountRolledItems.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGrantAccountRolledItems {
    fn default() -> &'a CMsgGCToGCGrantAccountRolledItems {
        <CMsgGCToGCGrantAccountRolledItems as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGrantAccountRolledItems {
    pub fn new() -> CMsgGCToGCGrantAccountRolledItems {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 audit_action = 3;

    pub fn audit_action(&self) -> u32 {
        self.audit_action.unwrap_or(0)
    }

    pub fn clear_audit_action(&mut self) {
        self.audit_action = ::std::option::Option::None;
    }

    pub fn has_audit_action(&self) -> bool {
        self.audit_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audit_action(&mut self, v: u32) {
        self.audit_action = ::std::option::Option::Some(v);
    }

    // optional uint64 audit_data = 4;

    pub fn audit_data(&self) -> u64 {
        self.audit_data.unwrap_or(0)
    }

    pub fn clear_audit_data(&mut self) {
        self.audit_data = ::std::option::Option::None;
    }

    pub fn has_audit_data(&self) -> bool {
        self.audit_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audit_data(&mut self, v: u64) {
        self.audit_data = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCGrantAccountRolledItems {
    const NAME: &'static str = "CMsgGCToGCGrantAccountRolledItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                24 => {
                    self.audit_action = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.audit_data = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.audit_action {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.audit_data {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.items {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.audit_action {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.audit_data {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGrantAccountRolledItems {
        CMsgGCToGCGrantAccountRolledItems::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.items.clear();
        self.audit_action = ::std::option::Option::None;
        self.audit_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGrantAccountRolledItems {
        static instance: CMsgGCToGCGrantAccountRolledItems = CMsgGCToGCGrantAccountRolledItems {
            account_id: ::std::option::Option::None,
            items: ::std::vec::Vec::new(),
            audit_action: ::std::option::Option::None,
            audit_data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToGCGrantAccountRolledItems`
pub mod cmsg_gcto_gcgrant_account_rolled_items {
    // @@protoc_insertion_point(message:CMsgGCToGCGrantAccountRolledItems.Item)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Item {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToGCGrantAccountRolledItems.Item.item_def)
        pub item_def: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToGCGrantAccountRolledItems.Item.loot_lists)
        pub loot_lists: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGCToGCGrantAccountRolledItems.Item.ignore_limit)
        pub ignore_limit: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgGCToGCGrantAccountRolledItems.Item.origin)
        pub origin: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToGCGrantAccountRolledItems.Item.dynamic_attributes)
        pub dynamic_attributes: ::std::vec::Vec<item::DynamicAttribute>,
        // @@protoc_insertion_point(field:CMsgGCToGCGrantAccountRolledItems.Item.additional_audit_entries)
        pub additional_audit_entries: ::std::vec::Vec<item::AdditionalAuditEntry>,
        // @@protoc_insertion_point(field:CMsgGCToGCGrantAccountRolledItems.Item.inventory_token)
        pub inventory_token: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToGCGrantAccountRolledItems.Item.quality)
        pub quality: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToGCGrantAccountRolledItems.Item.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Item {
        fn default() -> &'a Item {
            <Item as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Item {
        pub fn new() -> Item {
            ::std::default::Default::default()
        }

        // optional uint32 item_def = 1;

        pub fn item_def(&self) -> u32 {
            self.item_def.unwrap_or(0)
        }

        pub fn clear_item_def(&mut self) {
            self.item_def = ::std::option::Option::None;
        }

        pub fn has_item_def(&self) -> bool {
            self.item_def.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_def(&mut self, v: u32) {
            self.item_def = ::std::option::Option::Some(v);
        }

        // optional bool ignore_limit = 3;

        pub fn ignore_limit(&self) -> bool {
            self.ignore_limit.unwrap_or(false)
        }

        pub fn clear_ignore_limit(&mut self) {
            self.ignore_limit = ::std::option::Option::None;
        }

        pub fn has_ignore_limit(&self) -> bool {
            self.ignore_limit.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ignore_limit(&mut self, v: bool) {
            self.ignore_limit = ::std::option::Option::Some(v);
        }

        // optional uint32 origin = 4;

        pub fn origin(&self) -> u32 {
            self.origin.unwrap_or(0)
        }

        pub fn clear_origin(&mut self) {
            self.origin = ::std::option::Option::None;
        }

        pub fn has_origin(&self) -> bool {
            self.origin.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin(&mut self, v: u32) {
            self.origin = ::std::option::Option::Some(v);
        }

        // optional uint32 inventory_token = 7;

        pub fn inventory_token(&self) -> u32 {
            self.inventory_token.unwrap_or(0)
        }

        pub fn clear_inventory_token(&mut self) {
            self.inventory_token = ::std::option::Option::None;
        }

        pub fn has_inventory_token(&self) -> bool {
            self.inventory_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_inventory_token(&mut self, v: u32) {
            self.inventory_token = ::std::option::Option::Some(v);
        }

        // optional int32 quality = 8;

        pub fn quality(&self) -> i32 {
            self.quality.unwrap_or(-1i32)
        }

        pub fn clear_quality(&mut self) {
            self.quality = ::std::option::Option::None;
        }

        pub fn has_quality(&self) -> bool {
            self.quality.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quality(&mut self, v: i32) {
            self.quality = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Item {
        const NAME: &'static str = "Item";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.loot_lists.push(is.read_string()?);
                    },
                    24 => {
                        self.ignore_limit = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.origin = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        self.dynamic_attributes.push(is.read_message()?);
                    },
                    50 => {
                        self.additional_audit_entries.push(is.read_message()?);
                    },
                    56 => {
                        self.inventory_token = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.quality = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_def {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.loot_lists {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &value);
            };
            if let Some(v) = self.ignore_limit {
                my_size += 1 + 1;
            }
            if let Some(v) = self.origin {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            for value in &self.dynamic_attributes {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.additional_audit_entries {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.inventory_token {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.quality {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item_def {
                os.write_uint32(1, v)?;
            }
            for v in &self.loot_lists {
                os.write_string(2, &v)?;
            };
            if let Some(v) = self.ignore_limit {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.origin {
                os.write_uint32(4, v)?;
            }
            for v in &self.dynamic_attributes {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            };
            for v in &self.additional_audit_entries {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            if let Some(v) = self.inventory_token {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.quality {
                os.write_int32(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Item {
            Item::new()
        }

        fn clear(&mut self) {
            self.item_def = ::std::option::Option::None;
            self.loot_lists.clear();
            self.ignore_limit = ::std::option::Option::None;
            self.origin = ::std::option::Option::None;
            self.dynamic_attributes.clear();
            self.additional_audit_entries.clear();
            self.inventory_token = ::std::option::Option::None;
            self.quality = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Item {
            static instance: Item = Item {
                item_def: ::std::option::Option::None,
                loot_lists: ::std::vec::Vec::new(),
                ignore_limit: ::std::option::Option::None,
                origin: ::std::option::Option::None,
                dynamic_attributes: ::std::vec::Vec::new(),
                additional_audit_entries: ::std::vec::Vec::new(),
                inventory_token: ::std::option::Option::None,
                quality: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Item`
    pub mod item {
        // @@protoc_insertion_point(message:CMsgGCToGCGrantAccountRolledItems.Item.DynamicAttribute)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct DynamicAttribute {
            // message fields
            // @@protoc_insertion_point(field:CMsgGCToGCGrantAccountRolledItems.Item.DynamicAttribute.name)
            pub name: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:CMsgGCToGCGrantAccountRolledItems.Item.DynamicAttribute.value_uint32)
            pub value_uint32: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGCToGCGrantAccountRolledItems.Item.DynamicAttribute.value_float)
            pub value_float: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:CMsgGCToGCGrantAccountRolledItems.Item.DynamicAttribute.value_string)
            pub value_string: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgGCToGCGrantAccountRolledItems.Item.DynamicAttribute.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a DynamicAttribute {
            fn default() -> &'a DynamicAttribute {
                <DynamicAttribute as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl DynamicAttribute {
            pub fn new() -> DynamicAttribute {
                ::std::default::Default::default()
            }

            // optional string name = 1;

            pub fn name(&self) -> &str {
                match self.name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_name(&mut self) {
                self.name = ::std::option::Option::None;
            }

            pub fn has_name(&self) -> bool {
                self.name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                if self.name.is_none() {
                    self.name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.name.as_mut().unwrap()
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                self.name.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional uint32 value_uint32 = 2;

            pub fn value_uint32(&self) -> u32 {
                self.value_uint32.unwrap_or(0)
            }

            pub fn clear_value_uint32(&mut self) {
                self.value_uint32 = ::std::option::Option::None;
            }

            pub fn has_value_uint32(&self) -> bool {
                self.value_uint32.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value_uint32(&mut self, v: u32) {
                self.value_uint32 = ::std::option::Option::Some(v);
            }

            // optional float value_float = 3;

            pub fn value_float(&self) -> f32 {
                self.value_float.unwrap_or(0.)
            }

            pub fn clear_value_float(&mut self) {
                self.value_float = ::std::option::Option::None;
            }

            pub fn has_value_float(&self) -> bool {
                self.value_float.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value_float(&mut self, v: f32) {
                self.value_float = ::std::option::Option::Some(v);
            }

            // optional string value_string = 4;

            pub fn value_string(&self) -> &str {
                match self.value_string.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_value_string(&mut self) {
                self.value_string = ::std::option::Option::None;
            }

            pub fn has_value_string(&self) -> bool {
                self.value_string.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value_string(&mut self, v: ::std::string::String) {
                self.value_string = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_value_string(&mut self) -> &mut ::std::string::String {
                if self.value_string.is_none() {
                    self.value_string = ::std::option::Option::Some(::std::string::String::new());
                }
                self.value_string.as_mut().unwrap()
            }

            // Take field
            pub fn take_value_string(&mut self) -> ::std::string::String {
                self.value_string.take().unwrap_or_else(|| ::std::string::String::new())
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for DynamicAttribute {
            const NAME: &'static str = "DynamicAttribute";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = ::std::option::Option::Some(is.read_string()?);
                        },
                        16 => {
                            self.value_uint32 = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        29 => {
                            self.value_float = ::std::option::Option::Some(is.read_float()?);
                        },
                        34 => {
                            self.value_string = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.name.as_ref() {
                    my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.value_uint32 {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.value_float {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.value_string.as_ref() {
                    my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.name.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.value_uint32 {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.value_float {
                    os.write_float(3, v)?;
                }
                if let Some(v) = self.value_string.as_ref() {
                    os.write_string(4, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> DynamicAttribute {
                DynamicAttribute::new()
            }

            fn clear(&mut self) {
                self.name = ::std::option::Option::None;
                self.value_uint32 = ::std::option::Option::None;
                self.value_float = ::std::option::Option::None;
                self.value_string = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static DynamicAttribute {
                static instance: DynamicAttribute = DynamicAttribute {
                    name: ::std::option::Option::None,
                    value_uint32: ::std::option::Option::None,
                    value_float: ::std::option::Option::None,
                    value_string: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CMsgGCToGCGrantAccountRolledItems.Item.AdditionalAuditEntry)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct AdditionalAuditEntry {
            // message fields
            // @@protoc_insertion_point(field:CMsgGCToGCGrantAccountRolledItems.Item.AdditionalAuditEntry.owner_account_id)
            pub owner_account_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGCToGCGrantAccountRolledItems.Item.AdditionalAuditEntry.audit_action)
            pub audit_action: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGCToGCGrantAccountRolledItems.Item.AdditionalAuditEntry.audit_data)
            pub audit_data: ::std::option::Option<u64>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgGCToGCGrantAccountRolledItems.Item.AdditionalAuditEntry.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a AdditionalAuditEntry {
            fn default() -> &'a AdditionalAuditEntry {
                <AdditionalAuditEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl AdditionalAuditEntry {
            pub fn new() -> AdditionalAuditEntry {
                ::std::default::Default::default()
            }

            // optional uint32 owner_account_id = 1;

            pub fn owner_account_id(&self) -> u32 {
                self.owner_account_id.unwrap_or(0)
            }

            pub fn clear_owner_account_id(&mut self) {
                self.owner_account_id = ::std::option::Option::None;
            }

            pub fn has_owner_account_id(&self) -> bool {
                self.owner_account_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_owner_account_id(&mut self, v: u32) {
                self.owner_account_id = ::std::option::Option::Some(v);
            }

            // optional uint32 audit_action = 2;

            pub fn audit_action(&self) -> u32 {
                self.audit_action.unwrap_or(0)
            }

            pub fn clear_audit_action(&mut self) {
                self.audit_action = ::std::option::Option::None;
            }

            pub fn has_audit_action(&self) -> bool {
                self.audit_action.is_some()
            }

            // Param is passed by value, moved
            pub fn set_audit_action(&mut self, v: u32) {
                self.audit_action = ::std::option::Option::Some(v);
            }

            // optional uint64 audit_data = 3;

            pub fn audit_data(&self) -> u64 {
                self.audit_data.unwrap_or(0)
            }

            pub fn clear_audit_data(&mut self) {
                self.audit_data = ::std::option::Option::None;
            }

            pub fn has_audit_data(&self) -> bool {
                self.audit_data.is_some()
            }

            // Param is passed by value, moved
            pub fn set_audit_data(&mut self, v: u64) {
                self.audit_data = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for AdditionalAuditEntry {
            const NAME: &'static str = "AdditionalAuditEntry";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.owner_account_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.audit_action = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.audit_data = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.owner_account_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.audit_action {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.audit_data {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.owner_account_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.audit_action {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.audit_data {
                    os.write_uint64(3, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> AdditionalAuditEntry {
                AdditionalAuditEntry::new()
            }

            fn clear(&mut self) {
                self.owner_account_id = ::std::option::Option::None;
                self.audit_action = ::std::option::Option::None;
                self.audit_data = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static AdditionalAuditEntry {
                static instance: AdditionalAuditEntry = AdditionalAuditEntry {
                    owner_account_id: ::std::option::Option::None,
                    audit_action: ::std::option::Option::None,
                    audit_data: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCBetaDeleteItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCBetaDeleteItems {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCBetaDeleteItems.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCBetaDeleteItems.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgGCToGCBetaDeleteItems.item_defs)
    pub item_defs: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCBetaDeleteItems.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCBetaDeleteItems {
    fn default() -> &'a CMsgGCToGCBetaDeleteItems {
        <CMsgGCToGCBetaDeleteItems as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCBetaDeleteItems {
    pub fn new() -> CMsgGCToGCBetaDeleteItems {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCBetaDeleteItems {
    const NAME: &'static str = "CMsgGCToGCBetaDeleteItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                16 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.item_defs)?;
                },
                24 => {
                    self.item_defs.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.item_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, *value);
        };
        for value in &self.item_defs {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.item_ids {
            os.write_uint64(2, *v)?;
        };
        for v in &self.item_defs {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCBetaDeleteItems {
        CMsgGCToGCBetaDeleteItems::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.item_ids.clear();
        self.item_defs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCBetaDeleteItems {
        static instance: CMsgGCToGCBetaDeleteItems = CMsgGCToGCBetaDeleteItems {
            account_id: ::std::option::Option::None,
            item_ids: ::std::vec::Vec::new(),
            item_defs: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCGrantSelfMadeItemToAccount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCGrantSelfMadeItemToAccount {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCGrantSelfMadeItemToAccount.item_def_index)
    pub item_def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCGrantSelfMadeItemToAccount.accountid)
    pub accountid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCGrantSelfMadeItemToAccount.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGrantSelfMadeItemToAccount {
    fn default() -> &'a CMsgGCToGCGrantSelfMadeItemToAccount {
        <CMsgGCToGCGrantSelfMadeItemToAccount as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGrantSelfMadeItemToAccount {
    pub fn new() -> CMsgGCToGCGrantSelfMadeItemToAccount {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_index = 1;

    pub fn item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }

    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid = 2;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCGrantSelfMadeItemToAccount {
    const NAME: &'static str = "CMsgGCToGCGrantSelfMadeItemToAccount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.accountid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.accountid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGrantSelfMadeItemToAccount {
        CMsgGCToGCGrantSelfMadeItemToAccount::new()
    }

    fn clear(&mut self) {
        self.item_def_index = ::std::option::Option::None;
        self.accountid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGrantSelfMadeItemToAccount {
        static instance: CMsgGCToGCGrantSelfMadeItemToAccount = CMsgGCToGCGrantSelfMadeItemToAccount {
            item_def_index: ::std::option::Option::None,
            accountid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgUseItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgUseItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgUseItem.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgUseItem.target_steam_id)
    pub target_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgUseItem.gift__potential_targets)
    pub gift__potential_targets: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgUseItem.duel__class_lock)
    pub duel__class_lock: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgUseItem.initiator_steam_id)
    pub initiator_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgUseItem.itempack__ack_immediately)
    pub itempack__ack_immediately: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUseItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUseItem {
    fn default() -> &'a CMsgUseItem {
        <CMsgUseItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgUseItem {
    pub fn new() -> CMsgUseItem {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 target_steam_id = 2;

    pub fn target_steam_id(&self) -> u64 {
        self.target_steam_id.unwrap_or(0)
    }

    pub fn clear_target_steam_id(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
    }

    pub fn has_target_steam_id(&self) -> bool {
        self.target_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_steam_id(&mut self, v: u64) {
        self.target_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 duel__class_lock = 4;

    pub fn duel__class_lock(&self) -> u32 {
        self.duel__class_lock.unwrap_or(0)
    }

    pub fn clear_duel__class_lock(&mut self) {
        self.duel__class_lock = ::std::option::Option::None;
    }

    pub fn has_duel__class_lock(&self) -> bool {
        self.duel__class_lock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duel__class_lock(&mut self, v: u32) {
        self.duel__class_lock = ::std::option::Option::Some(v);
    }

    // optional uint64 initiator_steam_id = 5;

    pub fn initiator_steam_id(&self) -> u64 {
        self.initiator_steam_id.unwrap_or(0)
    }

    pub fn clear_initiator_steam_id(&mut self) {
        self.initiator_steam_id = ::std::option::Option::None;
    }

    pub fn has_initiator_steam_id(&self) -> bool {
        self.initiator_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator_steam_id(&mut self, v: u64) {
        self.initiator_steam_id = ::std::option::Option::Some(v);
    }

    // optional bool itempack__ack_immediately = 6;

    pub fn itempack__ack_immediately(&self) -> bool {
        self.itempack__ack_immediately.unwrap_or(false)
    }

    pub fn clear_itempack__ack_immediately(&mut self) {
        self.itempack__ack_immediately = ::std::option::Option::None;
    }

    pub fn has_itempack__ack_immediately(&self) -> bool {
        self.itempack__ack_immediately.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itempack__ack_immediately(&mut self, v: bool) {
        self.itempack__ack_immediately = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgUseItem {
    const NAME: &'static str = "CMsgUseItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.target_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.gift__potential_targets)?;
                },
                24 => {
                    self.gift__potential_targets.push(is.read_uint32()?);
                },
                32 => {
                    self.duel__class_lock = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.initiator_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.itempack__ack_immediately = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.target_steam_id {
            my_size += 1 + 8;
        }
        for value in &self.gift__potential_targets {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
        };
        if let Some(v) = self.duel__class_lock {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.initiator_steam_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.itempack__ack_immediately {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.target_steam_id {
            os.write_fixed64(2, v)?;
        }
        for v in &self.gift__potential_targets {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.duel__class_lock {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.initiator_steam_id {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.itempack__ack_immediately {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUseItem {
        CMsgUseItem::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.target_steam_id = ::std::option::Option::None;
        self.gift__potential_targets.clear();
        self.duel__class_lock = ::std::option::Option::None;
        self.initiator_steam_id = ::std::option::Option::None;
        self.itempack__ack_immediately = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUseItem {
        static instance: CMsgUseItem = CMsgUseItem {
            item_id: ::std::option::Option::None,
            target_steam_id: ::std::option::Option::None,
            gift__potential_targets: ::std::vec::Vec::new(),
            duel__class_lock: ::std::option::Option::None,
            initiator_steam_id: ::std::option::Option::None,
            itempack__ack_immediately: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerUseItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerUseItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerUseItem.initiator_account_id)
    pub initiator_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerUseItem.use_item_msg)
    pub use_item_msg: ::steam_vent_proto_common::protobuf::MessageField<CMsgUseItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerUseItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerUseItem {
    fn default() -> &'a CMsgServerUseItem {
        <CMsgServerUseItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerUseItem {
    pub fn new() -> CMsgServerUseItem {
        ::std::default::Default::default()
    }

    // optional uint32 initiator_account_id = 1;

    pub fn initiator_account_id(&self) -> u32 {
        self.initiator_account_id.unwrap_or(0)
    }

    pub fn clear_initiator_account_id(&mut self) {
        self.initiator_account_id = ::std::option::Option::None;
    }

    pub fn has_initiator_account_id(&self) -> bool {
        self.initiator_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator_account_id(&mut self, v: u32) {
        self.initiator_account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerUseItem {
    const NAME: &'static str = "CMsgServerUseItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.initiator_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.use_item_msg)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.initiator_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.use_item_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.initiator_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.use_item_msg.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerUseItem {
        CMsgServerUseItem::new()
    }

    fn clear(&mut self) {
        self.initiator_account_id = ::std::option::Option::None;
        self.use_item_msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerUseItem {
        static instance: CMsgServerUseItem = CMsgServerUseItem {
            initiator_account_id: ::std::option::Option::None,
            use_item_msg: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgUseMultipleItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgUseMultipleItems {
    // message fields
    // @@protoc_insertion_point(field:CMsgUseMultipleItems.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUseMultipleItems.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUseMultipleItems {
    fn default() -> &'a CMsgUseMultipleItems {
        <CMsgUseMultipleItems as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgUseMultipleItems {
    pub fn new() -> CMsgUseMultipleItems {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgUseMultipleItems {
    const NAME: &'static str = "CMsgUseMultipleItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                8 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.item_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUseMultipleItems {
        CMsgUseMultipleItems::new()
    }

    fn clear(&mut self) {
        self.item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUseMultipleItems {
        static instance: CMsgUseMultipleItems = CMsgUseMultipleItems {
            item_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGCStoreRechargeRedirect_LineItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCStoreRechargeRedirect_LineItem {
    // message fields
    // @@protoc_insertion_point(field:CGCStoreRechargeRedirect_LineItem.item_def_id)
    pub item_def_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCStoreRechargeRedirect_LineItem.quantity)
    pub quantity: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCStoreRechargeRedirect_LineItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCStoreRechargeRedirect_LineItem {
    fn default() -> &'a CGCStoreRechargeRedirect_LineItem {
        <CGCStoreRechargeRedirect_LineItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCStoreRechargeRedirect_LineItem {
    pub fn new() -> CGCStoreRechargeRedirect_LineItem {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_id = 1;

    pub fn item_def_id(&self) -> u32 {
        self.item_def_id.unwrap_or(0)
    }

    pub fn clear_item_def_id(&mut self) {
        self.item_def_id = ::std::option::Option::None;
    }

    pub fn has_item_def_id(&self) -> bool {
        self.item_def_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_id(&mut self, v: u32) {
        self.item_def_id = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 2;

    pub fn quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCStoreRechargeRedirect_LineItem {
    const NAME: &'static str = "CGCStoreRechargeRedirect_LineItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.quantity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_def_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCStoreRechargeRedirect_LineItem {
        CGCStoreRechargeRedirect_LineItem::new()
    }

    fn clear(&mut self) {
        self.item_def_id = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCStoreRechargeRedirect_LineItem {
        static instance: CGCStoreRechargeRedirect_LineItem = CGCStoreRechargeRedirect_LineItem {
            item_def_id: ::std::option::Option::None,
            quantity: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCEconSQLWorkItemEmbeddedRollbackData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCEconSQLWorkItemEmbeddedRollbackData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCEconSQLWorkItemEmbeddedRollbackData.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCEconSQLWorkItemEmbeddedRollbackData.deleted_item_id)
    pub deleted_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCEconSQLWorkItemEmbeddedRollbackData.old_audit_action)
    pub old_audit_action: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCEconSQLWorkItemEmbeddedRollbackData.new_audit_action)
    pub new_audit_action: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCEconSQLWorkItemEmbeddedRollbackData.expected_audit_action)
    pub expected_audit_action: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCEconSQLWorkItemEmbeddedRollbackData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCEconSQLWorkItemEmbeddedRollbackData {
    fn default() -> &'a CMsgGCEconSQLWorkItemEmbeddedRollbackData {
        <CMsgGCEconSQLWorkItemEmbeddedRollbackData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCEconSQLWorkItemEmbeddedRollbackData {
    pub fn new() -> CMsgGCEconSQLWorkItemEmbeddedRollbackData {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 deleted_item_id = 2;

    pub fn deleted_item_id(&self) -> u64 {
        self.deleted_item_id.unwrap_or(0)
    }

    pub fn clear_deleted_item_id(&mut self) {
        self.deleted_item_id = ::std::option::Option::None;
    }

    pub fn has_deleted_item_id(&self) -> bool {
        self.deleted_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleted_item_id(&mut self, v: u64) {
        self.deleted_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 old_audit_action = 3;

    pub fn old_audit_action(&self) -> u32 {
        self.old_audit_action.unwrap_or(0)
    }

    pub fn clear_old_audit_action(&mut self) {
        self.old_audit_action = ::std::option::Option::None;
    }

    pub fn has_old_audit_action(&self) -> bool {
        self.old_audit_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_old_audit_action(&mut self, v: u32) {
        self.old_audit_action = ::std::option::Option::Some(v);
    }

    // optional uint32 new_audit_action = 4;

    pub fn new_audit_action(&self) -> u32 {
        self.new_audit_action.unwrap_or(0)
    }

    pub fn clear_new_audit_action(&mut self) {
        self.new_audit_action = ::std::option::Option::None;
    }

    pub fn has_new_audit_action(&self) -> bool {
        self.new_audit_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_audit_action(&mut self, v: u32) {
        self.new_audit_action = ::std::option::Option::Some(v);
    }

    // optional uint32 expected_audit_action = 5;

    pub fn expected_audit_action(&self) -> u32 {
        self.expected_audit_action.unwrap_or(0)
    }

    pub fn clear_expected_audit_action(&mut self) {
        self.expected_audit_action = ::std::option::Option::None;
    }

    pub fn has_expected_audit_action(&self) -> bool {
        self.expected_audit_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expected_audit_action(&mut self, v: u32) {
        self.expected_audit_action = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCEconSQLWorkItemEmbeddedRollbackData {
    const NAME: &'static str = "CMsgGCEconSQLWorkItemEmbeddedRollbackData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.deleted_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.old_audit_action = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.new_audit_action = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.expected_audit_action = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.deleted_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.old_audit_action {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.new_audit_action {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.expected_audit_action {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.deleted_item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.old_audit_action {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.new_audit_action {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.expected_audit_action {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCEconSQLWorkItemEmbeddedRollbackData {
        CMsgGCEconSQLWorkItemEmbeddedRollbackData::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.deleted_item_id = ::std::option::Option::None;
        self.old_audit_action = ::std::option::Option::None;
        self.new_audit_action = ::std::option::Option::None;
        self.expected_audit_action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCEconSQLWorkItemEmbeddedRollbackData {
        static instance: CMsgGCEconSQLWorkItemEmbeddedRollbackData = CMsgGCEconSQLWorkItemEmbeddedRollbackData {
            account_id: ::std::option::Option::None,
            deleted_item_id: ::std::option::Option::None,
            old_audit_action: ::std::option::Option::None,
            new_audit_action: ::std::option::Option::None,
            expected_audit_action: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgCraftStatue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCraftStatue {
    // message fields
    // @@protoc_insertion_point(field:CMsgCraftStatue.heroid)
    pub heroid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCraftStatue.sequencename)
    pub sequencename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgCraftStatue.cycle)
    pub cycle: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgCraftStatue.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgCraftStatue.pedestal_itemdef)
    pub pedestal_itemdef: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCraftStatue.toolid)
    pub toolid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCraftStatue.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCraftStatue {
    fn default() -> &'a CMsgCraftStatue {
        <CMsgCraftStatue as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgCraftStatue {
    pub fn new() -> CMsgCraftStatue {
        ::std::default::Default::default()
    }

    // optional uint32 heroid = 1;

    pub fn heroid(&self) -> u32 {
        self.heroid.unwrap_or(0)
    }

    pub fn clear_heroid(&mut self) {
        self.heroid = ::std::option::Option::None;
    }

    pub fn has_heroid(&self) -> bool {
        self.heroid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heroid(&mut self, v: u32) {
        self.heroid = ::std::option::Option::Some(v);
    }

    // optional string sequencename = 2;

    pub fn sequencename(&self) -> &str {
        match self.sequencename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sequencename(&mut self) {
        self.sequencename = ::std::option::Option::None;
    }

    pub fn has_sequencename(&self) -> bool {
        self.sequencename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequencename(&mut self, v: ::std::string::String) {
        self.sequencename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sequencename(&mut self) -> &mut ::std::string::String {
        if self.sequencename.is_none() {
            self.sequencename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sequencename.as_mut().unwrap()
    }

    // Take field
    pub fn take_sequencename(&mut self) -> ::std::string::String {
        self.sequencename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float cycle = 3;

    pub fn cycle(&self) -> f32 {
        self.cycle.unwrap_or(0.)
    }

    pub fn clear_cycle(&mut self) {
        self.cycle = ::std::option::Option::None;
    }

    pub fn has_cycle(&self) -> bool {
        self.cycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cycle(&mut self, v: f32) {
        self.cycle = ::std::option::Option::Some(v);
    }

    // optional string description = 4;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 pedestal_itemdef = 5;

    pub fn pedestal_itemdef(&self) -> u32 {
        self.pedestal_itemdef.unwrap_or(0)
    }

    pub fn clear_pedestal_itemdef(&mut self) {
        self.pedestal_itemdef = ::std::option::Option::None;
    }

    pub fn has_pedestal_itemdef(&self) -> bool {
        self.pedestal_itemdef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pedestal_itemdef(&mut self, v: u32) {
        self.pedestal_itemdef = ::std::option::Option::Some(v);
    }

    // optional uint64 toolid = 6;

    pub fn toolid(&self) -> u64 {
        self.toolid.unwrap_or(0)
    }

    pub fn clear_toolid(&mut self) {
        self.toolid = ::std::option::Option::None;
    }

    pub fn has_toolid(&self) -> bool {
        self.toolid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toolid(&mut self, v: u64) {
        self.toolid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgCraftStatue {
    const NAME: &'static str = "CMsgCraftStatue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.heroid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.sequencename = ::std::option::Option::Some(is.read_string()?);
                },
                29 => {
                    self.cycle = ::std::option::Option::Some(is.read_float()?);
                },
                34 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.pedestal_itemdef = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.toolid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.heroid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.sequencename.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.cycle {
            my_size += 1 + 4;
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.pedestal_itemdef {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.toolid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.heroid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.sequencename.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.cycle {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.pedestal_itemdef {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.toolid {
            os.write_uint64(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCraftStatue {
        CMsgCraftStatue::new()
    }

    fn clear(&mut self) {
        self.heroid = ::std::option::Option::None;
        self.sequencename = ::std::option::Option::None;
        self.cycle = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.pedestal_itemdef = ::std::option::Option::None;
        self.toolid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCraftStatue {
        static instance: CMsgCraftStatue = CMsgCraftStatue {
            heroid: ::std::option::Option::None,
            sequencename: ::std::option::Option::None,
            cycle: ::std::option::Option::None,
            description: ::std::option::Option::None,
            pedestal_itemdef: ::std::option::Option::None,
            toolid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRedeemCode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRedeemCode {
    // message fields
    // @@protoc_insertion_point(field:CMsgRedeemCode.code)
    pub code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRedeemCode.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRedeemCode {
    fn default() -> &'a CMsgRedeemCode {
        <CMsgRedeemCode as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgRedeemCode {
    pub fn new() -> CMsgRedeemCode {
        ::std::default::Default::default()
    }

    // optional string code = 1;

    pub fn code(&self) -> &str {
        match self.code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_code(&mut self) {
        self.code = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        if self.code.is_none() {
            self.code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        self.code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgRedeemCode {
    const NAME: &'static str = "CMsgRedeemCode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.code.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.code.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRedeemCode {
        CMsgRedeemCode::new()
    }

    fn clear(&mut self) {
        self.code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRedeemCode {
        static instance: CMsgRedeemCode = CMsgRedeemCode {
            code: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRedeemCodeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRedeemCodeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgRedeemCodeResponse.response)
    pub response: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRedeemCodeResponse.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRedeemCodeResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRedeemCodeResponse {
    fn default() -> &'a CMsgRedeemCodeResponse {
        <CMsgRedeemCodeResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgRedeemCodeResponse {
    pub fn new() -> CMsgRedeemCodeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 response = 1;

    pub fn response(&self) -> u32 {
        self.response.unwrap_or(0)
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: u32) {
        self.response = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 2;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgRedeemCodeResponse {
    const NAME: &'static str = "CMsgRedeemCodeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRedeemCodeResponse {
        CMsgRedeemCodeResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRedeemCodeResponse {
        static instance: CMsgRedeemCodeResponse = CMsgRedeemCodeResponse {
            response: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgRedeemCodeResponse`
pub mod cmsg_redeem_code_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgRedeemCodeResponse.EResultCode)
    pub enum EResultCode {
        // @@protoc_insertion_point(enum_value:CMsgRedeemCodeResponse.EResultCode.k_Succeeded)
        k_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:CMsgRedeemCodeResponse.EResultCode.k_Failed_CodeNotFound)
        k_Failed_CodeNotFound = 1,
        // @@protoc_insertion_point(enum_value:CMsgRedeemCodeResponse.EResultCode.k_Failed_CodeAlreadyUsed)
        k_Failed_CodeAlreadyUsed = 2,
        // @@protoc_insertion_point(enum_value:CMsgRedeemCodeResponse.EResultCode.k_Failed_OtherError)
        k_Failed_OtherError = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResultCode {
        const NAME: &'static str = "EResultCode";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResultCode> {
            match value {
                0 => ::std::option::Option::Some(EResultCode::k_Succeeded),
                1 => ::std::option::Option::Some(EResultCode::k_Failed_CodeNotFound),
                2 => ::std::option::Option::Some(EResultCode::k_Failed_CodeAlreadyUsed),
                3 => ::std::option::Option::Some(EResultCode::k_Failed_OtherError),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResultCode> {
            match str {
                "k_Succeeded" => ::std::option::Option::Some(EResultCode::k_Succeeded),
                "k_Failed_CodeNotFound" => ::std::option::Option::Some(EResultCode::k_Failed_CodeNotFound),
                "k_Failed_CodeAlreadyUsed" => ::std::option::Option::Some(EResultCode::k_Failed_CodeAlreadyUsed),
                "k_Failed_OtherError" => ::std::option::Option::Some(EResultCode::k_Failed_OtherError),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResultCode] = &[
            EResultCode::k_Succeeded,
            EResultCode::k_Failed_CodeNotFound,
            EResultCode::k_Failed_CodeAlreadyUsed,
            EResultCode::k_Failed_OtherError,
        ];
    }

    impl ::std::default::Default for EResultCode {
        fn default() -> Self {
            EResultCode::k_Succeeded
        }
    }

}

// @@protoc_insertion_point(message:CMsgDevNewItemRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDevNewItemRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgDevNewItemRequest.item_def_name)
    pub item_def_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDevNewItemRequest.loot_list_name)
    pub loot_list_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDevNewItemRequest.attr_def_name)
    pub attr_def_name: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDevNewItemRequest.attr_value)
    pub attr_value: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDevNewItemRequest.item_quality)
    pub item_quality: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDevNewItemRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDevNewItemRequest {
    fn default() -> &'a CMsgDevNewItemRequest {
        <CMsgDevNewItemRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDevNewItemRequest {
    pub fn new() -> CMsgDevNewItemRequest {
        ::std::default::Default::default()
    }

    // optional string item_def_name = 3;

    pub fn item_def_name(&self) -> &str {
        match self.item_def_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_item_def_name(&mut self) {
        self.item_def_name = ::std::option::Option::None;
    }

    pub fn has_item_def_name(&self) -> bool {
        self.item_def_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_name(&mut self, v: ::std::string::String) {
        self.item_def_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_def_name(&mut self) -> &mut ::std::string::String {
        if self.item_def_name.is_none() {
            self.item_def_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.item_def_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_def_name(&mut self) -> ::std::string::String {
        self.item_def_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string loot_list_name = 4;

    pub fn loot_list_name(&self) -> &str {
        match self.loot_list_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_loot_list_name(&mut self) {
        self.loot_list_name = ::std::option::Option::None;
    }

    pub fn has_loot_list_name(&self) -> bool {
        self.loot_list_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loot_list_name(&mut self, v: ::std::string::String) {
        self.loot_list_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loot_list_name(&mut self) -> &mut ::std::string::String {
        if self.loot_list_name.is_none() {
            self.loot_list_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.loot_list_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_loot_list_name(&mut self) -> ::std::string::String {
        self.loot_list_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 item_quality = 7;

    pub fn item_quality(&self) -> u32 {
        self.item_quality.unwrap_or(0)
    }

    pub fn clear_item_quality(&mut self) {
        self.item_quality = ::std::option::Option::None;
    }

    pub fn has_item_quality(&self) -> bool {
        self.item_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality(&mut self, v: u32) {
        self.item_quality = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDevNewItemRequest {
    const NAME: &'static str = "CMsgDevNewItemRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.item_def_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.loot_list_name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.attr_def_name.push(is.read_string()?);
                },
                50 => {
                    self.attr_value.push(is.read_string()?);
                },
                56 => {
                    self.item_quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.loot_list_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        for value in &self.attr_def_name {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &value);
        };
        for value in &self.attr_value {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &value);
        };
        if let Some(v) = self.item_quality {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_def_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.loot_list_name.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.attr_def_name {
            os.write_string(5, &v)?;
        };
        for v in &self.attr_value {
            os.write_string(6, &v)?;
        };
        if let Some(v) = self.item_quality {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDevNewItemRequest {
        CMsgDevNewItemRequest::new()
    }

    fn clear(&mut self) {
        self.item_def_name = ::std::option::Option::None;
        self.loot_list_name = ::std::option::Option::None;
        self.attr_def_name.clear();
        self.attr_value.clear();
        self.item_quality = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDevNewItemRequest {
        static instance: CMsgDevNewItemRequest = CMsgDevNewItemRequest {
            item_def_name: ::std::option::Option::None,
            loot_list_name: ::std::option::Option::None,
            attr_def_name: ::std::vec::Vec::new(),
            attr_value: ::std::vec::Vec::new(),
            item_quality: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDevNewItemRequestResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDevNewItemRequestResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDevNewItemRequestResponse.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDevNewItemRequestResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDevNewItemRequestResponse {
    fn default() -> &'a CMsgDevNewItemRequestResponse {
        <CMsgDevNewItemRequestResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDevNewItemRequestResponse {
    pub fn new() -> CMsgDevNewItemRequestResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDevNewItemRequestResponse {
    const NAME: &'static str = "CMsgDevNewItemRequestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDevNewItemRequestResponse {
        CMsgDevNewItemRequestResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDevNewItemRequestResponse {
        static instance: CMsgDevNewItemRequestResponse = CMsgDevNewItemRequestResponse {
            success: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDevUnlockAllItemStyles)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDevUnlockAllItemStyles {
    // message fields
    // @@protoc_insertion_point(field:CMsgDevUnlockAllItemStyles.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDevUnlockAllItemStyles.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDevUnlockAllItemStyles {
    fn default() -> &'a CMsgDevUnlockAllItemStyles {
        <CMsgDevUnlockAllItemStyles as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDevUnlockAllItemStyles {
    pub fn new() -> CMsgDevUnlockAllItemStyles {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDevUnlockAllItemStyles {
    const NAME: &'static str = "CMsgDevUnlockAllItemStyles";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDevUnlockAllItemStyles {
        CMsgDevUnlockAllItemStyles::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDevUnlockAllItemStyles {
        static instance: CMsgDevUnlockAllItemStyles = CMsgDevUnlockAllItemStyles {
            item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDevUnlockAllItemStylesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDevUnlockAllItemStylesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDevUnlockAllItemStylesResponse.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDevUnlockAllItemStylesResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDevUnlockAllItemStylesResponse {
    fn default() -> &'a CMsgDevUnlockAllItemStylesResponse {
        <CMsgDevUnlockAllItemStylesResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDevUnlockAllItemStylesResponse {
    pub fn new() -> CMsgDevUnlockAllItemStylesResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDevUnlockAllItemStylesResponse {
    const NAME: &'static str = "CMsgDevUnlockAllItemStylesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDevUnlockAllItemStylesResponse {
        CMsgDevUnlockAllItemStylesResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDevUnlockAllItemStylesResponse {
        static instance: CMsgDevUnlockAllItemStylesResponse = CMsgDevUnlockAllItemStylesResponse {
            success: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCGetAccountSubscriptionItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCGetAccountSubscriptionItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCGetAccountSubscriptionItem.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCGetAccountSubscriptionItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCGetAccountSubscriptionItem {
    fn default() -> &'a CMsgGCGetAccountSubscriptionItem {
        <CMsgGCGetAccountSubscriptionItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCGetAccountSubscriptionItem {
    pub fn new() -> CMsgGCGetAccountSubscriptionItem {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCGetAccountSubscriptionItem {
    const NAME: &'static str = "CMsgGCGetAccountSubscriptionItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCGetAccountSubscriptionItem {
        CMsgGCGetAccountSubscriptionItem::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCGetAccountSubscriptionItem {
        static instance: CMsgGCGetAccountSubscriptionItem = CMsgGCGetAccountSubscriptionItem {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCGetAccountSubscriptionItemResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCGetAccountSubscriptionItemResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCGetAccountSubscriptionItemResponse.def_index)
    pub def_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCGetAccountSubscriptionItemResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCGetAccountSubscriptionItemResponse {
    fn default() -> &'a CMsgGCGetAccountSubscriptionItemResponse {
        <CMsgGCGetAccountSubscriptionItemResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCGetAccountSubscriptionItemResponse {
    pub fn new() -> CMsgGCGetAccountSubscriptionItemResponse {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCGetAccountSubscriptionItemResponse {
    const NAME: &'static str = "CMsgGCGetAccountSubscriptionItemResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCGetAccountSubscriptionItemResponse {
        CMsgGCGetAccountSubscriptionItemResponse::new()
    }

    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCGetAccountSubscriptionItemResponse {
        static instance: CMsgGCGetAccountSubscriptionItemResponse = CMsgGCGetAccountSubscriptionItemResponse {
            def_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCAddGiftItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCAddGiftItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCAddGiftItem.gifter_account_id)
    pub gifter_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCAddGiftItem.receiver_account_id)
    pub receiver_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCAddGiftItem.wrapped_item)
    pub wrapped_item: ::steam_vent_proto_common::protobuf::MessageField<super::base_gcmessages::CSOEconItem>,
    // @@protoc_insertion_point(field:CMsgGCAddGiftItem.gift_message)
    pub gift_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCAddGiftItem.is_wallet_cash_trusted)
    pub is_wallet_cash_trusted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCAddGiftItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCAddGiftItem {
    fn default() -> &'a CMsgGCAddGiftItem {
        <CMsgGCAddGiftItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCAddGiftItem {
    pub fn new() -> CMsgGCAddGiftItem {
        ::std::default::Default::default()
    }

    // optional uint32 gifter_account_id = 1;

    pub fn gifter_account_id(&self) -> u32 {
        self.gifter_account_id.unwrap_or(0)
    }

    pub fn clear_gifter_account_id(&mut self) {
        self.gifter_account_id = ::std::option::Option::None;
    }

    pub fn has_gifter_account_id(&self) -> bool {
        self.gifter_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifter_account_id(&mut self, v: u32) {
        self.gifter_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 receiver_account_id = 2;

    pub fn receiver_account_id(&self) -> u32 {
        self.receiver_account_id.unwrap_or(0)
    }

    pub fn clear_receiver_account_id(&mut self) {
        self.receiver_account_id = ::std::option::Option::None;
    }

    pub fn has_receiver_account_id(&self) -> bool {
        self.receiver_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_account_id(&mut self, v: u32) {
        self.receiver_account_id = ::std::option::Option::Some(v);
    }

    // optional string gift_message = 4;

    pub fn gift_message(&self) -> &str {
        match self.gift_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gift_message(&mut self) {
        self.gift_message = ::std::option::Option::None;
    }

    pub fn has_gift_message(&self) -> bool {
        self.gift_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gift_message(&mut self, v: ::std::string::String) {
        self.gift_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gift_message(&mut self) -> &mut ::std::string::String {
        if self.gift_message.is_none() {
            self.gift_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gift_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_gift_message(&mut self) -> ::std::string::String {
        self.gift_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_wallet_cash_trusted = 5;

    pub fn is_wallet_cash_trusted(&self) -> bool {
        self.is_wallet_cash_trusted.unwrap_or(false)
    }

    pub fn clear_is_wallet_cash_trusted(&mut self) {
        self.is_wallet_cash_trusted = ::std::option::Option::None;
    }

    pub fn has_is_wallet_cash_trusted(&self) -> bool {
        self.is_wallet_cash_trusted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_wallet_cash_trusted(&mut self, v: bool) {
        self.is_wallet_cash_trusted = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCAddGiftItem {
    const NAME: &'static str = "CMsgGCAddGiftItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gifter_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.receiver_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.wrapped_item)?;
                },
                34 => {
                    self.gift_message = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.is_wallet_cash_trusted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gifter_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.receiver_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.wrapped_item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.gift_message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.is_wallet_cash_trusted {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.gifter_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.receiver_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.wrapped_item.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.gift_message.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.is_wallet_cash_trusted {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCAddGiftItem {
        CMsgGCAddGiftItem::new()
    }

    fn clear(&mut self) {
        self.gifter_account_id = ::std::option::Option::None;
        self.receiver_account_id = ::std::option::Option::None;
        self.wrapped_item.clear();
        self.gift_message = ::std::option::Option::None;
        self.is_wallet_cash_trusted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCAddGiftItem {
        static instance: CMsgGCAddGiftItem = CMsgGCAddGiftItem {
            gifter_account_id: ::std::option::Option::None,
            receiver_account_id: ::std::option::Option::None,
            wrapped_item: ::steam_vent_proto_common::protobuf::MessageField::none(),
            gift_message: ::std::option::Option::None,
            is_wallet_cash_trusted: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCWrapAndDeliverGift)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCWrapAndDeliverGift {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCWrapAndDeliverGift.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCWrapAndDeliverGift.give_to_account_id)
    pub give_to_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCWrapAndDeliverGift.gift_message)
    pub gift_message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCWrapAndDeliverGift.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCWrapAndDeliverGift {
    fn default() -> &'a CMsgClientToGCWrapAndDeliverGift {
        <CMsgClientToGCWrapAndDeliverGift as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCWrapAndDeliverGift {
    pub fn new() -> CMsgClientToGCWrapAndDeliverGift {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 give_to_account_id = 2;

    pub fn give_to_account_id(&self) -> u32 {
        self.give_to_account_id.unwrap_or(0)
    }

    pub fn clear_give_to_account_id(&mut self) {
        self.give_to_account_id = ::std::option::Option::None;
    }

    pub fn has_give_to_account_id(&self) -> bool {
        self.give_to_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_give_to_account_id(&mut self, v: u32) {
        self.give_to_account_id = ::std::option::Option::Some(v);
    }

    // optional string gift_message = 3;

    pub fn gift_message(&self) -> &str {
        match self.gift_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gift_message(&mut self) {
        self.gift_message = ::std::option::Option::None;
    }

    pub fn has_gift_message(&self) -> bool {
        self.gift_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gift_message(&mut self, v: ::std::string::String) {
        self.gift_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gift_message(&mut self) -> &mut ::std::string::String {
        if self.gift_message.is_none() {
            self.gift_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gift_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_gift_message(&mut self) -> ::std::string::String {
        self.gift_message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCWrapAndDeliverGift {
    const NAME: &'static str = "CMsgClientToGCWrapAndDeliverGift";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.give_to_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.gift_message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.give_to_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.gift_message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.give_to_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.gift_message.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCWrapAndDeliverGift {
        CMsgClientToGCWrapAndDeliverGift::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.give_to_account_id = ::std::option::Option::None;
        self.gift_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCWrapAndDeliverGift {
        static instance: CMsgClientToGCWrapAndDeliverGift = CMsgClientToGCWrapAndDeliverGift {
            item_id: ::std::option::Option::None,
            give_to_account_id: ::std::option::Option::None,
            gift_message: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSQLGCToGCRevokeUntrustedGift)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSQLGCToGCRevokeUntrustedGift {
    // message fields
    // @@protoc_insertion_point(field:CMsgSQLGCToGCRevokeUntrustedGift.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSQLGCToGCRevokeUntrustedGift.sent_item_id)
    pub sent_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSQLGCToGCRevokeUntrustedGift.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSQLGCToGCRevokeUntrustedGift {
    fn default() -> &'a CMsgSQLGCToGCRevokeUntrustedGift {
        <CMsgSQLGCToGCRevokeUntrustedGift as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSQLGCToGCRevokeUntrustedGift {
    pub fn new() -> CMsgSQLGCToGCRevokeUntrustedGift {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 sent_item_id = 4;

    pub fn sent_item_id(&self) -> u64 {
        self.sent_item_id.unwrap_or(0)
    }

    pub fn clear_sent_item_id(&mut self) {
        self.sent_item_id = ::std::option::Option::None;
    }

    pub fn has_sent_item_id(&self) -> bool {
        self.sent_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sent_item_id(&mut self, v: u64) {
        self.sent_item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSQLGCToGCRevokeUntrustedGift {
    const NAME: &'static str = "CMsgSQLGCToGCRevokeUntrustedGift";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.sent_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.sent_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.sent_item_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSQLGCToGCRevokeUntrustedGift {
        CMsgSQLGCToGCRevokeUntrustedGift::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.sent_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSQLGCToGCRevokeUntrustedGift {
        static instance: CMsgSQLGCToGCRevokeUntrustedGift = CMsgSQLGCToGCRevokeUntrustedGift {
            account_id: ::std::option::Option::None,
            sent_item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCWrapAndDeliverGiftResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCWrapAndDeliverGiftResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCWrapAndDeliverGiftResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::econ_shared_enums::EGCMsgResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCWrapAndDeliverGiftResponse.gifting_charge_uses)
    pub gifting_charge_uses: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCWrapAndDeliverGiftResponse.gifting_charge_max)
    pub gifting_charge_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientToGCWrapAndDeliverGiftResponse.gifting_uses)
    pub gifting_uses: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCWrapAndDeliverGiftResponse.gifting_max)
    pub gifting_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientToGCWrapAndDeliverGiftResponse.gifting_window_hours)
    pub gifting_window_hours: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCWrapAndDeliverGiftResponse.trade_restriction)
    pub trade_restriction: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EGCMsgInitiateTradeResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCWrapAndDeliverGiftResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCWrapAndDeliverGiftResponse {
    fn default() -> &'a CMsgClientToGCWrapAndDeliverGiftResponse {
        <CMsgClientToGCWrapAndDeliverGiftResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCWrapAndDeliverGiftResponse {
    pub fn new() -> CMsgClientToGCWrapAndDeliverGiftResponse {
        ::std::default::Default::default()
    }

    // optional .EGCMsgResponse response = 1;

    pub fn response(&self) -> super::econ_shared_enums::EGCMsgResponse {
        match self.response {
            Some(e) => e.enum_value_or(super::econ_shared_enums::EGCMsgResponse::k_EGCMsgResponseOK),
            None => super::econ_shared_enums::EGCMsgResponse::k_EGCMsgResponseOK,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: super::econ_shared_enums::EGCMsgResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 gifting_charge_uses = 2;

    pub fn gifting_charge_uses(&self) -> u32 {
        self.gifting_charge_uses.unwrap_or(0)
    }

    pub fn clear_gifting_charge_uses(&mut self) {
        self.gifting_charge_uses = ::std::option::Option::None;
    }

    pub fn has_gifting_charge_uses(&self) -> bool {
        self.gifting_charge_uses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifting_charge_uses(&mut self, v: u32) {
        self.gifting_charge_uses = ::std::option::Option::Some(v);
    }

    // optional int32 gifting_charge_max = 3;

    pub fn gifting_charge_max(&self) -> i32 {
        self.gifting_charge_max.unwrap_or(0)
    }

    pub fn clear_gifting_charge_max(&mut self) {
        self.gifting_charge_max = ::std::option::Option::None;
    }

    pub fn has_gifting_charge_max(&self) -> bool {
        self.gifting_charge_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifting_charge_max(&mut self, v: i32) {
        self.gifting_charge_max = ::std::option::Option::Some(v);
    }

    // optional uint32 gifting_uses = 4;

    pub fn gifting_uses(&self) -> u32 {
        self.gifting_uses.unwrap_or(0)
    }

    pub fn clear_gifting_uses(&mut self) {
        self.gifting_uses = ::std::option::Option::None;
    }

    pub fn has_gifting_uses(&self) -> bool {
        self.gifting_uses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifting_uses(&mut self, v: u32) {
        self.gifting_uses = ::std::option::Option::Some(v);
    }

    // optional int32 gifting_max = 5;

    pub fn gifting_max(&self) -> i32 {
        self.gifting_max.unwrap_or(0)
    }

    pub fn clear_gifting_max(&mut self) {
        self.gifting_max = ::std::option::Option::None;
    }

    pub fn has_gifting_max(&self) -> bool {
        self.gifting_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifting_max(&mut self, v: i32) {
        self.gifting_max = ::std::option::Option::Some(v);
    }

    // optional uint32 gifting_window_hours = 6;

    pub fn gifting_window_hours(&self) -> u32 {
        self.gifting_window_hours.unwrap_or(0)
    }

    pub fn clear_gifting_window_hours(&mut self) {
        self.gifting_window_hours = ::std::option::Option::None;
    }

    pub fn has_gifting_window_hours(&self) -> bool {
        self.gifting_window_hours.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifting_window_hours(&mut self, v: u32) {
        self.gifting_window_hours = ::std::option::Option::Some(v);
    }

    // optional .EGCMsgInitiateTradeResponse trade_restriction = 7;

    pub fn trade_restriction(&self) -> EGCMsgInitiateTradeResponse {
        match self.trade_restriction {
            Some(e) => e.enum_value_or(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted),
            None => EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted,
        }
    }

    pub fn clear_trade_restriction(&mut self) {
        self.trade_restriction = ::std::option::Option::None;
    }

    pub fn has_trade_restriction(&self) -> bool {
        self.trade_restriction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_restriction(&mut self, v: EGCMsgInitiateTradeResponse) {
        self.trade_restriction = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCWrapAndDeliverGiftResponse {
    const NAME: &'static str = "CMsgClientToGCWrapAndDeliverGiftResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.gifting_charge_uses = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.gifting_charge_max = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.gifting_uses = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.gifting_max = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.gifting_window_hours = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.trade_restriction = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.gifting_charge_uses {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.gifting_charge_max {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.gifting_uses {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.gifting_max {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.gifting_window_hours {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.trade_restriction {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.gifting_charge_uses {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.gifting_charge_max {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.gifting_uses {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.gifting_max {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.gifting_window_hours {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.trade_restriction {
            os.write_enum(7, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCWrapAndDeliverGiftResponse {
        CMsgClientToGCWrapAndDeliverGiftResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.gifting_charge_uses = ::std::option::Option::None;
        self.gifting_charge_max = ::std::option::Option::None;
        self.gifting_uses = ::std::option::Option::None;
        self.gifting_max = ::std::option::Option::None;
        self.gifting_window_hours = ::std::option::Option::None;
        self.trade_restriction = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCWrapAndDeliverGiftResponse {
        static instance: CMsgClientToGCWrapAndDeliverGiftResponse = CMsgClientToGCWrapAndDeliverGiftResponse {
            response: ::std::option::Option::None,
            gifting_charge_uses: ::std::option::Option::None,
            gifting_charge_max: ::std::option::Option::None,
            gifting_uses: ::std::option::Option::None,
            gifting_max: ::std::option::Option::None,
            gifting_window_hours: ::std::option::Option::None,
            trade_restriction: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCUnwrapGift)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnwrapGift {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUnwrapGift.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUnwrapGift.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnwrapGift {
    fn default() -> &'a CMsgClientToGCUnwrapGift {
        <CMsgClientToGCUnwrapGift as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnwrapGift {
    pub fn new() -> CMsgClientToGCUnwrapGift {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUnwrapGift {
    const NAME: &'static str = "CMsgClientToGCUnwrapGift";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnwrapGift {
        CMsgClientToGCUnwrapGift::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnwrapGift {
        static instance: CMsgClientToGCUnwrapGift = CMsgClientToGCUnwrapGift {
            item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetGiftPermissions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetGiftPermissions {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetGiftPermissions.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetGiftPermissions {
    fn default() -> &'a CMsgClientToGCGetGiftPermissions {
        <CMsgClientToGCGetGiftPermissions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetGiftPermissions {
    pub fn new() -> CMsgClientToGCGetGiftPermissions {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetGiftPermissions {
    const NAME: &'static str = "CMsgClientToGCGetGiftPermissions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetGiftPermissions {
        CMsgClientToGCGetGiftPermissions::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetGiftPermissions {
        static instance: CMsgClientToGCGetGiftPermissions = CMsgClientToGCGetGiftPermissions {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetGiftPermissionsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetGiftPermissionsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetGiftPermissionsResponse.is_unlimited)
    pub is_unlimited: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetGiftPermissionsResponse.has_two_factor)
    pub has_two_factor: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetGiftPermissionsResponse.sender_permission)
    pub sender_permission: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EGCMsgInitiateTradeResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetGiftPermissionsResponse.friendship_age_requirement)
    pub friendship_age_requirement: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetGiftPermissionsResponse.friendship_age_requirement_two_factor)
    pub friendship_age_requirement_two_factor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetGiftPermissionsResponse.friend_permissions)
    pub friend_permissions: ::std::vec::Vec<cmsg_client_to_gcget_gift_permissions_response::FriendPermission>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetGiftPermissionsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetGiftPermissionsResponse {
    fn default() -> &'a CMsgClientToGCGetGiftPermissionsResponse {
        <CMsgClientToGCGetGiftPermissionsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetGiftPermissionsResponse {
    pub fn new() -> CMsgClientToGCGetGiftPermissionsResponse {
        ::std::default::Default::default()
    }

    // optional bool is_unlimited = 1;

    pub fn is_unlimited(&self) -> bool {
        self.is_unlimited.unwrap_or(false)
    }

    pub fn clear_is_unlimited(&mut self) {
        self.is_unlimited = ::std::option::Option::None;
    }

    pub fn has_is_unlimited(&self) -> bool {
        self.is_unlimited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_unlimited(&mut self, v: bool) {
        self.is_unlimited = ::std::option::Option::Some(v);
    }

    // optional bool has_two_factor = 3;

    pub fn has_two_factor(&self) -> bool {
        self.has_two_factor.unwrap_or(false)
    }

    pub fn clear_has_two_factor(&mut self) {
        self.has_two_factor = ::std::option::Option::None;
    }

    pub fn has_has_two_factor(&self) -> bool {
        self.has_two_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_two_factor(&mut self, v: bool) {
        self.has_two_factor = ::std::option::Option::Some(v);
    }

    // optional .EGCMsgInitiateTradeResponse sender_permission = 6;

    pub fn sender_permission(&self) -> EGCMsgInitiateTradeResponse {
        match self.sender_permission {
            Some(e) => e.enum_value_or(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted),
            None => EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted,
        }
    }

    pub fn clear_sender_permission(&mut self) {
        self.sender_permission = ::std::option::Option::None;
    }

    pub fn has_sender_permission(&self) -> bool {
        self.sender_permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_permission(&mut self, v: EGCMsgInitiateTradeResponse) {
        self.sender_permission = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 friendship_age_requirement = 7;

    pub fn friendship_age_requirement(&self) -> u32 {
        self.friendship_age_requirement.unwrap_or(0)
    }

    pub fn clear_friendship_age_requirement(&mut self) {
        self.friendship_age_requirement = ::std::option::Option::None;
    }

    pub fn has_friendship_age_requirement(&self) -> bool {
        self.friendship_age_requirement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendship_age_requirement(&mut self, v: u32) {
        self.friendship_age_requirement = ::std::option::Option::Some(v);
    }

    // optional uint32 friendship_age_requirement_two_factor = 8;

    pub fn friendship_age_requirement_two_factor(&self) -> u32 {
        self.friendship_age_requirement_two_factor.unwrap_or(0)
    }

    pub fn clear_friendship_age_requirement_two_factor(&mut self) {
        self.friendship_age_requirement_two_factor = ::std::option::Option::None;
    }

    pub fn has_friendship_age_requirement_two_factor(&self) -> bool {
        self.friendship_age_requirement_two_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendship_age_requirement_two_factor(&mut self, v: u32) {
        self.friendship_age_requirement_two_factor = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetGiftPermissionsResponse {
    const NAME: &'static str = "CMsgClientToGCGetGiftPermissionsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_unlimited = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.has_two_factor = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.sender_permission = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.friendship_age_requirement = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.friendship_age_requirement_two_factor = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    self.friend_permissions.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_unlimited {
            my_size += 1 + 1;
        }
        if let Some(v) = self.has_two_factor {
            my_size += 1 + 1;
        }
        if let Some(v) = self.sender_permission {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.friendship_age_requirement {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.friendship_age_requirement_two_factor {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        for value in &self.friend_permissions {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.is_unlimited {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.has_two_factor {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.sender_permission {
            os.write_enum(6, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.friendship_age_requirement {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.friendship_age_requirement_two_factor {
            os.write_uint32(8, v)?;
        }
        for v in &self.friend_permissions {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetGiftPermissionsResponse {
        CMsgClientToGCGetGiftPermissionsResponse::new()
    }

    fn clear(&mut self) {
        self.is_unlimited = ::std::option::Option::None;
        self.has_two_factor = ::std::option::Option::None;
        self.sender_permission = ::std::option::Option::None;
        self.friendship_age_requirement = ::std::option::Option::None;
        self.friendship_age_requirement_two_factor = ::std::option::Option::None;
        self.friend_permissions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetGiftPermissionsResponse {
        static instance: CMsgClientToGCGetGiftPermissionsResponse = CMsgClientToGCGetGiftPermissionsResponse {
            is_unlimited: ::std::option::Option::None,
            has_two_factor: ::std::option::Option::None,
            sender_permission: ::std::option::Option::None,
            friendship_age_requirement: ::std::option::Option::None,
            friendship_age_requirement_two_factor: ::std::option::Option::None,
            friend_permissions: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCGetGiftPermissionsResponse`
pub mod cmsg_client_to_gcget_gift_permissions_response {
    // @@protoc_insertion_point(message:CMsgClientToGCGetGiftPermissionsResponse.FriendPermission)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FriendPermission {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCGetGiftPermissionsResponse.FriendPermission.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCGetGiftPermissionsResponse.FriendPermission.permission)
        pub permission: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::EGCMsgInitiateTradeResponse>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCGetGiftPermissionsResponse.FriendPermission.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FriendPermission {
        fn default() -> &'a FriendPermission {
            <FriendPermission as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl FriendPermission {
        pub fn new() -> FriendPermission {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional .EGCMsgInitiateTradeResponse permission = 2;

        pub fn permission(&self) -> super::EGCMsgInitiateTradeResponse {
            match self.permission {
                Some(e) => e.enum_value_or(super::EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted),
                None => super::EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted,
            }
        }

        pub fn clear_permission(&mut self) {
            self.permission = ::std::option::Option::None;
        }

        pub fn has_permission(&self) -> bool {
            self.permission.is_some()
        }

        // Param is passed by value, moved
        pub fn set_permission(&mut self, v: super::EGCMsgInitiateTradeResponse) {
            self.permission = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for FriendPermission {
        const NAME: &'static str = "FriendPermission";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.permission = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.permission {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.permission {
                os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FriendPermission {
            FriendPermission::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.permission = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FriendPermission {
            static instance: FriendPermission = FriendPermission {
                account_id: ::std::option::Option::None,
                permission: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCUnpackBundle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnpackBundle {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUnpackBundle.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUnpackBundle.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnpackBundle {
    fn default() -> &'a CMsgClientToGCUnpackBundle {
        <CMsgClientToGCUnpackBundle as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnpackBundle {
    pub fn new() -> CMsgClientToGCUnpackBundle {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUnpackBundle {
    const NAME: &'static str = "CMsgClientToGCUnpackBundle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnpackBundle {
        CMsgClientToGCUnpackBundle::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnpackBundle {
        static instance: CMsgClientToGCUnpackBundle = CMsgClientToGCUnpackBundle {
            item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCUnpackBundleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnpackBundleResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUnpackBundleResponse.unpacked_item_ids)
    pub unpacked_item_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnpackBundleResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcunpack_bundle_response::EUnpackBundle>>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnpackBundleResponse.unpacked_item_def_indexes)
    pub unpacked_item_def_indexes: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUnpackBundleResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnpackBundleResponse {
    fn default() -> &'a CMsgClientToGCUnpackBundleResponse {
        <CMsgClientToGCUnpackBundleResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnpackBundleResponse {
    pub fn new() -> CMsgClientToGCUnpackBundleResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCUnpackBundleResponse.EUnpackBundle response = 2;

    pub fn response(&self) -> cmsg_client_to_gcunpack_bundle_response::EUnpackBundle {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcunpack_bundle_response::EUnpackBundle::k_UnpackBundle_Succeeded),
            None => cmsg_client_to_gcunpack_bundle_response::EUnpackBundle::k_UnpackBundle_Succeeded,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcunpack_bundle_response::EUnpackBundle) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUnpackBundleResponse {
    const NAME: &'static str = "CMsgClientToGCUnpackBundleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.unpacked_item_ids)?;
                },
                8 => {
                    self.unpacked_item_ids.push(is.read_uint64()?);
                },
                16 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.unpacked_item_def_indexes)?;
                },
                24 => {
                    self.unpacked_item_def_indexes.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.unpacked_item_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, *value);
        };
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        for value in &self.unpacked_item_def_indexes {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.unpacked_item_ids {
            os.write_uint64(1, *v)?;
        };
        if let Some(v) = self.response {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.unpacked_item_def_indexes {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnpackBundleResponse {
        CMsgClientToGCUnpackBundleResponse::new()
    }

    fn clear(&mut self) {
        self.unpacked_item_ids.clear();
        self.response = ::std::option::Option::None;
        self.unpacked_item_def_indexes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnpackBundleResponse {
        static instance: CMsgClientToGCUnpackBundleResponse = CMsgClientToGCUnpackBundleResponse {
            unpacked_item_ids: ::std::vec::Vec::new(),
            response: ::std::option::Option::None,
            unpacked_item_def_indexes: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCUnpackBundleResponse`
pub mod cmsg_client_to_gcunpack_bundle_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCUnpackBundleResponse.EUnpackBundle)
    pub enum EUnpackBundle {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCUnpackBundleResponse.EUnpackBundle.k_UnpackBundle_Succeeded)
        k_UnpackBundle_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCUnpackBundleResponse.EUnpackBundle.k_UnpackBundle_Failed_ItemIsNotBundle)
        k_UnpackBundle_Failed_ItemIsNotBundle = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCUnpackBundleResponse.EUnpackBundle.k_UnpackBundle_Failed_UnableToCreateContainedItem)
        k_UnpackBundle_Failed_UnableToCreateContainedItem = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCUnpackBundleResponse.EUnpackBundle.k_UnpackBundle_Failed_SOCacheError)
        k_UnpackBundle_Failed_SOCacheError = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCUnpackBundleResponse.EUnpackBundle.k_UnpackBundle_Failed_ItemIsInvalid)
        k_UnpackBundle_Failed_ItemIsInvalid = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCUnpackBundleResponse.EUnpackBundle.k_UnpackBundle_Failed_BadItemQuantity)
        k_UnpackBundle_Failed_BadItemQuantity = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCUnpackBundleResponse.EUnpackBundle.k_UnpackBundle_Failed_UnableToDeleteItem)
        k_UnpackBundle_Failed_UnableToDeleteItem = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EUnpackBundle {
        const NAME: &'static str = "EUnpackBundle";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EUnpackBundle> {
            match value {
                0 => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Succeeded),
                1 => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_ItemIsNotBundle),
                2 => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_UnableToCreateContainedItem),
                3 => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_SOCacheError),
                4 => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_ItemIsInvalid),
                5 => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_BadItemQuantity),
                6 => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_UnableToDeleteItem),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EUnpackBundle> {
            match str {
                "k_UnpackBundle_Succeeded" => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Succeeded),
                "k_UnpackBundle_Failed_ItemIsNotBundle" => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_ItemIsNotBundle),
                "k_UnpackBundle_Failed_UnableToCreateContainedItem" => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_UnableToCreateContainedItem),
                "k_UnpackBundle_Failed_SOCacheError" => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_SOCacheError),
                "k_UnpackBundle_Failed_ItemIsInvalid" => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_ItemIsInvalid),
                "k_UnpackBundle_Failed_BadItemQuantity" => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_BadItemQuantity),
                "k_UnpackBundle_Failed_UnableToDeleteItem" => ::std::option::Option::Some(EUnpackBundle::k_UnpackBundle_Failed_UnableToDeleteItem),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EUnpackBundle] = &[
            EUnpackBundle::k_UnpackBundle_Succeeded,
            EUnpackBundle::k_UnpackBundle_Failed_ItemIsNotBundle,
            EUnpackBundle::k_UnpackBundle_Failed_UnableToCreateContainedItem,
            EUnpackBundle::k_UnpackBundle_Failed_SOCacheError,
            EUnpackBundle::k_UnpackBundle_Failed_ItemIsInvalid,
            EUnpackBundle::k_UnpackBundle_Failed_BadItemQuantity,
            EUnpackBundle::k_UnpackBundle_Failed_UnableToDeleteItem,
        ];
    }

    impl ::std::default::Default for EUnpackBundle {
        fn default() -> Self {
            EUnpackBundle::k_UnpackBundle_Succeeded
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCPackBundle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCPackBundle {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCPackBundle.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCPackBundle.bundle_item_def_index)
    pub bundle_item_def_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCPackBundle.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCPackBundle {
    fn default() -> &'a CMsgClientToGCPackBundle {
        <CMsgClientToGCPackBundle as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCPackBundle {
    pub fn new() -> CMsgClientToGCPackBundle {
        ::std::default::Default::default()
    }

    // optional uint32 bundle_item_def_index = 2;

    pub fn bundle_item_def_index(&self) -> u32 {
        self.bundle_item_def_index.unwrap_or(0)
    }

    pub fn clear_bundle_item_def_index(&mut self) {
        self.bundle_item_def_index = ::std::option::Option::None;
    }

    pub fn has_bundle_item_def_index(&self) -> bool {
        self.bundle_item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bundle_item_def_index(&mut self, v: u32) {
        self.bundle_item_def_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCPackBundle {
    const NAME: &'static str = "CMsgClientToGCPackBundle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                8 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                16 => {
                    self.bundle_item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, *value);
        };
        if let Some(v) = self.bundle_item_def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.item_ids {
            os.write_uint64(1, *v)?;
        };
        if let Some(v) = self.bundle_item_def_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCPackBundle {
        CMsgClientToGCPackBundle::new()
    }

    fn clear(&mut self) {
        self.item_ids.clear();
        self.bundle_item_def_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCPackBundle {
        static instance: CMsgClientToGCPackBundle = CMsgClientToGCPackBundle {
            item_ids: ::std::vec::Vec::new(),
            bundle_item_def_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCPackBundleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCPackBundleResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCPackBundleResponse.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCPackBundleResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcpack_bundle_response::EPackBundle>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCPackBundleResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCPackBundleResponse {
    fn default() -> &'a CMsgClientToGCPackBundleResponse {
        <CMsgClientToGCPackBundleResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCPackBundleResponse {
    pub fn new() -> CMsgClientToGCPackBundleResponse {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgClientToGCPackBundleResponse.EPackBundle response = 2;

    pub fn response(&self) -> cmsg_client_to_gcpack_bundle_response::EPackBundle {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcpack_bundle_response::EPackBundle::k_PackBundle_Succeeded),
            None => cmsg_client_to_gcpack_bundle_response::EPackBundle::k_PackBundle_Succeeded,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcpack_bundle_response::EPackBundle) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCPackBundleResponse {
    const NAME: &'static str = "CMsgClientToGCPackBundleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.response {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCPackBundleResponse {
        CMsgClientToGCPackBundleResponse::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCPackBundleResponse {
        static instance: CMsgClientToGCPackBundleResponse = CMsgClientToGCPackBundleResponse {
            item_id: ::std::option::Option::None,
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCPackBundleResponse`
pub mod cmsg_client_to_gcpack_bundle_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCPackBundleResponse.EPackBundle)
    pub enum EPackBundle {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPackBundleResponse.EPackBundle.k_PackBundle_Succeeded)
        k_PackBundle_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPackBundleResponse.EPackBundle.k_PackBundle_Failed_InternalError)
        k_PackBundle_Failed_InternalError = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPackBundleResponse.EPackBundle.k_PackBundle_Failed_ItemIsNotBundle)
        k_PackBundle_Failed_ItemIsNotBundle = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPackBundleResponse.EPackBundle.k_PackBundle_Failed_SOCacheError)
        k_PackBundle_Failed_SOCacheError = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPackBundleResponse.EPackBundle.k_PackBundle_Failed_ItemIsInvalid)
        k_PackBundle_Failed_ItemIsInvalid = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPackBundleResponse.EPackBundle.k_PackBundle_Failed_BadItemQuantity)
        k_PackBundle_Failed_BadItemQuantity = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPackBundleResponse.EPackBundle.k_PackBundle_Failed_UnableToDeleteItem)
        k_PackBundle_Failed_UnableToDeleteItem = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPackBundleResponse.EPackBundle.k_PackBundle_Failed_BundleCannotBePacked)
        k_PackBundle_Failed_BundleCannotBePacked = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPackBundleResponse.EPackBundle.k_PackBundle_Failed_ItemIsUntradeable)
        k_PackBundle_Failed_ItemIsUntradeable = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPackBundleResponse.EPackBundle.k_PackBundle_Failed_ItemIsEquipped)
        k_PackBundle_Failed_ItemIsEquipped = 9,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPackBundleResponse.EPackBundle.k_PackBundle_Failed_ItemHasGems)
        k_PackBundle_Failed_ItemHasGems = 10,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPackBundleResponse.EPackBundle.k_PackBundle_Failed_ItemMixedQuality)
        k_PackBundle_Failed_ItemMixedQuality = 11,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPackBundleResponse.EPackBundle.k_PackBundle_Failed_ItemInvalidQuality)
        k_PackBundle_Failed_ItemInvalidQuality = 12,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPackBundleResponse.EPackBundle.k_PackBundle_Failed_ItemIsNonEconomy)
        k_PackBundle_Failed_ItemIsNonEconomy = 13,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPackBundleResponse.EPackBundle.k_PackBundle_Failed_Disabled)
        k_PackBundle_Failed_Disabled = 14,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EPackBundle {
        const NAME: &'static str = "EPackBundle";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EPackBundle> {
            match value {
                0 => ::std::option::Option::Some(EPackBundle::k_PackBundle_Succeeded),
                1 => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_InternalError),
                2 => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_ItemIsNotBundle),
                3 => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_SOCacheError),
                4 => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_ItemIsInvalid),
                5 => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_BadItemQuantity),
                6 => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_UnableToDeleteItem),
                7 => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_BundleCannotBePacked),
                8 => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_ItemIsUntradeable),
                9 => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_ItemIsEquipped),
                10 => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_ItemHasGems),
                11 => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_ItemMixedQuality),
                12 => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_ItemInvalidQuality),
                13 => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_ItemIsNonEconomy),
                14 => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_Disabled),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EPackBundle> {
            match str {
                "k_PackBundle_Succeeded" => ::std::option::Option::Some(EPackBundle::k_PackBundle_Succeeded),
                "k_PackBundle_Failed_InternalError" => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_InternalError),
                "k_PackBundle_Failed_ItemIsNotBundle" => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_ItemIsNotBundle),
                "k_PackBundle_Failed_SOCacheError" => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_SOCacheError),
                "k_PackBundle_Failed_ItemIsInvalid" => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_ItemIsInvalid),
                "k_PackBundle_Failed_BadItemQuantity" => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_BadItemQuantity),
                "k_PackBundle_Failed_UnableToDeleteItem" => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_UnableToDeleteItem),
                "k_PackBundle_Failed_BundleCannotBePacked" => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_BundleCannotBePacked),
                "k_PackBundle_Failed_ItemIsUntradeable" => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_ItemIsUntradeable),
                "k_PackBundle_Failed_ItemIsEquipped" => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_ItemIsEquipped),
                "k_PackBundle_Failed_ItemHasGems" => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_ItemHasGems),
                "k_PackBundle_Failed_ItemMixedQuality" => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_ItemMixedQuality),
                "k_PackBundle_Failed_ItemInvalidQuality" => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_ItemInvalidQuality),
                "k_PackBundle_Failed_ItemIsNonEconomy" => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_ItemIsNonEconomy),
                "k_PackBundle_Failed_Disabled" => ::std::option::Option::Some(EPackBundle::k_PackBundle_Failed_Disabled),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EPackBundle] = &[
            EPackBundle::k_PackBundle_Succeeded,
            EPackBundle::k_PackBundle_Failed_InternalError,
            EPackBundle::k_PackBundle_Failed_ItemIsNotBundle,
            EPackBundle::k_PackBundle_Failed_SOCacheError,
            EPackBundle::k_PackBundle_Failed_ItemIsInvalid,
            EPackBundle::k_PackBundle_Failed_BadItemQuantity,
            EPackBundle::k_PackBundle_Failed_UnableToDeleteItem,
            EPackBundle::k_PackBundle_Failed_BundleCannotBePacked,
            EPackBundle::k_PackBundle_Failed_ItemIsUntradeable,
            EPackBundle::k_PackBundle_Failed_ItemIsEquipped,
            EPackBundle::k_PackBundle_Failed_ItemHasGems,
            EPackBundle::k_PackBundle_Failed_ItemMixedQuality,
            EPackBundle::k_PackBundle_Failed_ItemInvalidQuality,
            EPackBundle::k_PackBundle_Failed_ItemIsNonEconomy,
            EPackBundle::k_PackBundle_Failed_Disabled,
        ];
    }

    impl ::std::default::Default for EPackBundle {
        fn default() -> Self {
            EPackBundle::k_PackBundle_Succeeded
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCToClientStoreTransactionCompleted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientStoreTransactionCompleted {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientStoreTransactionCompleted.txn_id)
    pub txn_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToClientStoreTransactionCompleted.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientStoreTransactionCompleted.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientStoreTransactionCompleted {
    fn default() -> &'a CMsgGCToClientStoreTransactionCompleted {
        <CMsgGCToClientStoreTransactionCompleted as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientStoreTransactionCompleted {
    pub fn new() -> CMsgGCToClientStoreTransactionCompleted {
        ::std::default::Default::default()
    }

    // optional uint64 txn_id = 1;

    pub fn txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }

    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientStoreTransactionCompleted {
    const NAME: &'static str = "CMsgGCToClientStoreTransactionCompleted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                16 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.txn_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.item_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.txn_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.item_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientStoreTransactionCompleted {
        CMsgGCToClientStoreTransactionCompleted::new()
    }

    fn clear(&mut self) {
        self.txn_id = ::std::option::Option::None;
        self.item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientStoreTransactionCompleted {
        static instance: CMsgGCToClientStoreTransactionCompleted = CMsgGCToClientStoreTransactionCompleted {
            txn_id: ::std::option::Option::None,
            item_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCEquipItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCEquipItems {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCEquipItems.equips)
    pub equips: ::std::vec::Vec<CMsgAdjustItemEquippedState>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCEquipItems.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCEquipItems {
    fn default() -> &'a CMsgClientToGCEquipItems {
        <CMsgClientToGCEquipItems as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCEquipItems {
    pub fn new() -> CMsgClientToGCEquipItems {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCEquipItems {
    const NAME: &'static str = "CMsgClientToGCEquipItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.equips.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.equips {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.equips {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCEquipItems {
        CMsgClientToGCEquipItems::new()
    }

    fn clear(&mut self) {
        self.equips.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCEquipItems {
        static instance: CMsgClientToGCEquipItems = CMsgClientToGCEquipItems {
            equips: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCEquipItemsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCEquipItemsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCEquipItemsResponse.so_cache_version_id)
    pub so_cache_version_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCEquipItemsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCEquipItemsResponse {
    fn default() -> &'a CMsgClientToGCEquipItemsResponse {
        <CMsgClientToGCEquipItemsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCEquipItemsResponse {
    pub fn new() -> CMsgClientToGCEquipItemsResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 so_cache_version_id = 1;

    pub fn so_cache_version_id(&self) -> u64 {
        self.so_cache_version_id.unwrap_or(0)
    }

    pub fn clear_so_cache_version_id(&mut self) {
        self.so_cache_version_id = ::std::option::Option::None;
    }

    pub fn has_so_cache_version_id(&self) -> bool {
        self.so_cache_version_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_so_cache_version_id(&mut self, v: u64) {
        self.so_cache_version_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCEquipItemsResponse {
    const NAME: &'static str = "CMsgClientToGCEquipItemsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.so_cache_version_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.so_cache_version_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.so_cache_version_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCEquipItemsResponse {
        CMsgClientToGCEquipItemsResponse::new()
    }

    fn clear(&mut self) {
        self.so_cache_version_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCEquipItemsResponse {
        static instance: CMsgClientToGCEquipItemsResponse = CMsgClientToGCEquipItemsResponse {
            so_cache_version_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCSetItemStyle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetItemStyle {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSetItemStyle.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCSetItemStyle.style_index)
    pub style_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSetItemStyle.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetItemStyle {
    fn default() -> &'a CMsgClientToGCSetItemStyle {
        <CMsgClientToGCSetItemStyle as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetItemStyle {
    pub fn new() -> CMsgClientToGCSetItemStyle {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 style_index = 2;

    pub fn style_index(&self) -> u32 {
        self.style_index.unwrap_or(255u32)
    }

    pub fn clear_style_index(&mut self) {
        self.style_index = ::std::option::Option::None;
    }

    pub fn has_style_index(&self) -> bool {
        self.style_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_index(&mut self, v: u32) {
        self.style_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSetItemStyle {
    const NAME: &'static str = "CMsgClientToGCSetItemStyle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.style_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.style_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.style_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetItemStyle {
        CMsgClientToGCSetItemStyle::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.style_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetItemStyle {
        static instance: CMsgClientToGCSetItemStyle = CMsgClientToGCSetItemStyle {
            item_id: ::std::option::Option::None,
            style_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCSetItemStyleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetItemStyleResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSetItemStyleResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcset_item_style_response::ESetStyle>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSetItemStyleResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetItemStyleResponse {
    fn default() -> &'a CMsgClientToGCSetItemStyleResponse {
        <CMsgClientToGCSetItemStyleResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetItemStyleResponse {
    pub fn new() -> CMsgClientToGCSetItemStyleResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCSetItemStyleResponse.ESetStyle response = 1;

    pub fn response(&self) -> cmsg_client_to_gcset_item_style_response::ESetStyle {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcset_item_style_response::ESetStyle::k_SetStyle_Succeeded),
            None => cmsg_client_to_gcset_item_style_response::ESetStyle::k_SetStyle_Succeeded,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcset_item_style_response::ESetStyle) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSetItemStyleResponse {
    const NAME: &'static str = "CMsgClientToGCSetItemStyleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetItemStyleResponse {
        CMsgClientToGCSetItemStyleResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetItemStyleResponse {
        static instance: CMsgClientToGCSetItemStyleResponse = CMsgClientToGCSetItemStyleResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCSetItemStyleResponse`
pub mod cmsg_client_to_gcset_item_style_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCSetItemStyleResponse.ESetStyle)
    pub enum ESetStyle {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetItemStyleResponse.ESetStyle.k_SetStyle_Succeeded)
        k_SetStyle_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetItemStyleResponse.ESetStyle.k_SetStyle_Failed)
        k_SetStyle_Failed = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetItemStyleResponse.ESetStyle.k_SetStyle_Failed_StyleIsLocked)
        k_SetStyle_Failed_StyleIsLocked = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for ESetStyle {
        const NAME: &'static str = "ESetStyle";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ESetStyle> {
            match value {
                0 => ::std::option::Option::Some(ESetStyle::k_SetStyle_Succeeded),
                1 => ::std::option::Option::Some(ESetStyle::k_SetStyle_Failed),
                2 => ::std::option::Option::Some(ESetStyle::k_SetStyle_Failed_StyleIsLocked),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ESetStyle> {
            match str {
                "k_SetStyle_Succeeded" => ::std::option::Option::Some(ESetStyle::k_SetStyle_Succeeded),
                "k_SetStyle_Failed" => ::std::option::Option::Some(ESetStyle::k_SetStyle_Failed),
                "k_SetStyle_Failed_StyleIsLocked" => ::std::option::Option::Some(ESetStyle::k_SetStyle_Failed_StyleIsLocked),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ESetStyle] = &[
            ESetStyle::k_SetStyle_Succeeded,
            ESetStyle::k_SetStyle_Failed,
            ESetStyle::k_SetStyle_Failed_StyleIsLocked,
        ];
    }

    impl ::std::default::Default for ESetStyle {
        fn default() -> Self {
            ESetStyle::k_SetStyle_Succeeded
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCUnlockItemStyle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnlockItemStyle {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUnlockItemStyle.item_to_unlock)
    pub item_to_unlock: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnlockItemStyle.style_index)
    pub style_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnlockItemStyle.consumable_item_ids)
    pub consumable_item_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUnlockItemStyle.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnlockItemStyle {
    fn default() -> &'a CMsgClientToGCUnlockItemStyle {
        <CMsgClientToGCUnlockItemStyle as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnlockItemStyle {
    pub fn new() -> CMsgClientToGCUnlockItemStyle {
        ::std::default::Default::default()
    }

    // optional uint64 item_to_unlock = 1;

    pub fn item_to_unlock(&self) -> u64 {
        self.item_to_unlock.unwrap_or(0)
    }

    pub fn clear_item_to_unlock(&mut self) {
        self.item_to_unlock = ::std::option::Option::None;
    }

    pub fn has_item_to_unlock(&self) -> bool {
        self.item_to_unlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_to_unlock(&mut self, v: u64) {
        self.item_to_unlock = ::std::option::Option::Some(v);
    }

    // optional uint32 style_index = 2;

    pub fn style_index(&self) -> u32 {
        self.style_index.unwrap_or(255u32)
    }

    pub fn clear_style_index(&mut self) {
        self.style_index = ::std::option::Option::None;
    }

    pub fn has_style_index(&self) -> bool {
        self.style_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_index(&mut self, v: u32) {
        self.style_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUnlockItemStyle {
    const NAME: &'static str = "CMsgClientToGCUnlockItemStyle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_to_unlock = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.style_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint64_into(&mut self.consumable_item_ids)?;
                },
                24 => {
                    self.consumable_item_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_to_unlock {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.style_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.consumable_item_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_to_unlock {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.style_index {
            os.write_uint32(2, v)?;
        }
        for v in &self.consumable_item_ids {
            os.write_uint64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnlockItemStyle {
        CMsgClientToGCUnlockItemStyle::new()
    }

    fn clear(&mut self) {
        self.item_to_unlock = ::std::option::Option::None;
        self.style_index = ::std::option::Option::None;
        self.consumable_item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnlockItemStyle {
        static instance: CMsgClientToGCUnlockItemStyle = CMsgClientToGCUnlockItemStyle {
            item_to_unlock: ::std::option::Option::None,
            style_index: ::std::option::Option::None,
            consumable_item_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCUnlockItemStyleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnlockItemStyleResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUnlockItemStyleResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcunlock_item_style_response::EUnlockStyle>>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnlockItemStyleResponse.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnlockItemStyleResponse.style_index)
    pub style_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnlockItemStyleResponse.style_prereq)
    pub style_prereq: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUnlockItemStyleResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnlockItemStyleResponse {
    fn default() -> &'a CMsgClientToGCUnlockItemStyleResponse {
        <CMsgClientToGCUnlockItemStyleResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnlockItemStyleResponse {
    pub fn new() -> CMsgClientToGCUnlockItemStyleResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle response = 1;

    pub fn response(&self) -> cmsg_client_to_gcunlock_item_style_response::EUnlockStyle {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcunlock_item_style_response::EUnlockStyle::k_UnlockStyle_Succeeded),
            None => cmsg_client_to_gcunlock_item_style_response::EUnlockStyle::k_UnlockStyle_Succeeded,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcunlock_item_style_response::EUnlockStyle) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 item_id = 2;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 style_index = 3;

    pub fn style_index(&self) -> u32 {
        self.style_index.unwrap_or(255u32)
    }

    pub fn clear_style_index(&mut self) {
        self.style_index = ::std::option::Option::None;
    }

    pub fn has_style_index(&self) -> bool {
        self.style_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_index(&mut self, v: u32) {
        self.style_index = ::std::option::Option::Some(v);
    }

    // optional uint32 style_prereq = 4;

    pub fn style_prereq(&self) -> u32 {
        self.style_prereq.unwrap_or(255u32)
    }

    pub fn clear_style_prereq(&mut self) {
        self.style_prereq = ::std::option::Option::None;
    }

    pub fn has_style_prereq(&self) -> bool {
        self.style_prereq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_prereq(&mut self, v: u32) {
        self.style_prereq = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUnlockItemStyleResponse {
    const NAME: &'static str = "CMsgClientToGCUnlockItemStyleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.style_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.style_prereq = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.style_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.style_prereq {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.style_index {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.style_prereq {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnlockItemStyleResponse {
        CMsgClientToGCUnlockItemStyleResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.style_index = ::std::option::Option::None;
        self.style_prereq = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnlockItemStyleResponse {
        static instance: CMsgClientToGCUnlockItemStyleResponse = CMsgClientToGCUnlockItemStyleResponse {
            response: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            style_index: ::std::option::Option::None,
            style_prereq: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCUnlockItemStyleResponse`
pub mod cmsg_client_to_gcunlock_item_style_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle)
    pub enum EUnlockStyle {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Succeeded)
        k_UnlockStyle_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_PreReq)
        k_UnlockStyle_Failed_PreReq = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_CantAfford)
        k_UnlockStyle_Failed_CantAfford = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_CantCommit)
        k_UnlockStyle_Failed_CantCommit = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_CantLockCache)
        k_UnlockStyle_Failed_CantLockCache = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_CantAffordAttrib)
        k_UnlockStyle_Failed_CantAffordAttrib = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_CantAffordGem)
        k_UnlockStyle_Failed_CantAffordGem = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_NoCompendiumLevel)
        k_UnlockStyle_Failed_NoCompendiumLevel = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_AlreadyUnlocked)
        k_UnlockStyle_Failed_AlreadyUnlocked = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_OtherError)
        k_UnlockStyle_Failed_OtherError = 9,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_ItemIsInvalid)
        k_UnlockStyle_Failed_ItemIsInvalid = 10,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle.k_UnlockStyle_Failed_ToolIsInvalid)
        k_UnlockStyle_Failed_ToolIsInvalid = 11,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EUnlockStyle {
        const NAME: &'static str = "EUnlockStyle";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EUnlockStyle> {
            match value {
                0 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Succeeded),
                1 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_PreReq),
                2 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAfford),
                3 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantCommit),
                4 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantLockCache),
                5 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAffordAttrib),
                6 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAffordGem),
                7 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_NoCompendiumLevel),
                8 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_AlreadyUnlocked),
                9 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_OtherError),
                10 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_ItemIsInvalid),
                11 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_ToolIsInvalid),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EUnlockStyle> {
            match str {
                "k_UnlockStyle_Succeeded" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Succeeded),
                "k_UnlockStyle_Failed_PreReq" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_PreReq),
                "k_UnlockStyle_Failed_CantAfford" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAfford),
                "k_UnlockStyle_Failed_CantCommit" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantCommit),
                "k_UnlockStyle_Failed_CantLockCache" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantLockCache),
                "k_UnlockStyle_Failed_CantAffordAttrib" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAffordAttrib),
                "k_UnlockStyle_Failed_CantAffordGem" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAffordGem),
                "k_UnlockStyle_Failed_NoCompendiumLevel" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_NoCompendiumLevel),
                "k_UnlockStyle_Failed_AlreadyUnlocked" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_AlreadyUnlocked),
                "k_UnlockStyle_Failed_OtherError" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_OtherError),
                "k_UnlockStyle_Failed_ItemIsInvalid" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_ItemIsInvalid),
                "k_UnlockStyle_Failed_ToolIsInvalid" => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_ToolIsInvalid),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EUnlockStyle] = &[
            EUnlockStyle::k_UnlockStyle_Succeeded,
            EUnlockStyle::k_UnlockStyle_Failed_PreReq,
            EUnlockStyle::k_UnlockStyle_Failed_CantAfford,
            EUnlockStyle::k_UnlockStyle_Failed_CantCommit,
            EUnlockStyle::k_UnlockStyle_Failed_CantLockCache,
            EUnlockStyle::k_UnlockStyle_Failed_CantAffordAttrib,
            EUnlockStyle::k_UnlockStyle_Failed_CantAffordGem,
            EUnlockStyle::k_UnlockStyle_Failed_NoCompendiumLevel,
            EUnlockStyle::k_UnlockStyle_Failed_AlreadyUnlocked,
            EUnlockStyle::k_UnlockStyle_Failed_OtherError,
            EUnlockStyle::k_UnlockStyle_Failed_ItemIsInvalid,
            EUnlockStyle::k_UnlockStyle_Failed_ToolIsInvalid,
        ];
    }

    impl ::std::default::Default for EUnlockStyle {
        fn default() -> Self {
            EUnlockStyle::k_UnlockStyle_Succeeded
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCSetItemInventoryCategory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetItemInventoryCategory {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSetItemInventoryCategory.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCSetItemInventoryCategory.set_to_value)
    pub set_to_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCSetItemInventoryCategory.remove_categories)
    pub remove_categories: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCSetItemInventoryCategory.add_categories)
    pub add_categories: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSetItemInventoryCategory.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetItemInventoryCategory {
    fn default() -> &'a CMsgClientToGCSetItemInventoryCategory {
        <CMsgClientToGCSetItemInventoryCategory as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetItemInventoryCategory {
    pub fn new() -> CMsgClientToGCSetItemInventoryCategory {
        ::std::default::Default::default()
    }

    // optional uint32 set_to_value = 2;

    pub fn set_to_value(&self) -> u32 {
        self.set_to_value.unwrap_or(0)
    }

    pub fn clear_set_to_value(&mut self) {
        self.set_to_value = ::std::option::Option::None;
    }

    pub fn has_set_to_value(&self) -> bool {
        self.set_to_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set_to_value(&mut self, v: u32) {
        self.set_to_value = ::std::option::Option::Some(v);
    }

    // optional uint32 remove_categories = 3;

    pub fn remove_categories(&self) -> u32 {
        self.remove_categories.unwrap_or(0)
    }

    pub fn clear_remove_categories(&mut self) {
        self.remove_categories = ::std::option::Option::None;
    }

    pub fn has_remove_categories(&self) -> bool {
        self.remove_categories.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove_categories(&mut self, v: u32) {
        self.remove_categories = ::std::option::Option::Some(v);
    }

    // optional uint32 add_categories = 4;

    pub fn add_categories(&self) -> u32 {
        self.add_categories.unwrap_or(0)
    }

    pub fn clear_add_categories(&mut self) {
        self.add_categories = ::std::option::Option::None;
    }

    pub fn has_add_categories(&self) -> bool {
        self.add_categories.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_categories(&mut self, v: u32) {
        self.add_categories = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSetItemInventoryCategory {
    const NAME: &'static str = "CMsgClientToGCSetItemInventoryCategory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                8 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                16 => {
                    self.set_to_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.remove_categories = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.add_categories = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, *value);
        };
        if let Some(v) = self.set_to_value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.remove_categories {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.add_categories {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.item_ids {
            os.write_uint64(1, *v)?;
        };
        if let Some(v) = self.set_to_value {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.remove_categories {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.add_categories {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetItemInventoryCategory {
        CMsgClientToGCSetItemInventoryCategory::new()
    }

    fn clear(&mut self) {
        self.item_ids.clear();
        self.set_to_value = ::std::option::Option::None;
        self.remove_categories = ::std::option::Option::None;
        self.add_categories = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetItemInventoryCategory {
        static instance: CMsgClientToGCSetItemInventoryCategory = CMsgClientToGCSetItemInventoryCategory {
            item_ids: ::std::vec::Vec::new(),
            set_to_value: ::std::option::Option::None,
            remove_categories: ::std::option::Option::None,
            add_categories: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCUnlockCrate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnlockCrate {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUnlockCrate.crate_item_id)
    pub crate_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnlockCrate.key_item_id)
    pub key_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUnlockCrate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnlockCrate {
    fn default() -> &'a CMsgClientToGCUnlockCrate {
        <CMsgClientToGCUnlockCrate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnlockCrate {
    pub fn new() -> CMsgClientToGCUnlockCrate {
        ::std::default::Default::default()
    }

    // optional uint64 crate_item_id = 1;

    pub fn crate_item_id(&self) -> u64 {
        self.crate_item_id.unwrap_or(0)
    }

    pub fn clear_crate_item_id(&mut self) {
        self.crate_item_id = ::std::option::Option::None;
    }

    pub fn has_crate_item_id(&self) -> bool {
        self.crate_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crate_item_id(&mut self, v: u64) {
        self.crate_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 key_item_id = 2;

    pub fn key_item_id(&self) -> u64 {
        self.key_item_id.unwrap_or(0)
    }

    pub fn clear_key_item_id(&mut self) {
        self.key_item_id = ::std::option::Option::None;
    }

    pub fn has_key_item_id(&self) -> bool {
        self.key_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_item_id(&mut self, v: u64) {
        self.key_item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUnlockCrate {
    const NAME: &'static str = "CMsgClientToGCUnlockCrate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.crate_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.key_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.crate_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.key_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.crate_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.key_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnlockCrate {
        CMsgClientToGCUnlockCrate::new()
    }

    fn clear(&mut self) {
        self.crate_item_id = ::std::option::Option::None;
        self.key_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnlockCrate {
        static instance: CMsgClientToGCUnlockCrate = CMsgClientToGCUnlockCrate {
            crate_item_id: ::std::option::Option::None,
            key_item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCUnlockCrateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnlockCrateResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUnlockCrateResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::econ_shared_enums::EGCMsgResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnlockCrateResponse.granted_items)
    pub granted_items: ::std::vec::Vec<cmsg_client_to_gcunlock_crate_response::Item>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUnlockCrateResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnlockCrateResponse {
    fn default() -> &'a CMsgClientToGCUnlockCrateResponse {
        <CMsgClientToGCUnlockCrateResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnlockCrateResponse {
    pub fn new() -> CMsgClientToGCUnlockCrateResponse {
        ::std::default::Default::default()
    }

    // optional .EGCMsgResponse result = 1;

    pub fn result(&self) -> super::econ_shared_enums::EGCMsgResponse {
        match self.result {
            Some(e) => e.enum_value_or(super::econ_shared_enums::EGCMsgResponse::k_EGCMsgResponseOK),
            None => super::econ_shared_enums::EGCMsgResponse::k_EGCMsgResponseOK,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: super::econ_shared_enums::EGCMsgResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUnlockCrateResponse {
    const NAME: &'static str = "CMsgClientToGCUnlockCrateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.granted_items.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.granted_items {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.granted_items {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnlockCrateResponse {
        CMsgClientToGCUnlockCrateResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.granted_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnlockCrateResponse {
        static instance: CMsgClientToGCUnlockCrateResponse = CMsgClientToGCUnlockCrateResponse {
            result: ::std::option::Option::None,
            granted_items: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCUnlockCrateResponse`
pub mod cmsg_client_to_gcunlock_crate_response {
    // @@protoc_insertion_point(message:CMsgClientToGCUnlockCrateResponse.Item)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Item {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCUnlockCrateResponse.Item.item_id)
        pub item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientToGCUnlockCrateResponse.Item.def_index)
        pub def_index: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCUnlockCrateResponse.Item.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Item {
        fn default() -> &'a Item {
            <Item as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Item {
        pub fn new() -> Item {
            ::std::default::Default::default()
        }

        // optional uint64 item_id = 1;

        pub fn item_id(&self) -> u64 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: u64) {
            self.item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 def_index = 2;

        pub fn def_index(&self) -> u32 {
            self.def_index.unwrap_or(0)
        }

        pub fn clear_def_index(&mut self) {
            self.def_index = ::std::option::Option::None;
        }

        pub fn has_def_index(&self) -> bool {
            self.def_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_def_index(&mut self, v: u32) {
            self.def_index = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Item {
        const NAME: &'static str = "Item";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.def_index {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.def_index {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Item {
            Item::new()
        }

        fn clear(&mut self) {
            self.item_id = ::std::option::Option::None;
            self.def_index = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Item {
            static instance: Item = Item {
                item_id: ::std::option::Option::None,
                def_index: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRemoveItemAttribute)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRemoveItemAttribute {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRemoveItemAttribute.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRemoveItemAttribute.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRemoveItemAttribute {
    fn default() -> &'a CMsgClientToGCRemoveItemAttribute {
        <CMsgClientToGCRemoveItemAttribute as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRemoveItemAttribute {
    pub fn new() -> CMsgClientToGCRemoveItemAttribute {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRemoveItemAttribute {
    const NAME: &'static str = "CMsgClientToGCRemoveItemAttribute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRemoveItemAttribute {
        CMsgClientToGCRemoveItemAttribute::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRemoveItemAttribute {
        static instance: CMsgClientToGCRemoveItemAttribute = CMsgClientToGCRemoveItemAttribute {
            item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRemoveItemAttributeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRemoveItemAttributeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRemoveItemAttributeResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcremove_item_attribute_response::ERemoveItemAttribute>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRemoveItemAttributeResponse.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRemoveItemAttributeResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRemoveItemAttributeResponse {
    fn default() -> &'a CMsgClientToGCRemoveItemAttributeResponse {
        <CMsgClientToGCRemoveItemAttributeResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRemoveItemAttributeResponse {
    pub fn new() -> CMsgClientToGCRemoveItemAttributeResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCRemoveItemAttributeResponse.ERemoveItemAttribute response = 1;

    pub fn response(&self) -> cmsg_client_to_gcremove_item_attribute_response::ERemoveItemAttribute {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcremove_item_attribute_response::ERemoveItemAttribute::k_RemoveItemAttribute_Succeeded),
            None => cmsg_client_to_gcremove_item_attribute_response::ERemoveItemAttribute::k_RemoveItemAttribute_Succeeded,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcremove_item_attribute_response::ERemoveItemAttribute) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 item_id = 2;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRemoveItemAttributeResponse {
    const NAME: &'static str = "CMsgClientToGCRemoveItemAttributeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRemoveItemAttributeResponse {
        CMsgClientToGCRemoveItemAttributeResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRemoveItemAttributeResponse {
        static instance: CMsgClientToGCRemoveItemAttributeResponse = CMsgClientToGCRemoveItemAttributeResponse {
            response: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCRemoveItemAttributeResponse`
pub mod cmsg_client_to_gcremove_item_attribute_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCRemoveItemAttributeResponse.ERemoveItemAttribute)
    pub enum ERemoveItemAttribute {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRemoveItemAttributeResponse.ERemoveItemAttribute.k_RemoveItemAttribute_Succeeded)
        k_RemoveItemAttribute_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRemoveItemAttributeResponse.ERemoveItemAttribute.k_RemoveItemAttribute_Failed)
        k_RemoveItemAttribute_Failed = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRemoveItemAttributeResponse.ERemoveItemAttribute.k_RemoveItemAttribute_Failed_ItemIsInvalid)
        k_RemoveItemAttribute_Failed_ItemIsInvalid = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRemoveItemAttributeResponse.ERemoveItemAttribute.k_RemoveItemAttribute_Failed_AttributeCannotBeRemoved)
        k_RemoveItemAttribute_Failed_AttributeCannotBeRemoved = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRemoveItemAttributeResponse.ERemoveItemAttribute.k_RemoveItemAttribute_Failed_AttributeDoesntExist)
        k_RemoveItemAttribute_Failed_AttributeDoesntExist = 4,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for ERemoveItemAttribute {
        const NAME: &'static str = "ERemoveItemAttribute";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ERemoveItemAttribute> {
            match value {
                0 => ::std::option::Option::Some(ERemoveItemAttribute::k_RemoveItemAttribute_Succeeded),
                1 => ::std::option::Option::Some(ERemoveItemAttribute::k_RemoveItemAttribute_Failed),
                2 => ::std::option::Option::Some(ERemoveItemAttribute::k_RemoveItemAttribute_Failed_ItemIsInvalid),
                3 => ::std::option::Option::Some(ERemoveItemAttribute::k_RemoveItemAttribute_Failed_AttributeCannotBeRemoved),
                4 => ::std::option::Option::Some(ERemoveItemAttribute::k_RemoveItemAttribute_Failed_AttributeDoesntExist),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ERemoveItemAttribute> {
            match str {
                "k_RemoveItemAttribute_Succeeded" => ::std::option::Option::Some(ERemoveItemAttribute::k_RemoveItemAttribute_Succeeded),
                "k_RemoveItemAttribute_Failed" => ::std::option::Option::Some(ERemoveItemAttribute::k_RemoveItemAttribute_Failed),
                "k_RemoveItemAttribute_Failed_ItemIsInvalid" => ::std::option::Option::Some(ERemoveItemAttribute::k_RemoveItemAttribute_Failed_ItemIsInvalid),
                "k_RemoveItemAttribute_Failed_AttributeCannotBeRemoved" => ::std::option::Option::Some(ERemoveItemAttribute::k_RemoveItemAttribute_Failed_AttributeCannotBeRemoved),
                "k_RemoveItemAttribute_Failed_AttributeDoesntExist" => ::std::option::Option::Some(ERemoveItemAttribute::k_RemoveItemAttribute_Failed_AttributeDoesntExist),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ERemoveItemAttribute] = &[
            ERemoveItemAttribute::k_RemoveItemAttribute_Succeeded,
            ERemoveItemAttribute::k_RemoveItemAttribute_Failed,
            ERemoveItemAttribute::k_RemoveItemAttribute_Failed_ItemIsInvalid,
            ERemoveItemAttribute::k_RemoveItemAttribute_Failed_AttributeCannotBeRemoved,
            ERemoveItemAttribute::k_RemoveItemAttribute_Failed_AttributeDoesntExist,
        ];
    }

    impl ::std::default::Default for ERemoveItemAttribute {
        fn default() -> Self {
            ERemoveItemAttribute::k_RemoveItemAttribute_Succeeded
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCNameItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCNameItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCNameItem.subject_item_id)
    pub subject_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCNameItem.tool_item_id)
    pub tool_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCNameItem.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCNameItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCNameItem {
    fn default() -> &'a CMsgClientToGCNameItem {
        <CMsgClientToGCNameItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCNameItem {
    pub fn new() -> CMsgClientToGCNameItem {
        ::std::default::Default::default()
    }

    // optional uint64 subject_item_id = 1;

    pub fn subject_item_id(&self) -> u64 {
        self.subject_item_id.unwrap_or(0)
    }

    pub fn clear_subject_item_id(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
    }

    pub fn has_subject_item_id(&self) -> bool {
        self.subject_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject_item_id(&mut self, v: u64) {
        self.subject_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 tool_item_id = 2;

    pub fn tool_item_id(&self) -> u64 {
        self.tool_item_id.unwrap_or(0)
    }

    pub fn clear_tool_item_id(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
    }

    pub fn has_tool_item_id(&self) -> bool {
        self.tool_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_item_id(&mut self, v: u64) {
        self.tool_item_id = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCNameItem {
    const NAME: &'static str = "CMsgClientToGCNameItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.subject_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.tool_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.subject_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.tool_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.subject_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.tool_item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCNameItem {
        CMsgClientToGCNameItem::new()
    }

    fn clear(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
        self.tool_item_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCNameItem {
        static instance: CMsgClientToGCNameItem = CMsgClientToGCNameItem {
            subject_item_id: ::std::option::Option::None,
            tool_item_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCNameItemResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCNameItemResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCNameItemResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcname_item_response::ENameItem>>,
    // @@protoc_insertion_point(field:CMsgClientToGCNameItemResponse.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCNameItemResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCNameItemResponse {
    fn default() -> &'a CMsgClientToGCNameItemResponse {
        <CMsgClientToGCNameItemResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCNameItemResponse {
    pub fn new() -> CMsgClientToGCNameItemResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCNameItemResponse.ENameItem response = 1;

    pub fn response(&self) -> cmsg_client_to_gcname_item_response::ENameItem {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcname_item_response::ENameItem::k_NameItem_Succeeded),
            None => cmsg_client_to_gcname_item_response::ENameItem::k_NameItem_Succeeded,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcname_item_response::ENameItem) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 item_id = 2;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCNameItemResponse {
    const NAME: &'static str = "CMsgClientToGCNameItemResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCNameItemResponse {
        CMsgClientToGCNameItemResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCNameItemResponse {
        static instance: CMsgClientToGCNameItemResponse = CMsgClientToGCNameItemResponse {
            response: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCNameItemResponse`
pub mod cmsg_client_to_gcname_item_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCNameItemResponse.ENameItem)
    pub enum ENameItem {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCNameItemResponse.ENameItem.k_NameItem_Succeeded)
        k_NameItem_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCNameItemResponse.ENameItem.k_NameItem_Failed)
        k_NameItem_Failed = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCNameItemResponse.ENameItem.k_NameItem_Failed_ToolIsInvalid)
        k_NameItem_Failed_ToolIsInvalid = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCNameItemResponse.ENameItem.k_NameItem_Failed_ItemIsInvalid)
        k_NameItem_Failed_ItemIsInvalid = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCNameItemResponse.ENameItem.k_NameItem_Failed_NameIsInvalid)
        k_NameItem_Failed_NameIsInvalid = 4,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for ENameItem {
        const NAME: &'static str = "ENameItem";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ENameItem> {
            match value {
                0 => ::std::option::Option::Some(ENameItem::k_NameItem_Succeeded),
                1 => ::std::option::Option::Some(ENameItem::k_NameItem_Failed),
                2 => ::std::option::Option::Some(ENameItem::k_NameItem_Failed_ToolIsInvalid),
                3 => ::std::option::Option::Some(ENameItem::k_NameItem_Failed_ItemIsInvalid),
                4 => ::std::option::Option::Some(ENameItem::k_NameItem_Failed_NameIsInvalid),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ENameItem> {
            match str {
                "k_NameItem_Succeeded" => ::std::option::Option::Some(ENameItem::k_NameItem_Succeeded),
                "k_NameItem_Failed" => ::std::option::Option::Some(ENameItem::k_NameItem_Failed),
                "k_NameItem_Failed_ToolIsInvalid" => ::std::option::Option::Some(ENameItem::k_NameItem_Failed_ToolIsInvalid),
                "k_NameItem_Failed_ItemIsInvalid" => ::std::option::Option::Some(ENameItem::k_NameItem_Failed_ItemIsInvalid),
                "k_NameItem_Failed_NameIsInvalid" => ::std::option::Option::Some(ENameItem::k_NameItem_Failed_NameIsInvalid),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ENameItem] = &[
            ENameItem::k_NameItem_Succeeded,
            ENameItem::k_NameItem_Failed,
            ENameItem::k_NameItem_Failed_ToolIsInvalid,
            ENameItem::k_NameItem_Failed_ItemIsInvalid,
            ENameItem::k_NameItem_Failed_NameIsInvalid,
        ];
    }

    impl ::std::default::Default for ENameItem {
        fn default() -> Self {
            ENameItem::k_NameItem_Succeeded
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCSetItemPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCSetItemPosition {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCSetItemPosition.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCSetItemPosition.new_position)
    pub new_position: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCSetItemPosition.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCSetItemPosition {
    fn default() -> &'a CMsgGCSetItemPosition {
        <CMsgGCSetItemPosition as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCSetItemPosition {
    pub fn new() -> CMsgGCSetItemPosition {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 new_position = 2;

    pub fn new_position(&self) -> u32 {
        self.new_position.unwrap_or(0)
    }

    pub fn clear_new_position(&mut self) {
        self.new_position = ::std::option::Option::None;
    }

    pub fn has_new_position(&self) -> bool {
        self.new_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_position(&mut self, v: u32) {
        self.new_position = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCSetItemPosition {
    const NAME: &'static str = "CMsgGCSetItemPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.new_position = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.new_position {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.new_position {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCSetItemPosition {
        CMsgGCSetItemPosition::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.new_position = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCSetItemPosition {
        static instance: CMsgGCSetItemPosition = CMsgGCSetItemPosition {
            item_id: ::std::option::Option::None,
            new_position: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CAttribute_ItemDynamicRecipeComponent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CAttribute_ItemDynamicRecipeComponent {
    // message fields
    // @@protoc_insertion_point(field:CAttribute_ItemDynamicRecipeComponent.item_def)
    pub item_def: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_ItemDynamicRecipeComponent.item_quality)
    pub item_quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_ItemDynamicRecipeComponent.item_flags)
    pub item_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_ItemDynamicRecipeComponent.attributes_string)
    pub attributes_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CAttribute_ItemDynamicRecipeComponent.item_count)
    pub item_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_ItemDynamicRecipeComponent.items_fulfilled)
    pub items_fulfilled: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_ItemDynamicRecipeComponent.item_rarity)
    pub item_rarity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_ItemDynamicRecipeComponent.lootlist)
    pub lootlist: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CAttribute_ItemDynamicRecipeComponent.fulfilled_item_id)
    pub fulfilled_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CAttribute_ItemDynamicRecipeComponent.associated_item_def)
    pub associated_item_def: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CAttribute_ItemDynamicRecipeComponent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAttribute_ItemDynamicRecipeComponent {
    fn default() -> &'a CAttribute_ItemDynamicRecipeComponent {
        <CAttribute_ItemDynamicRecipeComponent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CAttribute_ItemDynamicRecipeComponent {
    pub fn new() -> CAttribute_ItemDynamicRecipeComponent {
        ::std::default::Default::default()
    }

    // optional uint32 item_def = 1;

    pub fn item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    // optional uint32 item_quality = 2;

    pub fn item_quality(&self) -> u32 {
        self.item_quality.unwrap_or(0)
    }

    pub fn clear_item_quality(&mut self) {
        self.item_quality = ::std::option::Option::None;
    }

    pub fn has_item_quality(&self) -> bool {
        self.item_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality(&mut self, v: u32) {
        self.item_quality = ::std::option::Option::Some(v);
    }

    // optional uint32 item_flags = 3;

    pub fn item_flags(&self) -> u32 {
        self.item_flags.unwrap_or(0)
    }

    pub fn clear_item_flags(&mut self) {
        self.item_flags = ::std::option::Option::None;
    }

    pub fn has_item_flags(&self) -> bool {
        self.item_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_flags(&mut self, v: u32) {
        self.item_flags = ::std::option::Option::Some(v);
    }

    // optional string attributes_string = 4;

    pub fn attributes_string(&self) -> &str {
        match self.attributes_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_attributes_string(&mut self) {
        self.attributes_string = ::std::option::Option::None;
    }

    pub fn has_attributes_string(&self) -> bool {
        self.attributes_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes_string(&mut self, v: ::std::string::String) {
        self.attributes_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes_string(&mut self) -> &mut ::std::string::String {
        if self.attributes_string.is_none() {
            self.attributes_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.attributes_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes_string(&mut self) -> ::std::string::String {
        self.attributes_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 item_count = 5;

    pub fn item_count(&self) -> u32 {
        self.item_count.unwrap_or(0)
    }

    pub fn clear_item_count(&mut self) {
        self.item_count = ::std::option::Option::None;
    }

    pub fn has_item_count(&self) -> bool {
        self.item_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_count(&mut self, v: u32) {
        self.item_count = ::std::option::Option::Some(v);
    }

    // optional uint32 items_fulfilled = 6;

    pub fn items_fulfilled(&self) -> u32 {
        self.items_fulfilled.unwrap_or(0)
    }

    pub fn clear_items_fulfilled(&mut self) {
        self.items_fulfilled = ::std::option::Option::None;
    }

    pub fn has_items_fulfilled(&self) -> bool {
        self.items_fulfilled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_items_fulfilled(&mut self, v: u32) {
        self.items_fulfilled = ::std::option::Option::Some(v);
    }

    // optional uint32 item_rarity = 7;

    pub fn item_rarity(&self) -> u32 {
        self.item_rarity.unwrap_or(0)
    }

    pub fn clear_item_rarity(&mut self) {
        self.item_rarity = ::std::option::Option::None;
    }

    pub fn has_item_rarity(&self) -> bool {
        self.item_rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_rarity(&mut self, v: u32) {
        self.item_rarity = ::std::option::Option::Some(v);
    }

    // optional string lootlist = 8;

    pub fn lootlist(&self) -> &str {
        match self.lootlist.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lootlist(&mut self) {
        self.lootlist = ::std::option::Option::None;
    }

    pub fn has_lootlist(&self) -> bool {
        self.lootlist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lootlist(&mut self, v: ::std::string::String) {
        self.lootlist = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lootlist(&mut self) -> &mut ::std::string::String {
        if self.lootlist.is_none() {
            self.lootlist = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lootlist.as_mut().unwrap()
    }

    // Take field
    pub fn take_lootlist(&mut self) -> ::std::string::String {
        self.lootlist.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 fulfilled_item_id = 9;

    pub fn fulfilled_item_id(&self) -> u64 {
        self.fulfilled_item_id.unwrap_or(0)
    }

    pub fn clear_fulfilled_item_id(&mut self) {
        self.fulfilled_item_id = ::std::option::Option::None;
    }

    pub fn has_fulfilled_item_id(&self) -> bool {
        self.fulfilled_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fulfilled_item_id(&mut self, v: u64) {
        self.fulfilled_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 associated_item_def = 10;

    pub fn associated_item_def(&self) -> u32 {
        self.associated_item_def.unwrap_or(0)
    }

    pub fn clear_associated_item_def(&mut self) {
        self.associated_item_def = ::std::option::Option::None;
    }

    pub fn has_associated_item_def(&self) -> bool {
        self.associated_item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_associated_item_def(&mut self, v: u32) {
        self.associated_item_def = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CAttribute_ItemDynamicRecipeComponent {
    const NAME: &'static str = "CAttribute_ItemDynamicRecipeComponent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.attributes_string = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.item_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.items_fulfilled = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.item_rarity = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.lootlist = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.fulfilled_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                80 => {
                    self.associated_item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_quality {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.attributes_string.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.item_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.items_fulfilled {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.item_rarity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.lootlist.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.fulfilled_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.associated_item_def {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_def {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_quality {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.attributes_string.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.item_count {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.items_fulfilled {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.item_rarity {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.lootlist.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.fulfilled_item_id {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.associated_item_def {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAttribute_ItemDynamicRecipeComponent {
        CAttribute_ItemDynamicRecipeComponent::new()
    }

    fn clear(&mut self) {
        self.item_def = ::std::option::Option::None;
        self.item_quality = ::std::option::Option::None;
        self.item_flags = ::std::option::Option::None;
        self.attributes_string = ::std::option::Option::None;
        self.item_count = ::std::option::Option::None;
        self.items_fulfilled = ::std::option::Option::None;
        self.item_rarity = ::std::option::Option::None;
        self.lootlist = ::std::option::Option::None;
        self.fulfilled_item_id = ::std::option::Option::None;
        self.associated_item_def = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAttribute_ItemDynamicRecipeComponent {
        static instance: CAttribute_ItemDynamicRecipeComponent = CAttribute_ItemDynamicRecipeComponent {
            item_def: ::std::option::Option::None,
            item_quality: ::std::option::Option::None,
            item_flags: ::std::option::Option::None,
            attributes_string: ::std::option::Option::None,
            item_count: ::std::option::Option::None,
            items_fulfilled: ::std::option::Option::None,
            item_rarity: ::std::option::Option::None,
            lootlist: ::std::option::Option::None,
            fulfilled_item_id: ::std::option::Option::None,
            associated_item_def: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CProtoItemSocket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket {
    // message fields
    // @@protoc_insertion_point(field:CProtoItemSocket.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CProtoItemSocket.attr_def_index)
    pub attr_def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CProtoItemSocket.required_type)
    pub required_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CProtoItemSocket.required_hero)
    pub required_hero: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CProtoItemSocket.gem_def_index)
    pub gem_def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CProtoItemSocket.not_tradable)
    pub not_tradable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CProtoItemSocket.required_item_slot)
    pub required_item_slot: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CProtoItemSocket.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket {
    fn default() -> &'a CProtoItemSocket {
        <CProtoItemSocket as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket {
    pub fn new() -> CProtoItemSocket {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 attr_def_index = 2;

    pub fn attr_def_index(&self) -> u32 {
        self.attr_def_index.unwrap_or(0)
    }

    pub fn clear_attr_def_index(&mut self) {
        self.attr_def_index = ::std::option::Option::None;
    }

    pub fn has_attr_def_index(&self) -> bool {
        self.attr_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attr_def_index(&mut self, v: u32) {
        self.attr_def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 required_type = 3;

    pub fn required_type(&self) -> u32 {
        self.required_type.unwrap_or(0)
    }

    pub fn clear_required_type(&mut self) {
        self.required_type = ::std::option::Option::None;
    }

    pub fn has_required_type(&self) -> bool {
        self.required_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_type(&mut self, v: u32) {
        self.required_type = ::std::option::Option::Some(v);
    }

    // optional string required_hero = 4;

    pub fn required_hero(&self) -> &str {
        match self.required_hero.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_required_hero(&mut self) {
        self.required_hero = ::std::option::Option::None;
    }

    pub fn has_required_hero(&self) -> bool {
        self.required_hero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_hero(&mut self, v: ::std::string::String) {
        self.required_hero = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_required_hero(&mut self) -> &mut ::std::string::String {
        if self.required_hero.is_none() {
            self.required_hero = ::std::option::Option::Some(::std::string::String::new());
        }
        self.required_hero.as_mut().unwrap()
    }

    // Take field
    pub fn take_required_hero(&mut self) -> ::std::string::String {
        self.required_hero.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 gem_def_index = 5;

    pub fn gem_def_index(&self) -> u32 {
        self.gem_def_index.unwrap_or(0)
    }

    pub fn clear_gem_def_index(&mut self) {
        self.gem_def_index = ::std::option::Option::None;
    }

    pub fn has_gem_def_index(&self) -> bool {
        self.gem_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gem_def_index(&mut self, v: u32) {
        self.gem_def_index = ::std::option::Option::Some(v);
    }

    // optional bool not_tradable = 6;

    pub fn not_tradable(&self) -> bool {
        self.not_tradable.unwrap_or(false)
    }

    pub fn clear_not_tradable(&mut self) {
        self.not_tradable = ::std::option::Option::None;
    }

    pub fn has_not_tradable(&self) -> bool {
        self.not_tradable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_not_tradable(&mut self, v: bool) {
        self.not_tradable = ::std::option::Option::Some(v);
    }

    // optional string required_item_slot = 7;

    pub fn required_item_slot(&self) -> &str {
        match self.required_item_slot.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_required_item_slot(&mut self) {
        self.required_item_slot = ::std::option::Option::None;
    }

    pub fn has_required_item_slot(&self) -> bool {
        self.required_item_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_item_slot(&mut self, v: ::std::string::String) {
        self.required_item_slot = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_required_item_slot(&mut self) -> &mut ::std::string::String {
        if self.required_item_slot.is_none() {
            self.required_item_slot = ::std::option::Option::Some(::std::string::String::new());
        }
        self.required_item_slot.as_mut().unwrap()
    }

    // Take field
    pub fn take_required_item_slot(&mut self) -> ::std::string::String {
        self.required_item_slot.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CProtoItemSocket {
    const NAME: &'static str = "CProtoItemSocket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.attr_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.required_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.required_hero = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.gem_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.not_tradable = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    self.required_item_slot = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.attr_def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.required_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.required_hero.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.gem_def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.not_tradable {
            my_size += 1 + 1;
        }
        if let Some(v) = self.required_item_slot.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.attr_def_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.required_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.required_hero.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.gem_def_index {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.not_tradable {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.required_item_slot.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket {
        CProtoItemSocket::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.attr_def_index = ::std::option::Option::None;
        self.required_type = ::std::option::Option::None;
        self.required_hero = ::std::option::Option::None;
        self.gem_def_index = ::std::option::Option::None;
        self.not_tradable = ::std::option::Option::None;
        self.required_item_slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket {
        static instance: CProtoItemSocket = CProtoItemSocket {
            item_id: ::std::option::Option::None,
            attr_def_index: ::std::option::Option::None,
            required_type: ::std::option::Option::None,
            required_hero: ::std::option::Option::None,
            gem_def_index: ::std::option::Option::None,
            not_tradable: ::std::option::Option::None,
            required_item_slot: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CProtoItemSocket_Empty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket_Empty {
    // message fields
    // @@protoc_insertion_point(field:CProtoItemSocket_Empty.socket)
    pub socket: ::steam_vent_proto_common::protobuf::MessageField<CProtoItemSocket>,
    // special fields
    // @@protoc_insertion_point(special_field:CProtoItemSocket_Empty.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket_Empty {
    fn default() -> &'a CProtoItemSocket_Empty {
        <CProtoItemSocket_Empty as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket_Empty {
    pub fn new() -> CProtoItemSocket_Empty {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CProtoItemSocket_Empty {
    const NAME: &'static str = "CProtoItemSocket_Empty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.socket)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.socket.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket_Empty {
        CProtoItemSocket_Empty::new()
    }

    fn clear(&mut self) {
        self.socket.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket_Empty {
        static instance: CProtoItemSocket_Empty = CProtoItemSocket_Empty {
            socket: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CProtoItemSocket_Effect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket_Effect {
    // message fields
    // @@protoc_insertion_point(field:CProtoItemSocket_Effect.socket)
    pub socket: ::steam_vent_proto_common::protobuf::MessageField<CProtoItemSocket>,
    // @@protoc_insertion_point(field:CProtoItemSocket_Effect.effect)
    pub effect: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CProtoItemSocket_Effect.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket_Effect {
    fn default() -> &'a CProtoItemSocket_Effect {
        <CProtoItemSocket_Effect as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket_Effect {
    pub fn new() -> CProtoItemSocket_Effect {
        ::std::default::Default::default()
    }

    // optional uint32 effect = 2;

    pub fn effect(&self) -> u32 {
        self.effect.unwrap_or(0)
    }

    pub fn clear_effect(&mut self) {
        self.effect = ::std::option::Option::None;
    }

    pub fn has_effect(&self) -> bool {
        self.effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: u32) {
        self.effect = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CProtoItemSocket_Effect {
    const NAME: &'static str = "CProtoItemSocket_Effect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.socket)?;
                },
                16 => {
                    self.effect = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.effect {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.socket.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.effect {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket_Effect {
        CProtoItemSocket_Effect::new()
    }

    fn clear(&mut self) {
        self.socket.clear();
        self.effect = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket_Effect {
        static instance: CProtoItemSocket_Effect = CProtoItemSocket_Effect {
            socket: ::steam_vent_proto_common::protobuf::MessageField::none(),
            effect: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CProtoItemSocket_Color)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket_Color {
    // message fields
    // @@protoc_insertion_point(field:CProtoItemSocket_Color.socket)
    pub socket: ::steam_vent_proto_common::protobuf::MessageField<CProtoItemSocket>,
    // @@protoc_insertion_point(field:CProtoItemSocket_Color.red)
    pub red: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CProtoItemSocket_Color.green)
    pub green: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CProtoItemSocket_Color.blue)
    pub blue: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CProtoItemSocket_Color.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket_Color {
    fn default() -> &'a CProtoItemSocket_Color {
        <CProtoItemSocket_Color as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket_Color {
    pub fn new() -> CProtoItemSocket_Color {
        ::std::default::Default::default()
    }

    // optional uint32 red = 2;

    pub fn red(&self) -> u32 {
        self.red.unwrap_or(0)
    }

    pub fn clear_red(&mut self) {
        self.red = ::std::option::Option::None;
    }

    pub fn has_red(&self) -> bool {
        self.red.is_some()
    }

    // Param is passed by value, moved
    pub fn set_red(&mut self, v: u32) {
        self.red = ::std::option::Option::Some(v);
    }

    // optional uint32 green = 3;

    pub fn green(&self) -> u32 {
        self.green.unwrap_or(0)
    }

    pub fn clear_green(&mut self) {
        self.green = ::std::option::Option::None;
    }

    pub fn has_green(&self) -> bool {
        self.green.is_some()
    }

    // Param is passed by value, moved
    pub fn set_green(&mut self, v: u32) {
        self.green = ::std::option::Option::Some(v);
    }

    // optional uint32 blue = 4;

    pub fn blue(&self) -> u32 {
        self.blue.unwrap_or(0)
    }

    pub fn clear_blue(&mut self) {
        self.blue = ::std::option::Option::None;
    }

    pub fn has_blue(&self) -> bool {
        self.blue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blue(&mut self, v: u32) {
        self.blue = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CProtoItemSocket_Color {
    const NAME: &'static str = "CProtoItemSocket_Color";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.socket)?;
                },
                16 => {
                    self.red = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.green = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.blue = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.red {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.green {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.blue {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.socket.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.red {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.green {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.blue {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket_Color {
        CProtoItemSocket_Color::new()
    }

    fn clear(&mut self) {
        self.socket.clear();
        self.red = ::std::option::Option::None;
        self.green = ::std::option::Option::None;
        self.blue = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket_Color {
        static instance: CProtoItemSocket_Color = CProtoItemSocket_Color {
            socket: ::steam_vent_proto_common::protobuf::MessageField::none(),
            red: ::std::option::Option::None,
            green: ::std::option::Option::None,
            blue: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CProtoItemSocket_Strange)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket_Strange {
    // message fields
    // @@protoc_insertion_point(field:CProtoItemSocket_Strange.socket)
    pub socket: ::steam_vent_proto_common::protobuf::MessageField<CProtoItemSocket>,
    // @@protoc_insertion_point(field:CProtoItemSocket_Strange.strange_type)
    pub strange_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CProtoItemSocket_Strange.strange_value)
    pub strange_value: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CProtoItemSocket_Strange.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket_Strange {
    fn default() -> &'a CProtoItemSocket_Strange {
        <CProtoItemSocket_Strange as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket_Strange {
    pub fn new() -> CProtoItemSocket_Strange {
        ::std::default::Default::default()
    }

    // optional uint32 strange_type = 2;

    pub fn strange_type(&self) -> u32 {
        self.strange_type.unwrap_or(0)
    }

    pub fn clear_strange_type(&mut self) {
        self.strange_type = ::std::option::Option::None;
    }

    pub fn has_strange_type(&self) -> bool {
        self.strange_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_type(&mut self, v: u32) {
        self.strange_type = ::std::option::Option::Some(v);
    }

    // optional uint32 strange_value = 3;

    pub fn strange_value(&self) -> u32 {
        self.strange_value.unwrap_or(0)
    }

    pub fn clear_strange_value(&mut self) {
        self.strange_value = ::std::option::Option::None;
    }

    pub fn has_strange_value(&self) -> bool {
        self.strange_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_value(&mut self, v: u32) {
        self.strange_value = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CProtoItemSocket_Strange {
    const NAME: &'static str = "CProtoItemSocket_Strange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.socket)?;
                },
                16 => {
                    self.strange_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.strange_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.strange_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.strange_value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.socket.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.strange_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.strange_value {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket_Strange {
        CProtoItemSocket_Strange::new()
    }

    fn clear(&mut self) {
        self.socket.clear();
        self.strange_type = ::std::option::Option::None;
        self.strange_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket_Strange {
        static instance: CProtoItemSocket_Strange = CProtoItemSocket_Strange {
            socket: ::steam_vent_proto_common::protobuf::MessageField::none(),
            strange_type: ::std::option::Option::None,
            strange_value: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
    // message fields
    // @@protoc_insertion_point(field:CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY.socket)
    pub socket: ::steam_vent_proto_common::protobuf::MessageField<CProtoItemSocket>,
    // @@protoc_insertion_point(field:CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY.strange_type)
    pub strange_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY.strange_value)
    pub strange_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY.ability_effect)
    pub ability_effect: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
    fn default() -> &'a CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
        <CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
    pub fn new() -> CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
        ::std::default::Default::default()
    }

    // optional uint32 strange_type = 2;

    pub fn strange_type(&self) -> u32 {
        self.strange_type.unwrap_or(0)
    }

    pub fn clear_strange_type(&mut self) {
        self.strange_type = ::std::option::Option::None;
    }

    pub fn has_strange_type(&self) -> bool {
        self.strange_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_type(&mut self, v: u32) {
        self.strange_type = ::std::option::Option::Some(v);
    }

    // optional uint32 strange_value = 3;

    pub fn strange_value(&self) -> u32 {
        self.strange_value.unwrap_or(0)
    }

    pub fn clear_strange_value(&mut self) {
        self.strange_value = ::std::option::Option::None;
    }

    pub fn has_strange_value(&self) -> bool {
        self.strange_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_value(&mut self, v: u32) {
        self.strange_value = ::std::option::Option::Some(v);
    }

    // optional uint32 ability_effect = 4;

    pub fn ability_effect(&self) -> u32 {
        self.ability_effect.unwrap_or(0)
    }

    pub fn clear_ability_effect(&mut self) {
        self.ability_effect = ::std::option::Option::None;
    }

    pub fn has_ability_effect(&self) -> bool {
        self.ability_effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_effect(&mut self, v: u32) {
        self.ability_effect = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
    const NAME: &'static str = "CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.socket)?;
                },
                16 => {
                    self.strange_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.strange_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.ability_effect = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.strange_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.strange_value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.ability_effect {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.socket.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.strange_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.strange_value {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ability_effect {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
        CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY::new()
    }

    fn clear(&mut self) {
        self.socket.clear();
        self.strange_type = ::std::option::Option::None;
        self.strange_value = ::std::option::Option::None;
        self.ability_effect = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
        static instance: CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY = CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
            socket: ::steam_vent_proto_common::protobuf::MessageField::none(),
            strange_type: ::std::option::Option::None,
            strange_value: ::std::option::Option::None,
            ability_effect: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CProtoItemSocket_Spectator)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket_Spectator {
    // message fields
    // @@protoc_insertion_point(field:CProtoItemSocket_Spectator.socket)
    pub socket: ::steam_vent_proto_common::protobuf::MessageField<CProtoItemSocket>,
    // @@protoc_insertion_point(field:CProtoItemSocket_Spectator.games_viewed)
    pub games_viewed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CProtoItemSocket_Spectator.corporation_id)
    pub corporation_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CProtoItemSocket_Spectator.league_id)
    pub league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CProtoItemSocket_Spectator.team_id)
    pub team_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CProtoItemSocket_Spectator.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket_Spectator {
    fn default() -> &'a CProtoItemSocket_Spectator {
        <CProtoItemSocket_Spectator as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket_Spectator {
    pub fn new() -> CProtoItemSocket_Spectator {
        ::std::default::Default::default()
    }

    // optional uint32 games_viewed = 2;

    pub fn games_viewed(&self) -> u32 {
        self.games_viewed.unwrap_or(0)
    }

    pub fn clear_games_viewed(&mut self) {
        self.games_viewed = ::std::option::Option::None;
    }

    pub fn has_games_viewed(&self) -> bool {
        self.games_viewed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_games_viewed(&mut self, v: u32) {
        self.games_viewed = ::std::option::Option::Some(v);
    }

    // optional uint32 corporation_id = 3;

    pub fn corporation_id(&self) -> u32 {
        self.corporation_id.unwrap_or(0)
    }

    pub fn clear_corporation_id(&mut self) {
        self.corporation_id = ::std::option::Option::None;
    }

    pub fn has_corporation_id(&self) -> bool {
        self.corporation_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_corporation_id(&mut self, v: u32) {
        self.corporation_id = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 4;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional uint32 team_id = 5;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CProtoItemSocket_Spectator {
    const NAME: &'static str = "CProtoItemSocket_Spectator";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.socket)?;
                },
                16 => {
                    self.games_viewed = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.corporation_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.games_viewed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.corporation_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.league_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.socket.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.games_viewed {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.corporation_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket_Spectator {
        CProtoItemSocket_Spectator::new()
    }

    fn clear(&mut self) {
        self.socket.clear();
        self.games_viewed = ::std::option::Option::None;
        self.corporation_id = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket_Spectator {
        static instance: CProtoItemSocket_Spectator = CProtoItemSocket_Spectator {
            socket: ::steam_vent_proto_common::protobuf::MessageField::none(),
            games_viewed: ::std::option::Option::None,
            corporation_id: ::std::option::Option::None,
            league_id: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CProtoItemSocket_AssetModifier)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket_AssetModifier {
    // message fields
    // @@protoc_insertion_point(field:CProtoItemSocket_AssetModifier.socket)
    pub socket: ::steam_vent_proto_common::protobuf::MessageField<CProtoItemSocket>,
    // @@protoc_insertion_point(field:CProtoItemSocket_AssetModifier.asset_modifier)
    pub asset_modifier: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CProtoItemSocket_AssetModifier.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket_AssetModifier {
    fn default() -> &'a CProtoItemSocket_AssetModifier {
        <CProtoItemSocket_AssetModifier as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket_AssetModifier {
    pub fn new() -> CProtoItemSocket_AssetModifier {
        ::std::default::Default::default()
    }

    // optional uint32 asset_modifier = 2;

    pub fn asset_modifier(&self) -> u32 {
        self.asset_modifier.unwrap_or(0)
    }

    pub fn clear_asset_modifier(&mut self) {
        self.asset_modifier = ::std::option::Option::None;
    }

    pub fn has_asset_modifier(&self) -> bool {
        self.asset_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_asset_modifier(&mut self, v: u32) {
        self.asset_modifier = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CProtoItemSocket_AssetModifier {
    const NAME: &'static str = "CProtoItemSocket_AssetModifier";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.socket)?;
                },
                16 => {
                    self.asset_modifier = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.asset_modifier {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.socket.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.asset_modifier {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket_AssetModifier {
        CProtoItemSocket_AssetModifier::new()
    }

    fn clear(&mut self) {
        self.socket.clear();
        self.asset_modifier = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket_AssetModifier {
        static instance: CProtoItemSocket_AssetModifier = CProtoItemSocket_AssetModifier {
            socket: ::steam_vent_proto_common::protobuf::MessageField::none(),
            asset_modifier: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
    // message fields
    // @@protoc_insertion_point(field:CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY.socket)
    pub socket: ::steam_vent_proto_common::protobuf::MessageField<CProtoItemSocket>,
    // @@protoc_insertion_point(field:CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY.asset_modifier)
    pub asset_modifier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY.anim_modifier)
    pub anim_modifier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY.ability_effect)
    pub ability_effect: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
    fn default() -> &'a CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
        <CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
    pub fn new() -> CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
        ::std::default::Default::default()
    }

    // optional uint32 asset_modifier = 2;

    pub fn asset_modifier(&self) -> u32 {
        self.asset_modifier.unwrap_or(0)
    }

    pub fn clear_asset_modifier(&mut self) {
        self.asset_modifier = ::std::option::Option::None;
    }

    pub fn has_asset_modifier(&self) -> bool {
        self.asset_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_asset_modifier(&mut self, v: u32) {
        self.asset_modifier = ::std::option::Option::Some(v);
    }

    // optional uint32 anim_modifier = 3;

    pub fn anim_modifier(&self) -> u32 {
        self.anim_modifier.unwrap_or(0)
    }

    pub fn clear_anim_modifier(&mut self) {
        self.anim_modifier = ::std::option::Option::None;
    }

    pub fn has_anim_modifier(&self) -> bool {
        self.anim_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_anim_modifier(&mut self, v: u32) {
        self.anim_modifier = ::std::option::Option::Some(v);
    }

    // optional uint32 ability_effect = 4;

    pub fn ability_effect(&self) -> u32 {
        self.ability_effect.unwrap_or(0)
    }

    pub fn clear_ability_effect(&mut self) {
        self.ability_effect = ::std::option::Option::None;
    }

    pub fn has_ability_effect(&self) -> bool {
        self.ability_effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_effect(&mut self, v: u32) {
        self.ability_effect = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
    const NAME: &'static str = "CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.socket)?;
                },
                16 => {
                    self.asset_modifier = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.anim_modifier = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.ability_effect = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.asset_modifier {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.anim_modifier {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.ability_effect {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.socket.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.asset_modifier {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.anim_modifier {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ability_effect {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
        CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY::new()
    }

    fn clear(&mut self) {
        self.socket.clear();
        self.asset_modifier = ::std::option::Option::None;
        self.anim_modifier = ::std::option::Option::None;
        self.ability_effect = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
        static instance: CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY = CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
            socket: ::steam_vent_proto_common::protobuf::MessageField::none(),
            asset_modifier: ::std::option::Option::None,
            anim_modifier: ::std::option::Option::None,
            ability_effect: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CProtoItemSocket_Autograph)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket_Autograph {
    // message fields
    // @@protoc_insertion_point(field:CProtoItemSocket_Autograph.socket)
    pub socket: ::steam_vent_proto_common::protobuf::MessageField<CProtoItemSocket>,
    // @@protoc_insertion_point(field:CProtoItemSocket_Autograph.autograph)
    pub autograph: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CProtoItemSocket_Autograph.autograph_id)
    pub autograph_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CProtoItemSocket_Autograph.autograph_score)
    pub autograph_score: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CProtoItemSocket_Autograph.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket_Autograph {
    fn default() -> &'a CProtoItemSocket_Autograph {
        <CProtoItemSocket_Autograph as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket_Autograph {
    pub fn new() -> CProtoItemSocket_Autograph {
        ::std::default::Default::default()
    }

    // optional string autograph = 2;

    pub fn autograph(&self) -> &str {
        match self.autograph.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_autograph(&mut self) {
        self.autograph = ::std::option::Option::None;
    }

    pub fn has_autograph(&self) -> bool {
        self.autograph.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autograph(&mut self, v: ::std::string::String) {
        self.autograph = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_autograph(&mut self) -> &mut ::std::string::String {
        if self.autograph.is_none() {
            self.autograph = ::std::option::Option::Some(::std::string::String::new());
        }
        self.autograph.as_mut().unwrap()
    }

    // Take field
    pub fn take_autograph(&mut self) -> ::std::string::String {
        self.autograph.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 autograph_id = 3;

    pub fn autograph_id(&self) -> u32 {
        self.autograph_id.unwrap_or(0)
    }

    pub fn clear_autograph_id(&mut self) {
        self.autograph_id = ::std::option::Option::None;
    }

    pub fn has_autograph_id(&self) -> bool {
        self.autograph_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autograph_id(&mut self, v: u32) {
        self.autograph_id = ::std::option::Option::Some(v);
    }

    // optional uint32 autograph_score = 4;

    pub fn autograph_score(&self) -> u32 {
        self.autograph_score.unwrap_or(0)
    }

    pub fn clear_autograph_score(&mut self) {
        self.autograph_score = ::std::option::Option::None;
    }

    pub fn has_autograph_score(&self) -> bool {
        self.autograph_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autograph_score(&mut self, v: u32) {
        self.autograph_score = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CProtoItemSocket_Autograph {
    const NAME: &'static str = "CProtoItemSocket_Autograph";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.socket)?;
                },
                18 => {
                    self.autograph = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.autograph_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.autograph_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.autograph.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.autograph_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.autograph_score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.socket.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.autograph.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.autograph_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.autograph_score {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket_Autograph {
        CProtoItemSocket_Autograph::new()
    }

    fn clear(&mut self) {
        self.socket.clear();
        self.autograph = ::std::option::Option::None;
        self.autograph_id = ::std::option::Option::None;
        self.autograph_score = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket_Autograph {
        static instance: CProtoItemSocket_Autograph = CProtoItemSocket_Autograph {
            socket: ::steam_vent_proto_common::protobuf::MessageField::none(),
            autograph: ::std::option::Option::None,
            autograph_id: ::std::option::Option::None,
            autograph_score: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CProtoItemSocket_StaticVisuals)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemSocket_StaticVisuals {
    // message fields
    // @@protoc_insertion_point(field:CProtoItemSocket_StaticVisuals.socket)
    pub socket: ::steam_vent_proto_common::protobuf::MessageField<CProtoItemSocket>,
    // special fields
    // @@protoc_insertion_point(special_field:CProtoItemSocket_StaticVisuals.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemSocket_StaticVisuals {
    fn default() -> &'a CProtoItemSocket_StaticVisuals {
        <CProtoItemSocket_StaticVisuals as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CProtoItemSocket_StaticVisuals {
    pub fn new() -> CProtoItemSocket_StaticVisuals {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CProtoItemSocket_StaticVisuals {
    const NAME: &'static str = "CProtoItemSocket_StaticVisuals";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.socket)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.socket.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemSocket_StaticVisuals {
        CProtoItemSocket_StaticVisuals::new()
    }

    fn clear(&mut self) {
        self.socket.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemSocket_StaticVisuals {
        static instance: CProtoItemSocket_StaticVisuals = CProtoItemSocket_StaticVisuals {
            socket: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CAttribute_String)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CAttribute_String {
    // message fields
    // @@protoc_insertion_point(field:CAttribute_String.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CAttribute_String.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAttribute_String {
    fn default() -> &'a CAttribute_String {
        <CAttribute_String as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CAttribute_String {
    pub fn new() -> CAttribute_String {
        ::std::default::Default::default()
    }

    // optional string value = 1;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CAttribute_String {
    const NAME: &'static str = "CAttribute_String";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.value.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAttribute_String {
        CAttribute_String::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAttribute_String {
        static instance: CAttribute_String = CAttribute_String {
            value: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CWorkshop_GetItemDailyRevenue_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_GetItemDailyRevenue_Request {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_GetItemDailyRevenue_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_GetItemDailyRevenue_Request.item_id)
    pub item_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_GetItemDailyRevenue_Request.date_start)
    pub date_start: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_GetItemDailyRevenue_Request.date_end)
    pub date_end: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_GetItemDailyRevenue_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetItemDailyRevenue_Request {
    fn default() -> &'a CWorkshop_GetItemDailyRevenue_Request {
        <CWorkshop_GetItemDailyRevenue_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetItemDailyRevenue_Request {
    pub fn new() -> CWorkshop_GetItemDailyRevenue_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 item_id = 2;

    pub fn item_id(&self) -> u32 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u32) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 date_start = 3;

    pub fn date_start(&self) -> u32 {
        self.date_start.unwrap_or(0)
    }

    pub fn clear_date_start(&mut self) {
        self.date_start = ::std::option::Option::None;
    }

    pub fn has_date_start(&self) -> bool {
        self.date_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_start(&mut self, v: u32) {
        self.date_start = ::std::option::Option::Some(v);
    }

    // optional uint32 date_end = 4;

    pub fn date_end(&self) -> u32 {
        self.date_end.unwrap_or(0)
    }

    pub fn clear_date_end(&mut self) {
        self.date_end = ::std::option::Option::None;
    }

    pub fn has_date_end(&self) -> bool {
        self.date_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_end(&mut self, v: u32) {
        self.date_end = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CWorkshop_GetItemDailyRevenue_Request {
    const NAME: &'static str = "CWorkshop_GetItemDailyRevenue_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.date_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.date_end = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.date_start {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.date_end {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.date_start {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.date_end {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_GetItemDailyRevenue_Request {
        CWorkshop_GetItemDailyRevenue_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.date_start = ::std::option::Option::None;
        self.date_end = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_GetItemDailyRevenue_Request {
        static instance: CWorkshop_GetItemDailyRevenue_Request = CWorkshop_GetItemDailyRevenue_Request {
            appid: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            date_start: ::std::option::Option::None,
            date_end: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CWorkshop_GetItemDailyRevenue_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_GetItemDailyRevenue_Response {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_GetItemDailyRevenue_Response.country_revenue)
    pub country_revenue: ::std::vec::Vec<cworkshop_get_item_daily_revenue_response::CountryDailyRevenue>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_GetItemDailyRevenue_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetItemDailyRevenue_Response {
    fn default() -> &'a CWorkshop_GetItemDailyRevenue_Response {
        <CWorkshop_GetItemDailyRevenue_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetItemDailyRevenue_Response {
    pub fn new() -> CWorkshop_GetItemDailyRevenue_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CWorkshop_GetItemDailyRevenue_Response {
    const NAME: &'static str = "CWorkshop_GetItemDailyRevenue_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.country_revenue.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.country_revenue {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.country_revenue {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_GetItemDailyRevenue_Response {
        CWorkshop_GetItemDailyRevenue_Response::new()
    }

    fn clear(&mut self) {
        self.country_revenue.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_GetItemDailyRevenue_Response {
        static instance: CWorkshop_GetItemDailyRevenue_Response = CWorkshop_GetItemDailyRevenue_Response {
            country_revenue: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CWorkshop_GetItemDailyRevenue_Response`
pub mod cworkshop_get_item_daily_revenue_response {
    // @@protoc_insertion_point(message:CWorkshop_GetItemDailyRevenue_Response.CountryDailyRevenue)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CountryDailyRevenue {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_GetItemDailyRevenue_Response.CountryDailyRevenue.country_code)
        pub country_code: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CWorkshop_GetItemDailyRevenue_Response.CountryDailyRevenue.date)
        pub date: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CWorkshop_GetItemDailyRevenue_Response.CountryDailyRevenue.revenue_usd)
        pub revenue_usd: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CWorkshop_GetItemDailyRevenue_Response.CountryDailyRevenue.units)
        pub units: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_GetItemDailyRevenue_Response.CountryDailyRevenue.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CountryDailyRevenue {
        fn default() -> &'a CountryDailyRevenue {
            <CountryDailyRevenue as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CountryDailyRevenue {
        pub fn new() -> CountryDailyRevenue {
            ::std::default::Default::default()
        }

        // optional string country_code = 1;

        pub fn country_code(&self) -> &str {
            match self.country_code.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_country_code(&mut self) {
            self.country_code = ::std::option::Option::None;
        }

        pub fn has_country_code(&self) -> bool {
            self.country_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_country_code(&mut self, v: ::std::string::String) {
            self.country_code = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
            if self.country_code.is_none() {
                self.country_code = ::std::option::Option::Some(::std::string::String::new());
            }
            self.country_code.as_mut().unwrap()
        }

        // Take field
        pub fn take_country_code(&mut self) -> ::std::string::String {
            self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 date = 2;

        pub fn date(&self) -> u32 {
            self.date.unwrap_or(0)
        }

        pub fn clear_date(&mut self) {
            self.date = ::std::option::Option::None;
        }

        pub fn has_date(&self) -> bool {
            self.date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_date(&mut self, v: u32) {
            self.date = ::std::option::Option::Some(v);
        }

        // optional int64 revenue_usd = 3;

        pub fn revenue_usd(&self) -> i64 {
            self.revenue_usd.unwrap_or(0)
        }

        pub fn clear_revenue_usd(&mut self) {
            self.revenue_usd = ::std::option::Option::None;
        }

        pub fn has_revenue_usd(&self) -> bool {
            self.revenue_usd.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revenue_usd(&mut self, v: i64) {
            self.revenue_usd = ::std::option::Option::Some(v);
        }

        // optional int32 units = 4;

        pub fn units(&self) -> i32 {
            self.units.unwrap_or(0)
        }

        pub fn clear_units(&mut self) {
            self.units = ::std::option::Option::None;
        }

        pub fn has_units(&self) -> bool {
            self.units.is_some()
        }

        // Param is passed by value, moved
        pub fn set_units(&mut self, v: i32) {
            self.units = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CountryDailyRevenue {
        const NAME: &'static str = "CountryDailyRevenue";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.country_code = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.date = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.revenue_usd = ::std::option::Option::Some(is.read_int64()?);
                    },
                    32 => {
                        self.units = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.country_code.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.date {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.revenue_usd {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(3, v);
            }
            if let Some(v) = self.units {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.country_code.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.date {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.revenue_usd {
                os.write_int64(3, v)?;
            }
            if let Some(v) = self.units {
                os.write_int32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CountryDailyRevenue {
            CountryDailyRevenue::new()
        }

        fn clear(&mut self) {
            self.country_code = ::std::option::Option::None;
            self.date = ::std::option::Option::None;
            self.revenue_usd = ::std::option::Option::None;
            self.units = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CountryDailyRevenue {
            static instance: CountryDailyRevenue = CountryDailyRevenue {
                country_code: ::std::option::Option::None,
                date: ::std::option::Option::None,
                revenue_usd: ::std::option::Option::None,
                units: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CWorkshop_GetPackageDailyRevenue_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_GetPackageDailyRevenue_Request {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_GetPackageDailyRevenue_Request.packageid)
    pub packageid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_GetPackageDailyRevenue_Request.date_start)
    pub date_start: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_GetPackageDailyRevenue_Request.date_end)
    pub date_end: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_GetPackageDailyRevenue_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetPackageDailyRevenue_Request {
    fn default() -> &'a CWorkshop_GetPackageDailyRevenue_Request {
        <CWorkshop_GetPackageDailyRevenue_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetPackageDailyRevenue_Request {
    pub fn new() -> CWorkshop_GetPackageDailyRevenue_Request {
        ::std::default::Default::default()
    }

    // optional uint32 packageid = 1;

    pub fn packageid(&self) -> u32 {
        self.packageid.unwrap_or(0)
    }

    pub fn clear_packageid(&mut self) {
        self.packageid = ::std::option::Option::None;
    }

    pub fn has_packageid(&self) -> bool {
        self.packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packageid(&mut self, v: u32) {
        self.packageid = ::std::option::Option::Some(v);
    }

    // optional uint32 date_start = 2;

    pub fn date_start(&self) -> u32 {
        self.date_start.unwrap_or(0)
    }

    pub fn clear_date_start(&mut self) {
        self.date_start = ::std::option::Option::None;
    }

    pub fn has_date_start(&self) -> bool {
        self.date_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_start(&mut self, v: u32) {
        self.date_start = ::std::option::Option::Some(v);
    }

    // optional uint32 date_end = 3;

    pub fn date_end(&self) -> u32 {
        self.date_end.unwrap_or(0)
    }

    pub fn clear_date_end(&mut self) {
        self.date_end = ::std::option::Option::None;
    }

    pub fn has_date_end(&self) -> bool {
        self.date_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_end(&mut self, v: u32) {
        self.date_end = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CWorkshop_GetPackageDailyRevenue_Request {
    const NAME: &'static str = "CWorkshop_GetPackageDailyRevenue_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.packageid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.date_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.date_end = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.packageid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.date_start {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.date_end {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.packageid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.date_start {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.date_end {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_GetPackageDailyRevenue_Request {
        CWorkshop_GetPackageDailyRevenue_Request::new()
    }

    fn clear(&mut self) {
        self.packageid = ::std::option::Option::None;
        self.date_start = ::std::option::Option::None;
        self.date_end = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_GetPackageDailyRevenue_Request {
        static instance: CWorkshop_GetPackageDailyRevenue_Request = CWorkshop_GetPackageDailyRevenue_Request {
            packageid: ::std::option::Option::None,
            date_start: ::std::option::Option::None,
            date_end: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CWorkshop_GetPackageDailyRevenue_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_GetPackageDailyRevenue_Response {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_GetPackageDailyRevenue_Response.country_revenue)
    pub country_revenue: ::std::vec::Vec<cworkshop_get_package_daily_revenue_response::CountryDailyRevenue>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_GetPackageDailyRevenue_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetPackageDailyRevenue_Response {
    fn default() -> &'a CWorkshop_GetPackageDailyRevenue_Response {
        <CWorkshop_GetPackageDailyRevenue_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetPackageDailyRevenue_Response {
    pub fn new() -> CWorkshop_GetPackageDailyRevenue_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CWorkshop_GetPackageDailyRevenue_Response {
    const NAME: &'static str = "CWorkshop_GetPackageDailyRevenue_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.country_revenue.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.country_revenue {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.country_revenue {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_GetPackageDailyRevenue_Response {
        CWorkshop_GetPackageDailyRevenue_Response::new()
    }

    fn clear(&mut self) {
        self.country_revenue.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_GetPackageDailyRevenue_Response {
        static instance: CWorkshop_GetPackageDailyRevenue_Response = CWorkshop_GetPackageDailyRevenue_Response {
            country_revenue: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CWorkshop_GetPackageDailyRevenue_Response`
pub mod cworkshop_get_package_daily_revenue_response {
    // @@protoc_insertion_point(message:CWorkshop_GetPackageDailyRevenue_Response.CountryDailyRevenue)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CountryDailyRevenue {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_GetPackageDailyRevenue_Response.CountryDailyRevenue.country_code)
        pub country_code: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CWorkshop_GetPackageDailyRevenue_Response.CountryDailyRevenue.date)
        pub date: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CWorkshop_GetPackageDailyRevenue_Response.CountryDailyRevenue.revenue_usd)
        pub revenue_usd: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CWorkshop_GetPackageDailyRevenue_Response.CountryDailyRevenue.units)
        pub units: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_GetPackageDailyRevenue_Response.CountryDailyRevenue.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CountryDailyRevenue {
        fn default() -> &'a CountryDailyRevenue {
            <CountryDailyRevenue as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CountryDailyRevenue {
        pub fn new() -> CountryDailyRevenue {
            ::std::default::Default::default()
        }

        // optional string country_code = 1;

        pub fn country_code(&self) -> &str {
            match self.country_code.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_country_code(&mut self) {
            self.country_code = ::std::option::Option::None;
        }

        pub fn has_country_code(&self) -> bool {
            self.country_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_country_code(&mut self, v: ::std::string::String) {
            self.country_code = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
            if self.country_code.is_none() {
                self.country_code = ::std::option::Option::Some(::std::string::String::new());
            }
            self.country_code.as_mut().unwrap()
        }

        // Take field
        pub fn take_country_code(&mut self) -> ::std::string::String {
            self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 date = 2;

        pub fn date(&self) -> u32 {
            self.date.unwrap_or(0)
        }

        pub fn clear_date(&mut self) {
            self.date = ::std::option::Option::None;
        }

        pub fn has_date(&self) -> bool {
            self.date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_date(&mut self, v: u32) {
            self.date = ::std::option::Option::Some(v);
        }

        // optional int64 revenue_usd = 3;

        pub fn revenue_usd(&self) -> i64 {
            self.revenue_usd.unwrap_or(0)
        }

        pub fn clear_revenue_usd(&mut self) {
            self.revenue_usd = ::std::option::Option::None;
        }

        pub fn has_revenue_usd(&self) -> bool {
            self.revenue_usd.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revenue_usd(&mut self, v: i64) {
            self.revenue_usd = ::std::option::Option::Some(v);
        }

        // optional int32 units = 4;

        pub fn units(&self) -> i32 {
            self.units.unwrap_or(0)
        }

        pub fn clear_units(&mut self) {
            self.units = ::std::option::Option::None;
        }

        pub fn has_units(&self) -> bool {
            self.units.is_some()
        }

        // Param is passed by value, moved
        pub fn set_units(&mut self, v: i32) {
            self.units = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CountryDailyRevenue {
        const NAME: &'static str = "CountryDailyRevenue";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.country_code = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.date = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.revenue_usd = ::std::option::Option::Some(is.read_int64()?);
                    },
                    32 => {
                        self.units = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.country_code.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.date {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.revenue_usd {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(3, v);
            }
            if let Some(v) = self.units {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.country_code.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.date {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.revenue_usd {
                os.write_int64(3, v)?;
            }
            if let Some(v) = self.units {
                os.write_int32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CountryDailyRevenue {
            CountryDailyRevenue::new()
        }

        fn clear(&mut self) {
            self.country_code = ::std::option::Option::None;
            self.date = ::std::option::Option::None;
            self.revenue_usd = ::std::option::Option::None;
            self.units = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CountryDailyRevenue {
            static instance: CountryDailyRevenue = CountryDailyRevenue {
                country_code: ::std::option::Option::None,
                date: ::std::option::Option::None,
                revenue_usd: ::std::option::Option::None,
                units: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSQLGCToGCGrantBackpackSlots)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSQLGCToGCGrantBackpackSlots {
    // message fields
    // @@protoc_insertion_point(field:CMsgSQLGCToGCGrantBackpackSlots.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSQLGCToGCGrantBackpackSlots.add_slots)
    pub add_slots: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSQLGCToGCGrantBackpackSlots.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSQLGCToGCGrantBackpackSlots {
    fn default() -> &'a CMsgSQLGCToGCGrantBackpackSlots {
        <CMsgSQLGCToGCGrantBackpackSlots as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSQLGCToGCGrantBackpackSlots {
    pub fn new() -> CMsgSQLGCToGCGrantBackpackSlots {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 add_slots = 2;

    pub fn add_slots(&self) -> u32 {
        self.add_slots.unwrap_or(0)
    }

    pub fn clear_add_slots(&mut self) {
        self.add_slots = ::std::option::Option::None;
    }

    pub fn has_add_slots(&self) -> bool {
        self.add_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_slots(&mut self, v: u32) {
        self.add_slots = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSQLGCToGCGrantBackpackSlots {
    const NAME: &'static str = "CMsgSQLGCToGCGrantBackpackSlots";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.add_slots = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.add_slots {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.add_slots {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSQLGCToGCGrantBackpackSlots {
        CMsgSQLGCToGCGrantBackpackSlots::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.add_slots = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSQLGCToGCGrantBackpackSlots {
        static instance: CMsgSQLGCToGCGrantBackpackSlots = CMsgSQLGCToGCGrantBackpackSlots {
            account_id: ::std::option::Option::None,
            add_slots: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCLookupAccountName)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCLookupAccountName {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCLookupAccountName.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCLookupAccountName.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCLookupAccountName {
    fn default() -> &'a CMsgClientToGCLookupAccountName {
        <CMsgClientToGCLookupAccountName as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCLookupAccountName {
    pub fn new() -> CMsgClientToGCLookupAccountName {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCLookupAccountName {
    const NAME: &'static str = "CMsgClientToGCLookupAccountName";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCLookupAccountName {
        CMsgClientToGCLookupAccountName::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCLookupAccountName {
        static instance: CMsgClientToGCLookupAccountName = CMsgClientToGCLookupAccountName {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCLookupAccountNameResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCLookupAccountNameResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCLookupAccountNameResponse.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCLookupAccountNameResponse.account_name)
    pub account_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCLookupAccountNameResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCLookupAccountNameResponse {
    fn default() -> &'a CMsgClientToGCLookupAccountNameResponse {
        <CMsgClientToGCLookupAccountNameResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCLookupAccountNameResponse {
    pub fn new() -> CMsgClientToGCLookupAccountNameResponse {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional string account_name = 2;

    pub fn account_name(&self) -> &str {
        match self.account_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name(&mut self) {
        self.account_name = ::std::option::Option::None;
    }

    pub fn has_account_name(&self) -> bool {
        self.account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name(&mut self, v: ::std::string::String) {
        self.account_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name(&mut self) -> &mut ::std::string::String {
        if self.account_name.is_none() {
            self.account_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name(&mut self) -> ::std::string::String {
        self.account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCLookupAccountNameResponse {
    const NAME: &'static str = "CMsgClientToGCLookupAccountNameResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.account_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.account_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCLookupAccountNameResponse {
        CMsgClientToGCLookupAccountNameResponse::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.account_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCLookupAccountNameResponse {
        static instance: CMsgClientToGCLookupAccountNameResponse = CMsgClientToGCLookupAccountNameResponse {
            account_id: ::std::option::Option::None,
            account_name: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCCreateStaticRecipe)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCreateStaticRecipe {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCreateStaticRecipe.items)
    pub items: ::std::vec::Vec<cmsg_client_to_gccreate_static_recipe::Item>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreateStaticRecipe.recipe_def_index)
    pub recipe_def_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCreateStaticRecipe.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCreateStaticRecipe {
    fn default() -> &'a CMsgClientToGCCreateStaticRecipe {
        <CMsgClientToGCCreateStaticRecipe as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCreateStaticRecipe {
    pub fn new() -> CMsgClientToGCCreateStaticRecipe {
        ::std::default::Default::default()
    }

    // optional uint32 recipe_def_index = 2;

    pub fn recipe_def_index(&self) -> u32 {
        self.recipe_def_index.unwrap_or(0)
    }

    pub fn clear_recipe_def_index(&mut self) {
        self.recipe_def_index = ::std::option::Option::None;
    }

    pub fn has_recipe_def_index(&self) -> bool {
        self.recipe_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipe_def_index(&mut self, v: u32) {
        self.recipe_def_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCreateStaticRecipe {
    const NAME: &'static str = "CMsgClientToGCCreateStaticRecipe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.items.push(is.read_message()?);
                },
                16 => {
                    self.recipe_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.recipe_def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.items {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.recipe_def_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCreateStaticRecipe {
        CMsgClientToGCCreateStaticRecipe::new()
    }

    fn clear(&mut self) {
        self.items.clear();
        self.recipe_def_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCreateStaticRecipe {
        static instance: CMsgClientToGCCreateStaticRecipe = CMsgClientToGCCreateStaticRecipe {
            items: ::std::vec::Vec::new(),
            recipe_def_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCCreateStaticRecipe`
pub mod cmsg_client_to_gccreate_static_recipe {
    // @@protoc_insertion_point(message:CMsgClientToGCCreateStaticRecipe.Item)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Item {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCCreateStaticRecipe.Item.item_id)
        pub item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientToGCCreateStaticRecipe.Item.slot_id)
        pub slot_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCCreateStaticRecipe.Item.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Item {
        fn default() -> &'a Item {
            <Item as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Item {
        pub fn new() -> Item {
            ::std::default::Default::default()
        }

        // optional uint64 item_id = 1;

        pub fn item_id(&self) -> u64 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: u64) {
            self.item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 slot_id = 2;

        pub fn slot_id(&self) -> u32 {
            self.slot_id.unwrap_or(0)
        }

        pub fn clear_slot_id(&mut self) {
            self.slot_id = ::std::option::Option::None;
        }

        pub fn has_slot_id(&self) -> bool {
            self.slot_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot_id(&mut self, v: u32) {
            self.slot_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Item {
        const NAME: &'static str = "Item";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.slot_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.slot_id {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Item {
            Item::new()
        }

        fn clear(&mut self) {
            self.item_id = ::std::option::Option::None;
            self.slot_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Item {
            static instance: Item = Item {
                item_id: ::std::option::Option::None,
                slot_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCCreateStaticRecipeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCreateStaticRecipeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCreateStaticRecipeResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gccreate_static_recipe_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreateStaticRecipeResponse.output_items)
    pub output_items: ::std::vec::Vec<cmsg_client_to_gccreate_static_recipe_response::OutputItem>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreateStaticRecipeResponse.input_errors)
    pub input_errors: ::std::vec::Vec<cmsg_client_to_gccreate_static_recipe_response::InputError>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreateStaticRecipeResponse.additional_outputs)
    pub additional_outputs: ::std::vec::Vec<cmsg_client_to_gccreate_static_recipe_response::AdditionalOutput>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCreateStaticRecipeResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCreateStaticRecipeResponse {
    fn default() -> &'a CMsgClientToGCCreateStaticRecipeResponse {
        <CMsgClientToGCCreateStaticRecipeResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCreateStaticRecipeResponse {
    pub fn new() -> CMsgClientToGCCreateStaticRecipeResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCCreateStaticRecipeResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gccreate_static_recipe_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gccreate_static_recipe_response::EResponse::eResponse_Success),
            None => cmsg_client_to_gccreate_static_recipe_response::EResponse::eResponse_Success,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gccreate_static_recipe_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCreateStaticRecipeResponse {
    const NAME: &'static str = "CMsgClientToGCCreateStaticRecipeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.output_items.push(is.read_message()?);
                },
                26 => {
                    self.input_errors.push(is.read_message()?);
                },
                34 => {
                    self.additional_outputs.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.output_items {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.input_errors {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.additional_outputs {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.output_items {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.input_errors {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.additional_outputs {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCreateStaticRecipeResponse {
        CMsgClientToGCCreateStaticRecipeResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.output_items.clear();
        self.input_errors.clear();
        self.additional_outputs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCreateStaticRecipeResponse {
        static instance: CMsgClientToGCCreateStaticRecipeResponse = CMsgClientToGCCreateStaticRecipeResponse {
            response: ::std::option::Option::None,
            output_items: ::std::vec::Vec::new(),
            input_errors: ::std::vec::Vec::new(),
            additional_outputs: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCCreateStaticRecipeResponse`
pub mod cmsg_client_to_gccreate_static_recipe_response {
    // @@protoc_insertion_point(message:CMsgClientToGCCreateStaticRecipeResponse.OutputItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct OutputItem {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCCreateStaticRecipeResponse.OutputItem.def_index)
        pub def_index: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCCreateStaticRecipeResponse.OutputItem.item_id)
        pub item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientToGCCreateStaticRecipeResponse.OutputItem.slot_id)
        pub slot_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCCreateStaticRecipeResponse.OutputItem.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a OutputItem {
        fn default() -> &'a OutputItem {
            <OutputItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl OutputItem {
        pub fn new() -> OutputItem {
            ::std::default::Default::default()
        }

        // optional uint32 def_index = 1;

        pub fn def_index(&self) -> u32 {
            self.def_index.unwrap_or(0)
        }

        pub fn clear_def_index(&mut self) {
            self.def_index = ::std::option::Option::None;
        }

        pub fn has_def_index(&self) -> bool {
            self.def_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_def_index(&mut self, v: u32) {
            self.def_index = ::std::option::Option::Some(v);
        }

        // optional uint64 item_id = 2;

        pub fn item_id(&self) -> u64 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: u64) {
            self.item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 slot_id = 3;

        pub fn slot_id(&self) -> u32 {
            self.slot_id.unwrap_or(0)
        }

        pub fn clear_slot_id(&mut self) {
            self.slot_id = ::std::option::Option::None;
        }

        pub fn has_slot_id(&self) -> bool {
            self.slot_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot_id(&mut self, v: u32) {
            self.slot_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for OutputItem {
        const NAME: &'static str = "OutputItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    24 => {
                        self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.def_index {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.item_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.slot_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.def_index {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.item_id {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.slot_id {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> OutputItem {
            OutputItem::new()
        }

        fn clear(&mut self) {
            self.def_index = ::std::option::Option::None;
            self.item_id = ::std::option::Option::None;
            self.slot_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static OutputItem {
            static instance: OutputItem = OutputItem {
                def_index: ::std::option::Option::None,
                item_id: ::std::option::Option::None,
                slot_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgClientToGCCreateStaticRecipeResponse.InputError)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct InputError {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCCreateStaticRecipeResponse.InputError.slot_id)
        pub slot_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCCreateStaticRecipeResponse.InputError.error)
        pub error: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EResponse>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCCreateStaticRecipeResponse.InputError.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a InputError {
        fn default() -> &'a InputError {
            <InputError as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl InputError {
        pub fn new() -> InputError {
            ::std::default::Default::default()
        }

        // optional uint32 slot_id = 1;

        pub fn slot_id(&self) -> u32 {
            self.slot_id.unwrap_or(0)
        }

        pub fn clear_slot_id(&mut self) {
            self.slot_id = ::std::option::Option::None;
        }

        pub fn has_slot_id(&self) -> bool {
            self.slot_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot_id(&mut self, v: u32) {
            self.slot_id = ::std::option::Option::Some(v);
        }

        // optional .CMsgClientToGCCreateStaticRecipeResponse.EResponse error = 2;

        pub fn error(&self) -> EResponse {
            match self.error {
                Some(e) => e.enum_value_or(EResponse::eResponse_Success),
                None => EResponse::eResponse_Success,
            }
        }

        pub fn clear_error(&mut self) {
            self.error = ::std::option::Option::None;
        }

        pub fn has_error(&self) -> bool {
            self.error.is_some()
        }

        // Param is passed by value, moved
        pub fn set_error(&mut self, v: EResponse) {
            self.error = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for InputError {
        const NAME: &'static str = "InputError";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.error = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.slot_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.error {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.slot_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.error {
                os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> InputError {
            InputError::new()
        }

        fn clear(&mut self) {
            self.slot_id = ::std::option::Option::None;
            self.error = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static InputError {
            static instance: InputError = InputError {
                slot_id: ::std::option::Option::None,
                error: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgClientToGCCreateStaticRecipeResponse.AdditionalOutput)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AdditionalOutput {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCCreateStaticRecipeResponse.AdditionalOutput.slot_id)
        pub slot_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCCreateStaticRecipeResponse.AdditionalOutput.value)
        pub value: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCCreateStaticRecipeResponse.AdditionalOutput.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AdditionalOutput {
        fn default() -> &'a AdditionalOutput {
            <AdditionalOutput as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl AdditionalOutput {
        pub fn new() -> AdditionalOutput {
            ::std::default::Default::default()
        }

        // optional uint32 slot_id = 1;

        pub fn slot_id(&self) -> u32 {
            self.slot_id.unwrap_or(0)
        }

        pub fn clear_slot_id(&mut self) {
            self.slot_id = ::std::option::Option::None;
        }

        pub fn has_slot_id(&self) -> bool {
            self.slot_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot_id(&mut self, v: u32) {
            self.slot_id = ::std::option::Option::Some(v);
        }

        // optional uint64 value = 2;

        pub fn value(&self) -> u64 {
            self.value.unwrap_or(0)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: u64) {
            self.value = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for AdditionalOutput {
        const NAME: &'static str = "AdditionalOutput";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.value = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.slot_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.value {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.slot_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.value {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AdditionalOutput {
            AdditionalOutput::new()
        }

        fn clear(&mut self) {
            self.slot_id = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AdditionalOutput {
            static instance: AdditionalOutput = AdditionalOutput {
                slot_id: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCCreateStaticRecipeResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateStaticRecipeResponse.EResponse.eResponse_Success)
        eResponse_Success = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateStaticRecipeResponse.EResponse.eResponse_OfferingDisabled)
        eResponse_OfferingDisabled = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateStaticRecipeResponse.EResponse.eResponse_InvalidItems)
        eResponse_InvalidItems = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateStaticRecipeResponse.EResponse.eResponse_InternalError)
        eResponse_InternalError = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateStaticRecipeResponse.EResponse.eResponse_MissingLeague)
        eResponse_MissingLeague = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateStaticRecipeResponse.EResponse.eResponse_MissingEvent)
        eResponse_MissingEvent = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::eResponse_Success),
                1 => ::std::option::Option::Some(EResponse::eResponse_OfferingDisabled),
                2 => ::std::option::Option::Some(EResponse::eResponse_InvalidItems),
                3 => ::std::option::Option::Some(EResponse::eResponse_InternalError),
                4 => ::std::option::Option::Some(EResponse::eResponse_MissingLeague),
                5 => ::std::option::Option::Some(EResponse::eResponse_MissingEvent),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "eResponse_Success" => ::std::option::Option::Some(EResponse::eResponse_Success),
                "eResponse_OfferingDisabled" => ::std::option::Option::Some(EResponse::eResponse_OfferingDisabled),
                "eResponse_InvalidItems" => ::std::option::Option::Some(EResponse::eResponse_InvalidItems),
                "eResponse_InternalError" => ::std::option::Option::Some(EResponse::eResponse_InternalError),
                "eResponse_MissingLeague" => ::std::option::Option::Some(EResponse::eResponse_MissingLeague),
                "eResponse_MissingEvent" => ::std::option::Option::Some(EResponse::eResponse_MissingEvent),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::eResponse_Success,
            EResponse::eResponse_OfferingDisabled,
            EResponse::eResponse_InvalidItems,
            EResponse::eResponse_InternalError,
            EResponse::eResponse_MissingLeague,
            EResponse::eResponse_MissingEvent,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::eResponse_Success
        }
    }

}

// @@protoc_insertion_point(message:CMsgProcessTransactionOrder)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgProcessTransactionOrder {
    // message fields
    // @@protoc_insertion_point(field:CMsgProcessTransactionOrder.txn_id)
    pub txn_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProcessTransactionOrder.steam_txn_id)
    pub steam_txn_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProcessTransactionOrder.partner_txn_id)
    pub partner_txn_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProcessTransactionOrder.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProcessTransactionOrder.time_stamp)
    pub time_stamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProcessTransactionOrder.watermark)
    pub watermark: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProcessTransactionOrder.purchase_report_status)
    pub purchase_report_status: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgProcessTransactionOrder.currency)
    pub currency: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProcessTransactionOrder.items)
    pub items: ::std::vec::Vec<cmsg_process_transaction_order::Item>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgProcessTransactionOrder.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgProcessTransactionOrder {
    fn default() -> &'a CMsgProcessTransactionOrder {
        <CMsgProcessTransactionOrder as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgProcessTransactionOrder {
    pub fn new() -> CMsgProcessTransactionOrder {
        ::std::default::Default::default()
    }

    // optional uint64 txn_id = 1;

    pub fn txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }

    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }

    // optional uint64 steam_txn_id = 2;

    pub fn steam_txn_id(&self) -> u64 {
        self.steam_txn_id.unwrap_or(0)
    }

    pub fn clear_steam_txn_id(&mut self) {
        self.steam_txn_id = ::std::option::Option::None;
    }

    pub fn has_steam_txn_id(&self) -> bool {
        self.steam_txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_txn_id(&mut self, v: u64) {
        self.steam_txn_id = ::std::option::Option::Some(v);
    }

    // optional uint64 partner_txn_id = 3;

    pub fn partner_txn_id(&self) -> u64 {
        self.partner_txn_id.unwrap_or(0)
    }

    pub fn clear_partner_txn_id(&mut self) {
        self.partner_txn_id = ::std::option::Option::None;
    }

    pub fn has_partner_txn_id(&self) -> bool {
        self.partner_txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partner_txn_id(&mut self, v: u64) {
        self.partner_txn_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id = 4;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_stamp = 5;

    pub fn time_stamp(&self) -> u32 {
        self.time_stamp.unwrap_or(0)
    }

    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = ::std::option::Option::None;
    }

    pub fn has_time_stamp(&self) -> bool {
        self.time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: u32) {
        self.time_stamp = ::std::option::Option::Some(v);
    }

    // optional uint64 watermark = 6;

    pub fn watermark(&self) -> u64 {
        self.watermark.unwrap_or(0)
    }

    pub fn clear_watermark(&mut self) {
        self.watermark = ::std::option::Option::None;
    }

    pub fn has_watermark(&self) -> bool {
        self.watermark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watermark(&mut self, v: u64) {
        self.watermark = ::std::option::Option::Some(v);
    }

    // optional int32 purchase_report_status = 7;

    pub fn purchase_report_status(&self) -> i32 {
        self.purchase_report_status.unwrap_or(0)
    }

    pub fn clear_purchase_report_status(&mut self) {
        self.purchase_report_status = ::std::option::Option::None;
    }

    pub fn has_purchase_report_status(&self) -> bool {
        self.purchase_report_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_report_status(&mut self, v: i32) {
        self.purchase_report_status = ::std::option::Option::Some(v);
    }

    // optional uint32 currency = 8;

    pub fn currency(&self) -> u32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: u32) {
        self.currency = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgProcessTransactionOrder {
    const NAME: &'static str = "CMsgProcessTransactionOrder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.steam_txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.partner_txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                33 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                40 => {
                    self.time_stamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.watermark = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.purchase_report_status = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.txn_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steam_txn_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.partner_txn_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.time_stamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.watermark {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.purchase_report_status {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.currency {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.txn_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steam_txn_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.partner_txn_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.steam_id {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.time_stamp {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.watermark {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.purchase_report_status {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.currency {
            os.write_uint32(8, v)?;
        }
        for v in &self.items {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgProcessTransactionOrder {
        CMsgProcessTransactionOrder::new()
    }

    fn clear(&mut self) {
        self.txn_id = ::std::option::Option::None;
        self.steam_txn_id = ::std::option::Option::None;
        self.partner_txn_id = ::std::option::Option::None;
        self.steam_id = ::std::option::Option::None;
        self.time_stamp = ::std::option::Option::None;
        self.watermark = ::std::option::Option::None;
        self.purchase_report_status = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgProcessTransactionOrder {
        static instance: CMsgProcessTransactionOrder = CMsgProcessTransactionOrder {
            txn_id: ::std::option::Option::None,
            steam_txn_id: ::std::option::Option::None,
            partner_txn_id: ::std::option::Option::None,
            steam_id: ::std::option::Option::None,
            time_stamp: ::std::option::Option::None,
            watermark: ::std::option::Option::None,
            purchase_report_status: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            items: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgProcessTransactionOrder`
pub mod cmsg_process_transaction_order {
    // @@protoc_insertion_point(message:CMsgProcessTransactionOrder.Item)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Item {
        // message fields
        // @@protoc_insertion_point(field:CMsgProcessTransactionOrder.Item.item_def_index)
        pub item_def_index: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgProcessTransactionOrder.Item.item_price)
        pub item_price: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgProcessTransactionOrder.Item.quantity)
        pub quantity: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgProcessTransactionOrder.Item.category_desc)
        pub category_desc: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgProcessTransactionOrder.Item.store_purchase_type)
        pub store_purchase_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgProcessTransactionOrder.Item.source_reference_id)
        pub source_reference_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgProcessTransactionOrder.Item.parent_stack_index)
        pub parent_stack_index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgProcessTransactionOrder.Item.default_price)
        pub default_price: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgProcessTransactionOrder.Item.is_user_facing)
        pub is_user_facing: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgProcessTransactionOrder.Item.price_index)
        pub price_index: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgProcessTransactionOrder.Item.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Item {
        fn default() -> &'a Item {
            <Item as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Item {
        pub fn new() -> Item {
            ::std::default::Default::default()
        }

        // optional uint32 item_def_index = 1;

        pub fn item_def_index(&self) -> u32 {
            self.item_def_index.unwrap_or(0)
        }

        pub fn clear_item_def_index(&mut self) {
            self.item_def_index = ::std::option::Option::None;
        }

        pub fn has_item_def_index(&self) -> bool {
            self.item_def_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_def_index(&mut self, v: u32) {
            self.item_def_index = ::std::option::Option::Some(v);
        }

        // optional uint32 item_price = 2;

        pub fn item_price(&self) -> u32 {
            self.item_price.unwrap_or(0)
        }

        pub fn clear_item_price(&mut self) {
            self.item_price = ::std::option::Option::None;
        }

        pub fn has_item_price(&self) -> bool {
            self.item_price.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_price(&mut self, v: u32) {
            self.item_price = ::std::option::Option::Some(v);
        }

        // optional uint32 quantity = 3;

        pub fn quantity(&self) -> u32 {
            self.quantity.unwrap_or(0)
        }

        pub fn clear_quantity(&mut self) {
            self.quantity = ::std::option::Option::None;
        }

        pub fn has_quantity(&self) -> bool {
            self.quantity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quantity(&mut self, v: u32) {
            self.quantity = ::std::option::Option::Some(v);
        }

        // optional string category_desc = 4;

        pub fn category_desc(&self) -> &str {
            match self.category_desc.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_category_desc(&mut self) {
            self.category_desc = ::std::option::Option::None;
        }

        pub fn has_category_desc(&self) -> bool {
            self.category_desc.is_some()
        }

        // Param is passed by value, moved
        pub fn set_category_desc(&mut self, v: ::std::string::String) {
            self.category_desc = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_category_desc(&mut self) -> &mut ::std::string::String {
            if self.category_desc.is_none() {
                self.category_desc = ::std::option::Option::Some(::std::string::String::new());
            }
            self.category_desc.as_mut().unwrap()
        }

        // Take field
        pub fn take_category_desc(&mut self) -> ::std::string::String {
            self.category_desc.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 store_purchase_type = 5;

        pub fn store_purchase_type(&self) -> u32 {
            self.store_purchase_type.unwrap_or(0)
        }

        pub fn clear_store_purchase_type(&mut self) {
            self.store_purchase_type = ::std::option::Option::None;
        }

        pub fn has_store_purchase_type(&self) -> bool {
            self.store_purchase_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_store_purchase_type(&mut self, v: u32) {
            self.store_purchase_type = ::std::option::Option::Some(v);
        }

        // optional uint64 source_reference_id = 6;

        pub fn source_reference_id(&self) -> u64 {
            self.source_reference_id.unwrap_or(0)
        }

        pub fn clear_source_reference_id(&mut self) {
            self.source_reference_id = ::std::option::Option::None;
        }

        pub fn has_source_reference_id(&self) -> bool {
            self.source_reference_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_reference_id(&mut self, v: u64) {
            self.source_reference_id = ::std::option::Option::Some(v);
        }

        // optional int32 parent_stack_index = 7;

        pub fn parent_stack_index(&self) -> i32 {
            self.parent_stack_index.unwrap_or(0)
        }

        pub fn clear_parent_stack_index(&mut self) {
            self.parent_stack_index = ::std::option::Option::None;
        }

        pub fn has_parent_stack_index(&self) -> bool {
            self.parent_stack_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_parent_stack_index(&mut self, v: i32) {
            self.parent_stack_index = ::std::option::Option::Some(v);
        }

        // optional bool default_price = 8;

        pub fn default_price(&self) -> bool {
            self.default_price.unwrap_or(false)
        }

        pub fn clear_default_price(&mut self) {
            self.default_price = ::std::option::Option::None;
        }

        pub fn has_default_price(&self) -> bool {
            self.default_price.is_some()
        }

        // Param is passed by value, moved
        pub fn set_default_price(&mut self, v: bool) {
            self.default_price = ::std::option::Option::Some(v);
        }

        // optional bool is_user_facing = 9;

        pub fn is_user_facing(&self) -> bool {
            self.is_user_facing.unwrap_or(false)
        }

        pub fn clear_is_user_facing(&mut self) {
            self.is_user_facing = ::std::option::Option::None;
        }

        pub fn has_is_user_facing(&self) -> bool {
            self.is_user_facing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_user_facing(&mut self, v: bool) {
            self.is_user_facing = ::std::option::Option::Some(v);
        }

        // optional int32 price_index = 11;

        pub fn price_index(&self) -> i32 {
            self.price_index.unwrap_or(0)
        }

        pub fn clear_price_index(&mut self) {
            self.price_index = ::std::option::Option::None;
        }

        pub fn has_price_index(&self) -> bool {
            self.price_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_price_index(&mut self, v: i32) {
            self.price_index = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Item {
        const NAME: &'static str = "Item";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.item_price = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.category_desc = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.store_purchase_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.source_reference_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    56 => {
                        self.parent_stack_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.default_price = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.is_user_facing = ::std::option::Option::Some(is.read_bool()?);
                    },
                    88 => {
                        self.price_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_def_index {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.item_price {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.quantity {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.category_desc.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.store_purchase_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.source_reference_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(6, v);
            }
            if let Some(v) = self.parent_stack_index {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.default_price {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_user_facing {
                my_size += 1 + 1;
            }
            if let Some(v) = self.price_index {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(11, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item_def_index {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.item_price {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.quantity {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.category_desc.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.store_purchase_type {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.source_reference_id {
                os.write_uint64(6, v)?;
            }
            if let Some(v) = self.parent_stack_index {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.default_price {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.is_user_facing {
                os.write_bool(9, v)?;
            }
            if let Some(v) = self.price_index {
                os.write_int32(11, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Item {
            Item::new()
        }

        fn clear(&mut self) {
            self.item_def_index = ::std::option::Option::None;
            self.item_price = ::std::option::Option::None;
            self.quantity = ::std::option::Option::None;
            self.category_desc = ::std::option::Option::None;
            self.store_purchase_type = ::std::option::Option::None;
            self.source_reference_id = ::std::option::Option::None;
            self.parent_stack_index = ::std::option::Option::None;
            self.default_price = ::std::option::Option::None;
            self.is_user_facing = ::std::option::Option::None;
            self.price_index = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Item {
            static instance: Item = Item {
                item_def_index: ::std::option::Option::None,
                item_price: ::std::option::Option::None,
                quantity: ::std::option::Option::None,
                category_desc: ::std::option::Option::None,
                store_purchase_type: ::std::option::Option::None,
                source_reference_id: ::std::option::Option::None,
                parent_stack_index: ::std::option::Option::None,
                default_price: ::std::option::Option::None,
                is_user_facing: ::std::option::Option::None,
                price_index: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCStoreProcessCDKeyTransaction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCStoreProcessCDKeyTransaction {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCStoreProcessCDKeyTransaction.order)
    pub order: ::steam_vent_proto_common::protobuf::MessageField<CMsgProcessTransactionOrder>,
    // @@protoc_insertion_point(field:CMsgGCToGCStoreProcessCDKeyTransaction.reason_code)
    pub reason_code: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCStoreProcessCDKeyTransaction.partner)
    pub partner: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCStoreProcessCDKeyTransaction.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCStoreProcessCDKeyTransaction {
    fn default() -> &'a CMsgGCToGCStoreProcessCDKeyTransaction {
        <CMsgGCToGCStoreProcessCDKeyTransaction as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCStoreProcessCDKeyTransaction {
    pub fn new() -> CMsgGCToGCStoreProcessCDKeyTransaction {
        ::std::default::Default::default()
    }

    // optional uint32 reason_code = 2;

    pub fn reason_code(&self) -> u32 {
        self.reason_code.unwrap_or(0)
    }

    pub fn clear_reason_code(&mut self) {
        self.reason_code = ::std::option::Option::None;
    }

    pub fn has_reason_code(&self) -> bool {
        self.reason_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason_code(&mut self, v: u32) {
        self.reason_code = ::std::option::Option::Some(v);
    }

    // optional uint32 partner = 3;

    pub fn partner(&self) -> u32 {
        self.partner.unwrap_or(0)
    }

    pub fn clear_partner(&mut self) {
        self.partner = ::std::option::Option::None;
    }

    pub fn has_partner(&self) -> bool {
        self.partner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partner(&mut self, v: u32) {
        self.partner = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCStoreProcessCDKeyTransaction {
    const NAME: &'static str = "CMsgGCToGCStoreProcessCDKeyTransaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.order)?;
                },
                16 => {
                    self.reason_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.partner = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason_code {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.partner {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.order.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.reason_code {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.partner {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCStoreProcessCDKeyTransaction {
        CMsgGCToGCStoreProcessCDKeyTransaction::new()
    }

    fn clear(&mut self) {
        self.order.clear();
        self.reason_code = ::std::option::Option::None;
        self.partner = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCStoreProcessCDKeyTransaction {
        static instance: CMsgGCToGCStoreProcessCDKeyTransaction = CMsgGCToGCStoreProcessCDKeyTransaction {
            order: ::steam_vent_proto_common::protobuf::MessageField::none(),
            reason_code: ::std::option::Option::None,
            partner: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCStoreProcessCDKeyTransactionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCStoreProcessCDKeyTransactionResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCStoreProcessCDKeyTransactionResponse.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCStoreProcessCDKeyTransactionResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCStoreProcessCDKeyTransactionResponse {
    fn default() -> &'a CMsgGCToGCStoreProcessCDKeyTransactionResponse {
        <CMsgGCToGCStoreProcessCDKeyTransactionResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCStoreProcessCDKeyTransactionResponse {
    pub fn new() -> CMsgGCToGCStoreProcessCDKeyTransactionResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCStoreProcessCDKeyTransactionResponse {
    const NAME: &'static str = "CMsgGCToGCStoreProcessCDKeyTransactionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCStoreProcessCDKeyTransactionResponse {
        CMsgGCToGCStoreProcessCDKeyTransactionResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCStoreProcessCDKeyTransactionResponse {
        static instance: CMsgGCToGCStoreProcessCDKeyTransactionResponse = CMsgGCToGCStoreProcessCDKeyTransactionResponse {
            success: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCStoreProcessSettlement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCStoreProcessSettlement {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCStoreProcessSettlement.order)
    pub order: ::steam_vent_proto_common::protobuf::MessageField<CMsgProcessTransactionOrder>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCStoreProcessSettlement.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCStoreProcessSettlement {
    fn default() -> &'a CMsgGCToGCStoreProcessSettlement {
        <CMsgGCToGCStoreProcessSettlement as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCStoreProcessSettlement {
    pub fn new() -> CMsgGCToGCStoreProcessSettlement {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCStoreProcessSettlement {
    const NAME: &'static str = "CMsgGCToGCStoreProcessSettlement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.order)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.order.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCStoreProcessSettlement {
        CMsgGCToGCStoreProcessSettlement::new()
    }

    fn clear(&mut self) {
        self.order.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCStoreProcessSettlement {
        static instance: CMsgGCToGCStoreProcessSettlement = CMsgGCToGCStoreProcessSettlement {
            order: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCStoreProcessSettlementResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCStoreProcessSettlementResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCStoreProcessSettlementResponse.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCStoreProcessSettlementResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCStoreProcessSettlementResponse {
    fn default() -> &'a CMsgGCToGCStoreProcessSettlementResponse {
        <CMsgGCToGCStoreProcessSettlementResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCStoreProcessSettlementResponse {
    pub fn new() -> CMsgGCToGCStoreProcessSettlementResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCStoreProcessSettlementResponse {
    const NAME: &'static str = "CMsgGCToGCStoreProcessSettlementResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCStoreProcessSettlementResponse {
        CMsgGCToGCStoreProcessSettlementResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCStoreProcessSettlementResponse {
        static instance: CMsgGCToGCStoreProcessSettlementResponse = CMsgGCToGCStoreProcessSettlementResponse {
            success: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCBroadcastConsoleCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCBroadcastConsoleCommand {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCBroadcastConsoleCommand.con_command)
    pub con_command: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCToGCBroadcastConsoleCommand.report_output)
    pub report_output: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCToGCBroadcastConsoleCommand.sending_gc)
    pub sending_gc: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCToGCBroadcastConsoleCommand.output_initiator)
    pub output_initiator: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCBroadcastConsoleCommand.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCBroadcastConsoleCommand {
    fn default() -> &'a CMsgGCToGCBroadcastConsoleCommand {
        <CMsgGCToGCBroadcastConsoleCommand as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCBroadcastConsoleCommand {
    pub fn new() -> CMsgGCToGCBroadcastConsoleCommand {
        ::std::default::Default::default()
    }

    // optional string con_command = 1;

    pub fn con_command(&self) -> &str {
        match self.con_command.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_con_command(&mut self) {
        self.con_command = ::std::option::Option::None;
    }

    pub fn has_con_command(&self) -> bool {
        self.con_command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_con_command(&mut self, v: ::std::string::String) {
        self.con_command = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_con_command(&mut self) -> &mut ::std::string::String {
        if self.con_command.is_none() {
            self.con_command = ::std::option::Option::Some(::std::string::String::new());
        }
        self.con_command.as_mut().unwrap()
    }

    // Take field
    pub fn take_con_command(&mut self) -> ::std::string::String {
        self.con_command.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool report_output = 2;

    pub fn report_output(&self) -> bool {
        self.report_output.unwrap_or(false)
    }

    pub fn clear_report_output(&mut self) {
        self.report_output = ::std::option::Option::None;
    }

    pub fn has_report_output(&self) -> bool {
        self.report_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_output(&mut self, v: bool) {
        self.report_output = ::std::option::Option::Some(v);
    }

    // optional int32 sending_gc = 3;

    pub fn sending_gc(&self) -> i32 {
        self.sending_gc.unwrap_or(-1i32)
    }

    pub fn clear_sending_gc(&mut self) {
        self.sending_gc = ::std::option::Option::None;
    }

    pub fn has_sending_gc(&self) -> bool {
        self.sending_gc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sending_gc(&mut self, v: i32) {
        self.sending_gc = ::std::option::Option::Some(v);
    }

    // optional string output_initiator = 4;

    pub fn output_initiator(&self) -> &str {
        match self.output_initiator.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_output_initiator(&mut self) {
        self.output_initiator = ::std::option::Option::None;
    }

    pub fn has_output_initiator(&self) -> bool {
        self.output_initiator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_initiator(&mut self, v: ::std::string::String) {
        self.output_initiator = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_initiator(&mut self) -> &mut ::std::string::String {
        if self.output_initiator.is_none() {
            self.output_initiator = ::std::option::Option::Some(::std::string::String::new());
        }
        self.output_initiator.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_initiator(&mut self) -> ::std::string::String {
        self.output_initiator.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCBroadcastConsoleCommand {
    const NAME: &'static str = "CMsgGCToGCBroadcastConsoleCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.con_command = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.report_output = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.sending_gc = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.output_initiator = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.con_command.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.report_output {
            my_size += 1 + 1;
        }
        if let Some(v) = self.sending_gc {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.output_initiator.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.con_command.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.report_output {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.sending_gc {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.output_initiator.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCBroadcastConsoleCommand {
        CMsgGCToGCBroadcastConsoleCommand::new()
    }

    fn clear(&mut self) {
        self.con_command = ::std::option::Option::None;
        self.report_output = ::std::option::Option::None;
        self.sending_gc = ::std::option::Option::None;
        self.output_initiator = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCBroadcastConsoleCommand {
        static instance: CMsgGCToGCBroadcastConsoleCommand = CMsgGCToGCBroadcastConsoleCommand {
            con_command: ::std::option::Option::None,
            report_output: ::std::option::Option::None,
            sending_gc: ::std::option::Option::None,
            output_initiator: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCConsoleOutput)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCConsoleOutput {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCConsoleOutput.initiator)
    pub initiator: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCToGCConsoleOutput.sending_gc)
    pub sending_gc: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCToGCConsoleOutput.msgs)
    pub msgs: ::std::vec::Vec<cmsg_gcto_gcconsole_output::OutputLine>,
    // @@protoc_insertion_point(field:CMsgGCToGCConsoleOutput.is_last_for_source_job)
    pub is_last_for_source_job: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCConsoleOutput.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCConsoleOutput {
    fn default() -> &'a CMsgGCToGCConsoleOutput {
        <CMsgGCToGCConsoleOutput as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCConsoleOutput {
    pub fn new() -> CMsgGCToGCConsoleOutput {
        ::std::default::Default::default()
    }

    // optional string initiator = 1;

    pub fn initiator(&self) -> &str {
        match self.initiator.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_initiator(&mut self) {
        self.initiator = ::std::option::Option::None;
    }

    pub fn has_initiator(&self) -> bool {
        self.initiator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator(&mut self, v: ::std::string::String) {
        self.initiator = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initiator(&mut self) -> &mut ::std::string::String {
        if self.initiator.is_none() {
            self.initiator = ::std::option::Option::Some(::std::string::String::new());
        }
        self.initiator.as_mut().unwrap()
    }

    // Take field
    pub fn take_initiator(&mut self) -> ::std::string::String {
        self.initiator.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 sending_gc = 2;

    pub fn sending_gc(&self) -> i32 {
        self.sending_gc.unwrap_or(-1i32)
    }

    pub fn clear_sending_gc(&mut self) {
        self.sending_gc = ::std::option::Option::None;
    }

    pub fn has_sending_gc(&self) -> bool {
        self.sending_gc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sending_gc(&mut self, v: i32) {
        self.sending_gc = ::std::option::Option::Some(v);
    }

    // optional bool is_last_for_source_job = 4;

    pub fn is_last_for_source_job(&self) -> bool {
        self.is_last_for_source_job.unwrap_or(false)
    }

    pub fn clear_is_last_for_source_job(&mut self) {
        self.is_last_for_source_job = ::std::option::Option::None;
    }

    pub fn has_is_last_for_source_job(&self) -> bool {
        self.is_last_for_source_job.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_last_for_source_job(&mut self, v: bool) {
        self.is_last_for_source_job = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCConsoleOutput {
    const NAME: &'static str = "CMsgGCToGCConsoleOutput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.initiator = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.sending_gc = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.msgs.push(is.read_message()?);
                },
                32 => {
                    self.is_last_for_source_job = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.initiator.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.sending_gc {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        for value in &self.msgs {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_last_for_source_job {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.initiator.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.sending_gc {
            os.write_int32(2, v)?;
        }
        for v in &self.msgs {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.is_last_for_source_job {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCConsoleOutput {
        CMsgGCToGCConsoleOutput::new()
    }

    fn clear(&mut self) {
        self.initiator = ::std::option::Option::None;
        self.sending_gc = ::std::option::Option::None;
        self.msgs.clear();
        self.is_last_for_source_job = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCConsoleOutput {
        static instance: CMsgGCToGCConsoleOutput = CMsgGCToGCConsoleOutput {
            initiator: ::std::option::Option::None,
            sending_gc: ::std::option::Option::None,
            msgs: ::std::vec::Vec::new(),
            is_last_for_source_job: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToGCConsoleOutput`
pub mod cmsg_gcto_gcconsole_output {
    // @@protoc_insertion_point(message:CMsgGCToGCConsoleOutput.OutputLine)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct OutputLine {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToGCConsoleOutput.OutputLine.text)
        pub text: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGCToGCConsoleOutput.OutputLine.spew_level)
        pub spew_level: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToGCConsoleOutput.OutputLine.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a OutputLine {
        fn default() -> &'a OutputLine {
            <OutputLine as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl OutputLine {
        pub fn new() -> OutputLine {
            ::std::default::Default::default()
        }

        // optional string text = 1;

        pub fn text(&self) -> &str {
            match self.text.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_text(&mut self) {
            self.text = ::std::option::Option::None;
        }

        pub fn has_text(&self) -> bool {
            self.text.is_some()
        }

        // Param is passed by value, moved
        pub fn set_text(&mut self, v: ::std::string::String) {
            self.text = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_text(&mut self) -> &mut ::std::string::String {
            if self.text.is_none() {
                self.text = ::std::option::Option::Some(::std::string::String::new());
            }
            self.text.as_mut().unwrap()
        }

        // Take field
        pub fn take_text(&mut self) -> ::std::string::String {
            self.text.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 spew_level = 2;

        pub fn spew_level(&self) -> u32 {
            self.spew_level.unwrap_or(0)
        }

        pub fn clear_spew_level(&mut self) {
            self.spew_level = ::std::option::Option::None;
        }

        pub fn has_spew_level(&self) -> bool {
            self.spew_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_spew_level(&mut self, v: u32) {
            self.spew_level = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for OutputLine {
        const NAME: &'static str = "OutputLine";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.text = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.spew_level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.text.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.spew_level {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.text.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.spew_level {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> OutputLine {
            OutputLine::new()
        }

        fn clear(&mut self) {
            self.text = ::std::option::Option::None;
            self.spew_level = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static OutputLine {
            static instance: OutputLine = OutputLine {
                text: ::std::option::Option::None,
                spew_level: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgItemAges)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgItemAges {
    // message fields
    // @@protoc_insertion_point(field:CMsgItemAges.max_item_id_timestamps)
    pub max_item_id_timestamps: ::std::vec::Vec<cmsg_item_ages::MaxItemIDTimestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgItemAges.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgItemAges {
    fn default() -> &'a CMsgItemAges {
        <CMsgItemAges as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgItemAges {
    pub fn new() -> CMsgItemAges {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgItemAges {
    const NAME: &'static str = "CMsgItemAges";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.max_item_id_timestamps.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.max_item_id_timestamps {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.max_item_id_timestamps {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgItemAges {
        CMsgItemAges::new()
    }

    fn clear(&mut self) {
        self.max_item_id_timestamps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgItemAges {
        static instance: CMsgItemAges = CMsgItemAges {
            max_item_id_timestamps: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgItemAges`
pub mod cmsg_item_ages {
    // @@protoc_insertion_point(message:CMsgItemAges.MaxItemIDTimestamp)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MaxItemIDTimestamp {
        // message fields
        // @@protoc_insertion_point(field:CMsgItemAges.MaxItemIDTimestamp.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgItemAges.MaxItemIDTimestamp.max_item_id)
        pub max_item_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgItemAges.MaxItemIDTimestamp.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MaxItemIDTimestamp {
        fn default() -> &'a MaxItemIDTimestamp {
            <MaxItemIDTimestamp as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl MaxItemIDTimestamp {
        pub fn new() -> MaxItemIDTimestamp {
            ::std::default::Default::default()
        }

        // optional uint32 timestamp = 1;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional uint64 max_item_id = 2;

        pub fn max_item_id(&self) -> u64 {
            self.max_item_id.unwrap_or(0)
        }

        pub fn clear_max_item_id(&mut self) {
            self.max_item_id = ::std::option::Option::None;
        }

        pub fn has_max_item_id(&self) -> bool {
            self.max_item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max_item_id(&mut self, v: u64) {
            self.max_item_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for MaxItemIDTimestamp {
        const NAME: &'static str = "MaxItemIDTimestamp";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.max_item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.max_item_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.timestamp {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.max_item_id {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MaxItemIDTimestamp {
            MaxItemIDTimestamp::new()
        }

        fn clear(&mut self) {
            self.timestamp = ::std::option::Option::None;
            self.max_item_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MaxItemIDTimestamp {
            static instance: MaxItemIDTimestamp = MaxItemIDTimestamp {
                timestamp: ::std::option::Option::None,
                max_item_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCInternalTestMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCInternalTestMsg {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCInternalTestMsg.sending_gc)
    pub sending_gc: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCToGCInternalTestMsg.sender_id)
    pub sender_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToGCInternalTestMsg.context)
    pub context: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCInternalTestMsg.message_id)
    pub message_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCInternalTestMsg.message_body)
    pub message_body: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGCToGCInternalTestMsg.job_id_source)
    pub job_id_source: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToGCInternalTestMsg.job_id_target)
    pub job_id_target: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCInternalTestMsg.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCInternalTestMsg {
    fn default() -> &'a CMsgGCToGCInternalTestMsg {
        <CMsgGCToGCInternalTestMsg as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCInternalTestMsg {
    pub fn new() -> CMsgGCToGCInternalTestMsg {
        ::std::default::Default::default()
    }

    // optional int32 sending_gc = 1;

    pub fn sending_gc(&self) -> i32 {
        self.sending_gc.unwrap_or(-1i32)
    }

    pub fn clear_sending_gc(&mut self) {
        self.sending_gc = ::std::option::Option::None;
    }

    pub fn has_sending_gc(&self) -> bool {
        self.sending_gc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sending_gc(&mut self, v: i32) {
        self.sending_gc = ::std::option::Option::Some(v);
    }

    // optional fixed64 sender_id = 2;

    pub fn sender_id(&self) -> u64 {
        self.sender_id.unwrap_or(0)
    }

    pub fn clear_sender_id(&mut self) {
        self.sender_id = ::std::option::Option::None;
    }

    pub fn has_sender_id(&self) -> bool {
        self.sender_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_id(&mut self, v: u64) {
        self.sender_id = ::std::option::Option::Some(v);
    }

    // optional uint32 context = 3;

    pub fn context(&self) -> u32 {
        self.context.unwrap_or(0)
    }

    pub fn clear_context(&mut self) {
        self.context = ::std::option::Option::None;
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: u32) {
        self.context = ::std::option::Option::Some(v);
    }

    // optional uint32 message_id = 4;

    pub fn message_id(&self) -> u32 {
        self.message_id.unwrap_or(0)
    }

    pub fn clear_message_id(&mut self) {
        self.message_id = ::std::option::Option::None;
    }

    pub fn has_message_id(&self) -> bool {
        self.message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: u32) {
        self.message_id = ::std::option::Option::Some(v);
    }

    // optional bytes message_body = 5;

    pub fn message_body(&self) -> &[u8] {
        match self.message_body.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_message_body(&mut self) {
        self.message_body = ::std::option::Option::None;
    }

    pub fn has_message_body(&self) -> bool {
        self.message_body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.message_body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message_body.is_none() {
            self.message_body = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.message_body.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_body(&mut self) -> ::std::vec::Vec<u8> {
        self.message_body.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 job_id_source = 6;

    pub fn job_id_source(&self) -> u64 {
        self.job_id_source.unwrap_or(0)
    }

    pub fn clear_job_id_source(&mut self) {
        self.job_id_source = ::std::option::Option::None;
    }

    pub fn has_job_id_source(&self) -> bool {
        self.job_id_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job_id_source(&mut self, v: u64) {
        self.job_id_source = ::std::option::Option::Some(v);
    }

    // optional fixed64 job_id_target = 7;

    pub fn job_id_target(&self) -> u64 {
        self.job_id_target.unwrap_or(0)
    }

    pub fn clear_job_id_target(&mut self) {
        self.job_id_target = ::std::option::Option::None;
    }

    pub fn has_job_id_target(&self) -> bool {
        self.job_id_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job_id_target(&mut self, v: u64) {
        self.job_id_target = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCInternalTestMsg {
    const NAME: &'static str = "CMsgGCToGCInternalTestMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sending_gc = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.sender_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.context = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.message_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.message_body = ::std::option::Option::Some(is.read_bytes()?);
                },
                49 => {
                    self.job_id_source = ::std::option::Option::Some(is.read_fixed64()?);
                },
                57 => {
                    self.job_id_target = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sending_gc {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.sender_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.context {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.message_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.message_body.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.job_id_source {
            my_size += 1 + 8;
        }
        if let Some(v) = self.job_id_target {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.sending_gc {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.sender_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.context {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.message_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.message_body.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.job_id_source {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.job_id_target {
            os.write_fixed64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCInternalTestMsg {
        CMsgGCToGCInternalTestMsg::new()
    }

    fn clear(&mut self) {
        self.sending_gc = ::std::option::Option::None;
        self.sender_id = ::std::option::Option::None;
        self.context = ::std::option::Option::None;
        self.message_id = ::std::option::Option::None;
        self.message_body = ::std::option::Option::None;
        self.job_id_source = ::std::option::Option::None;
        self.job_id_target = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCInternalTestMsg {
        static instance: CMsgGCToGCInternalTestMsg = CMsgGCToGCInternalTestMsg {
            sending_gc: ::std::option::Option::None,
            sender_id: ::std::option::Option::None,
            context: ::std::option::Option::None,
            message_id: ::std::option::Option::None,
            message_body: ::std::option::Option::None,
            job_id_source: ::std::option::Option::None,
            job_id_target: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCClientServerVersionsUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCClientServerVersionsUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCClientServerVersionsUpdated.client_min_allowed_version)
    pub client_min_allowed_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCClientServerVersionsUpdated.client_active_version)
    pub client_active_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCClientServerVersionsUpdated.server_active_version)
    pub server_active_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCClientServerVersionsUpdated.server_deployed_version)
    pub server_deployed_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCClientServerVersionsUpdated.what_changed)
    pub what_changed: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCClientServerVersionsUpdated.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCClientServerVersionsUpdated {
    fn default() -> &'a CMsgGCToGCClientServerVersionsUpdated {
        <CMsgGCToGCClientServerVersionsUpdated as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCClientServerVersionsUpdated {
    pub fn new() -> CMsgGCToGCClientServerVersionsUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 client_min_allowed_version = 1;

    pub fn client_min_allowed_version(&self) -> u32 {
        self.client_min_allowed_version.unwrap_or(0)
    }

    pub fn clear_client_min_allowed_version(&mut self) {
        self.client_min_allowed_version = ::std::option::Option::None;
    }

    pub fn has_client_min_allowed_version(&self) -> bool {
        self.client_min_allowed_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_min_allowed_version(&mut self, v: u32) {
        self.client_min_allowed_version = ::std::option::Option::Some(v);
    }

    // optional uint32 client_active_version = 2;

    pub fn client_active_version(&self) -> u32 {
        self.client_active_version.unwrap_or(0)
    }

    pub fn clear_client_active_version(&mut self) {
        self.client_active_version = ::std::option::Option::None;
    }

    pub fn has_client_active_version(&self) -> bool {
        self.client_active_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_active_version(&mut self, v: u32) {
        self.client_active_version = ::std::option::Option::Some(v);
    }

    // optional uint32 server_active_version = 3;

    pub fn server_active_version(&self) -> u32 {
        self.server_active_version.unwrap_or(0)
    }

    pub fn clear_server_active_version(&mut self) {
        self.server_active_version = ::std::option::Option::None;
    }

    pub fn has_server_active_version(&self) -> bool {
        self.server_active_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_active_version(&mut self, v: u32) {
        self.server_active_version = ::std::option::Option::Some(v);
    }

    // optional uint32 server_deployed_version = 4;

    pub fn server_deployed_version(&self) -> u32 {
        self.server_deployed_version.unwrap_or(0)
    }

    pub fn clear_server_deployed_version(&mut self) {
        self.server_deployed_version = ::std::option::Option::None;
    }

    pub fn has_server_deployed_version(&self) -> bool {
        self.server_deployed_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_deployed_version(&mut self, v: u32) {
        self.server_deployed_version = ::std::option::Option::Some(v);
    }

    // optional uint32 what_changed = 5;

    pub fn what_changed(&self) -> u32 {
        self.what_changed.unwrap_or(0)
    }

    pub fn clear_what_changed(&mut self) {
        self.what_changed = ::std::option::Option::None;
    }

    pub fn has_what_changed(&self) -> bool {
        self.what_changed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_what_changed(&mut self, v: u32) {
        self.what_changed = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCClientServerVersionsUpdated {
    const NAME: &'static str = "CMsgGCToGCClientServerVersionsUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.client_min_allowed_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.client_active_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.server_active_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.server_deployed_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.what_changed = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_min_allowed_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.client_active_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.server_active_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.server_deployed_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.what_changed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.client_min_allowed_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.client_active_version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.server_active_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.server_deployed_version {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.what_changed {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCClientServerVersionsUpdated {
        CMsgGCToGCClientServerVersionsUpdated::new()
    }

    fn clear(&mut self) {
        self.client_min_allowed_version = ::std::option::Option::None;
        self.client_active_version = ::std::option::Option::None;
        self.server_active_version = ::std::option::Option::None;
        self.server_deployed_version = ::std::option::Option::None;
        self.what_changed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCClientServerVersionsUpdated {
        static instance: CMsgGCToGCClientServerVersionsUpdated = CMsgGCToGCClientServerVersionsUpdated {
            client_min_allowed_version: ::std::option::Option::None,
            client_active_version: ::std::option::Option::None,
            server_active_version: ::std::option::Option::None,
            server_deployed_version: ::std::option::Option::None,
            what_changed: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCBroadcastMessageFromSub)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCBroadcastMessageFromSub {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCBroadcastMessageFromSub.msg_id)
    pub msg_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCBroadcastMessageFromSub.serialized_msg)
    pub serialized_msg: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGCToGCBroadcastMessageFromSub.account_id_list)
    pub account_id_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCBroadcastMessageFromSub.steam_id_list)
    pub steam_id_list: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCBroadcastMessageFromSub.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCBroadcastMessageFromSub {
    fn default() -> &'a CMsgGCToGCBroadcastMessageFromSub {
        <CMsgGCToGCBroadcastMessageFromSub as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCBroadcastMessageFromSub {
    pub fn new() -> CMsgGCToGCBroadcastMessageFromSub {
        ::std::default::Default::default()
    }

    // optional uint32 msg_id = 1;

    pub fn msg_id(&self) -> u32 {
        self.msg_id.unwrap_or(0)
    }

    pub fn clear_msg_id(&mut self) {
        self.msg_id = ::std::option::Option::None;
    }

    pub fn has_msg_id(&self) -> bool {
        self.msg_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_id(&mut self, v: u32) {
        self.msg_id = ::std::option::Option::Some(v);
    }

    // optional bytes serialized_msg = 2;

    pub fn serialized_msg(&self) -> &[u8] {
        match self.serialized_msg.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serialized_msg(&mut self) {
        self.serialized_msg = ::std::option::Option::None;
    }

    pub fn has_serialized_msg(&self) -> bool {
        self.serialized_msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_msg(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_msg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_msg(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_msg.is_none() {
            self.serialized_msg = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.serialized_msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_msg(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_msg.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCBroadcastMessageFromSub {
    const NAME: &'static str = "CMsgGCToGCBroadcastMessageFromSub";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.serialized_msg = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_id_list)?;
                },
                24 => {
                    self.account_id_list.push(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steam_id_list)?;
                },
                33 => {
                    self.steam_id_list.push(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.serialized_msg.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_uint32_size(3, &self.account_id_list);
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_fixed64_size(4, &self.steam_id_list);
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.msg_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.serialized_msg.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_repeated_packed_uint32(3, &self.account_id_list)?;
        os.write_repeated_packed_fixed64(4, &self.steam_id_list)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCBroadcastMessageFromSub {
        CMsgGCToGCBroadcastMessageFromSub::new()
    }

    fn clear(&mut self) {
        self.msg_id = ::std::option::Option::None;
        self.serialized_msg = ::std::option::Option::None;
        self.account_id_list.clear();
        self.steam_id_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCBroadcastMessageFromSub {
        static instance: CMsgGCToGCBroadcastMessageFromSub = CMsgGCToGCBroadcastMessageFromSub {
            msg_id: ::std::option::Option::None,
            serialized_msg: ::std::option::Option::None,
            account_id_list: ::std::vec::Vec::new(),
            steam_id_list: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientCurrencyPricePoints)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientCurrencyPricePoints {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientCurrencyPricePoints.price_key)
    pub price_key: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgGCToClientCurrencyPricePoints.currencies)
    pub currencies: ::std::vec::Vec<cmsg_gcto_client_currency_price_points::Currency>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientCurrencyPricePoints.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientCurrencyPricePoints {
    fn default() -> &'a CMsgGCToClientCurrencyPricePoints {
        <CMsgGCToClientCurrencyPricePoints as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientCurrencyPricePoints {
    pub fn new() -> CMsgGCToClientCurrencyPricePoints {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientCurrencyPricePoints {
    const NAME: &'static str = "CMsgGCToClientCurrencyPricePoints";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.price_key)?;
                },
                8 => {
                    self.price_key.push(is.read_uint64()?);
                },
                18 => {
                    self.currencies.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_uint64_size(1, &self.price_key);
        for value in &self.currencies {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_repeated_packed_uint64(1, &self.price_key)?;
        for v in &self.currencies {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientCurrencyPricePoints {
        CMsgGCToClientCurrencyPricePoints::new()
    }

    fn clear(&mut self) {
        self.price_key.clear();
        self.currencies.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientCurrencyPricePoints {
        static instance: CMsgGCToClientCurrencyPricePoints = CMsgGCToClientCurrencyPricePoints {
            price_key: ::std::vec::Vec::new(),
            currencies: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientCurrencyPricePoints`
pub mod cmsg_gcto_client_currency_price_points {
    // @@protoc_insertion_point(message:CMsgGCToClientCurrencyPricePoints.Currency)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Currency {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientCurrencyPricePoints.Currency.currency_id)
        pub currency_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientCurrencyPricePoints.Currency.currency_price)
        pub currency_price: ::std::vec::Vec<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientCurrencyPricePoints.Currency.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Currency {
        fn default() -> &'a Currency {
            <Currency as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Currency {
        pub fn new() -> Currency {
            ::std::default::Default::default()
        }

        // optional uint32 currency_id = 1;

        pub fn currency_id(&self) -> u32 {
            self.currency_id.unwrap_or(0)
        }

        pub fn clear_currency_id(&mut self) {
            self.currency_id = ::std::option::Option::None;
        }

        pub fn has_currency_id(&self) -> bool {
            self.currency_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_currency_id(&mut self, v: u32) {
            self.currency_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Currency {
        const NAME: &'static str = "Currency";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.currency_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        is.read_repeated_packed_uint64_into(&mut self.currency_price)?;
                    },
                    16 => {
                        self.currency_price.push(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.currency_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_uint64_size(2, &self.currency_price);
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.currency_id {
                os.write_uint32(1, v)?;
            }
            os.write_repeated_packed_uint64(2, &self.currency_price)?;
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Currency {
            Currency::new()
        }

        fn clear(&mut self) {
            self.currency_id = ::std::option::Option::None;
            self.currency_price.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Currency {
            static instance: Currency = Currency {
                currency_id: ::std::option::Option::None,
                currency_price: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgBannedWordList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBannedWordList {
    // message fields
    // @@protoc_insertion_point(field:CMsgBannedWordList.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBannedWordList.banned_words)
    pub banned_words: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBannedWordList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBannedWordList {
    fn default() -> &'a CMsgBannedWordList {
        <CMsgBannedWordList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgBannedWordList {
    pub fn new() -> CMsgBannedWordList {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgBannedWordList {
    const NAME: &'static str = "CMsgBannedWordList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.banned_words.push(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.banned_words {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        for v in &self.banned_words {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBannedWordList {
        CMsgBannedWordList::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.banned_words.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBannedWordList {
        static instance: CMsgBannedWordList = CMsgBannedWordList {
            version: ::std::option::Option::None,
            banned_words: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCFlushSteamInventoryCache)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCFlushSteamInventoryCache {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCFlushSteamInventoryCache.keys)
    pub keys: ::std::vec::Vec<cmsg_gcto_gcflush_steam_inventory_cache::Key>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCFlushSteamInventoryCache.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCFlushSteamInventoryCache {
    fn default() -> &'a CMsgGCToGCFlushSteamInventoryCache {
        <CMsgGCToGCFlushSteamInventoryCache as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCFlushSteamInventoryCache {
    pub fn new() -> CMsgGCToGCFlushSteamInventoryCache {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCFlushSteamInventoryCache {
    const NAME: &'static str = "CMsgGCToGCFlushSteamInventoryCache";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.keys.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.keys {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCFlushSteamInventoryCache {
        CMsgGCToGCFlushSteamInventoryCache::new()
    }

    fn clear(&mut self) {
        self.keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCFlushSteamInventoryCache {
        static instance: CMsgGCToGCFlushSteamInventoryCache = CMsgGCToGCFlushSteamInventoryCache {
            keys: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToGCFlushSteamInventoryCache`
pub mod cmsg_gcto_gcflush_steam_inventory_cache {
    // @@protoc_insertion_point(message:CMsgGCToGCFlushSteamInventoryCache.Key)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Key {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToGCFlushSteamInventoryCache.Key.steamid)
        pub steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgGCToGCFlushSteamInventoryCache.Key.contextid)
        pub contextid: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToGCFlushSteamInventoryCache.Key.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Key {
        fn default() -> &'a Key {
            <Key as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Key {
        pub fn new() -> Key {
            ::std::default::Default::default()
        }

        // optional uint64 steamid = 1;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        // optional uint64 contextid = 2;

        pub fn contextid(&self) -> u64 {
            self.contextid.unwrap_or(0)
        }

        pub fn clear_contextid(&mut self) {
            self.contextid = ::std::option::Option::None;
        }

        pub fn has_contextid(&self) -> bool {
            self.contextid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_contextid(&mut self, v: u64) {
            self.contextid = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Key {
        const NAME: &'static str = "Key";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.steamid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.contextid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.contextid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.steamid {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.contextid {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Key {
            Key::new()
        }

        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.contextid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Key {
            static instance: Key = Key {
                steamid: ::std::option::Option::None,
                contextid: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCUpdateSubscriptionItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCUpdateSubscriptionItems {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCUpdateSubscriptionItems.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCUpdateSubscriptionItems.always_notify)
    pub always_notify: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCUpdateSubscriptionItems.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCUpdateSubscriptionItems {
    fn default() -> &'a CMsgGCToGCUpdateSubscriptionItems {
        <CMsgGCToGCUpdateSubscriptionItems as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCUpdateSubscriptionItems {
    pub fn new() -> CMsgGCToGCUpdateSubscriptionItems {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional bool always_notify = 2;

    pub fn always_notify(&self) -> bool {
        self.always_notify.unwrap_or(false)
    }

    pub fn clear_always_notify(&mut self) {
        self.always_notify = ::std::option::Option::None;
    }

    pub fn has_always_notify(&self) -> bool {
        self.always_notify.is_some()
    }

    // Param is passed by value, moved
    pub fn set_always_notify(&mut self, v: bool) {
        self.always_notify = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCUpdateSubscriptionItems {
    const NAME: &'static str = "CMsgGCToGCUpdateSubscriptionItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.always_notify = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.always_notify {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.always_notify {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCUpdateSubscriptionItems {
        CMsgGCToGCUpdateSubscriptionItems::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.always_notify = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCUpdateSubscriptionItems {
        static instance: CMsgGCToGCUpdateSubscriptionItems = CMsgGCToGCUpdateSubscriptionItems {
            account_id: ::std::option::Option::None,
            always_notify: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCSelfPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCSelfPing {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCSelfPing.sample_id)
    pub sample_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCSelfPing.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCSelfPing {
    fn default() -> &'a CMsgGCToGCSelfPing {
        <CMsgGCToGCSelfPing as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCSelfPing {
    pub fn new() -> CMsgGCToGCSelfPing {
        ::std::default::Default::default()
    }

    // optional uint32 sample_id = 1;

    pub fn sample_id(&self) -> u32 {
        self.sample_id.unwrap_or(0)
    }

    pub fn clear_sample_id(&mut self) {
        self.sample_id = ::std::option::Option::None;
    }

    pub fn has_sample_id(&self) -> bool {
        self.sample_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sample_id(&mut self, v: u32) {
        self.sample_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCSelfPing {
    const NAME: &'static str = "CMsgGCToGCSelfPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sample_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sample_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.sample_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCSelfPing {
        CMsgGCToGCSelfPing::new()
    }

    fn clear(&mut self) {
        self.sample_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCSelfPing {
        static instance: CMsgGCToGCSelfPing = CMsgGCToGCSelfPing {
            sample_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCGetInfuxIntervalStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCGetInfuxIntervalStats {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCGetInfuxIntervalStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetInfuxIntervalStats {
    fn default() -> &'a CMsgGCToGCGetInfuxIntervalStats {
        <CMsgGCToGCGetInfuxIntervalStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetInfuxIntervalStats {
    pub fn new() -> CMsgGCToGCGetInfuxIntervalStats {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCGetInfuxIntervalStats {
    const NAME: &'static str = "CMsgGCToGCGetInfuxIntervalStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGetInfuxIntervalStats {
        CMsgGCToGCGetInfuxIntervalStats::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGetInfuxIntervalStats {
        static instance: CMsgGCToGCGetInfuxIntervalStats = CMsgGCToGCGetInfuxIntervalStats {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCGetInfuxIntervalStatsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCGetInfuxIntervalStatsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCGetInfuxIntervalStatsResponse.stat_ids)
    pub stat_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCGetInfuxIntervalStatsResponse.stat_total)
    pub stat_total: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgGCToGCGetInfuxIntervalStatsResponse.stat_samples)
    pub stat_samples: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCGetInfuxIntervalStatsResponse.stat_max)
    pub stat_max: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCGetInfuxIntervalStatsResponse.sample_duration_ms)
    pub sample_duration_ms: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCGetInfuxIntervalStatsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetInfuxIntervalStatsResponse {
    fn default() -> &'a CMsgGCToGCGetInfuxIntervalStatsResponse {
        <CMsgGCToGCGetInfuxIntervalStatsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetInfuxIntervalStatsResponse {
    pub fn new() -> CMsgGCToGCGetInfuxIntervalStatsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 sample_duration_ms = 5;

    pub fn sample_duration_ms(&self) -> u32 {
        self.sample_duration_ms.unwrap_or(0)
    }

    pub fn clear_sample_duration_ms(&mut self) {
        self.sample_duration_ms = ::std::option::Option::None;
    }

    pub fn has_sample_duration_ms(&self) -> bool {
        self.sample_duration_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sample_duration_ms(&mut self, v: u32) {
        self.sample_duration_ms = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCGetInfuxIntervalStatsResponse {
    const NAME: &'static str = "CMsgGCToGCGetInfuxIntervalStatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed32_into(&mut self.stat_ids)?;
                },
                13 => {
                    self.stat_ids.push(is.read_fixed32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.stat_total)?;
                },
                16 => {
                    self.stat_total.push(is.read_uint64()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.stat_samples)?;
                },
                24 => {
                    self.stat_samples.push(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.stat_max)?;
                },
                32 => {
                    self.stat_max.push(is.read_uint32()?);
                },
                40 => {
                    self.sample_duration_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_fixed32_size(1, &self.stat_ids);
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_uint64_size(2, &self.stat_total);
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_uint32_size(3, &self.stat_samples);
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_uint32_size(4, &self.stat_max);
        if let Some(v) = self.sample_duration_ms {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_repeated_packed_fixed32(1, &self.stat_ids)?;
        os.write_repeated_packed_uint64(2, &self.stat_total)?;
        os.write_repeated_packed_uint32(3, &self.stat_samples)?;
        os.write_repeated_packed_uint32(4, &self.stat_max)?;
        if let Some(v) = self.sample_duration_ms {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGetInfuxIntervalStatsResponse {
        CMsgGCToGCGetInfuxIntervalStatsResponse::new()
    }

    fn clear(&mut self) {
        self.stat_ids.clear();
        self.stat_total.clear();
        self.stat_samples.clear();
        self.stat_max.clear();
        self.sample_duration_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGetInfuxIntervalStatsResponse {
        static instance: CMsgGCToGCGetInfuxIntervalStatsResponse = CMsgGCToGCGetInfuxIntervalStatsResponse {
            stat_ids: ::std::vec::Vec::new(),
            stat_total: ::std::vec::Vec::new(),
            stat_samples: ::std::vec::Vec::new(),
            stat_max: ::std::vec::Vec::new(),
            sample_duration_ms: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCPurchaseSucceeded)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCPurchaseSucceeded {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCPurchaseSucceeded.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCPurchaseSucceeded {
    fn default() -> &'a CMsgGCToGCPurchaseSucceeded {
        <CMsgGCToGCPurchaseSucceeded as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCPurchaseSucceeded {
    pub fn new() -> CMsgGCToGCPurchaseSucceeded {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCPurchaseSucceeded {
    const NAME: &'static str = "CMsgGCToGCPurchaseSucceeded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCPurchaseSucceeded {
        CMsgGCToGCPurchaseSucceeded::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCPurchaseSucceeded {
        static instance: CMsgGCToGCPurchaseSucceeded = CMsgGCToGCPurchaseSucceeded {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetLimitedItemPurchaseQuantity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetLimitedItemPurchaseQuantity {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetLimitedItemPurchaseQuantity.item_def)
    pub item_def: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetLimitedItemPurchaseQuantity.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetLimitedItemPurchaseQuantity {
    fn default() -> &'a CMsgClientToGCGetLimitedItemPurchaseQuantity {
        <CMsgClientToGCGetLimitedItemPurchaseQuantity as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetLimitedItemPurchaseQuantity {
    pub fn new() -> CMsgClientToGCGetLimitedItemPurchaseQuantity {
        ::std::default::Default::default()
    }

    // optional uint32 item_def = 1;

    pub fn item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetLimitedItemPurchaseQuantity {
    const NAME: &'static str = "CMsgClientToGCGetLimitedItemPurchaseQuantity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_def {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetLimitedItemPurchaseQuantity {
        CMsgClientToGCGetLimitedItemPurchaseQuantity::new()
    }

    fn clear(&mut self) {
        self.item_def = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetLimitedItemPurchaseQuantity {
        static instance: CMsgClientToGCGetLimitedItemPurchaseQuantity = CMsgClientToGCGetLimitedItemPurchaseQuantity {
            item_def: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetLimitedItemPurchaseQuantityResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcget_limited_item_purchase_quantity_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.quantity_purchased)
    pub quantity_purchased: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
    fn default() -> &'a CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
        <CMsgClientToGCGetLimitedItemPurchaseQuantityResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
    pub fn new() -> CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcget_limited_item_purchase_quantity_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcget_limited_item_purchase_quantity_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcget_limited_item_purchase_quantity_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcget_limited_item_purchase_quantity_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 quantity_purchased = 2;

    pub fn quantity_purchased(&self) -> u32 {
        self.quantity_purchased.unwrap_or(0)
    }

    pub fn clear_quantity_purchased(&mut self) {
        self.quantity_purchased = ::std::option::Option::None;
    }

    pub fn has_quantity_purchased(&self) -> bool {
        self.quantity_purchased.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity_purchased(&mut self, v: u32) {
        self.quantity_purchased = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
    const NAME: &'static str = "CMsgClientToGCGetLimitedItemPurchaseQuantityResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.quantity_purchased = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.quantity_purchased {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.quantity_purchased {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
        CMsgClientToGCGetLimitedItemPurchaseQuantityResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.quantity_purchased = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
        static instance: CMsgClientToGCGetLimitedItemPurchaseQuantityResponse = CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
            result: ::std::option::Option::None,
            quantity_purchased: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCGetLimitedItemPurchaseQuantityResponse`
pub mod cmsg_client_to_gcget_limited_item_purchase_quantity_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.EResponse.k_eInvalidItemDef)
        k_eInvalidItemDef = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetLimitedItemPurchaseQuantityResponse.EResponse.k_eItemDefNotLimited)
        k_eItemDefNotLimited = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidItemDef),
                6 => ::std::option::Option::Some(EResponse::k_eItemDefNotLimited),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidItemDef" => ::std::option::Option::Some(EResponse::k_eInvalidItemDef),
                "k_eItemDefNotLimited" => ::std::option::Option::Some(EResponse::k_eItemDefNotLimited),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidItemDef,
            EResponse::k_eItemDefNotLimited,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCGetInFlightItemCharges)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetInFlightItemCharges {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetInFlightItemCharges.item_def)
    pub item_def: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetInFlightItemCharges.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetInFlightItemCharges {
    fn default() -> &'a CMsgClientToGCGetInFlightItemCharges {
        <CMsgClientToGCGetInFlightItemCharges as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetInFlightItemCharges {
    pub fn new() -> CMsgClientToGCGetInFlightItemCharges {
        ::std::default::Default::default()
    }

    // optional uint32 item_def = 1;

    pub fn item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetInFlightItemCharges {
    const NAME: &'static str = "CMsgClientToGCGetInFlightItemCharges";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_def {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetInFlightItemCharges {
        CMsgClientToGCGetInFlightItemCharges::new()
    }

    fn clear(&mut self) {
        self.item_def = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetInFlightItemCharges {
        static instance: CMsgClientToGCGetInFlightItemCharges = CMsgClientToGCGetInFlightItemCharges {
            item_def: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetInFlightItemChargesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetInFlightItemChargesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetInFlightItemChargesResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcget_in_flight_item_charges_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetInFlightItemChargesResponse.charges_in_flight)
    pub charges_in_flight: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetInFlightItemChargesResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetInFlightItemChargesResponse {
    fn default() -> &'a CMsgClientToGCGetInFlightItemChargesResponse {
        <CMsgClientToGCGetInFlightItemChargesResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetInFlightItemChargesResponse {
    pub fn new() -> CMsgClientToGCGetInFlightItemChargesResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCGetInFlightItemChargesResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcget_in_flight_item_charges_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcget_in_flight_item_charges_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcget_in_flight_item_charges_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcget_in_flight_item_charges_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 charges_in_flight = 2;

    pub fn charges_in_flight(&self) -> u32 {
        self.charges_in_flight.unwrap_or(0)
    }

    pub fn clear_charges_in_flight(&mut self) {
        self.charges_in_flight = ::std::option::Option::None;
    }

    pub fn has_charges_in_flight(&self) -> bool {
        self.charges_in_flight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_charges_in_flight(&mut self, v: u32) {
        self.charges_in_flight = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetInFlightItemChargesResponse {
    const NAME: &'static str = "CMsgClientToGCGetInFlightItemChargesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.charges_in_flight = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.charges_in_flight {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.charges_in_flight {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetInFlightItemChargesResponse {
        CMsgClientToGCGetInFlightItemChargesResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.charges_in_flight = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetInFlightItemChargesResponse {
        static instance: CMsgClientToGCGetInFlightItemChargesResponse = CMsgClientToGCGetInFlightItemChargesResponse {
            result: ::std::option::Option::None,
            charges_in_flight: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCGetInFlightItemChargesResponse`
pub mod cmsg_client_to_gcget_in_flight_item_charges_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCGetInFlightItemChargesResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetInFlightItemChargesResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetInFlightItemChargesResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetInFlightItemChargesResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetInFlightItemChargesResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetInFlightItemChargesResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetInFlightItemChargesResponse.EResponse.k_eInvalidItemDef)
        k_eInvalidItemDef = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidItemDef),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidItemDef" => ::std::option::Option::Some(EResponse::k_eInvalidItemDef),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidItemDef,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCPurchaseChargeCostItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCPurchaseChargeCostItems {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCPurchaseChargeCostItems.items)
    pub items: ::std::vec::Vec<cmsg_client_to_gcpurchase_charge_cost_items::Item>,
    // @@protoc_insertion_point(field:CMsgClientToGCPurchaseChargeCostItems.currency)
    pub currency: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCPurchaseChargeCostItems.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCPurchaseChargeCostItems {
    fn default() -> &'a CMsgClientToGCPurchaseChargeCostItems {
        <CMsgClientToGCPurchaseChargeCostItems as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCPurchaseChargeCostItems {
    pub fn new() -> CMsgClientToGCPurchaseChargeCostItems {
        ::std::default::Default::default()
    }

    // optional uint32 currency = 2;

    pub fn currency(&self) -> u32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: u32) {
        self.currency = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCPurchaseChargeCostItems {
    const NAME: &'static str = "CMsgClientToGCPurchaseChargeCostItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.items.push(is.read_message()?);
                },
                16 => {
                    self.currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.currency {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.items {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.currency {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCPurchaseChargeCostItems {
        CMsgClientToGCPurchaseChargeCostItems::new()
    }

    fn clear(&mut self) {
        self.items.clear();
        self.currency = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCPurchaseChargeCostItems {
        static instance: CMsgClientToGCPurchaseChargeCostItems = CMsgClientToGCPurchaseChargeCostItems {
            items: ::std::vec::Vec::new(),
            currency: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCPurchaseChargeCostItems`
pub mod cmsg_client_to_gcpurchase_charge_cost_items {
    // @@protoc_insertion_point(message:CMsgClientToGCPurchaseChargeCostItems.Item)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Item {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCPurchaseChargeCostItems.Item.item_def_index)
        pub item_def_index: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCPurchaseChargeCostItems.Item.quantity)
        pub quantity: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCPurchaseChargeCostItems.Item.source_reference_id)
        pub source_reference_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientToGCPurchaseChargeCostItems.Item.price_index)
        pub price_index: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCPurchaseChargeCostItems.Item.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Item {
        fn default() -> &'a Item {
            <Item as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Item {
        pub fn new() -> Item {
            ::std::default::Default::default()
        }

        // optional uint32 item_def_index = 1;

        pub fn item_def_index(&self) -> u32 {
            self.item_def_index.unwrap_or(0)
        }

        pub fn clear_item_def_index(&mut self) {
            self.item_def_index = ::std::option::Option::None;
        }

        pub fn has_item_def_index(&self) -> bool {
            self.item_def_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_def_index(&mut self, v: u32) {
            self.item_def_index = ::std::option::Option::Some(v);
        }

        // optional uint32 quantity = 2;

        pub fn quantity(&self) -> u32 {
            self.quantity.unwrap_or(0)
        }

        pub fn clear_quantity(&mut self) {
            self.quantity = ::std::option::Option::None;
        }

        pub fn has_quantity(&self) -> bool {
            self.quantity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quantity(&mut self, v: u32) {
            self.quantity = ::std::option::Option::Some(v);
        }

        // optional uint64 source_reference_id = 3;

        pub fn source_reference_id(&self) -> u64 {
            self.source_reference_id.unwrap_or(0)
        }

        pub fn clear_source_reference_id(&mut self) {
            self.source_reference_id = ::std::option::Option::None;
        }

        pub fn has_source_reference_id(&self) -> bool {
            self.source_reference_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_reference_id(&mut self, v: u64) {
            self.source_reference_id = ::std::option::Option::Some(v);
        }

        // optional int32 price_index = 4;

        pub fn price_index(&self) -> i32 {
            self.price_index.unwrap_or(0)
        }

        pub fn clear_price_index(&mut self) {
            self.price_index = ::std::option::Option::None;
        }

        pub fn has_price_index(&self) -> bool {
            self.price_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_price_index(&mut self, v: i32) {
            self.price_index = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Item {
        const NAME: &'static str = "Item";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.source_reference_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    32 => {
                        self.price_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_def_index {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.quantity {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.source_reference_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
            }
            if let Some(v) = self.price_index {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item_def_index {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.quantity {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.source_reference_id {
                os.write_uint64(3, v)?;
            }
            if let Some(v) = self.price_index {
                os.write_int32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Item {
            Item::new()
        }

        fn clear(&mut self) {
            self.item_def_index = ::std::option::Option::None;
            self.quantity = ::std::option::Option::None;
            self.source_reference_id = ::std::option::Option::None;
            self.price_index = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Item {
            static instance: Item = Item {
                item_def_index: ::std::option::Option::None,
                quantity: ::std::option::Option::None,
                source_reference_id: ::std::option::Option::None,
                price_index: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCPurchaseChargeCostItemsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCPurchaseChargeCostItemsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCPurchaseChargeCostItemsResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcpurchase_charge_cost_items_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCPurchaseChargeCostItemsResponse.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCPurchaseChargeCostItemsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCPurchaseChargeCostItemsResponse {
    fn default() -> &'a CMsgClientToGCPurchaseChargeCostItemsResponse {
        <CMsgClientToGCPurchaseChargeCostItemsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCPurchaseChargeCostItemsResponse {
    pub fn new() -> CMsgClientToGCPurchaseChargeCostItemsResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCPurchaseChargeCostItemsResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcpurchase_charge_cost_items_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcpurchase_charge_cost_items_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcpurchase_charge_cost_items_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcpurchase_charge_cost_items_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCPurchaseChargeCostItemsResponse {
    const NAME: &'static str = "CMsgClientToGCPurchaseChargeCostItemsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                16 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.item_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.item_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCPurchaseChargeCostItemsResponse {
        CMsgClientToGCPurchaseChargeCostItemsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCPurchaseChargeCostItemsResponse {
        static instance: CMsgClientToGCPurchaseChargeCostItemsResponse = CMsgClientToGCPurchaseChargeCostItemsResponse {
            result: ::std::option::Option::None,
            item_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCPurchaseChargeCostItemsResponse`
pub mod cmsg_client_to_gcpurchase_charge_cost_items_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCPurchaseChargeCostItemsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPurchaseChargeCostItemsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPurchaseChargeCostItemsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPurchaseChargeCostItemsResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPurchaseChargeCostItemsResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPurchaseChargeCostItemsResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPurchaseChargeCostItemsResponse.EResponse.k_eInvalidParam)
        k_eInvalidParam = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPurchaseChargeCostItemsResponse.EResponse.k_eInvalidPrice)
        k_eInvalidPrice = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPurchaseChargeCostItemsResponse.EResponse.k_eInsufficientCharges)
        k_eInsufficientCharges = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPurchaseChargeCostItemsResponse.EResponse.k_eLimitedItem)
        k_eLimitedItem = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPurchaseChargeCostItemsResponse.EResponse.k_eMissingPrereq)
        k_eMissingPrereq = 10,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidParam),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidPrice),
                7 => ::std::option::Option::Some(EResponse::k_eInsufficientCharges),
                8 => ::std::option::Option::Some(EResponse::k_eLimitedItem),
                10 => ::std::option::Option::Some(EResponse::k_eMissingPrereq),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidParam" => ::std::option::Option::Some(EResponse::k_eInvalidParam),
                "k_eInvalidPrice" => ::std::option::Option::Some(EResponse::k_eInvalidPrice),
                "k_eInsufficientCharges" => ::std::option::Option::Some(EResponse::k_eInsufficientCharges),
                "k_eLimitedItem" => ::std::option::Option::Some(EResponse::k_eLimitedItem),
                "k_eMissingPrereq" => ::std::option::Option::Some(EResponse::k_eMissingPrereq),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidParam,
            EResponse::k_eInvalidPrice,
            EResponse::k_eInsufficientCharges,
            EResponse::k_eLimitedItem,
            EResponse::k_eMissingPrereq,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCToClientInFlightChargesUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientInFlightChargesUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientInFlightChargesUpdated.in_flight_charges)
    pub in_flight_charges: ::std::vec::Vec<cmsg_gcto_client_in_flight_charges_updated::ItemCharges>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientInFlightChargesUpdated.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientInFlightChargesUpdated {
    fn default() -> &'a CMsgGCToClientInFlightChargesUpdated {
        <CMsgGCToClientInFlightChargesUpdated as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientInFlightChargesUpdated {
    pub fn new() -> CMsgGCToClientInFlightChargesUpdated {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientInFlightChargesUpdated {
    const NAME: &'static str = "CMsgGCToClientInFlightChargesUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.in_flight_charges.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.in_flight_charges {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.in_flight_charges {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientInFlightChargesUpdated {
        CMsgGCToClientInFlightChargesUpdated::new()
    }

    fn clear(&mut self) {
        self.in_flight_charges.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientInFlightChargesUpdated {
        static instance: CMsgGCToClientInFlightChargesUpdated = CMsgGCToClientInFlightChargesUpdated {
            in_flight_charges: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientInFlightChargesUpdated`
pub mod cmsg_gcto_client_in_flight_charges_updated {
    // @@protoc_insertion_point(message:CMsgGCToClientInFlightChargesUpdated.ItemCharges)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemCharges {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientInFlightChargesUpdated.ItemCharges.item_def)
        pub item_def: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientInFlightChargesUpdated.ItemCharges.charges_in_flight)
        pub charges_in_flight: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientInFlightChargesUpdated.ItemCharges.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemCharges {
        fn default() -> &'a ItemCharges {
            <ItemCharges as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ItemCharges {
        pub fn new() -> ItemCharges {
            ::std::default::Default::default()
        }

        // optional uint32 item_def = 1;

        pub fn item_def(&self) -> u32 {
            self.item_def.unwrap_or(0)
        }

        pub fn clear_item_def(&mut self) {
            self.item_def = ::std::option::Option::None;
        }

        pub fn has_item_def(&self) -> bool {
            self.item_def.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_def(&mut self, v: u32) {
            self.item_def = ::std::option::Option::Some(v);
        }

        // optional uint32 charges_in_flight = 2;

        pub fn charges_in_flight(&self) -> u32 {
            self.charges_in_flight.unwrap_or(0)
        }

        pub fn clear_charges_in_flight(&mut self) {
            self.charges_in_flight = ::std::option::Option::None;
        }

        pub fn has_charges_in_flight(&self) -> bool {
            self.charges_in_flight.is_some()
        }

        // Param is passed by value, moved
        pub fn set_charges_in_flight(&mut self, v: u32) {
            self.charges_in_flight = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ItemCharges {
        const NAME: &'static str = "ItemCharges";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.charges_in_flight = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_def {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.charges_in_flight {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item_def {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.charges_in_flight {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemCharges {
            ItemCharges::new()
        }

        fn clear(&mut self) {
            self.item_def = ::std::option::Option::None;
            self.charges_in_flight = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemCharges {
            static instance: ItemCharges = ItemCharges {
                item_def: ::std::option::Option::None,
                charges_in_flight: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCCancelUnfinalizedTransactions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCancelUnfinalizedTransactions {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCancelUnfinalizedTransactions.unused)
    pub unused: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCancelUnfinalizedTransactions.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCancelUnfinalizedTransactions {
    fn default() -> &'a CMsgClientToGCCancelUnfinalizedTransactions {
        <CMsgClientToGCCancelUnfinalizedTransactions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCancelUnfinalizedTransactions {
    pub fn new() -> CMsgClientToGCCancelUnfinalizedTransactions {
        ::std::default::Default::default()
    }

    // optional uint32 unused = 1;

    pub fn unused(&self) -> u32 {
        self.unused.unwrap_or(0)
    }

    pub fn clear_unused(&mut self) {
        self.unused = ::std::option::Option::None;
    }

    pub fn has_unused(&self) -> bool {
        self.unused.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unused(&mut self, v: u32) {
        self.unused = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCancelUnfinalizedTransactions {
    const NAME: &'static str = "CMsgClientToGCCancelUnfinalizedTransactions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.unused = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unused {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.unused {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCancelUnfinalizedTransactions {
        CMsgClientToGCCancelUnfinalizedTransactions::new()
    }

    fn clear(&mut self) {
        self.unused = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCancelUnfinalizedTransactions {
        static instance: CMsgClientToGCCancelUnfinalizedTransactions = CMsgClientToGCCancelUnfinalizedTransactions {
            unused: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCCancelUnfinalizedTransactionsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCancelUnfinalizedTransactionsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCancelUnfinalizedTransactionsResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCancelUnfinalizedTransactionsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCancelUnfinalizedTransactionsResponse {
    fn default() -> &'a CMsgClientToGCCancelUnfinalizedTransactionsResponse {
        <CMsgClientToGCCancelUnfinalizedTransactionsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCancelUnfinalizedTransactionsResponse {
    pub fn new() -> CMsgClientToGCCancelUnfinalizedTransactionsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCancelUnfinalizedTransactionsResponse {
    const NAME: &'static str = "CMsgClientToGCCancelUnfinalizedTransactionsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCancelUnfinalizedTransactionsResponse {
        CMsgClientToGCCancelUnfinalizedTransactionsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCancelUnfinalizedTransactionsResponse {
        static instance: CMsgClientToGCCancelUnfinalizedTransactionsResponse = CMsgClientToGCCancelUnfinalizedTransactionsResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCUpdateWelcomeMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCUpdateWelcomeMsg {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCUpdateWelcomeMsg.server)
    pub server: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCToGCUpdateWelcomeMsg.new_msg)
    pub new_msg: ::steam_vent_proto_common::protobuf::MessageField<super::gcsdk_gcmessages::CExtraMsgBlock>,
    // @@protoc_insertion_point(field:CMsgGCToGCUpdateWelcomeMsg.broadcast)
    pub broadcast: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCUpdateWelcomeMsg.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCUpdateWelcomeMsg {
    fn default() -> &'a CMsgGCToGCUpdateWelcomeMsg {
        <CMsgGCToGCUpdateWelcomeMsg as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCUpdateWelcomeMsg {
    pub fn new() -> CMsgGCToGCUpdateWelcomeMsg {
        ::std::default::Default::default()
    }

    // optional bool server = 1;

    pub fn server(&self) -> bool {
        self.server.unwrap_or(false)
    }

    pub fn clear_server(&mut self) {
        self.server = ::std::option::Option::None;
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: bool) {
        self.server = ::std::option::Option::Some(v);
    }

    // optional bool broadcast = 3;

    pub fn broadcast(&self) -> bool {
        self.broadcast.unwrap_or(false)
    }

    pub fn clear_broadcast(&mut self) {
        self.broadcast = ::std::option::Option::None;
    }

    pub fn has_broadcast(&self) -> bool {
        self.broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast(&mut self, v: bool) {
        self.broadcast = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCUpdateWelcomeMsg {
    const NAME: &'static str = "CMsgGCToGCUpdateWelcomeMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.server = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.new_msg)?;
                },
                24 => {
                    self.broadcast = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server {
            my_size += 1 + 1;
        }
        if let Some(v) = self.new_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.broadcast {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.server {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.new_msg.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.broadcast {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCUpdateWelcomeMsg {
        CMsgGCToGCUpdateWelcomeMsg::new()
    }

    fn clear(&mut self) {
        self.server = ::std::option::Option::None;
        self.new_msg.clear();
        self.broadcast = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCUpdateWelcomeMsg {
        static instance: CMsgGCToGCUpdateWelcomeMsg = CMsgGCToGCUpdateWelcomeMsg {
            server: ::std::option::Option::None,
            new_msg: ::steam_vent_proto_common::protobuf::MessageField::none(),
            broadcast: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGCItemMsg)
pub enum EGCItemMsg {
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCBase)
    k_EMsgGCBase = 1000,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCSetItemPosition)
    k_EMsgGCSetItemPosition = 1001,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCPackBundle)
    k_EMsgClientToGCPackBundle = 1002,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCPackBundleResponse)
    k_EMsgClientToGCPackBundleResponse = 1003,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCDelete)
    k_EMsgGCDelete = 1004,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCVerifyCacheSubscription)
    k_EMsgGCVerifyCacheSubscription = 1005,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCNameItem)
    k_EMsgClientToGCNameItem = 1006,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCPaintItem)
    k_EMsgGCPaintItem = 1009,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCPaintItemResponse)
    k_EMsgGCPaintItemResponse = 1010,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCNameBaseItem)
    k_EMsgGCNameBaseItem = 1019,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCNameBaseItemResponse)
    k_EMsgGCNameBaseItemResponse = 1020,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCUseItemRequest)
    k_EMsgGCUseItemRequest = 1025,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCUseItemResponse)
    k_EMsgGCUseItemResponse = 1026,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCGiftedItems)
    k_EMsgGCGiftedItems = 1027,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCUnwrapGiftRequest)
    k_EMsgGCUnwrapGiftRequest = 1037,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCUnwrapGiftResponse)
    k_EMsgGCUnwrapGiftResponse = 1038,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCSortItems)
    k_EMsgGCSortItems = 1041,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCBackpackSortFinished)
    k_EMsgGCBackpackSortFinished = 1058,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCAdjustItemEquippedState)
    k_EMsgGCAdjustItemEquippedState = 1059,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemAcknowledged)
    k_EMsgGCItemAcknowledged = 1062,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCNameItemResponse)
    k_EMsgClientToGCNameItemResponse = 1068,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyStrangePart)
    k_EMsgGCApplyStrangePart = 1073,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyPennantUpgrade)
    k_EMsgGCApplyPennantUpgrade = 1076,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCSetItemPositions)
    k_EMsgGCSetItemPositions = 1077,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyEggEssence)
    k_EMsgGCApplyEggEssence = 1078,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCNameEggEssenceResponse)
    k_EMsgGCNameEggEssenceResponse = 1079,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCExtractGems)
    k_EMsgGCExtractGems = 1086,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCAddSocket)
    k_EMsgGCAddSocket = 1087,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCAddItemToSocket)
    k_EMsgGCAddItemToSocket = 1088,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCAddItemToSocketResponse)
    k_EMsgGCAddItemToSocketResponse = 1089,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCAddSocketResponse)
    k_EMsgGCAddSocketResponse = 1090,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCResetStrangeGemCount)
    k_EMsgGCResetStrangeGemCount = 1091,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRequestCrateItems)
    k_EMsgGCRequestCrateItems = 1092,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRequestCrateItemsResponse)
    k_EMsgGCRequestCrateItemsResponse = 1093,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCExtractGemsResponse)
    k_EMsgGCExtractGemsResponse = 1094,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCResetStrangeGemCountResponse)
    k_EMsgGCResetStrangeGemCountResponse = 1095,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCServerUseItemRequest)
    k_EMsgGCServerUseItemRequest = 1103,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCAddGiftItem)
    k_EMsgGCAddGiftItem = 1104,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgSQLGCToGCRevokeUntrustedGift)
    k_EMsgSQLGCToGCRevokeUntrustedGift = 1105,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCRemoveItemGifterAttributes)
    k_EMsgClientToGCRemoveItemGifterAttributes = 1109,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCRemoveItemName)
    k_EMsgClientToGCRemoveItemName = 1110,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCRemoveItemDescription)
    k_EMsgClientToGCRemoveItemDescription = 1111,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCRemoveItemAttributeResponse)
    k_EMsgClientToGCRemoveItemAttributeResponse = 1112,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCDev_NewItemRequest)
    k_EMsgGCDev_NewItemRequest = 2001,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCDev_NewItemRequestResponse)
    k_EMsgGCDev_NewItemRequestResponse = 2002,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCDev_UnlockAllItemStylesRequest)
    k_EMsgGCDev_UnlockAllItemStylesRequest = 2003,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCDev_UnlockAllItemStylesResponse)
    k_EMsgGCDev_UnlockAllItemStylesResponse = 2004,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseFinalize)
    k_EMsgGCStorePurchaseFinalize = 2504,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseFinalizeResponse)
    k_EMsgGCStorePurchaseFinalizeResponse = 2505,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseCancel)
    k_EMsgGCStorePurchaseCancel = 2506,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseCancelResponse)
    k_EMsgGCStorePurchaseCancelResponse = 2507,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseInit)
    k_EMsgGCStorePurchaseInit = 2510,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseInitResponse)
    k_EMsgGCStorePurchaseInitResponse = 2511,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCBannedWordListUpdated)
    k_EMsgGCToGCBannedWordListUpdated = 2515,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCDirtySDOCache)
    k_EMsgGCToGCDirtySDOCache = 2516,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCUpdateSQLKeyValue)
    k_EMsgGCToGCUpdateSQLKeyValue = 2518,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCBroadcastConsoleCommand)
    k_EMsgGCToGCBroadcastConsoleCommand = 2521,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCServerVersionUpdated)
    k_EMsgGCServerVersionUpdated = 2522,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyAutograph)
    k_EMsgGCApplyAutograph = 2523,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCWebAPIAccountChanged)
    k_EMsgGCToGCWebAPIAccountChanged = 2524,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCClientVersionUpdated)
    k_EMsgGCClientVersionUpdated = 2528,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCUpdateWelcomeMsg)
    k_EMsgGCToGCUpdateWelcomeMsg = 2529,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCPlayerStrangeCountAdjustments)
    k_EMsgGCToGCPlayerStrangeCountAdjustments = 2535,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRequestStoreSalesData)
    k_EMsgGCRequestStoreSalesData = 2536,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRequestStoreSalesDataResponse)
    k_EMsgGCRequestStoreSalesDataResponse = 2537,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRequestStoreSalesDataUpToDateResponse)
    k_EMsgGCRequestStoreSalesDataUpToDateResponse = 2538,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCPingRequest)
    k_EMsgGCToGCPingRequest = 2539,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCPingResponse)
    k_EMsgGCToGCPingResponse = 2540,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCGetUserSessionServer)
    k_EMsgGCToGCGetUserSessionServer = 2541,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCGetUserSessionServerResponse)
    k_EMsgGCToGCGetUserSessionServerResponse = 2542,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCGetUserServerMembers)
    k_EMsgGCToGCGetUserServerMembers = 2543,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCGetUserServerMembersResponse)
    k_EMsgGCToGCGetUserServerMembersResponse = 2544,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCCanUseDropRateBonus)
    k_EMsgGCToGCCanUseDropRateBonus = 2547,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgSQLAddDropRateBonus)
    k_EMsgSQLAddDropRateBonus = 2548,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCRefreshSOCache)
    k_EMsgGCToGCRefreshSOCache = 2549,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCGrantAccountRolledItems)
    k_EMsgGCToGCGrantAccountRolledItems = 2554,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCGrantSelfMadeItemToAccount)
    k_EMsgGCToGCGrantSelfMadeItemToAccount = 2555,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStatueCraft)
    k_EMsgGCStatueCraft = 2561,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRedeemCode)
    k_EMsgGCRedeemCode = 2562,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRedeemCodeResponse)
    k_EMsgGCRedeemCodeResponse = 2563,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCItemConsumptionRollback)
    k_EMsgGCToGCItemConsumptionRollback = 2564,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCWrapAndDeliverGift)
    k_EMsgClientToGCWrapAndDeliverGift = 2565,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCWrapAndDeliverGiftResponse)
    k_EMsgClientToGCWrapAndDeliverGiftResponse = 2566,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCUnpackBundleResponse)
    k_EMsgClientToGCUnpackBundleResponse = 2567,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToClientStoreTransactionCompleted)
    k_EMsgGCToClientStoreTransactionCompleted = 2568,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCEquipItems)
    k_EMsgClientToGCEquipItems = 2569,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCEquipItemsResponse)
    k_EMsgClientToGCEquipItemsResponse = 2570,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCUnlockItemStyle)
    k_EMsgClientToGCUnlockItemStyle = 2571,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCUnlockItemStyleResponse)
    k_EMsgClientToGCUnlockItemStyleResponse = 2572,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCSetItemInventoryCategory)
    k_EMsgClientToGCSetItemInventoryCategory = 2573,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCUnlockCrate)
    k_EMsgClientToGCUnlockCrate = 2574,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCUnlockCrateResponse)
    k_EMsgClientToGCUnlockCrateResponse = 2575,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCUnpackBundle)
    k_EMsgClientToGCUnpackBundle = 2576,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCSetItemStyle)
    k_EMsgClientToGCSetItemStyle = 2577,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCSetItemStyleResponse)
    k_EMsgClientToGCSetItemStyleResponse = 2578,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgSQLGCToGCGrantBackpackSlots)
    k_EMsgSQLGCToGCGrantBackpackSlots = 2580,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCLookupAccountName)
    k_EMsgClientToGCLookupAccountName = 2581,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCLookupAccountNameResponse)
    k_EMsgClientToGCLookupAccountNameResponse = 2582,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCCreateStaticRecipe)
    k_EMsgClientToGCCreateStaticRecipe = 2584,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCCreateStaticRecipeResponse)
    k_EMsgClientToGCCreateStaticRecipeResponse = 2585,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCStoreProcessCDKeyTransaction)
    k_EMsgGCToGCStoreProcessCDKeyTransaction = 2586,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCStoreProcessCDKeyTransactionResponse)
    k_EMsgGCToGCStoreProcessCDKeyTransactionResponse = 2587,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCStoreProcessSettlement)
    k_EMsgGCToGCStoreProcessSettlement = 2588,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCStoreProcessSettlementResponse)
    k_EMsgGCToGCStoreProcessSettlementResponse = 2589,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCConsoleOutput)
    k_EMsgGCToGCConsoleOutput = 2590,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToClientItemAges)
    k_EMsgGCToClientItemAges = 2591,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCInternalTestMsg)
    k_EMsgGCToGCInternalTestMsg = 2592,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCClientServerVersionsUpdated)
    k_EMsgGCToGCClientServerVersionsUpdated = 2593,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCUseMultipleItemsRequest)
    k_EMsgGCUseMultipleItemsRequest = 2594,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCGetAccountSubscriptionItem)
    k_EMsgGCGetAccountSubscriptionItem = 2595,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCGetAccountSubscriptionItemResponse)
    k_EMsgGCGetAccountSubscriptionItemResponse = 2596,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCBroadcastMessageFromSub)
    k_EMsgGCToGCBroadcastMessageFromSub = 2598,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToClientCurrencyPricePoints)
    k_EMsgGCToClientCurrencyPricePoints = 2599,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCAddSubscriptionTime)
    k_EMsgGCToGCAddSubscriptionTime = 2600,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCFlushSteamInventoryCache)
    k_EMsgGCToGCFlushSteamInventoryCache = 2601,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRequestCrateEscalationLevel)
    k_EMsgGCRequestCrateEscalationLevel = 2602,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRequestCrateEscalationLevelResponse)
    k_EMsgGCRequestCrateEscalationLevelResponse = 2603,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCUpdateSubscriptionItems)
    k_EMsgGCToGCUpdateSubscriptionItems = 2604,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCSelfPing)
    k_EMsgGCToGCSelfPing = 2605,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCGetInfuxIntervalStats)
    k_EMsgGCToGCGetInfuxIntervalStats = 2606,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCGetInfuxIntervalStatsResponse)
    k_EMsgGCToGCGetInfuxIntervalStatsResponse = 2607,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCPurchaseSucceeded)
    k_EMsgGCToGCPurchaseSucceeded = 2608,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCGetLimitedItemPurchaseQuantity)
    k_EMsgClientToGCGetLimitedItemPurchaseQuantity = 2609,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCGetLimitedItemPurchaseQuantityResponse)
    k_EMsgClientToGCGetLimitedItemPurchaseQuantityResponse = 2610,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCBetaDeleteItems)
    k_EMsgGCToGCBetaDeleteItems = 2611,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCGetInFlightItemCharges)
    k_EMsgClientToGCGetInFlightItemCharges = 2612,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCGetInFlightItemChargesResponse)
    k_EMsgClientToGCGetInFlightItemChargesResponse = 2613,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToClientInFlightChargesUpdated)
    k_EMsgGCToClientInFlightChargesUpdated = 2614,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCPurchaseChargeCostItems)
    k_EMsgClientToGCPurchaseChargeCostItems = 2615,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCPurchaseChargeCostItemsResponse)
    k_EMsgClientToGCPurchaseChargeCostItemsResponse = 2616,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCCancelUnfinalizedTransactions)
    k_EMsgClientToGCCancelUnfinalizedTransactions = 2617,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgClientToGCCancelUnfinalizedTransactionsResponse)
    k_EMsgClientToGCCancelUnfinalizedTransactionsResponse = 2618,
}

impl ::steam_vent_proto_common::protobuf::Enum for EGCItemMsg {
    const NAME: &'static str = "EGCItemMsg";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCItemMsg> {
        match value {
            1000 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCBase),
            1001 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemPosition),
            1002 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCPackBundle),
            1003 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCPackBundleResponse),
            1004 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDelete),
            1005 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCVerifyCacheSubscription),
            1006 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCNameItem),
            1009 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPaintItem),
            1010 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPaintItemResponse),
            1019 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameBaseItem),
            1020 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameBaseItemResponse),
            1025 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseItemRequest),
            1026 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseItemResponse),
            1027 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGiftedItems),
            1037 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnwrapGiftRequest),
            1038 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnwrapGiftResponse),
            1041 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSortItems),
            1058 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCBackpackSortFinished),
            1059 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAdjustItemEquippedState),
            1062 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemAcknowledged),
            1068 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCNameItemResponse),
            1073 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyStrangePart),
            1076 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyPennantUpgrade),
            1077 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemPositions),
            1078 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyEggEssence),
            1079 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameEggEssenceResponse),
            1086 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCExtractGems),
            1087 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddSocket),
            1088 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddItemToSocket),
            1089 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddItemToSocketResponse),
            1090 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddSocketResponse),
            1091 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCResetStrangeGemCount),
            1092 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestCrateItems),
            1093 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestCrateItemsResponse),
            1094 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCExtractGemsResponse),
            1095 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCResetStrangeGemCountResponse),
            1103 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerUseItemRequest),
            1104 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddGiftItem),
            1105 => ::std::option::Option::Some(EGCItemMsg::k_EMsgSQLGCToGCRevokeUntrustedGift),
            1109 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCRemoveItemGifterAttributes),
            1110 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCRemoveItemName),
            1111 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCRemoveItemDescription),
            1112 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCRemoveItemAttributeResponse),
            2001 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_NewItemRequest),
            2002 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_NewItemRequestResponse),
            2003 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_UnlockAllItemStylesRequest),
            2004 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_UnlockAllItemStylesResponse),
            2504 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseFinalize),
            2505 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseFinalizeResponse),
            2506 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseCancel),
            2507 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseCancelResponse),
            2510 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInit),
            2511 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInitResponse),
            2515 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBannedWordListUpdated),
            2516 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCDirtySDOCache),
            2518 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCUpdateSQLKeyValue),
            2521 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBroadcastConsoleCommand),
            2522 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerVersionUpdated),
            2523 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyAutograph),
            2524 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCWebAPIAccountChanged),
            2528 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientVersionUpdated),
            2529 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCUpdateWelcomeMsg),
            2535 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPlayerStrangeCountAdjustments),
            2536 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesData),
            2537 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesDataResponse),
            2538 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesDataUpToDateResponse),
            2539 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPingRequest),
            2540 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPingResponse),
            2541 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserSessionServer),
            2542 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserSessionServerResponse),
            2543 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserServerMembers),
            2544 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserServerMembersResponse),
            2547 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCCanUseDropRateBonus),
            2548 => ::std::option::Option::Some(EGCItemMsg::k_EMsgSQLAddDropRateBonus),
            2549 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCRefreshSOCache),
            2554 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGrantAccountRolledItems),
            2555 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGrantSelfMadeItemToAccount),
            2561 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStatueCraft),
            2562 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRedeemCode),
            2563 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRedeemCodeResponse),
            2564 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCItemConsumptionRollback),
            2565 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCWrapAndDeliverGift),
            2566 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCWrapAndDeliverGiftResponse),
            2567 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnpackBundleResponse),
            2568 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToClientStoreTransactionCompleted),
            2569 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCEquipItems),
            2570 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCEquipItemsResponse),
            2571 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnlockItemStyle),
            2572 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnlockItemStyleResponse),
            2573 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCSetItemInventoryCategory),
            2574 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnlockCrate),
            2575 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnlockCrateResponse),
            2576 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnpackBundle),
            2577 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCSetItemStyle),
            2578 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCSetItemStyleResponse),
            2580 => ::std::option::Option::Some(EGCItemMsg::k_EMsgSQLGCToGCGrantBackpackSlots),
            2581 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCLookupAccountName),
            2582 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCLookupAccountNameResponse),
            2584 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCCreateStaticRecipe),
            2585 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCCreateStaticRecipeResponse),
            2586 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCStoreProcessCDKeyTransaction),
            2587 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCStoreProcessCDKeyTransactionResponse),
            2588 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCStoreProcessSettlement),
            2589 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCStoreProcessSettlementResponse),
            2590 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCConsoleOutput),
            2591 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToClientItemAges),
            2592 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCInternalTestMsg),
            2593 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCClientServerVersionsUpdated),
            2594 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseMultipleItemsRequest),
            2595 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGetAccountSubscriptionItem),
            2596 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGetAccountSubscriptionItemResponse),
            2598 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBroadcastMessageFromSub),
            2599 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToClientCurrencyPricePoints),
            2600 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCAddSubscriptionTime),
            2601 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCFlushSteamInventoryCache),
            2602 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestCrateEscalationLevel),
            2603 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestCrateEscalationLevelResponse),
            2604 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCUpdateSubscriptionItems),
            2605 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCSelfPing),
            2606 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetInfuxIntervalStats),
            2607 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetInfuxIntervalStatsResponse),
            2608 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPurchaseSucceeded),
            2609 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCGetLimitedItemPurchaseQuantity),
            2610 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCGetLimitedItemPurchaseQuantityResponse),
            2611 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBetaDeleteItems),
            2612 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCGetInFlightItemCharges),
            2613 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCGetInFlightItemChargesResponse),
            2614 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToClientInFlightChargesUpdated),
            2615 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCPurchaseChargeCostItems),
            2616 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCPurchaseChargeCostItemsResponse),
            2617 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCCancelUnfinalizedTransactions),
            2618 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCCancelUnfinalizedTransactionsResponse),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGCItemMsg> {
        match str {
            "k_EMsgGCBase" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCBase),
            "k_EMsgGCSetItemPosition" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemPosition),
            "k_EMsgClientToGCPackBundle" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCPackBundle),
            "k_EMsgClientToGCPackBundleResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCPackBundleResponse),
            "k_EMsgGCDelete" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDelete),
            "k_EMsgGCVerifyCacheSubscription" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCVerifyCacheSubscription),
            "k_EMsgClientToGCNameItem" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCNameItem),
            "k_EMsgGCPaintItem" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPaintItem),
            "k_EMsgGCPaintItemResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPaintItemResponse),
            "k_EMsgGCNameBaseItem" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameBaseItem),
            "k_EMsgGCNameBaseItemResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameBaseItemResponse),
            "k_EMsgGCUseItemRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseItemRequest),
            "k_EMsgGCUseItemResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseItemResponse),
            "k_EMsgGCGiftedItems" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGiftedItems),
            "k_EMsgGCUnwrapGiftRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnwrapGiftRequest),
            "k_EMsgGCUnwrapGiftResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnwrapGiftResponse),
            "k_EMsgGCSortItems" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSortItems),
            "k_EMsgGCBackpackSortFinished" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCBackpackSortFinished),
            "k_EMsgGCAdjustItemEquippedState" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAdjustItemEquippedState),
            "k_EMsgGCItemAcknowledged" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemAcknowledged),
            "k_EMsgClientToGCNameItemResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCNameItemResponse),
            "k_EMsgGCApplyStrangePart" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyStrangePart),
            "k_EMsgGCApplyPennantUpgrade" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyPennantUpgrade),
            "k_EMsgGCSetItemPositions" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemPositions),
            "k_EMsgGCApplyEggEssence" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyEggEssence),
            "k_EMsgGCNameEggEssenceResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameEggEssenceResponse),
            "k_EMsgGCExtractGems" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCExtractGems),
            "k_EMsgGCAddSocket" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddSocket),
            "k_EMsgGCAddItemToSocket" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddItemToSocket),
            "k_EMsgGCAddItemToSocketResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddItemToSocketResponse),
            "k_EMsgGCAddSocketResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddSocketResponse),
            "k_EMsgGCResetStrangeGemCount" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCResetStrangeGemCount),
            "k_EMsgGCRequestCrateItems" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestCrateItems),
            "k_EMsgGCRequestCrateItemsResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestCrateItemsResponse),
            "k_EMsgGCExtractGemsResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCExtractGemsResponse),
            "k_EMsgGCResetStrangeGemCountResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCResetStrangeGemCountResponse),
            "k_EMsgGCServerUseItemRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerUseItemRequest),
            "k_EMsgGCAddGiftItem" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddGiftItem),
            "k_EMsgSQLGCToGCRevokeUntrustedGift" => ::std::option::Option::Some(EGCItemMsg::k_EMsgSQLGCToGCRevokeUntrustedGift),
            "k_EMsgClientToGCRemoveItemGifterAttributes" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCRemoveItemGifterAttributes),
            "k_EMsgClientToGCRemoveItemName" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCRemoveItemName),
            "k_EMsgClientToGCRemoveItemDescription" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCRemoveItemDescription),
            "k_EMsgClientToGCRemoveItemAttributeResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCRemoveItemAttributeResponse),
            "k_EMsgGCDev_NewItemRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_NewItemRequest),
            "k_EMsgGCDev_NewItemRequestResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_NewItemRequestResponse),
            "k_EMsgGCDev_UnlockAllItemStylesRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_UnlockAllItemStylesRequest),
            "k_EMsgGCDev_UnlockAllItemStylesResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_UnlockAllItemStylesResponse),
            "k_EMsgGCStorePurchaseFinalize" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseFinalize),
            "k_EMsgGCStorePurchaseFinalizeResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseFinalizeResponse),
            "k_EMsgGCStorePurchaseCancel" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseCancel),
            "k_EMsgGCStorePurchaseCancelResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseCancelResponse),
            "k_EMsgGCStorePurchaseInit" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInit),
            "k_EMsgGCStorePurchaseInitResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInitResponse),
            "k_EMsgGCToGCBannedWordListUpdated" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBannedWordListUpdated),
            "k_EMsgGCToGCDirtySDOCache" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCDirtySDOCache),
            "k_EMsgGCToGCUpdateSQLKeyValue" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCUpdateSQLKeyValue),
            "k_EMsgGCToGCBroadcastConsoleCommand" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBroadcastConsoleCommand),
            "k_EMsgGCServerVersionUpdated" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerVersionUpdated),
            "k_EMsgGCApplyAutograph" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyAutograph),
            "k_EMsgGCToGCWebAPIAccountChanged" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCWebAPIAccountChanged),
            "k_EMsgGCClientVersionUpdated" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientVersionUpdated),
            "k_EMsgGCToGCUpdateWelcomeMsg" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCUpdateWelcomeMsg),
            "k_EMsgGCToGCPlayerStrangeCountAdjustments" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPlayerStrangeCountAdjustments),
            "k_EMsgGCRequestStoreSalesData" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesData),
            "k_EMsgGCRequestStoreSalesDataResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesDataResponse),
            "k_EMsgGCRequestStoreSalesDataUpToDateResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesDataUpToDateResponse),
            "k_EMsgGCToGCPingRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPingRequest),
            "k_EMsgGCToGCPingResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPingResponse),
            "k_EMsgGCToGCGetUserSessionServer" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserSessionServer),
            "k_EMsgGCToGCGetUserSessionServerResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserSessionServerResponse),
            "k_EMsgGCToGCGetUserServerMembers" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserServerMembers),
            "k_EMsgGCToGCGetUserServerMembersResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserServerMembersResponse),
            "k_EMsgGCToGCCanUseDropRateBonus" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCCanUseDropRateBonus),
            "k_EMsgSQLAddDropRateBonus" => ::std::option::Option::Some(EGCItemMsg::k_EMsgSQLAddDropRateBonus),
            "k_EMsgGCToGCRefreshSOCache" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCRefreshSOCache),
            "k_EMsgGCToGCGrantAccountRolledItems" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGrantAccountRolledItems),
            "k_EMsgGCToGCGrantSelfMadeItemToAccount" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGrantSelfMadeItemToAccount),
            "k_EMsgGCStatueCraft" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStatueCraft),
            "k_EMsgGCRedeemCode" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRedeemCode),
            "k_EMsgGCRedeemCodeResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRedeemCodeResponse),
            "k_EMsgGCToGCItemConsumptionRollback" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCItemConsumptionRollback),
            "k_EMsgClientToGCWrapAndDeliverGift" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCWrapAndDeliverGift),
            "k_EMsgClientToGCWrapAndDeliverGiftResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCWrapAndDeliverGiftResponse),
            "k_EMsgClientToGCUnpackBundleResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnpackBundleResponse),
            "k_EMsgGCToClientStoreTransactionCompleted" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToClientStoreTransactionCompleted),
            "k_EMsgClientToGCEquipItems" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCEquipItems),
            "k_EMsgClientToGCEquipItemsResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCEquipItemsResponse),
            "k_EMsgClientToGCUnlockItemStyle" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnlockItemStyle),
            "k_EMsgClientToGCUnlockItemStyleResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnlockItemStyleResponse),
            "k_EMsgClientToGCSetItemInventoryCategory" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCSetItemInventoryCategory),
            "k_EMsgClientToGCUnlockCrate" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnlockCrate),
            "k_EMsgClientToGCUnlockCrateResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnlockCrateResponse),
            "k_EMsgClientToGCUnpackBundle" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnpackBundle),
            "k_EMsgClientToGCSetItemStyle" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCSetItemStyle),
            "k_EMsgClientToGCSetItemStyleResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCSetItemStyleResponse),
            "k_EMsgSQLGCToGCGrantBackpackSlots" => ::std::option::Option::Some(EGCItemMsg::k_EMsgSQLGCToGCGrantBackpackSlots),
            "k_EMsgClientToGCLookupAccountName" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCLookupAccountName),
            "k_EMsgClientToGCLookupAccountNameResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCLookupAccountNameResponse),
            "k_EMsgClientToGCCreateStaticRecipe" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCCreateStaticRecipe),
            "k_EMsgClientToGCCreateStaticRecipeResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCCreateStaticRecipeResponse),
            "k_EMsgGCToGCStoreProcessCDKeyTransaction" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCStoreProcessCDKeyTransaction),
            "k_EMsgGCToGCStoreProcessCDKeyTransactionResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCStoreProcessCDKeyTransactionResponse),
            "k_EMsgGCToGCStoreProcessSettlement" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCStoreProcessSettlement),
            "k_EMsgGCToGCStoreProcessSettlementResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCStoreProcessSettlementResponse),
            "k_EMsgGCToGCConsoleOutput" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCConsoleOutput),
            "k_EMsgGCToClientItemAges" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToClientItemAges),
            "k_EMsgGCToGCInternalTestMsg" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCInternalTestMsg),
            "k_EMsgGCToGCClientServerVersionsUpdated" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCClientServerVersionsUpdated),
            "k_EMsgGCUseMultipleItemsRequest" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseMultipleItemsRequest),
            "k_EMsgGCGetAccountSubscriptionItem" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGetAccountSubscriptionItem),
            "k_EMsgGCGetAccountSubscriptionItemResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGetAccountSubscriptionItemResponse),
            "k_EMsgGCToGCBroadcastMessageFromSub" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBroadcastMessageFromSub),
            "k_EMsgGCToClientCurrencyPricePoints" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToClientCurrencyPricePoints),
            "k_EMsgGCToGCAddSubscriptionTime" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCAddSubscriptionTime),
            "k_EMsgGCToGCFlushSteamInventoryCache" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCFlushSteamInventoryCache),
            "k_EMsgGCRequestCrateEscalationLevel" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestCrateEscalationLevel),
            "k_EMsgGCRequestCrateEscalationLevelResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestCrateEscalationLevelResponse),
            "k_EMsgGCToGCUpdateSubscriptionItems" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCUpdateSubscriptionItems),
            "k_EMsgGCToGCSelfPing" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCSelfPing),
            "k_EMsgGCToGCGetInfuxIntervalStats" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetInfuxIntervalStats),
            "k_EMsgGCToGCGetInfuxIntervalStatsResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetInfuxIntervalStatsResponse),
            "k_EMsgGCToGCPurchaseSucceeded" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPurchaseSucceeded),
            "k_EMsgClientToGCGetLimitedItemPurchaseQuantity" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCGetLimitedItemPurchaseQuantity),
            "k_EMsgClientToGCGetLimitedItemPurchaseQuantityResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCGetLimitedItemPurchaseQuantityResponse),
            "k_EMsgGCToGCBetaDeleteItems" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBetaDeleteItems),
            "k_EMsgClientToGCGetInFlightItemCharges" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCGetInFlightItemCharges),
            "k_EMsgClientToGCGetInFlightItemChargesResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCGetInFlightItemChargesResponse),
            "k_EMsgGCToClientInFlightChargesUpdated" => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToClientInFlightChargesUpdated),
            "k_EMsgClientToGCPurchaseChargeCostItems" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCPurchaseChargeCostItems),
            "k_EMsgClientToGCPurchaseChargeCostItemsResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCPurchaseChargeCostItemsResponse),
            "k_EMsgClientToGCCancelUnfinalizedTransactions" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCCancelUnfinalizedTransactions),
            "k_EMsgClientToGCCancelUnfinalizedTransactionsResponse" => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCCancelUnfinalizedTransactionsResponse),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGCItemMsg] = &[
        EGCItemMsg::k_EMsgGCBase,
        EGCItemMsg::k_EMsgGCSetItemPosition,
        EGCItemMsg::k_EMsgClientToGCPackBundle,
        EGCItemMsg::k_EMsgClientToGCPackBundleResponse,
        EGCItemMsg::k_EMsgGCDelete,
        EGCItemMsg::k_EMsgGCVerifyCacheSubscription,
        EGCItemMsg::k_EMsgClientToGCNameItem,
        EGCItemMsg::k_EMsgGCPaintItem,
        EGCItemMsg::k_EMsgGCPaintItemResponse,
        EGCItemMsg::k_EMsgGCNameBaseItem,
        EGCItemMsg::k_EMsgGCNameBaseItemResponse,
        EGCItemMsg::k_EMsgGCUseItemRequest,
        EGCItemMsg::k_EMsgGCUseItemResponse,
        EGCItemMsg::k_EMsgGCGiftedItems,
        EGCItemMsg::k_EMsgGCUnwrapGiftRequest,
        EGCItemMsg::k_EMsgGCUnwrapGiftResponse,
        EGCItemMsg::k_EMsgGCSortItems,
        EGCItemMsg::k_EMsgGCBackpackSortFinished,
        EGCItemMsg::k_EMsgGCAdjustItemEquippedState,
        EGCItemMsg::k_EMsgGCItemAcknowledged,
        EGCItemMsg::k_EMsgClientToGCNameItemResponse,
        EGCItemMsg::k_EMsgGCApplyStrangePart,
        EGCItemMsg::k_EMsgGCApplyPennantUpgrade,
        EGCItemMsg::k_EMsgGCSetItemPositions,
        EGCItemMsg::k_EMsgGCApplyEggEssence,
        EGCItemMsg::k_EMsgGCNameEggEssenceResponse,
        EGCItemMsg::k_EMsgGCExtractGems,
        EGCItemMsg::k_EMsgGCAddSocket,
        EGCItemMsg::k_EMsgGCAddItemToSocket,
        EGCItemMsg::k_EMsgGCAddItemToSocketResponse,
        EGCItemMsg::k_EMsgGCAddSocketResponse,
        EGCItemMsg::k_EMsgGCResetStrangeGemCount,
        EGCItemMsg::k_EMsgGCRequestCrateItems,
        EGCItemMsg::k_EMsgGCRequestCrateItemsResponse,
        EGCItemMsg::k_EMsgGCExtractGemsResponse,
        EGCItemMsg::k_EMsgGCResetStrangeGemCountResponse,
        EGCItemMsg::k_EMsgGCServerUseItemRequest,
        EGCItemMsg::k_EMsgGCAddGiftItem,
        EGCItemMsg::k_EMsgSQLGCToGCRevokeUntrustedGift,
        EGCItemMsg::k_EMsgClientToGCRemoveItemGifterAttributes,
        EGCItemMsg::k_EMsgClientToGCRemoveItemName,
        EGCItemMsg::k_EMsgClientToGCRemoveItemDescription,
        EGCItemMsg::k_EMsgClientToGCRemoveItemAttributeResponse,
        EGCItemMsg::k_EMsgGCDev_NewItemRequest,
        EGCItemMsg::k_EMsgGCDev_NewItemRequestResponse,
        EGCItemMsg::k_EMsgGCDev_UnlockAllItemStylesRequest,
        EGCItemMsg::k_EMsgGCDev_UnlockAllItemStylesResponse,
        EGCItemMsg::k_EMsgGCStorePurchaseFinalize,
        EGCItemMsg::k_EMsgGCStorePurchaseFinalizeResponse,
        EGCItemMsg::k_EMsgGCStorePurchaseCancel,
        EGCItemMsg::k_EMsgGCStorePurchaseCancelResponse,
        EGCItemMsg::k_EMsgGCStorePurchaseInit,
        EGCItemMsg::k_EMsgGCStorePurchaseInitResponse,
        EGCItemMsg::k_EMsgGCToGCBannedWordListUpdated,
        EGCItemMsg::k_EMsgGCToGCDirtySDOCache,
        EGCItemMsg::k_EMsgGCToGCUpdateSQLKeyValue,
        EGCItemMsg::k_EMsgGCToGCBroadcastConsoleCommand,
        EGCItemMsg::k_EMsgGCServerVersionUpdated,
        EGCItemMsg::k_EMsgGCApplyAutograph,
        EGCItemMsg::k_EMsgGCToGCWebAPIAccountChanged,
        EGCItemMsg::k_EMsgGCClientVersionUpdated,
        EGCItemMsg::k_EMsgGCToGCUpdateWelcomeMsg,
        EGCItemMsg::k_EMsgGCToGCPlayerStrangeCountAdjustments,
        EGCItemMsg::k_EMsgGCRequestStoreSalesData,
        EGCItemMsg::k_EMsgGCRequestStoreSalesDataResponse,
        EGCItemMsg::k_EMsgGCRequestStoreSalesDataUpToDateResponse,
        EGCItemMsg::k_EMsgGCToGCPingRequest,
        EGCItemMsg::k_EMsgGCToGCPingResponse,
        EGCItemMsg::k_EMsgGCToGCGetUserSessionServer,
        EGCItemMsg::k_EMsgGCToGCGetUserSessionServerResponse,
        EGCItemMsg::k_EMsgGCToGCGetUserServerMembers,
        EGCItemMsg::k_EMsgGCToGCGetUserServerMembersResponse,
        EGCItemMsg::k_EMsgGCToGCCanUseDropRateBonus,
        EGCItemMsg::k_EMsgSQLAddDropRateBonus,
        EGCItemMsg::k_EMsgGCToGCRefreshSOCache,
        EGCItemMsg::k_EMsgGCToGCGrantAccountRolledItems,
        EGCItemMsg::k_EMsgGCToGCGrantSelfMadeItemToAccount,
        EGCItemMsg::k_EMsgGCStatueCraft,
        EGCItemMsg::k_EMsgGCRedeemCode,
        EGCItemMsg::k_EMsgGCRedeemCodeResponse,
        EGCItemMsg::k_EMsgGCToGCItemConsumptionRollback,
        EGCItemMsg::k_EMsgClientToGCWrapAndDeliverGift,
        EGCItemMsg::k_EMsgClientToGCWrapAndDeliverGiftResponse,
        EGCItemMsg::k_EMsgClientToGCUnpackBundleResponse,
        EGCItemMsg::k_EMsgGCToClientStoreTransactionCompleted,
        EGCItemMsg::k_EMsgClientToGCEquipItems,
        EGCItemMsg::k_EMsgClientToGCEquipItemsResponse,
        EGCItemMsg::k_EMsgClientToGCUnlockItemStyle,
        EGCItemMsg::k_EMsgClientToGCUnlockItemStyleResponse,
        EGCItemMsg::k_EMsgClientToGCSetItemInventoryCategory,
        EGCItemMsg::k_EMsgClientToGCUnlockCrate,
        EGCItemMsg::k_EMsgClientToGCUnlockCrateResponse,
        EGCItemMsg::k_EMsgClientToGCUnpackBundle,
        EGCItemMsg::k_EMsgClientToGCSetItemStyle,
        EGCItemMsg::k_EMsgClientToGCSetItemStyleResponse,
        EGCItemMsg::k_EMsgSQLGCToGCGrantBackpackSlots,
        EGCItemMsg::k_EMsgClientToGCLookupAccountName,
        EGCItemMsg::k_EMsgClientToGCLookupAccountNameResponse,
        EGCItemMsg::k_EMsgClientToGCCreateStaticRecipe,
        EGCItemMsg::k_EMsgClientToGCCreateStaticRecipeResponse,
        EGCItemMsg::k_EMsgGCToGCStoreProcessCDKeyTransaction,
        EGCItemMsg::k_EMsgGCToGCStoreProcessCDKeyTransactionResponse,
        EGCItemMsg::k_EMsgGCToGCStoreProcessSettlement,
        EGCItemMsg::k_EMsgGCToGCStoreProcessSettlementResponse,
        EGCItemMsg::k_EMsgGCToGCConsoleOutput,
        EGCItemMsg::k_EMsgGCToClientItemAges,
        EGCItemMsg::k_EMsgGCToGCInternalTestMsg,
        EGCItemMsg::k_EMsgGCToGCClientServerVersionsUpdated,
        EGCItemMsg::k_EMsgGCUseMultipleItemsRequest,
        EGCItemMsg::k_EMsgGCGetAccountSubscriptionItem,
        EGCItemMsg::k_EMsgGCGetAccountSubscriptionItemResponse,
        EGCItemMsg::k_EMsgGCToGCBroadcastMessageFromSub,
        EGCItemMsg::k_EMsgGCToClientCurrencyPricePoints,
        EGCItemMsg::k_EMsgGCToGCAddSubscriptionTime,
        EGCItemMsg::k_EMsgGCToGCFlushSteamInventoryCache,
        EGCItemMsg::k_EMsgGCRequestCrateEscalationLevel,
        EGCItemMsg::k_EMsgGCRequestCrateEscalationLevelResponse,
        EGCItemMsg::k_EMsgGCToGCUpdateSubscriptionItems,
        EGCItemMsg::k_EMsgGCToGCSelfPing,
        EGCItemMsg::k_EMsgGCToGCGetInfuxIntervalStats,
        EGCItemMsg::k_EMsgGCToGCGetInfuxIntervalStatsResponse,
        EGCItemMsg::k_EMsgGCToGCPurchaseSucceeded,
        EGCItemMsg::k_EMsgClientToGCGetLimitedItemPurchaseQuantity,
        EGCItemMsg::k_EMsgClientToGCGetLimitedItemPurchaseQuantityResponse,
        EGCItemMsg::k_EMsgGCToGCBetaDeleteItems,
        EGCItemMsg::k_EMsgClientToGCGetInFlightItemCharges,
        EGCItemMsg::k_EMsgClientToGCGetInFlightItemChargesResponse,
        EGCItemMsg::k_EMsgGCToClientInFlightChargesUpdated,
        EGCItemMsg::k_EMsgClientToGCPurchaseChargeCostItems,
        EGCItemMsg::k_EMsgClientToGCPurchaseChargeCostItemsResponse,
        EGCItemMsg::k_EMsgClientToGCCancelUnfinalizedTransactions,
        EGCItemMsg::k_EMsgClientToGCCancelUnfinalizedTransactionsResponse,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGCItemMsg {
    fn default() -> Self {
        EGCItemMsg::k_EMsgGCBase
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGCMsgInitiateTradeResponse)
pub enum EGCMsgInitiateTradeResponse {
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Accepted)
    k_EGCMsgInitiateTradeResponse_Accepted = 0,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Declined)
    k_EGCMsgInitiateTradeResponse_Declined = 1,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_VAC_Banned_Initiator)
    k_EGCMsgInitiateTradeResponse_VAC_Banned_Initiator = 2,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_VAC_Banned_Target)
    k_EGCMsgInitiateTradeResponse_VAC_Banned_Target = 3,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Target_Already_Trading)
    k_EGCMsgInitiateTradeResponse_Target_Already_Trading = 4,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Disabled)
    k_EGCMsgInitiateTradeResponse_Disabled = 5,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_NotLoggedIn)
    k_EGCMsgInitiateTradeResponse_NotLoggedIn = 6,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Cancel)
    k_EGCMsgInitiateTradeResponse_Cancel = 7,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_TooSoon)
    k_EGCMsgInitiateTradeResponse_TooSoon = 8,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_TooSoonPenalty)
    k_EGCMsgInitiateTradeResponse_TooSoonPenalty = 9,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Trade_Banned_Initiator)
    k_EGCMsgInitiateTradeResponse_Trade_Banned_Initiator = 10,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Trade_Banned_Target)
    k_EGCMsgInitiateTradeResponse_Trade_Banned_Target = 11,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Free_Account_Initiator_DEPRECATED)
    k_EGCMsgInitiateTradeResponse_Free_Account_Initiator_DEPRECATED = 12,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Shared_Account_Initiator)
    k_EGCMsgInitiateTradeResponse_Shared_Account_Initiator = 13,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Service_Unavailable)
    k_EGCMsgInitiateTradeResponse_Service_Unavailable = 14,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Target_Blocked)
    k_EGCMsgInitiateTradeResponse_Target_Blocked = 15,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_NeedVerifiedEmail)
    k_EGCMsgInitiateTradeResponse_NeedVerifiedEmail = 16,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_NeedSteamGuard)
    k_EGCMsgInitiateTradeResponse_NeedSteamGuard = 17,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_SteamGuardDuration)
    k_EGCMsgInitiateTradeResponse_SteamGuardDuration = 18,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_TheyCannotTrade)
    k_EGCMsgInitiateTradeResponse_TheyCannotTrade = 19,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Recent_Password_Reset)
    k_EGCMsgInitiateTradeResponse_Recent_Password_Reset = 20,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Using_New_Device)
    k_EGCMsgInitiateTradeResponse_Using_New_Device = 21,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_Sent_Invalid_Cookie)
    k_EGCMsgInitiateTradeResponse_Sent_Invalid_Cookie = 22,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_TooRecentFriend)
    k_EGCMsgInitiateTradeResponse_TooRecentFriend = 23,
    // @@protoc_insertion_point(enum_value:EGCMsgInitiateTradeResponse.k_EGCMsgInitiateTradeResponse_WalledFundsNotTrusted)
    k_EGCMsgInitiateTradeResponse_WalledFundsNotTrusted = 24,
}

impl ::steam_vent_proto_common::protobuf::Enum for EGCMsgInitiateTradeResponse {
    const NAME: &'static str = "EGCMsgInitiateTradeResponse";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCMsgInitiateTradeResponse> {
        match value {
            0 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted),
            1 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Declined),
            2 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_VAC_Banned_Initiator),
            3 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_VAC_Banned_Target),
            4 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Target_Already_Trading),
            5 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Disabled),
            6 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NotLoggedIn),
            7 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Cancel),
            8 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooSoon),
            9 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooSoonPenalty),
            10 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Trade_Banned_Initiator),
            11 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Trade_Banned_Target),
            12 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Free_Account_Initiator_DEPRECATED),
            13 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Shared_Account_Initiator),
            14 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Service_Unavailable),
            15 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Target_Blocked),
            16 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NeedVerifiedEmail),
            17 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NeedSteamGuard),
            18 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_SteamGuardDuration),
            19 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TheyCannotTrade),
            20 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Recent_Password_Reset),
            21 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Using_New_Device),
            22 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Sent_Invalid_Cookie),
            23 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooRecentFriend),
            24 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_WalledFundsNotTrusted),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGCMsgInitiateTradeResponse> {
        match str {
            "k_EGCMsgInitiateTradeResponse_Accepted" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted),
            "k_EGCMsgInitiateTradeResponse_Declined" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Declined),
            "k_EGCMsgInitiateTradeResponse_VAC_Banned_Initiator" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_VAC_Banned_Initiator),
            "k_EGCMsgInitiateTradeResponse_VAC_Banned_Target" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_VAC_Banned_Target),
            "k_EGCMsgInitiateTradeResponse_Target_Already_Trading" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Target_Already_Trading),
            "k_EGCMsgInitiateTradeResponse_Disabled" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Disabled),
            "k_EGCMsgInitiateTradeResponse_NotLoggedIn" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NotLoggedIn),
            "k_EGCMsgInitiateTradeResponse_Cancel" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Cancel),
            "k_EGCMsgInitiateTradeResponse_TooSoon" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooSoon),
            "k_EGCMsgInitiateTradeResponse_TooSoonPenalty" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooSoonPenalty),
            "k_EGCMsgInitiateTradeResponse_Trade_Banned_Initiator" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Trade_Banned_Initiator),
            "k_EGCMsgInitiateTradeResponse_Trade_Banned_Target" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Trade_Banned_Target),
            "k_EGCMsgInitiateTradeResponse_Free_Account_Initiator_DEPRECATED" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Free_Account_Initiator_DEPRECATED),
            "k_EGCMsgInitiateTradeResponse_Shared_Account_Initiator" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Shared_Account_Initiator),
            "k_EGCMsgInitiateTradeResponse_Service_Unavailable" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Service_Unavailable),
            "k_EGCMsgInitiateTradeResponse_Target_Blocked" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Target_Blocked),
            "k_EGCMsgInitiateTradeResponse_NeedVerifiedEmail" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NeedVerifiedEmail),
            "k_EGCMsgInitiateTradeResponse_NeedSteamGuard" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NeedSteamGuard),
            "k_EGCMsgInitiateTradeResponse_SteamGuardDuration" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_SteamGuardDuration),
            "k_EGCMsgInitiateTradeResponse_TheyCannotTrade" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TheyCannotTrade),
            "k_EGCMsgInitiateTradeResponse_Recent_Password_Reset" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Recent_Password_Reset),
            "k_EGCMsgInitiateTradeResponse_Using_New_Device" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Using_New_Device),
            "k_EGCMsgInitiateTradeResponse_Sent_Invalid_Cookie" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Sent_Invalid_Cookie),
            "k_EGCMsgInitiateTradeResponse_TooRecentFriend" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooRecentFriend),
            "k_EGCMsgInitiateTradeResponse_WalledFundsNotTrusted" => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_WalledFundsNotTrusted),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGCMsgInitiateTradeResponse] = &[
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Declined,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_VAC_Banned_Initiator,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_VAC_Banned_Target,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Target_Already_Trading,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Disabled,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NotLoggedIn,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Cancel,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooSoon,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooSoonPenalty,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Trade_Banned_Initiator,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Trade_Banned_Target,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Free_Account_Initiator_DEPRECATED,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Shared_Account_Initiator,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Service_Unavailable,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Target_Blocked,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NeedVerifiedEmail,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NeedSteamGuard,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_SteamGuardDuration,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TheyCannotTrade,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Recent_Password_Reset,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Using_New_Device,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Sent_Invalid_Cookie,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooRecentFriend,
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_WalledFundsNotTrusted,
    ];
}

impl ::std::default::Default for EGCMsgInitiateTradeResponse {
    fn default() -> Self {
        EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::steammessages::*;
#[allow(unused_imports)]
use crate::econ_shared_enums::*;
#[allow(unused_imports)]
use crate::gcsdk_gcmessages::*;
#[allow(unused_imports)]
use crate::base_gcmessages::*;
impl ::steam_vent_proto_common::RpcMessage for CMsgApplyAutograph {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgApplyAutograph {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCApplyAutograph;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgAdjustItemEquippedState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgAdjustItemEquippedState {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCAdjustItemEquippedState;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgEconPlayerStrangeCountAdjustment {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgCraftingResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCRequestStoreSalesData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCRequestStoreSalesData {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCRequestStoreSalesData;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCRequestStoreSalesDataResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCRequestStoreSalesDataResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCRequestStoreSalesDataResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCRequestStoreSalesDataUpToDateResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCRequestStoreSalesDataUpToDateResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCRequestStoreSalesDataUpToDateResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCPingRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToGCPingRequest {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCPingRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCPingResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToGCPingResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCPingResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCGetUserSessionServer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToGCGetUserSessionServer {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCGetUserSessionServer;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCGetUserSessionServerResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToGCGetUserSessionServerResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCGetUserSessionServerResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCGetUserServerMembers {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToGCGetUserServerMembers {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCGetUserServerMembers;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCGetUserServerMembersResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToGCGetUserServerMembersResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCGetUserServerMembersResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLookupMultipleAccountNames {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLookupMultipleAccountNamesResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgRequestCrateItems {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgRequestCrateItems {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCRequestCrateItems;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgRequestCrateItemsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgRequestCrateItemsResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCRequestCrateItemsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgRequestCrateEscalationLevel {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgRequestCrateEscalationLevel {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCRequestCrateEscalationLevel;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgRequestCrateEscalationLevelResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgRequestCrateEscalationLevelResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCRequestCrateEscalationLevelResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCCanUseDropRateBonus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToGCCanUseDropRateBonus {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCCanUseDropRateBonus;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSQLAddDropRateBonus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSQLAddDropRateBonus {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgSQLAddDropRateBonus;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSQLUpgradeBattleBooster {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCRefreshSOCache {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToGCRefreshSOCache {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCRefreshSOCache;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCAddSubscriptionTime {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToGCAddSubscriptionTime {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCAddSubscriptionTime;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCGrantAccountRolledItems {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToGCGrantAccountRolledItems {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCGrantAccountRolledItems;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCBetaDeleteItems {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToGCBetaDeleteItems {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCBetaDeleteItems;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCGrantSelfMadeItemToAccount {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToGCGrantSelfMadeItemToAccount {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCGrantSelfMadeItemToAccount;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgUseItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerUseItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgUseMultipleItems {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGCStoreRechargeRedirect_LineItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCEconSQLWorkItemEmbeddedRollbackData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgCraftStatue {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgRedeemCode {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgRedeemCode {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCRedeemCode;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgRedeemCodeResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgRedeemCodeResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCRedeemCodeResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDevNewItemRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDevNewItemRequestResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDevUnlockAllItemStyles {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDevUnlockAllItemStylesResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCGetAccountSubscriptionItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCGetAccountSubscriptionItem {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCGetAccountSubscriptionItem;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCGetAccountSubscriptionItemResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCGetAccountSubscriptionItemResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCGetAccountSubscriptionItemResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCAddGiftItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCAddGiftItem {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCAddGiftItem;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCWrapAndDeliverGift {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCWrapAndDeliverGift {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCWrapAndDeliverGift;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSQLGCToGCRevokeUntrustedGift {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSQLGCToGCRevokeUntrustedGift {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgSQLGCToGCRevokeUntrustedGift;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCWrapAndDeliverGiftResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCWrapAndDeliverGiftResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCWrapAndDeliverGiftResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCUnwrapGift {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetGiftPermissions {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCGetGiftPermissions {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetGiftPermissions;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetGiftPermissionsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetGiftPermissionsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetGiftPermissionsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCUnpackBundle {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCUnpackBundle {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCUnpackBundle;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCUnpackBundleResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCUnpackBundleResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCUnpackBundleResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCPackBundle {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCPackBundle {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCPackBundle;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCPackBundleResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCPackBundleResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCPackBundleResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientStoreTransactionCompleted {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientStoreTransactionCompleted {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToClientStoreTransactionCompleted;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCEquipItems {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCEquipItems {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCEquipItems;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCEquipItemsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCEquipItemsResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCEquipItemsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCSetItemStyle {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCSetItemStyle {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCSetItemStyle;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCSetItemStyleResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSetItemStyleResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCSetItemStyleResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCUnlockItemStyle {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCUnlockItemStyle {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCUnlockItemStyle;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCUnlockItemStyleResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCUnlockItemStyleResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCUnlockItemStyleResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCSetItemInventoryCategory {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSetItemInventoryCategory {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCSetItemInventoryCategory;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCUnlockCrate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCUnlockCrate {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCUnlockCrate;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCUnlockCrateResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCUnlockCrateResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCUnlockCrateResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRemoveItemAttribute {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRemoveItemAttributeResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRemoveItemAttributeResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCRemoveItemAttributeResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCNameItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCNameItem {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCNameItem;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCNameItemResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCNameItemResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCNameItemResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCSetItemPosition {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCSetItemPosition {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCSetItemPosition;
}
impl ::steam_vent_proto_common::RpcMessage for CAttribute_ItemDynamicRecipeComponent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CProtoItemSocket {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CProtoItemSocket_Empty {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CProtoItemSocket_Effect {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CProtoItemSocket_Color {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CProtoItemSocket_Strange {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CProtoItemSocket_Strange_DESERIALIZE_FROM_STRING_ONLY {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CProtoItemSocket_Spectator {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CProtoItemSocket_AssetModifier {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CProtoItemSocket_Autograph {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CProtoItemSocket_StaticVisuals {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CAttribute_String {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CWorkshop_GetItemDailyRevenue_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CWorkshop_GetItemDailyRevenue_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CWorkshop_GetPackageDailyRevenue_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CWorkshop_GetPackageDailyRevenue_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSQLGCToGCGrantBackpackSlots {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSQLGCToGCGrantBackpackSlots {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgSQLGCToGCGrantBackpackSlots;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCLookupAccountName {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCLookupAccountName {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCLookupAccountName;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCLookupAccountNameResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCLookupAccountNameResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCLookupAccountNameResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCCreateStaticRecipe {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCCreateStaticRecipe {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCCreateStaticRecipe;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCCreateStaticRecipeResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCreateStaticRecipeResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCCreateStaticRecipeResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgProcessTransactionOrder {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCStoreProcessCDKeyTransaction {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToGCStoreProcessCDKeyTransaction {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCStoreProcessCDKeyTransaction;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToGCStoreProcessCDKeyTransactionResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToGCStoreProcessCDKeyTransactionResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCStoreProcessCDKeyTransactionResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCStoreProcessSettlement {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToGCStoreProcessSettlement {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCStoreProcessSettlement;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCStoreProcessSettlementResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToGCStoreProcessSettlementResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCStoreProcessSettlementResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCBroadcastConsoleCommand {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToGCBroadcastConsoleCommand {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCBroadcastConsoleCommand;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCConsoleOutput {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToGCConsoleOutput {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCConsoleOutput;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgItemAges {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCInternalTestMsg {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToGCInternalTestMsg {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCInternalTestMsg;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCClientServerVersionsUpdated {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToGCClientServerVersionsUpdated {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCClientServerVersionsUpdated;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCBroadcastMessageFromSub {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToGCBroadcastMessageFromSub {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCBroadcastMessageFromSub;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientCurrencyPricePoints {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientCurrencyPricePoints {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToClientCurrencyPricePoints;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgBannedWordList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCFlushSteamInventoryCache {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToGCFlushSteamInventoryCache {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCFlushSteamInventoryCache;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCUpdateSubscriptionItems {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToGCUpdateSubscriptionItems {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCUpdateSubscriptionItems;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCSelfPing {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToGCSelfPing {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCSelfPing;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCGetInfuxIntervalStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToGCGetInfuxIntervalStats {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCGetInfuxIntervalStats;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCGetInfuxIntervalStatsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToGCGetInfuxIntervalStatsResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCGetInfuxIntervalStatsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCPurchaseSucceeded {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToGCPurchaseSucceeded {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCPurchaseSucceeded;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCGetLimitedItemPurchaseQuantity {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetLimitedItemPurchaseQuantity {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCGetLimitedItemPurchaseQuantity;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetLimitedItemPurchaseQuantityResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCGetLimitedItemPurchaseQuantityResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetInFlightItemCharges {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetInFlightItemCharges {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCGetInFlightItemCharges;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCGetInFlightItemChargesResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetInFlightItemChargesResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCGetInFlightItemChargesResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCPurchaseChargeCostItems {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCPurchaseChargeCostItems {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCPurchaseChargeCostItems;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCPurchaseChargeCostItemsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCPurchaseChargeCostItemsResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCPurchaseChargeCostItemsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientInFlightChargesUpdated {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientInFlightChargesUpdated {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToClientInFlightChargesUpdated;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCCancelUnfinalizedTransactions {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCancelUnfinalizedTransactions {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCCancelUnfinalizedTransactions;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCCancelUnfinalizedTransactionsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCancelUnfinalizedTransactionsResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgClientToGCCancelUnfinalizedTransactionsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCUpdateWelcomeMsg {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToGCUpdateWelcomeMsg {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCUpdateWelcomeMsg;
}
impl ::steam_vent_proto_common::MsgKindEnum for EGCItemMsg {}
