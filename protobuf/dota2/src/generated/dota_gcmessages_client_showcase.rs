// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_client_showcase.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CMsgShowcaseEconItemReference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseEconItemReference {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseEconItemReference.id)
    pub id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgShowcaseEconItemReference.original_id)
    pub original_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgShowcaseEconItemReference.definition_index)
    pub definition_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseEconItemReference.equipment_slot_index)
    pub equipment_slot_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseEconItemReference.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseEconItemReference {
    fn default() -> &'a CMsgShowcaseEconItemReference {
        <CMsgShowcaseEconItemReference as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseEconItemReference {
    pub fn new() -> CMsgShowcaseEconItemReference {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;

    pub fn id(&self) -> u64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint64 original_id = 2;

    pub fn original_id(&self) -> u64 {
        self.original_id.unwrap_or(0)
    }

    pub fn clear_original_id(&mut self) {
        self.original_id = ::std::option::Option::None;
    }

    pub fn has_original_id(&self) -> bool {
        self.original_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_id(&mut self, v: u64) {
        self.original_id = ::std::option::Option::Some(v);
    }

    // optional uint32 definition_index = 3;

    pub fn definition_index(&self) -> u32 {
        self.definition_index.unwrap_or(0)
    }

    pub fn clear_definition_index(&mut self) {
        self.definition_index = ::std::option::Option::None;
    }

    pub fn has_definition_index(&self) -> bool {
        self.definition_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_definition_index(&mut self, v: u32) {
        self.definition_index = ::std::option::Option::Some(v);
    }

    // optional int32 equipment_slot_index = 4;

    pub fn equipment_slot_index(&self) -> i32 {
        self.equipment_slot_index.unwrap_or(-1i32)
    }

    pub fn clear_equipment_slot_index(&mut self) {
        self.equipment_slot_index = ::std::option::Option::None;
    }

    pub fn has_equipment_slot_index(&self) -> bool {
        self.equipment_slot_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_equipment_slot_index(&mut self, v: i32) {
        self.equipment_slot_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseEconItemReference {
    const NAME: &'static str = "CMsgShowcaseEconItemReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.original_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.definition_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.equipment_slot_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.original_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.definition_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.equipment_slot_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.original_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.definition_index {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.equipment_slot_index {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseEconItemReference {
        CMsgShowcaseEconItemReference::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.original_id = ::std::option::Option::None;
        self.definition_index = ::std::option::Option::None;
        self.equipment_slot_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseEconItemReference {
        static instance: CMsgShowcaseEconItemReference = CMsgShowcaseEconItemReference {
            id: ::std::option::Option::None,
            original_id: ::std::option::Option::None,
            definition_index: ::std::option::Option::None,
            equipment_slot_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgHeroPlusInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHeroPlusInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgHeroPlusInfo.flags)
    pub flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHeroPlusInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHeroPlusInfo {
    fn default() -> &'a CMsgHeroPlusInfo {
        <CMsgHeroPlusInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgHeroPlusInfo {
    pub fn new() -> CMsgHeroPlusInfo {
        ::std::default::Default::default()
    }

    // optional uint32 flags = 1;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgHeroPlusInfo {
    const NAME: &'static str = "CMsgHeroPlusInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.flags {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHeroPlusInfo {
        CMsgHeroPlusInfo::new()
    }

    fn clear(&mut self) {
        self.flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHeroPlusInfo {
        static instance: CMsgHeroPlusInfo = CMsgHeroPlusInfo {
            flags: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgShowcaseItem_Trophy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseItem_Trophy {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseItem_Trophy.data)
    pub data: ::steam_vent_proto_common::protobuf::MessageField<cmsg_showcase_item_trophy::Data>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem_Trophy.trophy_id)
    pub trophy_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseItem_Trophy.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseItem_Trophy {
    fn default() -> &'a CMsgShowcaseItem_Trophy {
        <CMsgShowcaseItem_Trophy as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseItem_Trophy {
    pub fn new() -> CMsgShowcaseItem_Trophy {
        ::std::default::Default::default()
    }

    // optional uint32 trophy_id = 2;

    pub fn trophy_id(&self) -> u32 {
        self.trophy_id.unwrap_or(0)
    }

    pub fn clear_trophy_id(&mut self) {
        self.trophy_id = ::std::option::Option::None;
    }

    pub fn has_trophy_id(&self) -> bool {
        self.trophy_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trophy_id(&mut self, v: u32) {
        self.trophy_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseItem_Trophy {
    const NAME: &'static str = "CMsgShowcaseItem_Trophy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                16 => {
                    self.trophy_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.trophy_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.trophy_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseItem_Trophy {
        CMsgShowcaseItem_Trophy::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.trophy_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseItem_Trophy {
        static instance: CMsgShowcaseItem_Trophy = CMsgShowcaseItem_Trophy {
            data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            trophy_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgShowcaseItem_Trophy`
pub mod cmsg_showcase_item_trophy {
    // @@protoc_insertion_point(message:CMsgShowcaseItem_Trophy.Data)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Data {
        // message fields
        // @@protoc_insertion_point(field:CMsgShowcaseItem_Trophy.Data.trophy_score)
        pub trophy_score: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgShowcaseItem_Trophy.Data.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Data {
        fn default() -> &'a Data {
            <Data as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Data {
        pub fn new() -> Data {
            ::std::default::Default::default()
        }

        // optional uint32 trophy_score = 1;

        pub fn trophy_score(&self) -> u32 {
            self.trophy_score.unwrap_or(0)
        }

        pub fn clear_trophy_score(&mut self) {
            self.trophy_score = ::std::option::Option::None;
        }

        pub fn has_trophy_score(&self) -> bool {
            self.trophy_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_trophy_score(&mut self, v: u32) {
            self.trophy_score = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Data {
        const NAME: &'static str = "Data";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.trophy_score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.trophy_score {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.trophy_score {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Data {
            Data::new()
        }

        fn clear(&mut self) {
            self.trophy_score = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Data {
            static instance: Data = Data {
                trophy_score: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgShowcaseItem_EconItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseItem_EconItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseItem_EconItem.data)
    pub data: ::steam_vent_proto_common::protobuf::MessageField<cmsg_showcase_item_econ_item::Data>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem_EconItem.ref)
    pub ref_: ::steam_vent_proto_common::protobuf::MessageField<CMsgShowcaseEconItemReference>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseItem_EconItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseItem_EconItem {
    fn default() -> &'a CMsgShowcaseItem_EconItem {
        <CMsgShowcaseItem_EconItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseItem_EconItem {
    pub fn new() -> CMsgShowcaseItem_EconItem {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseItem_EconItem {
    const NAME: &'static str = "CMsgShowcaseItem_EconItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.ref_)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ref_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.ref_.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseItem_EconItem {
        CMsgShowcaseItem_EconItem::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.ref_.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseItem_EconItem {
        static instance: CMsgShowcaseItem_EconItem = CMsgShowcaseItem_EconItem {
            data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            ref_: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgShowcaseItem_EconItem`
pub mod cmsg_showcase_item_econ_item {
    // @@protoc_insertion_point(message:CMsgShowcaseItem_EconItem.Data)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Data {
        // message fields
        // @@protoc_insertion_point(field:CMsgShowcaseItem_EconItem.Data.econ_item)
        pub econ_item: ::steam_vent_proto_common::protobuf::MessageField<super::super::base_gcmessages::CSOEconItem>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgShowcaseItem_EconItem.Data.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Data {
        fn default() -> &'a Data {
            <Data as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Data {
        pub fn new() -> Data {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Data {
        const NAME: &'static str = "Data";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.econ_item)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.econ_item.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.econ_item.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Data {
            Data::new()
        }

        fn clear(&mut self) {
            self.econ_item.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Data {
            static instance: Data = Data {
                econ_item: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgShowcaseItem_Hero)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseItem_Hero {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseItem_Hero.data)
    pub data: ::steam_vent_proto_common::protobuf::MessageField<cmsg_showcase_item_hero::Data>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem_Hero.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem_Hero.econ_item_refs)
    pub econ_item_refs: ::std::vec::Vec<CMsgShowcaseEconItemReference>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem_Hero.rotation)
    pub rotation: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem_Hero.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem_Hero.plus_info)
    pub plus_info: ::steam_vent_proto_common::protobuf::MessageField<CMsgHeroPlusInfo>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem_Hero.animation_name)
    pub animation_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem_Hero.animation_playback_speed)
    pub animation_playback_speed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem_Hero.animation_offset)
    pub animation_offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem_Hero.zoom)
    pub zoom: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem_Hero.slot_index)
    pub slot_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem_Hero.model_index)
    pub model_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseItem_Hero.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseItem_Hero {
    fn default() -> &'a CMsgShowcaseItem_Hero {
        <CMsgShowcaseItem_Hero as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseItem_Hero {
    pub fn new() -> CMsgShowcaseItem_Hero {
        ::std::default::Default::default()
    }

    // optional int32 hero_id = 2;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 rotation = 4;

    pub fn rotation(&self) -> u32 {
        self.rotation.unwrap_or(0)
    }

    pub fn clear_rotation(&mut self) {
        self.rotation = ::std::option::Option::None;
    }

    pub fn has_rotation(&self) -> bool {
        self.rotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rotation(&mut self, v: u32) {
        self.rotation = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 5;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional string animation_name = 7;

    pub fn animation_name(&self) -> &str {
        match self.animation_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_animation_name(&mut self) {
        self.animation_name = ::std::option::Option::None;
    }

    pub fn has_animation_name(&self) -> bool {
        self.animation_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_animation_name(&mut self, v: ::std::string::String) {
        self.animation_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_animation_name(&mut self) -> &mut ::std::string::String {
        if self.animation_name.is_none() {
            self.animation_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.animation_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_animation_name(&mut self) -> ::std::string::String {
        self.animation_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 animation_playback_speed = 8;

    pub fn animation_playback_speed(&self) -> u32 {
        self.animation_playback_speed.unwrap_or(100u32)
    }

    pub fn clear_animation_playback_speed(&mut self) {
        self.animation_playback_speed = ::std::option::Option::None;
    }

    pub fn has_animation_playback_speed(&self) -> bool {
        self.animation_playback_speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_animation_playback_speed(&mut self, v: u32) {
        self.animation_playback_speed = ::std::option::Option::Some(v);
    }

    // optional uint32 animation_offset = 9;

    pub fn animation_offset(&self) -> u32 {
        self.animation_offset.unwrap_or(0)
    }

    pub fn clear_animation_offset(&mut self) {
        self.animation_offset = ::std::option::Option::None;
    }

    pub fn has_animation_offset(&self) -> bool {
        self.animation_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_animation_offset(&mut self, v: u32) {
        self.animation_offset = ::std::option::Option::Some(v);
    }

    // optional uint32 zoom = 10;

    pub fn zoom(&self) -> u32 {
        self.zoom.unwrap_or(100u32)
    }

    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: u32) {
        self.zoom = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_index = 11;

    pub fn slot_index(&self) -> u32 {
        self.slot_index.unwrap_or(0)
    }

    pub fn clear_slot_index(&mut self) {
        self.slot_index = ::std::option::Option::None;
    }

    pub fn has_slot_index(&self) -> bool {
        self.slot_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_index(&mut self, v: u32) {
        self.slot_index = ::std::option::Option::Some(v);
    }

    // optional uint32 model_index = 12;

    pub fn model_index(&self) -> u32 {
        self.model_index.unwrap_or(0)
    }

    pub fn clear_model_index(&mut self) {
        self.model_index = ::std::option::Option::None;
    }

    pub fn has_model_index(&self) -> bool {
        self.model_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_index(&mut self, v: u32) {
        self.model_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseItem_Hero {
    const NAME: &'static str = "CMsgShowcaseItem_Hero";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                16 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.econ_item_refs.push(is.read_message()?);
                },
                32 => {
                    self.rotation = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.plus_info)?;
                },
                58 => {
                    self.animation_name = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.animation_playback_speed = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.animation_offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.zoom = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.slot_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.model_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        for value in &self.econ_item_refs {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.rotation {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.plus_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.animation_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.animation_playback_speed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.animation_offset {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.zoom {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.slot_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.model_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(2, v)?;
        }
        for v in &self.econ_item_refs {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.rotation {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.plus_info.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.animation_name.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.animation_playback_speed {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.animation_offset {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.zoom {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.slot_index {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.model_index {
            os.write_uint32(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseItem_Hero {
        CMsgShowcaseItem_Hero::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.hero_id = ::std::option::Option::None;
        self.econ_item_refs.clear();
        self.rotation = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.plus_info.clear();
        self.animation_name = ::std::option::Option::None;
        self.animation_playback_speed = ::std::option::Option::None;
        self.animation_offset = ::std::option::Option::None;
        self.zoom = ::std::option::Option::None;
        self.slot_index = ::std::option::Option::None;
        self.model_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseItem_Hero {
        static instance: CMsgShowcaseItem_Hero = CMsgShowcaseItem_Hero {
            data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            hero_id: ::std::option::Option::None,
            econ_item_refs: ::std::vec::Vec::new(),
            rotation: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            plus_info: ::steam_vent_proto_common::protobuf::MessageField::none(),
            animation_name: ::std::option::Option::None,
            animation_playback_speed: ::std::option::Option::None,
            animation_offset: ::std::option::Option::None,
            zoom: ::std::option::Option::None,
            slot_index: ::std::option::Option::None,
            model_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgShowcaseItem_Hero`
pub mod cmsg_showcase_item_hero {
    // @@protoc_insertion_point(message:CMsgShowcaseItem_Hero.Data)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Data {
        // message fields
        // @@protoc_insertion_point(field:CMsgShowcaseItem_Hero.Data.econ_items)
        pub econ_items: ::std::vec::Vec<super::super::base_gcmessages::CSOEconItem>,
        // @@protoc_insertion_point(field:CMsgShowcaseItem_Hero.Data.actual_hero_id)
        pub actual_hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgShowcaseItem_Hero.Data.plus_hero_xp)
        pub plus_hero_xp: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgShowcaseItem_Hero.Data.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Data {
        fn default() -> &'a Data {
            <Data as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Data {
        pub fn new() -> Data {
            ::std::default::Default::default()
        }

        // optional int32 actual_hero_id = 2;

        pub fn actual_hero_id(&self) -> i32 {
            self.actual_hero_id.unwrap_or(0)
        }

        pub fn clear_actual_hero_id(&mut self) {
            self.actual_hero_id = ::std::option::Option::None;
        }

        pub fn has_actual_hero_id(&self) -> bool {
            self.actual_hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_actual_hero_id(&mut self, v: i32) {
            self.actual_hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 plus_hero_xp = 3;

        pub fn plus_hero_xp(&self) -> u32 {
            self.plus_hero_xp.unwrap_or(0)
        }

        pub fn clear_plus_hero_xp(&mut self) {
            self.plus_hero_xp = ::std::option::Option::None;
        }

        pub fn has_plus_hero_xp(&self) -> bool {
            self.plus_hero_xp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_plus_hero_xp(&mut self, v: u32) {
            self.plus_hero_xp = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Data {
        const NAME: &'static str = "Data";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.econ_items.push(is.read_message()?);
                    },
                    16 => {
                        self.actual_hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.plus_hero_xp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.econ_items {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.actual_hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.plus_hero_xp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            for v in &self.econ_items {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            if let Some(v) = self.actual_hero_id {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.plus_hero_xp {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Data {
            Data::new()
        }

        fn clear(&mut self) {
            self.econ_items.clear();
            self.actual_hero_id = ::std::option::Option::None;
            self.plus_hero_xp = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Data {
            static instance: Data = Data {
                econ_items: ::std::vec::Vec::new(),
                actual_hero_id: ::std::option::Option::None,
                plus_hero_xp: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgShowcaseItem_HeroIcon)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseItem_HeroIcon {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseItem_HeroIcon.data)
    pub data: ::steam_vent_proto_common::protobuf::MessageField<cmsg_showcase_item_hero_icon::Data>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem_HeroIcon.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem_HeroIcon.econ_item_ref)
    pub econ_item_ref: ::steam_vent_proto_common::protobuf::MessageField<CMsgShowcaseEconItemReference>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseItem_HeroIcon.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseItem_HeroIcon {
    fn default() -> &'a CMsgShowcaseItem_HeroIcon {
        <CMsgShowcaseItem_HeroIcon as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseItem_HeroIcon {
    pub fn new() -> CMsgShowcaseItem_HeroIcon {
        ::std::default::Default::default()
    }

    // optional int32 hero_id = 2;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseItem_HeroIcon {
    const NAME: &'static str = "CMsgShowcaseItem_HeroIcon";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                16 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.econ_item_ref)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.econ_item_ref.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.econ_item_ref.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseItem_HeroIcon {
        CMsgShowcaseItem_HeroIcon::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.hero_id = ::std::option::Option::None;
        self.econ_item_ref.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseItem_HeroIcon {
        static instance: CMsgShowcaseItem_HeroIcon = CMsgShowcaseItem_HeroIcon {
            data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            hero_id: ::std::option::Option::None,
            econ_item_ref: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgShowcaseItem_HeroIcon`
pub mod cmsg_showcase_item_hero_icon {
    // @@protoc_insertion_point(message:CMsgShowcaseItem_HeroIcon.Data)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Data {
        // message fields
        // @@protoc_insertion_point(field:CMsgShowcaseItem_HeroIcon.Data.econ_item)
        pub econ_item: ::steam_vent_proto_common::protobuf::MessageField<super::super::base_gcmessages::CSOEconItem>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgShowcaseItem_HeroIcon.Data.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Data {
        fn default() -> &'a Data {
            <Data as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Data {
        pub fn new() -> Data {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Data {
        const NAME: &'static str = "Data";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.econ_item)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.econ_item.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.econ_item.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Data {
            Data::new()
        }

        fn clear(&mut self) {
            self.econ_item.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Data {
            static instance: Data = Data {
                econ_item: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgShowcaseItem_PlayerMatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseItem_PlayerMatch {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseItem_PlayerMatch.data)
    pub data: ::steam_vent_proto_common::protobuf::MessageField<cmsg_showcase_item_player_match::Data>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem_PlayerMatch.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem_PlayerMatch.player_slot)
    pub player_slot: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseItem_PlayerMatch.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseItem_PlayerMatch {
    fn default() -> &'a CMsgShowcaseItem_PlayerMatch {
        <CMsgShowcaseItem_PlayerMatch as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseItem_PlayerMatch {
    pub fn new() -> CMsgShowcaseItem_PlayerMatch {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 player_slot = 3;

    pub fn player_slot(&self) -> u32 {
        self.player_slot.unwrap_or(0)
    }

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: u32) {
        self.player_slot = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseItem_PlayerMatch {
    const NAME: &'static str = "CMsgShowcaseItem_PlayerMatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.player_slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.player_slot {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseItem_PlayerMatch {
        CMsgShowcaseItem_PlayerMatch::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.match_id = ::std::option::Option::None;
        self.player_slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseItem_PlayerMatch {
        static instance: CMsgShowcaseItem_PlayerMatch = CMsgShowcaseItem_PlayerMatch {
            data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            match_id: ::std::option::Option::None,
            player_slot: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgShowcaseItem_PlayerMatch`
pub mod cmsg_showcase_item_player_match {
    // @@protoc_insertion_point(message:CMsgShowcaseItem_PlayerMatch.Data)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Data {
        // message fields
        // @@protoc_insertion_point(field:CMsgShowcaseItem_PlayerMatch.Data.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgShowcaseItem_PlayerMatch.Data.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgShowcaseItem_PlayerMatch.Data.duration)
        pub duration: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgShowcaseItem_PlayerMatch.Data.game_mode)
        pub game_mode: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::DOTA_GameMode>>,
        // @@protoc_insertion_point(field:CMsgShowcaseItem_PlayerMatch.Data.outcome)
        pub outcome: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EPlayerOutcome>>,
        // @@protoc_insertion_point(field:CMsgShowcaseItem_PlayerMatch.Data.kills)
        pub kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgShowcaseItem_PlayerMatch.Data.deaths)
        pub deaths: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgShowcaseItem_PlayerMatch.Data.assists)
        pub assists: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgShowcaseItem_PlayerMatch.Data.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Data {
        fn default() -> &'a Data {
            <Data as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Data {
        pub fn new() -> Data {
            ::std::default::Default::default()
        }

        // optional int32 hero_id = 1;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 2;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 duration = 3;

        pub fn duration(&self) -> u32 {
            self.duration.unwrap_or(0)
        }

        pub fn clear_duration(&mut self) {
            self.duration = ::std::option::Option::None;
        }

        pub fn has_duration(&self) -> bool {
            self.duration.is_some()
        }

        // Param is passed by value, moved
        pub fn set_duration(&mut self, v: u32) {
            self.duration = ::std::option::Option::Some(v);
        }

        // optional .DOTA_GameMode game_mode = 4;

        pub fn game_mode(&self) -> super::super::dota_shared_enums::DOTA_GameMode {
            match self.game_mode {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE),
                None => super::super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE,
            }
        }

        pub fn clear_game_mode(&mut self) {
            self.game_mode = ::std::option::Option::None;
        }

        pub fn has_game_mode(&self) -> bool {
            self.game_mode.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_mode(&mut self, v: super::super::dota_shared_enums::DOTA_GameMode) {
            self.game_mode = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional .CMsgShowcaseItem_PlayerMatch.EPlayerOutcome outcome = 5;

        pub fn outcome(&self) -> EPlayerOutcome {
            match self.outcome {
                Some(e) => e.enum_value_or(EPlayerOutcome::k_eInvalid),
                None => EPlayerOutcome::k_eInvalid,
            }
        }

        pub fn clear_outcome(&mut self) {
            self.outcome = ::std::option::Option::None;
        }

        pub fn has_outcome(&self) -> bool {
            self.outcome.is_some()
        }

        // Param is passed by value, moved
        pub fn set_outcome(&mut self, v: EPlayerOutcome) {
            self.outcome = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 kills = 6;

        pub fn kills(&self) -> u32 {
            self.kills.unwrap_or(0)
        }

        pub fn clear_kills(&mut self) {
            self.kills = ::std::option::Option::None;
        }

        pub fn has_kills(&self) -> bool {
            self.kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kills(&mut self, v: u32) {
            self.kills = ::std::option::Option::Some(v);
        }

        // optional uint32 deaths = 7;

        pub fn deaths(&self) -> u32 {
            self.deaths.unwrap_or(0)
        }

        pub fn clear_deaths(&mut self) {
            self.deaths = ::std::option::Option::None;
        }

        pub fn has_deaths(&self) -> bool {
            self.deaths.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deaths(&mut self, v: u32) {
            self.deaths = ::std::option::Option::Some(v);
        }

        // optional uint32 assists = 8;

        pub fn assists(&self) -> u32 {
            self.assists.unwrap_or(0)
        }

        pub fn clear_assists(&mut self) {
            self.assists = ::std::option::Option::None;
        }

        pub fn has_assists(&self) -> bool {
            self.assists.is_some()
        }

        // Param is passed by value, moved
        pub fn set_assists(&mut self, v: u32) {
            self.assists = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Data {
        const NAME: &'static str = "Data";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.duration = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.game_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    40 => {
                        self.outcome = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    48 => {
                        self.kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.assists = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.duration {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.game_mode {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
            }
            if let Some(v) = self.outcome {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v.value());
            }
            if let Some(v) = self.kills {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.deaths {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.assists {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.hero_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.duration {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.game_mode {
                os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.outcome {
                os.write_enum(5, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.kills {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.deaths {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.assists {
                os.write_uint32(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Data {
            Data::new()
        }

        fn clear(&mut self) {
            self.hero_id = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.duration = ::std::option::Option::None;
            self.game_mode = ::std::option::Option::None;
            self.outcome = ::std::option::Option::None;
            self.kills = ::std::option::Option::None;
            self.deaths = ::std::option::Option::None;
            self.assists = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Data {
            static instance: Data = Data {
                hero_id: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                duration: ::std::option::Option::None,
                game_mode: ::std::option::Option::None,
                outcome: ::std::option::Option::None,
                kills: ::std::option::Option::None,
                deaths: ::std::option::Option::None,
                assists: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgShowcaseItem_PlayerMatch.EPlayerOutcome)
    pub enum EPlayerOutcome {
        // @@protoc_insertion_point(enum_value:CMsgShowcaseItem_PlayerMatch.EPlayerOutcome.k_eInvalid)
        k_eInvalid = 0,
        // @@protoc_insertion_point(enum_value:CMsgShowcaseItem_PlayerMatch.EPlayerOutcome.k_eWin)
        k_eWin = 1,
        // @@protoc_insertion_point(enum_value:CMsgShowcaseItem_PlayerMatch.EPlayerOutcome.k_eLoss)
        k_eLoss = 2,
        // @@protoc_insertion_point(enum_value:CMsgShowcaseItem_PlayerMatch.EPlayerOutcome.k_eNotScored)
        k_eNotScored = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EPlayerOutcome {
        const NAME: &'static str = "EPlayerOutcome";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EPlayerOutcome> {
            match value {
                0 => ::std::option::Option::Some(EPlayerOutcome::k_eInvalid),
                1 => ::std::option::Option::Some(EPlayerOutcome::k_eWin),
                2 => ::std::option::Option::Some(EPlayerOutcome::k_eLoss),
                3 => ::std::option::Option::Some(EPlayerOutcome::k_eNotScored),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EPlayerOutcome> {
            match str {
                "k_eInvalid" => ::std::option::Option::Some(EPlayerOutcome::k_eInvalid),
                "k_eWin" => ::std::option::Option::Some(EPlayerOutcome::k_eWin),
                "k_eLoss" => ::std::option::Option::Some(EPlayerOutcome::k_eLoss),
                "k_eNotScored" => ::std::option::Option::Some(EPlayerOutcome::k_eNotScored),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EPlayerOutcome] = &[
            EPlayerOutcome::k_eInvalid,
            EPlayerOutcome::k_eWin,
            EPlayerOutcome::k_eLoss,
            EPlayerOutcome::k_eNotScored,
        ];
    }

    impl ::std::default::Default for EPlayerOutcome {
        fn default() -> Self {
            EPlayerOutcome::k_eInvalid
        }
    }

}

// @@protoc_insertion_point(message:CMsgShowcaseItem_ChatWheel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseItem_ChatWheel {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseItem_ChatWheel.data)
    pub data: ::steam_vent_proto_common::protobuf::MessageField<cmsg_showcase_item_chat_wheel::Data>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem_ChatWheel.chat_wheel_message_id)
    pub chat_wheel_message_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseItem_ChatWheel.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseItem_ChatWheel {
    fn default() -> &'a CMsgShowcaseItem_ChatWheel {
        <CMsgShowcaseItem_ChatWheel as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseItem_ChatWheel {
    pub fn new() -> CMsgShowcaseItem_ChatWheel {
        ::std::default::Default::default()
    }

    // optional uint32 chat_wheel_message_id = 2;

    pub fn chat_wheel_message_id(&self) -> u32 {
        self.chat_wheel_message_id.unwrap_or(4294967295u32)
    }

    pub fn clear_chat_wheel_message_id(&mut self) {
        self.chat_wheel_message_id = ::std::option::Option::None;
    }

    pub fn has_chat_wheel_message_id(&self) -> bool {
        self.chat_wheel_message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_wheel_message_id(&mut self, v: u32) {
        self.chat_wheel_message_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseItem_ChatWheel {
    const NAME: &'static str = "CMsgShowcaseItem_ChatWheel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                16 => {
                    self.chat_wheel_message_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.chat_wheel_message_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.chat_wheel_message_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseItem_ChatWheel {
        CMsgShowcaseItem_ChatWheel::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.chat_wheel_message_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseItem_ChatWheel {
        static instance: CMsgShowcaseItem_ChatWheel = CMsgShowcaseItem_ChatWheel {
            data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            chat_wheel_message_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgShowcaseItem_ChatWheel`
pub mod cmsg_showcase_item_chat_wheel {
    // @@protoc_insertion_point(message:CMsgShowcaseItem_ChatWheel.Data)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Data {
        // special fields
        // @@protoc_insertion_point(special_field:CMsgShowcaseItem_ChatWheel.Data.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Data {
        fn default() -> &'a Data {
            <Data as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Data {
        pub fn new() -> Data {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Data {
        const NAME: &'static str = "Data";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Data {
            Data::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Data {
            static instance: Data = Data {
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgShowcaseItem_Emoticon)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseItem_Emoticon {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseItem_Emoticon.data)
    pub data: ::steam_vent_proto_common::protobuf::MessageField<cmsg_showcase_item_emoticon::Data>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem_Emoticon.emoticon_id)
    pub emoticon_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseItem_Emoticon.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseItem_Emoticon {
    fn default() -> &'a CMsgShowcaseItem_Emoticon {
        <CMsgShowcaseItem_Emoticon as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseItem_Emoticon {
    pub fn new() -> CMsgShowcaseItem_Emoticon {
        ::std::default::Default::default()
    }

    // optional uint32 emoticon_id = 2;

    pub fn emoticon_id(&self) -> u32 {
        self.emoticon_id.unwrap_or(0)
    }

    pub fn clear_emoticon_id(&mut self) {
        self.emoticon_id = ::std::option::Option::None;
    }

    pub fn has_emoticon_id(&self) -> bool {
        self.emoticon_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emoticon_id(&mut self, v: u32) {
        self.emoticon_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseItem_Emoticon {
    const NAME: &'static str = "CMsgShowcaseItem_Emoticon";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                16 => {
                    self.emoticon_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.emoticon_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.emoticon_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseItem_Emoticon {
        CMsgShowcaseItem_Emoticon::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.emoticon_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseItem_Emoticon {
        static instance: CMsgShowcaseItem_Emoticon = CMsgShowcaseItem_Emoticon {
            data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            emoticon_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgShowcaseItem_Emoticon`
pub mod cmsg_showcase_item_emoticon {
    // @@protoc_insertion_point(message:CMsgShowcaseItem_Emoticon.Data)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Data {
        // special fields
        // @@protoc_insertion_point(special_field:CMsgShowcaseItem_Emoticon.Data.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Data {
        fn default() -> &'a Data {
            <Data as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Data {
        pub fn new() -> Data {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Data {
        const NAME: &'static str = "Data";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Data {
            Data::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Data {
            static instance: Data = Data {
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgShowcaseItem_SpiderGraph)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseItem_SpiderGraph {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseItem_SpiderGraph.data)
    pub data: ::steam_vent_proto_common::protobuf::MessageField<cmsg_showcase_item_spider_graph::Data>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseItem_SpiderGraph.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseItem_SpiderGraph {
    fn default() -> &'a CMsgShowcaseItem_SpiderGraph {
        <CMsgShowcaseItem_SpiderGraph as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseItem_SpiderGraph {
    pub fn new() -> CMsgShowcaseItem_SpiderGraph {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseItem_SpiderGraph {
    const NAME: &'static str = "CMsgShowcaseItem_SpiderGraph";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseItem_SpiderGraph {
        CMsgShowcaseItem_SpiderGraph::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseItem_SpiderGraph {
        static instance: CMsgShowcaseItem_SpiderGraph = CMsgShowcaseItem_SpiderGraph {
            data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgShowcaseItem_SpiderGraph`
pub mod cmsg_showcase_item_spider_graph {
    // @@protoc_insertion_point(message:CMsgShowcaseItem_SpiderGraph.Data)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Data {
        // special fields
        // @@protoc_insertion_point(special_field:CMsgShowcaseItem_SpiderGraph.Data.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Data {
        fn default() -> &'a Data {
            <Data as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Data {
        pub fn new() -> Data {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Data {
        const NAME: &'static str = "Data";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Data {
            Data::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Data {
            static instance: Data = Data {
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgShowcaseItem_UserFeed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseItem_UserFeed {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseItem_UserFeed.data)
    pub data: ::steam_vent_proto_common::protobuf::MessageField<cmsg_showcase_item_user_feed::Data>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseItem_UserFeed.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseItem_UserFeed {
    fn default() -> &'a CMsgShowcaseItem_UserFeed {
        <CMsgShowcaseItem_UserFeed as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseItem_UserFeed {
    pub fn new() -> CMsgShowcaseItem_UserFeed {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseItem_UserFeed {
    const NAME: &'static str = "CMsgShowcaseItem_UserFeed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseItem_UserFeed {
        CMsgShowcaseItem_UserFeed::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseItem_UserFeed {
        static instance: CMsgShowcaseItem_UserFeed = CMsgShowcaseItem_UserFeed {
            data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgShowcaseItem_UserFeed`
pub mod cmsg_showcase_item_user_feed {
    // @@protoc_insertion_point(message:CMsgShowcaseItem_UserFeed.Data)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Data {
        // special fields
        // @@protoc_insertion_point(special_field:CMsgShowcaseItem_UserFeed.Data.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Data {
        fn default() -> &'a Data {
            <Data as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Data {
        pub fn new() -> Data {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Data {
        const NAME: &'static str = "Data";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Data {
            Data::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Data {
            static instance: Data = Data {
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgShowcaseItem_Stat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseItem_Stat {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseItem_Stat.data)
    pub data: ::steam_vent_proto_common::protobuf::MessageField<cmsg_showcase_item_stat::Data>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem_Stat.stat_id)
    pub stat_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_gcmessages_common::cmsg_dotaprofile_card::EStatID>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseItem_Stat.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseItem_Stat {
    fn default() -> &'a CMsgShowcaseItem_Stat {
        <CMsgShowcaseItem_Stat as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseItem_Stat {
    pub fn new() -> CMsgShowcaseItem_Stat {
        ::std::default::Default::default()
    }

    // optional .CMsgDOTAProfileCard.EStatID stat_id = 2;

    pub fn stat_id(&self) -> super::dota_gcmessages_common::cmsg_dotaprofile_card::EStatID {
        match self.stat_id {
            Some(e) => e.enum_value_or(super::dota_gcmessages_common::cmsg_dotaprofile_card::EStatID::k_eStat_Wins),
            None => super::dota_gcmessages_common::cmsg_dotaprofile_card::EStatID::k_eStat_Wins,
        }
    }

    pub fn clear_stat_id(&mut self) {
        self.stat_id = ::std::option::Option::None;
    }

    pub fn has_stat_id(&self) -> bool {
        self.stat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_id(&mut self, v: super::dota_gcmessages_common::cmsg_dotaprofile_card::EStatID) {
        self.stat_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseItem_Stat {
    const NAME: &'static str = "CMsgShowcaseItem_Stat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                16 => {
                    self.stat_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stat_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.stat_id {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseItem_Stat {
        CMsgShowcaseItem_Stat::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.stat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseItem_Stat {
        static instance: CMsgShowcaseItem_Stat = CMsgShowcaseItem_Stat {
            data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            stat_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgShowcaseItem_Stat`
pub mod cmsg_showcase_item_stat {
    // @@protoc_insertion_point(message:CMsgShowcaseItem_Stat.Data)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Data {
        // message fields
        // @@protoc_insertion_point(field:CMsgShowcaseItem_Stat.Data.stat_score)
        pub stat_score: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgShowcaseItem_Stat.Data.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Data {
        fn default() -> &'a Data {
            <Data as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Data {
        pub fn new() -> Data {
            ::std::default::Default::default()
        }

        // optional uint32 stat_score = 1;

        pub fn stat_score(&self) -> u32 {
            self.stat_score.unwrap_or(0)
        }

        pub fn clear_stat_score(&mut self) {
            self.stat_score = ::std::option::Option::None;
        }

        pub fn has_stat_score(&self) -> bool {
            self.stat_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_score(&mut self, v: u32) {
            self.stat_score = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Data {
        const NAME: &'static str = "Data";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.stat_score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.stat_score {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.stat_score {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Data {
            Data::new()
        }

        fn clear(&mut self) {
            self.stat_score = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Data {
            static instance: Data = Data {
                stat_score: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgShowcaseBackground)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseBackground {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseBackground.data)
    pub data: ::steam_vent_proto_common::protobuf::MessageField<cmsg_showcase_background::Data>,
    // @@protoc_insertion_point(field:CMsgShowcaseBackground.loading_screen_ref)
    pub loading_screen_ref: ::steam_vent_proto_common::protobuf::MessageField<CMsgShowcaseEconItemReference>,
    // @@protoc_insertion_point(field:CMsgShowcaseBackground.dim)
    pub dim: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseBackground.blur)
    pub blur: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseBackground.background_id)
    pub background_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseBackground.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseBackground {
    fn default() -> &'a CMsgShowcaseBackground {
        <CMsgShowcaseBackground as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseBackground {
    pub fn new() -> CMsgShowcaseBackground {
        ::std::default::Default::default()
    }

    // optional uint32 dim = 3;

    pub fn dim(&self) -> u32 {
        self.dim.unwrap_or(0)
    }

    pub fn clear_dim(&mut self) {
        self.dim = ::std::option::Option::None;
    }

    pub fn has_dim(&self) -> bool {
        self.dim.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dim(&mut self, v: u32) {
        self.dim = ::std::option::Option::Some(v);
    }

    // optional uint32 blur = 4;

    pub fn blur(&self) -> u32 {
        self.blur.unwrap_or(0)
    }

    pub fn clear_blur(&mut self) {
        self.blur = ::std::option::Option::None;
    }

    pub fn has_blur(&self) -> bool {
        self.blur.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blur(&mut self, v: u32) {
        self.blur = ::std::option::Option::Some(v);
    }

    // optional uint32 background_id = 5;

    pub fn background_id(&self) -> u32 {
        self.background_id.unwrap_or(0)
    }

    pub fn clear_background_id(&mut self) {
        self.background_id = ::std::option::Option::None;
    }

    pub fn has_background_id(&self) -> bool {
        self.background_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_background_id(&mut self, v: u32) {
        self.background_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseBackground {
    const NAME: &'static str = "CMsgShowcaseBackground";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.loading_screen_ref)?;
                },
                24 => {
                    self.dim = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.blur = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.background_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.loading_screen_ref.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dim {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.blur {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.background_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.loading_screen_ref.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.dim {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.blur {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.background_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseBackground {
        CMsgShowcaseBackground::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.loading_screen_ref.clear();
        self.dim = ::std::option::Option::None;
        self.blur = ::std::option::Option::None;
        self.background_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseBackground {
        static instance: CMsgShowcaseBackground = CMsgShowcaseBackground {
            data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            loading_screen_ref: ::steam_vent_proto_common::protobuf::MessageField::none(),
            dim: ::std::option::Option::None,
            blur: ::std::option::Option::None,
            background_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgShowcaseBackground`
pub mod cmsg_showcase_background {
    // @@protoc_insertion_point(message:CMsgShowcaseBackground.Data)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Data {
        // message fields
        // @@protoc_insertion_point(field:CMsgShowcaseBackground.Data.loading_screen)
        pub loading_screen: ::steam_vent_proto_common::protobuf::MessageField<super::super::base_gcmessages::CSOEconItem>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgShowcaseBackground.Data.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Data {
        fn default() -> &'a Data {
            <Data as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Data {
        pub fn new() -> Data {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Data {
        const NAME: &'static str = "Data";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.loading_screen)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.loading_screen.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.loading_screen.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Data {
            Data::new()
        }

        fn clear(&mut self) {
            self.loading_screen.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Data {
            static instance: Data = Data {
                loading_screen: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgShowcaseItemData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseItemData {
    // message oneof groups
    pub item: ::std::option::Option<cmsg_showcase_item_data::Item>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseItemData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseItemData {
    fn default() -> &'a CMsgShowcaseItemData {
        <CMsgShowcaseItemData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseItemData {
    pub fn new() -> CMsgShowcaseItemData {
        ::std::default::Default::default()
    }

    // optional .CMsgShowcaseItem_Trophy trophy = 1;

    pub fn trophy(&self) -> &CMsgShowcaseItem_Trophy {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Trophy(ref v)) => v,
            _ => <CMsgShowcaseItem_Trophy as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_trophy(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_trophy(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Trophy(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_trophy(&mut self, v: CMsgShowcaseItem_Trophy) {
        self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Trophy(v))
    }

    // Mutable pointer to the field.
    pub fn mut_trophy(&mut self) -> &mut CMsgShowcaseItem_Trophy {
        if let ::std::option::Option::Some(cmsg_showcase_item_data::Item::Trophy(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Trophy(CMsgShowcaseItem_Trophy::new()));
        }
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Trophy(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_trophy(&mut self) -> CMsgShowcaseItem_Trophy {
        if self.has_trophy() {
            match self.item.take() {
                ::std::option::Option::Some(cmsg_showcase_item_data::Item::Trophy(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgShowcaseItem_Trophy::new()
        }
    }

    // optional .CMsgShowcaseItem_EconItem econ_item_icon = 2;

    pub fn econ_item_icon(&self) -> &CMsgShowcaseItem_EconItem {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::EconItemIcon(ref v)) => v,
            _ => <CMsgShowcaseItem_EconItem as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_econ_item_icon(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_econ_item_icon(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::EconItemIcon(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_econ_item_icon(&mut self, v: CMsgShowcaseItem_EconItem) {
        self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::EconItemIcon(v))
    }

    // Mutable pointer to the field.
    pub fn mut_econ_item_icon(&mut self) -> &mut CMsgShowcaseItem_EconItem {
        if let ::std::option::Option::Some(cmsg_showcase_item_data::Item::EconItemIcon(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::EconItemIcon(CMsgShowcaseItem_EconItem::new()));
        }
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::EconItemIcon(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_econ_item_icon(&mut self) -> CMsgShowcaseItem_EconItem {
        if self.has_econ_item_icon() {
            match self.item.take() {
                ::std::option::Option::Some(cmsg_showcase_item_data::Item::EconItemIcon(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgShowcaseItem_EconItem::new()
        }
    }

    // optional .CMsgShowcaseItem_EconItem sticker = 3;

    pub fn sticker(&self) -> &CMsgShowcaseItem_EconItem {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Sticker(ref v)) => v,
            _ => <CMsgShowcaseItem_EconItem as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sticker(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_sticker(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Sticker(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sticker(&mut self, v: CMsgShowcaseItem_EconItem) {
        self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Sticker(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sticker(&mut self) -> &mut CMsgShowcaseItem_EconItem {
        if let ::std::option::Option::Some(cmsg_showcase_item_data::Item::Sticker(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Sticker(CMsgShowcaseItem_EconItem::new()));
        }
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Sticker(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sticker(&mut self) -> CMsgShowcaseItem_EconItem {
        if self.has_sticker() {
            match self.item.take() {
                ::std::option::Option::Some(cmsg_showcase_item_data::Item::Sticker(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgShowcaseItem_EconItem::new()
        }
    }

    // optional .CMsgShowcaseItem_Hero hero_model = 4;

    pub fn hero_model(&self) -> &CMsgShowcaseItem_Hero {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::HeroModel(ref v)) => v,
            _ => <CMsgShowcaseItem_Hero as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_hero_model(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_hero_model(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::HeroModel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hero_model(&mut self, v: CMsgShowcaseItem_Hero) {
        self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::HeroModel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hero_model(&mut self) -> &mut CMsgShowcaseItem_Hero {
        if let ::std::option::Option::Some(cmsg_showcase_item_data::Item::HeroModel(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::HeroModel(CMsgShowcaseItem_Hero::new()));
        }
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::HeroModel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hero_model(&mut self) -> CMsgShowcaseItem_Hero {
        if self.has_hero_model() {
            match self.item.take() {
                ::std::option::Option::Some(cmsg_showcase_item_data::Item::HeroModel(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgShowcaseItem_Hero::new()
        }
    }

    // optional .CMsgShowcaseItem_PlayerMatch player_match = 5;

    pub fn player_match(&self) -> &CMsgShowcaseItem_PlayerMatch {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::PlayerMatch(ref v)) => v,
            _ => <CMsgShowcaseItem_PlayerMatch as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_player_match(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_player_match(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::PlayerMatch(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_player_match(&mut self, v: CMsgShowcaseItem_PlayerMatch) {
        self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::PlayerMatch(v))
    }

    // Mutable pointer to the field.
    pub fn mut_player_match(&mut self) -> &mut CMsgShowcaseItem_PlayerMatch {
        if let ::std::option::Option::Some(cmsg_showcase_item_data::Item::PlayerMatch(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::PlayerMatch(CMsgShowcaseItem_PlayerMatch::new()));
        }
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::PlayerMatch(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_player_match(&mut self) -> CMsgShowcaseItem_PlayerMatch {
        if self.has_player_match() {
            match self.item.take() {
                ::std::option::Option::Some(cmsg_showcase_item_data::Item::PlayerMatch(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgShowcaseItem_PlayerMatch::new()
        }
    }

    // optional .CMsgShowcaseItem_ChatWheel chat_wheel = 6;

    pub fn chat_wheel(&self) -> &CMsgShowcaseItem_ChatWheel {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::ChatWheel(ref v)) => v,
            _ => <CMsgShowcaseItem_ChatWheel as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_chat_wheel(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_chat_wheel(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::ChatWheel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chat_wheel(&mut self, v: CMsgShowcaseItem_ChatWheel) {
        self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::ChatWheel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chat_wheel(&mut self) -> &mut CMsgShowcaseItem_ChatWheel {
        if let ::std::option::Option::Some(cmsg_showcase_item_data::Item::ChatWheel(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::ChatWheel(CMsgShowcaseItem_ChatWheel::new()));
        }
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::ChatWheel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chat_wheel(&mut self) -> CMsgShowcaseItem_ChatWheel {
        if self.has_chat_wheel() {
            match self.item.take() {
                ::std::option::Option::Some(cmsg_showcase_item_data::Item::ChatWheel(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgShowcaseItem_ChatWheel::new()
        }
    }

    // optional .CMsgShowcaseItem_ChatWheel spray = 7;

    pub fn spray(&self) -> &CMsgShowcaseItem_ChatWheel {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Spray(ref v)) => v,
            _ => <CMsgShowcaseItem_ChatWheel as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_spray(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_spray(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Spray(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_spray(&mut self, v: CMsgShowcaseItem_ChatWheel) {
        self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Spray(v))
    }

    // Mutable pointer to the field.
    pub fn mut_spray(&mut self) -> &mut CMsgShowcaseItem_ChatWheel {
        if let ::std::option::Option::Some(cmsg_showcase_item_data::Item::Spray(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Spray(CMsgShowcaseItem_ChatWheel::new()));
        }
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Spray(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_spray(&mut self) -> CMsgShowcaseItem_ChatWheel {
        if self.has_spray() {
            match self.item.take() {
                ::std::option::Option::Some(cmsg_showcase_item_data::Item::Spray(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgShowcaseItem_ChatWheel::new()
        }
    }

    // optional .CMsgShowcaseItem_Emoticon emoticon = 8;

    pub fn emoticon(&self) -> &CMsgShowcaseItem_Emoticon {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Emoticon(ref v)) => v,
            _ => <CMsgShowcaseItem_Emoticon as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_emoticon(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_emoticon(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Emoticon(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_emoticon(&mut self, v: CMsgShowcaseItem_Emoticon) {
        self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Emoticon(v))
    }

    // Mutable pointer to the field.
    pub fn mut_emoticon(&mut self) -> &mut CMsgShowcaseItem_Emoticon {
        if let ::std::option::Option::Some(cmsg_showcase_item_data::Item::Emoticon(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Emoticon(CMsgShowcaseItem_Emoticon::new()));
        }
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Emoticon(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_emoticon(&mut self) -> CMsgShowcaseItem_Emoticon {
        if self.has_emoticon() {
            match self.item.take() {
                ::std::option::Option::Some(cmsg_showcase_item_data::Item::Emoticon(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgShowcaseItem_Emoticon::new()
        }
    }

    // optional .CMsgShowcaseItem_EconItem courier = 10;

    pub fn courier(&self) -> &CMsgShowcaseItem_EconItem {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Courier(ref v)) => v,
            _ => <CMsgShowcaseItem_EconItem as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_courier(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_courier(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Courier(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_courier(&mut self, v: CMsgShowcaseItem_EconItem) {
        self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Courier(v))
    }

    // Mutable pointer to the field.
    pub fn mut_courier(&mut self) -> &mut CMsgShowcaseItem_EconItem {
        if let ::std::option::Option::Some(cmsg_showcase_item_data::Item::Courier(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Courier(CMsgShowcaseItem_EconItem::new()));
        }
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Courier(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_courier(&mut self) -> CMsgShowcaseItem_EconItem {
        if self.has_courier() {
            match self.item.take() {
                ::std::option::Option::Some(cmsg_showcase_item_data::Item::Courier(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgShowcaseItem_EconItem::new()
        }
    }

    // optional .CMsgShowcaseItem_EconItem ward = 11;

    pub fn ward(&self) -> &CMsgShowcaseItem_EconItem {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Ward(ref v)) => v,
            _ => <CMsgShowcaseItem_EconItem as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ward(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_ward(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Ward(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ward(&mut self, v: CMsgShowcaseItem_EconItem) {
        self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Ward(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ward(&mut self) -> &mut CMsgShowcaseItem_EconItem {
        if let ::std::option::Option::Some(cmsg_showcase_item_data::Item::Ward(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Ward(CMsgShowcaseItem_EconItem::new()));
        }
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Ward(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ward(&mut self) -> CMsgShowcaseItem_EconItem {
        if self.has_ward() {
            match self.item.take() {
                ::std::option::Option::Some(cmsg_showcase_item_data::Item::Ward(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgShowcaseItem_EconItem::new()
        }
    }

    // optional .CMsgShowcaseItem_HeroIcon hero_icon = 12;

    pub fn hero_icon(&self) -> &CMsgShowcaseItem_HeroIcon {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::HeroIcon(ref v)) => v,
            _ => <CMsgShowcaseItem_HeroIcon as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_hero_icon(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_hero_icon(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::HeroIcon(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hero_icon(&mut self, v: CMsgShowcaseItem_HeroIcon) {
        self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::HeroIcon(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hero_icon(&mut self) -> &mut CMsgShowcaseItem_HeroIcon {
        if let ::std::option::Option::Some(cmsg_showcase_item_data::Item::HeroIcon(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::HeroIcon(CMsgShowcaseItem_HeroIcon::new()));
        }
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::HeroIcon(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hero_icon(&mut self) -> CMsgShowcaseItem_HeroIcon {
        if self.has_hero_icon() {
            match self.item.take() {
                ::std::option::Option::Some(cmsg_showcase_item_data::Item::HeroIcon(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgShowcaseItem_HeroIcon::new()
        }
    }

    // optional .CMsgShowcaseItem_SpiderGraph spider_graph = 13;

    pub fn spider_graph(&self) -> &CMsgShowcaseItem_SpiderGraph {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::SpiderGraph(ref v)) => v,
            _ => <CMsgShowcaseItem_SpiderGraph as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_spider_graph(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_spider_graph(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::SpiderGraph(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_spider_graph(&mut self, v: CMsgShowcaseItem_SpiderGraph) {
        self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::SpiderGraph(v))
    }

    // Mutable pointer to the field.
    pub fn mut_spider_graph(&mut self) -> &mut CMsgShowcaseItem_SpiderGraph {
        if let ::std::option::Option::Some(cmsg_showcase_item_data::Item::SpiderGraph(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::SpiderGraph(CMsgShowcaseItem_SpiderGraph::new()));
        }
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::SpiderGraph(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_spider_graph(&mut self) -> CMsgShowcaseItem_SpiderGraph {
        if self.has_spider_graph() {
            match self.item.take() {
                ::std::option::Option::Some(cmsg_showcase_item_data::Item::SpiderGraph(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgShowcaseItem_SpiderGraph::new()
        }
    }

    // optional .CMsgShowcaseItem_UserFeed user_feed = 14;

    pub fn user_feed(&self) -> &CMsgShowcaseItem_UserFeed {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::UserFeed(ref v)) => v,
            _ => <CMsgShowcaseItem_UserFeed as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_user_feed(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_user_feed(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::UserFeed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_user_feed(&mut self, v: CMsgShowcaseItem_UserFeed) {
        self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::UserFeed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_user_feed(&mut self) -> &mut CMsgShowcaseItem_UserFeed {
        if let ::std::option::Option::Some(cmsg_showcase_item_data::Item::UserFeed(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::UserFeed(CMsgShowcaseItem_UserFeed::new()));
        }
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::UserFeed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_user_feed(&mut self) -> CMsgShowcaseItem_UserFeed {
        if self.has_user_feed() {
            match self.item.take() {
                ::std::option::Option::Some(cmsg_showcase_item_data::Item::UserFeed(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgShowcaseItem_UserFeed::new()
        }
    }

    // optional .CMsgShowcaseItem_Stat stat = 15;

    pub fn stat(&self) -> &CMsgShowcaseItem_Stat {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Stat(ref v)) => v,
            _ => <CMsgShowcaseItem_Stat as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_stat(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_stat(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Stat(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stat(&mut self, v: CMsgShowcaseItem_Stat) {
        self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Stat(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stat(&mut self) -> &mut CMsgShowcaseItem_Stat {
        if let ::std::option::Option::Some(cmsg_showcase_item_data::Item::Stat(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Stat(CMsgShowcaseItem_Stat::new()));
        }
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Stat(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stat(&mut self) -> CMsgShowcaseItem_Stat {
        if self.has_stat() {
            match self.item.take() {
                ::std::option::Option::Some(cmsg_showcase_item_data::Item::Stat(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgShowcaseItem_Stat::new()
        }
    }

    // optional .CMsgShowcaseItem_EconItem roshan = 16;

    pub fn roshan(&self) -> &CMsgShowcaseItem_EconItem {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Roshan(ref v)) => v,
            _ => <CMsgShowcaseItem_EconItem as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_roshan(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_roshan(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Roshan(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_roshan(&mut self, v: CMsgShowcaseItem_EconItem) {
        self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Roshan(v))
    }

    // Mutable pointer to the field.
    pub fn mut_roshan(&mut self) -> &mut CMsgShowcaseItem_EconItem {
        if let ::std::option::Option::Some(cmsg_showcase_item_data::Item::Roshan(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Roshan(CMsgShowcaseItem_EconItem::new()));
        }
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Roshan(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_roshan(&mut self) -> CMsgShowcaseItem_EconItem {
        if self.has_roshan() {
            match self.item.take() {
                ::std::option::Option::Some(cmsg_showcase_item_data::Item::Roshan(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgShowcaseItem_EconItem::new()
        }
    }

    // optional .CMsgShowcaseItem_EconItem creep = 17;

    pub fn creep(&self) -> &CMsgShowcaseItem_EconItem {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Creep(ref v)) => v,
            _ => <CMsgShowcaseItem_EconItem as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_creep(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_creep(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Creep(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_creep(&mut self, v: CMsgShowcaseItem_EconItem) {
        self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Creep(v))
    }

    // Mutable pointer to the field.
    pub fn mut_creep(&mut self) -> &mut CMsgShowcaseItem_EconItem {
        if let ::std::option::Option::Some(cmsg_showcase_item_data::Item::Creep(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Creep(CMsgShowcaseItem_EconItem::new()));
        }
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Creep(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_creep(&mut self) -> CMsgShowcaseItem_EconItem {
        if self.has_creep() {
            match self.item.take() {
                ::std::option::Option::Some(cmsg_showcase_item_data::Item::Creep(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgShowcaseItem_EconItem::new()
        }
    }

    // optional .CMsgShowcaseItem_EconItem tower = 18;

    pub fn tower(&self) -> &CMsgShowcaseItem_EconItem {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Tower(ref v)) => v,
            _ => <CMsgShowcaseItem_EconItem as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_tower(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_tower(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Tower(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tower(&mut self, v: CMsgShowcaseItem_EconItem) {
        self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Tower(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tower(&mut self) -> &mut CMsgShowcaseItem_EconItem {
        if let ::std::option::Option::Some(cmsg_showcase_item_data::Item::Tower(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Tower(CMsgShowcaseItem_EconItem::new()));
        }
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Tower(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tower(&mut self) -> CMsgShowcaseItem_EconItem {
        if self.has_tower() {
            match self.item.take() {
                ::std::option::Option::Some(cmsg_showcase_item_data::Item::Tower(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgShowcaseItem_EconItem::new()
        }
    }

    // optional .CMsgShowcaseItem_EconItem effigy = 19;

    pub fn effigy(&self) -> &CMsgShowcaseItem_EconItem {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Effigy(ref v)) => v,
            _ => <CMsgShowcaseItem_EconItem as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_effigy(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_effigy(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Effigy(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_effigy(&mut self, v: CMsgShowcaseItem_EconItem) {
        self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Effigy(v))
    }

    // Mutable pointer to the field.
    pub fn mut_effigy(&mut self) -> &mut CMsgShowcaseItem_EconItem {
        if let ::std::option::Option::Some(cmsg_showcase_item_data::Item::Effigy(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Effigy(CMsgShowcaseItem_EconItem::new()));
        }
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Effigy(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_effigy(&mut self) -> CMsgShowcaseItem_EconItem {
        if self.has_effigy() {
            match self.item.take() {
                ::std::option::Option::Some(cmsg_showcase_item_data::Item::Effigy(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgShowcaseItem_EconItem::new()
        }
    }

    // optional .CMsgShowcaseItem_EconItem decoration = 20;

    pub fn decoration(&self) -> &CMsgShowcaseItem_EconItem {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Decoration(ref v)) => v,
            _ => <CMsgShowcaseItem_EconItem as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_decoration(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_decoration(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Decoration(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_decoration(&mut self, v: CMsgShowcaseItem_EconItem) {
        self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Decoration(v))
    }

    // Mutable pointer to the field.
    pub fn mut_decoration(&mut self) -> &mut CMsgShowcaseItem_EconItem {
        if let ::std::option::Option::Some(cmsg_showcase_item_data::Item::Decoration(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Decoration(CMsgShowcaseItem_EconItem::new()));
        }
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Decoration(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_decoration(&mut self) -> CMsgShowcaseItem_EconItem {
        if self.has_decoration() {
            match self.item.take() {
                ::std::option::Option::Some(cmsg_showcase_item_data::Item::Decoration(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgShowcaseItem_EconItem::new()
        }
    }

    // optional .CMsgShowcaseBackground background = 100;

    pub fn background(&self) -> &CMsgShowcaseBackground {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Background(ref v)) => v,
            _ => <CMsgShowcaseBackground as ::steam_vent_proto_common::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_background(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_background(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Background(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_background(&mut self, v: CMsgShowcaseBackground) {
        self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Background(v))
    }

    // Mutable pointer to the field.
    pub fn mut_background(&mut self) -> &mut CMsgShowcaseBackground {
        if let ::std::option::Option::Some(cmsg_showcase_item_data::Item::Background(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Background(CMsgShowcaseBackground::new()));
        }
        match self.item {
            ::std::option::Option::Some(cmsg_showcase_item_data::Item::Background(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_background(&mut self) -> CMsgShowcaseBackground {
        if self.has_background() {
            match self.item.take() {
                ::std::option::Option::Some(cmsg_showcase_item_data::Item::Background(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgShowcaseBackground::new()
        }
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseItemData {
    const NAME: &'static str = "CMsgShowcaseItemData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Trophy(is.read_message()?));
                },
                18 => {
                    self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::EconItemIcon(is.read_message()?));
                },
                26 => {
                    self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Sticker(is.read_message()?));
                },
                34 => {
                    self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::HeroModel(is.read_message()?));
                },
                42 => {
                    self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::PlayerMatch(is.read_message()?));
                },
                50 => {
                    self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::ChatWheel(is.read_message()?));
                },
                58 => {
                    self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Spray(is.read_message()?));
                },
                66 => {
                    self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Emoticon(is.read_message()?));
                },
                82 => {
                    self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Courier(is.read_message()?));
                },
                90 => {
                    self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Ward(is.read_message()?));
                },
                98 => {
                    self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::HeroIcon(is.read_message()?));
                },
                106 => {
                    self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::SpiderGraph(is.read_message()?));
                },
                114 => {
                    self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::UserFeed(is.read_message()?));
                },
                122 => {
                    self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Stat(is.read_message()?));
                },
                130 => {
                    self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Roshan(is.read_message()?));
                },
                138 => {
                    self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Creep(is.read_message()?));
                },
                146 => {
                    self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Tower(is.read_message()?));
                },
                154 => {
                    self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Effigy(is.read_message()?));
                },
                162 => {
                    self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Decoration(is.read_message()?));
                },
                802 => {
                    self.item = ::std::option::Option::Some(cmsg_showcase_item_data::Item::Background(is.read_message()?));
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.item {
            match v {
                &cmsg_showcase_item_data::Item::Trophy(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_showcase_item_data::Item::EconItemIcon(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_showcase_item_data::Item::Sticker(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_showcase_item_data::Item::HeroModel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_showcase_item_data::Item::PlayerMatch(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_showcase_item_data::Item::ChatWheel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_showcase_item_data::Item::Spray(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_showcase_item_data::Item::Emoticon(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_showcase_item_data::Item::Courier(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_showcase_item_data::Item::Ward(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_showcase_item_data::Item::HeroIcon(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_showcase_item_data::Item::SpiderGraph(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_showcase_item_data::Item::UserFeed(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_showcase_item_data::Item::Stat(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_showcase_item_data::Item::Roshan(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_showcase_item_data::Item::Creep(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_showcase_item_data::Item::Tower(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_showcase_item_data::Item::Effigy(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_showcase_item_data::Item::Decoration(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cmsg_showcase_item_data::Item::Background(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.item {
            match v {
                &cmsg_showcase_item_data::Item::Trophy(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &cmsg_showcase_item_data::Item::EconItemIcon(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &cmsg_showcase_item_data::Item::Sticker(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &cmsg_showcase_item_data::Item::HeroModel(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &cmsg_showcase_item_data::Item::PlayerMatch(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &cmsg_showcase_item_data::Item::ChatWheel(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &cmsg_showcase_item_data::Item::Spray(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &cmsg_showcase_item_data::Item::Emoticon(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &cmsg_showcase_item_data::Item::Courier(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &cmsg_showcase_item_data::Item::Ward(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &cmsg_showcase_item_data::Item::HeroIcon(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &cmsg_showcase_item_data::Item::SpiderGraph(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &cmsg_showcase_item_data::Item::UserFeed(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &cmsg_showcase_item_data::Item::Stat(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &cmsg_showcase_item_data::Item::Roshan(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
                },
                &cmsg_showcase_item_data::Item::Creep(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
                },
                &cmsg_showcase_item_data::Item::Tower(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
                },
                &cmsg_showcase_item_data::Item::Effigy(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
                },
                &cmsg_showcase_item_data::Item::Decoration(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
                },
                &cmsg_showcase_item_data::Item::Background(ref v) => {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(100, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseItemData {
        CMsgShowcaseItemData::new()
    }

    fn clear(&mut self) {
        self.item = ::std::option::Option::None;
        self.item = ::std::option::Option::None;
        self.item = ::std::option::Option::None;
        self.item = ::std::option::Option::None;
        self.item = ::std::option::Option::None;
        self.item = ::std::option::Option::None;
        self.item = ::std::option::Option::None;
        self.item = ::std::option::Option::None;
        self.item = ::std::option::Option::None;
        self.item = ::std::option::Option::None;
        self.item = ::std::option::Option::None;
        self.item = ::std::option::Option::None;
        self.item = ::std::option::Option::None;
        self.item = ::std::option::Option::None;
        self.item = ::std::option::Option::None;
        self.item = ::std::option::Option::None;
        self.item = ::std::option::Option::None;
        self.item = ::std::option::Option::None;
        self.item = ::std::option::Option::None;
        self.item = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseItemData {
        static instance: CMsgShowcaseItemData = CMsgShowcaseItemData {
            item: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgShowcaseItemData`
pub mod cmsg_showcase_item_data {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CMsgShowcaseItemData.item)
    pub enum Item {
        // @@protoc_insertion_point(oneof_field:CMsgShowcaseItemData.trophy)
        Trophy(super::CMsgShowcaseItem_Trophy),
        // @@protoc_insertion_point(oneof_field:CMsgShowcaseItemData.econ_item_icon)
        EconItemIcon(super::CMsgShowcaseItem_EconItem),
        // @@protoc_insertion_point(oneof_field:CMsgShowcaseItemData.sticker)
        Sticker(super::CMsgShowcaseItem_EconItem),
        // @@protoc_insertion_point(oneof_field:CMsgShowcaseItemData.hero_model)
        HeroModel(super::CMsgShowcaseItem_Hero),
        // @@protoc_insertion_point(oneof_field:CMsgShowcaseItemData.player_match)
        PlayerMatch(super::CMsgShowcaseItem_PlayerMatch),
        // @@protoc_insertion_point(oneof_field:CMsgShowcaseItemData.chat_wheel)
        ChatWheel(super::CMsgShowcaseItem_ChatWheel),
        // @@protoc_insertion_point(oneof_field:CMsgShowcaseItemData.spray)
        Spray(super::CMsgShowcaseItem_ChatWheel),
        // @@protoc_insertion_point(oneof_field:CMsgShowcaseItemData.emoticon)
        Emoticon(super::CMsgShowcaseItem_Emoticon),
        // @@protoc_insertion_point(oneof_field:CMsgShowcaseItemData.courier)
        Courier(super::CMsgShowcaseItem_EconItem),
        // @@protoc_insertion_point(oneof_field:CMsgShowcaseItemData.ward)
        Ward(super::CMsgShowcaseItem_EconItem),
        // @@protoc_insertion_point(oneof_field:CMsgShowcaseItemData.hero_icon)
        HeroIcon(super::CMsgShowcaseItem_HeroIcon),
        // @@protoc_insertion_point(oneof_field:CMsgShowcaseItemData.spider_graph)
        SpiderGraph(super::CMsgShowcaseItem_SpiderGraph),
        // @@protoc_insertion_point(oneof_field:CMsgShowcaseItemData.user_feed)
        UserFeed(super::CMsgShowcaseItem_UserFeed),
        // @@protoc_insertion_point(oneof_field:CMsgShowcaseItemData.stat)
        Stat(super::CMsgShowcaseItem_Stat),
        // @@protoc_insertion_point(oneof_field:CMsgShowcaseItemData.roshan)
        Roshan(super::CMsgShowcaseItem_EconItem),
        // @@protoc_insertion_point(oneof_field:CMsgShowcaseItemData.creep)
        Creep(super::CMsgShowcaseItem_EconItem),
        // @@protoc_insertion_point(oneof_field:CMsgShowcaseItemData.tower)
        Tower(super::CMsgShowcaseItem_EconItem),
        // @@protoc_insertion_point(oneof_field:CMsgShowcaseItemData.effigy)
        Effigy(super::CMsgShowcaseItem_EconItem),
        // @@protoc_insertion_point(oneof_field:CMsgShowcaseItemData.decoration)
        Decoration(super::CMsgShowcaseItem_EconItem),
        // @@protoc_insertion_point(oneof_field:CMsgShowcaseItemData.background)
        Background(super::CMsgShowcaseBackground),
    }

    impl ::steam_vent_proto_common::protobuf::Oneof for Item {
    }

    impl Item {
    }
}

// @@protoc_insertion_point(message:CMsgShowcaseItemPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseItemPosition {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseItemPosition.position_x)
    pub position_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgShowcaseItemPosition.position_y)
    pub position_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgShowcaseItemPosition.scale)
    pub scale: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseItemPosition.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseItemPosition.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseItemPosition.rotation)
    pub rotation: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseItemPosition.parent_id)
    pub parent_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseItemPosition.parent_attachment_point_id)
    pub parent_attachment_point_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseItemPosition.attachment_anchor_x)
    pub attachment_anchor_x: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseItemPosition.attachment_anchor_y)
    pub attachment_anchor_y: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseItemPosition.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseItemPosition {
    fn default() -> &'a CMsgShowcaseItemPosition {
        <CMsgShowcaseItemPosition as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseItemPosition {
    pub fn new() -> CMsgShowcaseItemPosition {
        ::std::default::Default::default()
    }

    // optional int32 position_x = 1;

    pub fn position_x(&self) -> i32 {
        self.position_x.unwrap_or(0)
    }

    pub fn clear_position_x(&mut self) {
        self.position_x = ::std::option::Option::None;
    }

    pub fn has_position_x(&self) -> bool {
        self.position_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_x(&mut self, v: i32) {
        self.position_x = ::std::option::Option::Some(v);
    }

    // optional int32 position_y = 2;

    pub fn position_y(&self) -> i32 {
        self.position_y.unwrap_or(0)
    }

    pub fn clear_position_y(&mut self) {
        self.position_y = ::std::option::Option::None;
    }

    pub fn has_position_y(&self) -> bool {
        self.position_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_y(&mut self, v: i32) {
        self.position_y = ::std::option::Option::Some(v);
    }

    // optional uint32 scale = 3;

    pub fn scale(&self) -> u32 {
        self.scale.unwrap_or(0)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: u32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 4;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 5;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 rotation = 6;

    pub fn rotation(&self) -> u32 {
        self.rotation.unwrap_or(0)
    }

    pub fn clear_rotation(&mut self) {
        self.rotation = ::std::option::Option::None;
    }

    pub fn has_rotation(&self) -> bool {
        self.rotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rotation(&mut self, v: u32) {
        self.rotation = ::std::option::Option::Some(v);
    }

    // optional uint32 parent_id = 7;

    pub fn parent_id(&self) -> u32 {
        self.parent_id.unwrap_or(0)
    }

    pub fn clear_parent_id(&mut self) {
        self.parent_id = ::std::option::Option::None;
    }

    pub fn has_parent_id(&self) -> bool {
        self.parent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_id(&mut self, v: u32) {
        self.parent_id = ::std::option::Option::Some(v);
    }

    // optional uint32 parent_attachment_point_id = 8;

    pub fn parent_attachment_point_id(&self) -> u32 {
        self.parent_attachment_point_id.unwrap_or(0)
    }

    pub fn clear_parent_attachment_point_id(&mut self) {
        self.parent_attachment_point_id = ::std::option::Option::None;
    }

    pub fn has_parent_attachment_point_id(&self) -> bool {
        self.parent_attachment_point_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_attachment_point_id(&mut self, v: u32) {
        self.parent_attachment_point_id = ::std::option::Option::Some(v);
    }

    // optional uint32 attachment_anchor_x = 9;

    pub fn attachment_anchor_x(&self) -> u32 {
        self.attachment_anchor_x.unwrap_or(0)
    }

    pub fn clear_attachment_anchor_x(&mut self) {
        self.attachment_anchor_x = ::std::option::Option::None;
    }

    pub fn has_attachment_anchor_x(&self) -> bool {
        self.attachment_anchor_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachment_anchor_x(&mut self, v: u32) {
        self.attachment_anchor_x = ::std::option::Option::Some(v);
    }

    // optional uint32 attachment_anchor_y = 10;

    pub fn attachment_anchor_y(&self) -> u32 {
        self.attachment_anchor_y.unwrap_or(0)
    }

    pub fn clear_attachment_anchor_y(&mut self) {
        self.attachment_anchor_y = ::std::option::Option::None;
    }

    pub fn has_attachment_anchor_y(&self) -> bool {
        self.attachment_anchor_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachment_anchor_y(&mut self, v: u32) {
        self.attachment_anchor_y = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseItemPosition {
    const NAME: &'static str = "CMsgShowcaseItemPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.position_x = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.position_y = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.scale = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.rotation = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.parent_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.parent_attachment_point_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.attachment_anchor_x = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.attachment_anchor_y = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.position_x {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.position_y {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.scale {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.width {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.height {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.rotation {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.parent_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.parent_attachment_point_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.attachment_anchor_x {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.attachment_anchor_y {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.position_x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.position_y {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.scale {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.rotation {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.parent_id {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.parent_attachment_point_id {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.attachment_anchor_x {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.attachment_anchor_y {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseItemPosition {
        CMsgShowcaseItemPosition::new()
    }

    fn clear(&mut self) {
        self.position_x = ::std::option::Option::None;
        self.position_y = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.rotation = ::std::option::Option::None;
        self.parent_id = ::std::option::Option::None;
        self.parent_attachment_point_id = ::std::option::Option::None;
        self.attachment_anchor_x = ::std::option::Option::None;
        self.attachment_anchor_y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseItemPosition {
        static instance: CMsgShowcaseItemPosition = CMsgShowcaseItemPosition {
            position_x: ::std::option::Option::None,
            position_y: ::std::option::Option::None,
            scale: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            rotation: ::std::option::Option::None,
            parent_id: ::std::option::Option::None,
            parent_attachment_point_id: ::std::option::Option::None,
            attachment_anchor_x: ::std::option::Option::None,
            attachment_anchor_y: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgShowcaseItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseItem.showcase_item_id)
    pub showcase_item_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem.item_position)
    pub item_position: ::steam_vent_proto_common::protobuf::MessageField<CMsgShowcaseItemPosition>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem.item_data)
    pub item_data: ::steam_vent_proto_common::protobuf::MessageField<CMsgShowcaseItemData>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem.state)
    pub state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EShowcaseItemState>>,
    // @@protoc_insertion_point(field:CMsgShowcaseItem.flags)
    pub flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseItem {
    fn default() -> &'a CMsgShowcaseItem {
        <CMsgShowcaseItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseItem {
    pub fn new() -> CMsgShowcaseItem {
        ::std::default::Default::default()
    }

    // optional uint32 showcase_item_id = 1;

    pub fn showcase_item_id(&self) -> u32 {
        self.showcase_item_id.unwrap_or(0)
    }

    pub fn clear_showcase_item_id(&mut self) {
        self.showcase_item_id = ::std::option::Option::None;
    }

    pub fn has_showcase_item_id(&self) -> bool {
        self.showcase_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showcase_item_id(&mut self, v: u32) {
        self.showcase_item_id = ::std::option::Option::Some(v);
    }

    // optional .EShowcaseItemState state = 4;

    pub fn state(&self) -> EShowcaseItemState {
        match self.state {
            Some(e) => e.enum_value_or(EShowcaseItemState::k_eShowcaseItemState_Ok),
            None => EShowcaseItemState::k_eShowcaseItemState_Ok,
        }
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: EShowcaseItemState) {
        self.state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 flags = 5;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseItem {
    const NAME: &'static str = "CMsgShowcaseItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.showcase_item_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.item_position)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.item_data)?;
                },
                32 => {
                    self.state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.showcase_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.item_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.state {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.showcase_item_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_position.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.item_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.state {
            os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseItem {
        CMsgShowcaseItem::new()
    }

    fn clear(&mut self) {
        self.showcase_item_id = ::std::option::Option::None;
        self.item_position.clear();
        self.item_data.clear();
        self.state = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseItem {
        static instance: CMsgShowcaseItem = CMsgShowcaseItem {
            showcase_item_id: ::std::option::Option::None,
            item_position: ::steam_vent_proto_common::protobuf::MessageField::none(),
            item_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            state: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgShowcase)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcase {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcase.showcase_items)
    pub showcase_items: ::std::vec::Vec<CMsgShowcaseItem>,
    // @@protoc_insertion_point(field:CMsgShowcase.background)
    pub background: ::steam_vent_proto_common::protobuf::MessageField<CMsgShowcaseItem>,
    // @@protoc_insertion_point(field:CMsgShowcase.moderation_state)
    pub moderation_state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_showcase::EModerationState>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcase.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcase {
    fn default() -> &'a CMsgShowcase {
        <CMsgShowcase as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcase {
    pub fn new() -> CMsgShowcase {
        ::std::default::Default::default()
    }

    // optional .CMsgShowcase.EModerationState moderation_state = 4;

    pub fn moderation_state(&self) -> cmsg_showcase::EModerationState {
        match self.moderation_state {
            Some(e) => e.enum_value_or(cmsg_showcase::EModerationState::k_eModerationState_Ok),
            None => cmsg_showcase::EModerationState::k_eModerationState_Ok,
        }
    }

    pub fn clear_moderation_state(&mut self) {
        self.moderation_state = ::std::option::Option::None;
    }

    pub fn has_moderation_state(&self) -> bool {
        self.moderation_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_moderation_state(&mut self, v: cmsg_showcase::EModerationState) {
        self.moderation_state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcase {
    const NAME: &'static str = "CMsgShowcase";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.showcase_items.push(is.read_message()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.background)?;
                },
                32 => {
                    self.moderation_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.showcase_items {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.background.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.moderation_state {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.showcase_items {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.background.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.moderation_state {
            os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcase {
        CMsgShowcase::new()
    }

    fn clear(&mut self) {
        self.showcase_items.clear();
        self.background.clear();
        self.moderation_state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcase {
        static instance: CMsgShowcase = CMsgShowcase {
            showcase_items: ::std::vec::Vec::new(),
            background: ::steam_vent_proto_common::protobuf::MessageField::none(),
            moderation_state: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgShowcase`
pub mod cmsg_showcase {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgShowcase.EModerationState)
    pub enum EModerationState {
        // @@protoc_insertion_point(enum_value:CMsgShowcase.EModerationState.k_eModerationState_Ok)
        k_eModerationState_Ok = 0,
        // @@protoc_insertion_point(enum_value:CMsgShowcase.EModerationState.k_eModerationState_PendingApproval)
        k_eModerationState_PendingApproval = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EModerationState {
        const NAME: &'static str = "EModerationState";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EModerationState> {
            match value {
                0 => ::std::option::Option::Some(EModerationState::k_eModerationState_Ok),
                1 => ::std::option::Option::Some(EModerationState::k_eModerationState_PendingApproval),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EModerationState> {
            match str {
                "k_eModerationState_Ok" => ::std::option::Option::Some(EModerationState::k_eModerationState_Ok),
                "k_eModerationState_PendingApproval" => ::std::option::Option::Some(EModerationState::k_eModerationState_PendingApproval),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EModerationState] = &[
            EModerationState::k_eModerationState_Ok,
            EModerationState::k_eModerationState_PendingApproval,
        ];
    }

    impl ::std::default::Default for EModerationState {
        fn default() -> Self {
            EModerationState::k_eModerationState_Ok
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseGetUserData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseGetUserData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseGetUserData.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseGetUserData.showcase_type)
    pub showcase_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EShowcaseType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseGetUserData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseGetUserData {
    fn default() -> &'a CMsgClientToGCShowcaseGetUserData {
        <CMsgClientToGCShowcaseGetUserData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseGetUserData {
    pub fn new() -> CMsgClientToGCShowcaseGetUserData {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional .EShowcaseType showcase_type = 2;

    pub fn showcase_type(&self) -> EShowcaseType {
        match self.showcase_type {
            Some(e) => e.enum_value_or(EShowcaseType::k_eShowcaseType_Invalid),
            None => EShowcaseType::k_eShowcaseType_Invalid,
        }
    }

    pub fn clear_showcase_type(&mut self) {
        self.showcase_type = ::std::option::Option::None;
    }

    pub fn has_showcase_type(&self) -> bool {
        self.showcase_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showcase_type(&mut self, v: EShowcaseType) {
        self.showcase_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseGetUserData {
    const NAME: &'static str = "CMsgClientToGCShowcaseGetUserData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.showcase_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.showcase_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.showcase_type {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseGetUserData {
        CMsgClientToGCShowcaseGetUserData::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.showcase_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseGetUserData {
        static instance: CMsgClientToGCShowcaseGetUserData = CMsgClientToGCShowcaseGetUserData {
            account_id: ::std::option::Option::None,
            showcase_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseGetUserDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseGetUserDataResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseGetUserDataResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcshowcase_get_user_data_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseGetUserDataResponse.showcase)
    pub showcase: ::steam_vent_proto_common::protobuf::MessageField<CMsgShowcase>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseGetUserDataResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseGetUserDataResponse {
    fn default() -> &'a CMsgClientToGCShowcaseGetUserDataResponse {
        <CMsgClientToGCShowcaseGetUserDataResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseGetUserDataResponse {
    pub fn new() -> CMsgClientToGCShowcaseGetUserDataResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCShowcaseGetUserDataResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcshowcase_get_user_data_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcshowcase_get_user_data_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcshowcase_get_user_data_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcshowcase_get_user_data_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseGetUserDataResponse {
    const NAME: &'static str = "CMsgClientToGCShowcaseGetUserDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.showcase)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.showcase.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.showcase.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseGetUserDataResponse {
        CMsgClientToGCShowcaseGetUserDataResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.showcase.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseGetUserDataResponse {
        static instance: CMsgClientToGCShowcaseGetUserDataResponse = CMsgClientToGCShowcaseGetUserDataResponse {
            response: ::std::option::Option::None,
            showcase: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCShowcaseGetUserDataResponse`
pub mod cmsg_client_to_gcshowcase_get_user_data_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCShowcaseGetUserDataResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseGetUserDataResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseGetUserDataResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseGetUserDataResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseGetUserDataResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseGetUserDataResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseGetUserDataResponse.EResponse.k_eUnknownShowcase)
        k_eUnknownShowcase = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eUnknownShowcase),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eUnknownShowcase" => ::std::option::Option::Some(EResponse::k_eUnknownShowcase),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eUnknownShowcase,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseSetUserData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseSetUserData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseSetUserData.showcase_type)
    pub showcase_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EShowcaseType>>,
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseSetUserData.showcase)
    pub showcase: ::steam_vent_proto_common::protobuf::MessageField<CMsgShowcase>,
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseSetUserData.format_version)
    pub format_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseSetUserData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseSetUserData {
    fn default() -> &'a CMsgClientToGCShowcaseSetUserData {
        <CMsgClientToGCShowcaseSetUserData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseSetUserData {
    pub fn new() -> CMsgClientToGCShowcaseSetUserData {
        ::std::default::Default::default()
    }

    // optional .EShowcaseType showcase_type = 1;

    pub fn showcase_type(&self) -> EShowcaseType {
        match self.showcase_type {
            Some(e) => e.enum_value_or(EShowcaseType::k_eShowcaseType_Invalid),
            None => EShowcaseType::k_eShowcaseType_Invalid,
        }
    }

    pub fn clear_showcase_type(&mut self) {
        self.showcase_type = ::std::option::Option::None;
    }

    pub fn has_showcase_type(&self) -> bool {
        self.showcase_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showcase_type(&mut self, v: EShowcaseType) {
        self.showcase_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 format_version = 3;

    pub fn format_version(&self) -> u32 {
        self.format_version.unwrap_or(0)
    }

    pub fn clear_format_version(&mut self) {
        self.format_version = ::std::option::Option::None;
    }

    pub fn has_format_version(&self) -> bool {
        self.format_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format_version(&mut self, v: u32) {
        self.format_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseSetUserData {
    const NAME: &'static str = "CMsgClientToGCShowcaseSetUserData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.showcase_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.showcase)?;
                },
                24 => {
                    self.format_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.showcase_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.showcase.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.format_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.showcase_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.showcase.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.format_version {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseSetUserData {
        CMsgClientToGCShowcaseSetUserData::new()
    }

    fn clear(&mut self) {
        self.showcase_type = ::std::option::Option::None;
        self.showcase.clear();
        self.format_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseSetUserData {
        static instance: CMsgClientToGCShowcaseSetUserData = CMsgClientToGCShowcaseSetUserData {
            showcase_type: ::std::option::Option::None,
            showcase: ::steam_vent_proto_common::protobuf::MessageField::none(),
            format_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseSetUserDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseSetUserDataResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseSetUserDataResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcshowcase_set_user_data_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseSetUserDataResponse.validated_showcase)
    pub validated_showcase: ::steam_vent_proto_common::protobuf::MessageField<CMsgShowcase>,
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseSetUserDataResponse.locked_until_timestamp)
    pub locked_until_timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseSetUserDataResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseSetUserDataResponse {
    fn default() -> &'a CMsgClientToGCShowcaseSetUserDataResponse {
        <CMsgClientToGCShowcaseSetUserDataResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseSetUserDataResponse {
    pub fn new() -> CMsgClientToGCShowcaseSetUserDataResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCShowcaseSetUserDataResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcshowcase_set_user_data_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcshowcase_set_user_data_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcshowcase_set_user_data_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcshowcase_set_user_data_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 locked_until_timestamp = 3;

    pub fn locked_until_timestamp(&self) -> u32 {
        self.locked_until_timestamp.unwrap_or(0)
    }

    pub fn clear_locked_until_timestamp(&mut self) {
        self.locked_until_timestamp = ::std::option::Option::None;
    }

    pub fn has_locked_until_timestamp(&self) -> bool {
        self.locked_until_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locked_until_timestamp(&mut self, v: u32) {
        self.locked_until_timestamp = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseSetUserDataResponse {
    const NAME: &'static str = "CMsgClientToGCShowcaseSetUserDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.validated_showcase)?;
                },
                24 => {
                    self.locked_until_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.validated_showcase.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.locked_until_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.validated_showcase.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.locked_until_timestamp {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseSetUserDataResponse {
        CMsgClientToGCShowcaseSetUserDataResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.validated_showcase.clear();
        self.locked_until_timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseSetUserDataResponse {
        static instance: CMsgClientToGCShowcaseSetUserDataResponse = CMsgClientToGCShowcaseSetUserDataResponse {
            response: ::std::option::Option::None,
            validated_showcase: ::steam_vent_proto_common::protobuf::MessageField::none(),
            locked_until_timestamp: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCShowcaseSetUserDataResponse`
pub mod cmsg_client_to_gcshowcase_set_user_data_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCShowcaseSetUserDataResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseSetUserDataResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseSetUserDataResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseSetUserDataResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseSetUserDataResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseSetUserDataResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseSetUserDataResponse.EResponse.k_eInvalid)
        k_eInvalid = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseSetUserDataResponse.EResponse.k_eLockedFromEditing)
        k_eLockedFromEditing = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseSetUserDataResponse.EResponse.k_eBudgetExceeded)
        k_eBudgetExceeded = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseSetUserDataResponse.EResponse.k_eCommunicationScoreTooLow)
        k_eCommunicationScoreTooLow = 8,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalid),
                6 => ::std::option::Option::Some(EResponse::k_eLockedFromEditing),
                7 => ::std::option::Option::Some(EResponse::k_eBudgetExceeded),
                8 => ::std::option::Option::Some(EResponse::k_eCommunicationScoreTooLow),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalid" => ::std::option::Option::Some(EResponse::k_eInvalid),
                "k_eLockedFromEditing" => ::std::option::Option::Some(EResponse::k_eLockedFromEditing),
                "k_eBudgetExceeded" => ::std::option::Option::Some(EResponse::k_eBudgetExceeded),
                "k_eCommunicationScoreTooLow" => ::std::option::Option::Some(EResponse::k_eCommunicationScoreTooLow),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalid,
            EResponse::k_eLockedFromEditing,
            EResponse::k_eBudgetExceeded,
            EResponse::k_eCommunicationScoreTooLow,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseSubmitReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseSubmitReport {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseSubmitReport.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseSubmitReport.showcase_type)
    pub showcase_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EShowcaseType>>,
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseSubmitReport.report_comment)
    pub report_comment: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseSubmitReport.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseSubmitReport {
    fn default() -> &'a CMsgClientToGCShowcaseSubmitReport {
        <CMsgClientToGCShowcaseSubmitReport as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseSubmitReport {
    pub fn new() -> CMsgClientToGCShowcaseSubmitReport {
        ::std::default::Default::default()
    }

    // optional uint32 target_account_id = 1;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    // optional .EShowcaseType showcase_type = 2;

    pub fn showcase_type(&self) -> EShowcaseType {
        match self.showcase_type {
            Some(e) => e.enum_value_or(EShowcaseType::k_eShowcaseType_Invalid),
            None => EShowcaseType::k_eShowcaseType_Invalid,
        }
    }

    pub fn clear_showcase_type(&mut self) {
        self.showcase_type = ::std::option::Option::None;
    }

    pub fn has_showcase_type(&self) -> bool {
        self.showcase_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showcase_type(&mut self, v: EShowcaseType) {
        self.showcase_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string report_comment = 3;

    pub fn report_comment(&self) -> &str {
        match self.report_comment.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_report_comment(&mut self) {
        self.report_comment = ::std::option::Option::None;
    }

    pub fn has_report_comment(&self) -> bool {
        self.report_comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_comment(&mut self, v: ::std::string::String) {
        self.report_comment = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_report_comment(&mut self) -> &mut ::std::string::String {
        if self.report_comment.is_none() {
            self.report_comment = ::std::option::Option::Some(::std::string::String::new());
        }
        self.report_comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_report_comment(&mut self) -> ::std::string::String {
        self.report_comment.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseSubmitReport {
    const NAME: &'static str = "CMsgClientToGCShowcaseSubmitReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.showcase_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.report_comment = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.showcase_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.report_comment.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.showcase_type {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.report_comment.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseSubmitReport {
        CMsgClientToGCShowcaseSubmitReport::new()
    }

    fn clear(&mut self) {
        self.target_account_id = ::std::option::Option::None;
        self.showcase_type = ::std::option::Option::None;
        self.report_comment = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseSubmitReport {
        static instance: CMsgClientToGCShowcaseSubmitReport = CMsgClientToGCShowcaseSubmitReport {
            target_account_id: ::std::option::Option::None,
            showcase_type: ::std::option::Option::None,
            report_comment: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseSubmitReportResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseSubmitReportResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseSubmitReportResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcshowcase_submit_report_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseSubmitReportResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseSubmitReportResponse {
    fn default() -> &'a CMsgClientToGCShowcaseSubmitReportResponse {
        <CMsgClientToGCShowcaseSubmitReportResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseSubmitReportResponse {
    pub fn new() -> CMsgClientToGCShowcaseSubmitReportResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCShowcaseSubmitReportResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcshowcase_submit_report_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcshowcase_submit_report_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcshowcase_submit_report_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcshowcase_submit_report_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseSubmitReportResponse {
    const NAME: &'static str = "CMsgClientToGCShowcaseSubmitReportResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseSubmitReportResponse {
        CMsgClientToGCShowcaseSubmitReportResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseSubmitReportResponse {
        static instance: CMsgClientToGCShowcaseSubmitReportResponse = CMsgClientToGCShowcaseSubmitReportResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCShowcaseSubmitReportResponse`
pub mod cmsg_client_to_gcshowcase_submit_report_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCShowcaseSubmitReportResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseSubmitReportResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseSubmitReportResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseSubmitReportResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseSubmitReportResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseSubmitReportResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseSubmitReportResponse.EResponse.k_eAlreadyReported)
        k_eAlreadyReported = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eAlreadyReported),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eAlreadyReported" => ::std::option::Option::Some(EResponse::k_eAlreadyReported),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eAlreadyReported,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgShowcaseReportsRollupInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseReportsRollupInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseReportsRollupInfo.rollup_id)
    pub rollup_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseReportsRollupInfo.start_timestamp)
    pub start_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseReportsRollupInfo.end_timestamp)
    pub end_timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseReportsRollupInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseReportsRollupInfo {
    fn default() -> &'a CMsgShowcaseReportsRollupInfo {
        <CMsgShowcaseReportsRollupInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseReportsRollupInfo {
    pub fn new() -> CMsgShowcaseReportsRollupInfo {
        ::std::default::Default::default()
    }

    // optional uint32 rollup_id = 1;

    pub fn rollup_id(&self) -> u32 {
        self.rollup_id.unwrap_or(0)
    }

    pub fn clear_rollup_id(&mut self) {
        self.rollup_id = ::std::option::Option::None;
    }

    pub fn has_rollup_id(&self) -> bool {
        self.rollup_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollup_id(&mut self, v: u32) {
        self.rollup_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_timestamp = 2;

    pub fn start_timestamp(&self) -> u32 {
        self.start_timestamp.unwrap_or(0)
    }

    pub fn clear_start_timestamp(&mut self) {
        self.start_timestamp = ::std::option::Option::None;
    }

    pub fn has_start_timestamp(&self) -> bool {
        self.start_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_timestamp(&mut self, v: u32) {
        self.start_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 end_timestamp = 3;

    pub fn end_timestamp(&self) -> u32 {
        self.end_timestamp.unwrap_or(0)
    }

    pub fn clear_end_timestamp(&mut self) {
        self.end_timestamp = ::std::option::Option::None;
    }

    pub fn has_end_timestamp(&self) -> bool {
        self.end_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_timestamp(&mut self, v: u32) {
        self.end_timestamp = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseReportsRollupInfo {
    const NAME: &'static str = "CMsgShowcaseReportsRollupInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rollup_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.start_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.end_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rollup_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.start_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.end_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.rollup_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.end_timestamp {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseReportsRollupInfo {
        CMsgShowcaseReportsRollupInfo::new()
    }

    fn clear(&mut self) {
        self.rollup_id = ::std::option::Option::None;
        self.start_timestamp = ::std::option::Option::None;
        self.end_timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseReportsRollupInfo {
        static instance: CMsgShowcaseReportsRollupInfo = CMsgShowcaseReportsRollupInfo {
            rollup_id: ::std::option::Option::None,
            start_timestamp: ::std::option::Option::None,
            end_timestamp: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgShowcaseReportsRollupList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseReportsRollupList {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseReportsRollupList.rollups)
    pub rollups: ::std::vec::Vec<CMsgShowcaseReportsRollupInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseReportsRollupList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseReportsRollupList {
    fn default() -> &'a CMsgShowcaseReportsRollupList {
        <CMsgShowcaseReportsRollupList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseReportsRollupList {
    pub fn new() -> CMsgShowcaseReportsRollupList {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseReportsRollupList {
    const NAME: &'static str = "CMsgShowcaseReportsRollupList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rollups.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.rollups {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.rollups {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseReportsRollupList {
        CMsgShowcaseReportsRollupList::new()
    }

    fn clear(&mut self) {
        self.rollups.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseReportsRollupList {
        static instance: CMsgShowcaseReportsRollupList = CMsgShowcaseReportsRollupList {
            rollups: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgShowcaseReportsRollupEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseReportsRollupEntry {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseReportsRollupEntry.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseReportsRollupEntry.showcase_type)
    pub showcase_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EShowcaseType>>,
    // @@protoc_insertion_point(field:CMsgShowcaseReportsRollupEntry.report_count)
    pub report_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseReportsRollupEntry.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseReportsRollupEntry {
    fn default() -> &'a CMsgShowcaseReportsRollupEntry {
        <CMsgShowcaseReportsRollupEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseReportsRollupEntry {
    pub fn new() -> CMsgShowcaseReportsRollupEntry {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional .EShowcaseType showcase_type = 2;

    pub fn showcase_type(&self) -> EShowcaseType {
        match self.showcase_type {
            Some(e) => e.enum_value_or(EShowcaseType::k_eShowcaseType_Invalid),
            None => EShowcaseType::k_eShowcaseType_Invalid,
        }
    }

    pub fn clear_showcase_type(&mut self) {
        self.showcase_type = ::std::option::Option::None;
    }

    pub fn has_showcase_type(&self) -> bool {
        self.showcase_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showcase_type(&mut self, v: EShowcaseType) {
        self.showcase_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 report_count = 3;

    pub fn report_count(&self) -> u32 {
        self.report_count.unwrap_or(0)
    }

    pub fn clear_report_count(&mut self) {
        self.report_count = ::std::option::Option::None;
    }

    pub fn has_report_count(&self) -> bool {
        self.report_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_count(&mut self, v: u32) {
        self.report_count = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseReportsRollupEntry {
    const NAME: &'static str = "CMsgShowcaseReportsRollupEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.showcase_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.report_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.showcase_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.report_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.showcase_type {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.report_count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseReportsRollupEntry {
        CMsgShowcaseReportsRollupEntry::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.showcase_type = ::std::option::Option::None;
        self.report_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseReportsRollupEntry {
        static instance: CMsgShowcaseReportsRollupEntry = CMsgShowcaseReportsRollupEntry {
            account_id: ::std::option::Option::None,
            showcase_type: ::std::option::Option::None,
            report_count: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgShowcaseReportsRollup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseReportsRollup {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseReportsRollup.rollup_info)
    pub rollup_info: ::steam_vent_proto_common::protobuf::MessageField<CMsgShowcaseReportsRollupInfo>,
    // @@protoc_insertion_point(field:CMsgShowcaseReportsRollup.rollup_entries)
    pub rollup_entries: ::std::vec::Vec<CMsgShowcaseReportsRollupEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseReportsRollup.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseReportsRollup {
    fn default() -> &'a CMsgShowcaseReportsRollup {
        <CMsgShowcaseReportsRollup as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseReportsRollup {
    pub fn new() -> CMsgShowcaseReportsRollup {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseReportsRollup {
    const NAME: &'static str = "CMsgShowcaseReportsRollup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.rollup_info)?;
                },
                18 => {
                    self.rollup_entries.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rollup_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.rollup_entries {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.rollup_info.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.rollup_entries {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseReportsRollup {
        CMsgShowcaseReportsRollup::new()
    }

    fn clear(&mut self) {
        self.rollup_info.clear();
        self.rollup_entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseReportsRollup {
        static instance: CMsgShowcaseReportsRollup = CMsgShowcaseReportsRollup {
            rollup_info: ::steam_vent_proto_common::protobuf::MessageField::none(),
            rollup_entries: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseAdminGetReportsRollupList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseAdminGetReportsRollupList {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseAdminGetReportsRollupList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseAdminGetReportsRollupList {
    fn default() -> &'a CMsgClientToGCShowcaseAdminGetReportsRollupList {
        <CMsgClientToGCShowcaseAdminGetReportsRollupList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseAdminGetReportsRollupList {
    pub fn new() -> CMsgClientToGCShowcaseAdminGetReportsRollupList {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseAdminGetReportsRollupList {
    const NAME: &'static str = "CMsgClientToGCShowcaseAdminGetReportsRollupList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseAdminGetReportsRollupList {
        CMsgClientToGCShowcaseAdminGetReportsRollupList::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseAdminGetReportsRollupList {
        static instance: CMsgClientToGCShowcaseAdminGetReportsRollupList = CMsgClientToGCShowcaseAdminGetReportsRollupList {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseAdminGetReportsRollupListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseAdminGetReportsRollupListResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseAdminGetReportsRollupListResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcshowcase_admin_get_reports_rollup_list_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseAdminGetReportsRollupListResponse.rollup_list)
    pub rollup_list: ::steam_vent_proto_common::protobuf::MessageField<CMsgShowcaseReportsRollupList>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseAdminGetReportsRollupListResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseAdminGetReportsRollupListResponse {
    fn default() -> &'a CMsgClientToGCShowcaseAdminGetReportsRollupListResponse {
        <CMsgClientToGCShowcaseAdminGetReportsRollupListResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseAdminGetReportsRollupListResponse {
    pub fn new() -> CMsgClientToGCShowcaseAdminGetReportsRollupListResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCShowcaseAdminGetReportsRollupListResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcshowcase_admin_get_reports_rollup_list_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcshowcase_admin_get_reports_rollup_list_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcshowcase_admin_get_reports_rollup_list_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcshowcase_admin_get_reports_rollup_list_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseAdminGetReportsRollupListResponse {
    const NAME: &'static str = "CMsgClientToGCShowcaseAdminGetReportsRollupListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.rollup_list)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.rollup_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.rollup_list.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseAdminGetReportsRollupListResponse {
        CMsgClientToGCShowcaseAdminGetReportsRollupListResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.rollup_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseAdminGetReportsRollupListResponse {
        static instance: CMsgClientToGCShowcaseAdminGetReportsRollupListResponse = CMsgClientToGCShowcaseAdminGetReportsRollupListResponse {
            response: ::std::option::Option::None,
            rollup_list: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCShowcaseAdminGetReportsRollupListResponse`
pub mod cmsg_client_to_gcshowcase_admin_get_reports_rollup_list_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCShowcaseAdminGetReportsRollupListResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminGetReportsRollupListResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminGetReportsRollupListResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminGetReportsRollupListResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminGetReportsRollupListResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminGetReportsRollupListResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminGetReportsRollupListResponse.EResponse.k_eNoPermission)
        k_eNoPermission = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNoPermission),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNoPermission" => ::std::option::Option::Some(EResponse::k_eNoPermission),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNoPermission,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseAdminGetReportsRollup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseAdminGetReportsRollup {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseAdminGetReportsRollup.rollup_id)
    pub rollup_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseAdminGetReportsRollup.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseAdminGetReportsRollup {
    fn default() -> &'a CMsgClientToGCShowcaseAdminGetReportsRollup {
        <CMsgClientToGCShowcaseAdminGetReportsRollup as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseAdminGetReportsRollup {
    pub fn new() -> CMsgClientToGCShowcaseAdminGetReportsRollup {
        ::std::default::Default::default()
    }

    // optional uint32 rollup_id = 1;

    pub fn rollup_id(&self) -> u32 {
        self.rollup_id.unwrap_or(0)
    }

    pub fn clear_rollup_id(&mut self) {
        self.rollup_id = ::std::option::Option::None;
    }

    pub fn has_rollup_id(&self) -> bool {
        self.rollup_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollup_id(&mut self, v: u32) {
        self.rollup_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseAdminGetReportsRollup {
    const NAME: &'static str = "CMsgClientToGCShowcaseAdminGetReportsRollup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rollup_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rollup_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.rollup_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseAdminGetReportsRollup {
        CMsgClientToGCShowcaseAdminGetReportsRollup::new()
    }

    fn clear(&mut self) {
        self.rollup_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseAdminGetReportsRollup {
        static instance: CMsgClientToGCShowcaseAdminGetReportsRollup = CMsgClientToGCShowcaseAdminGetReportsRollup {
            rollup_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseAdminGetReportsRollupResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseAdminGetReportsRollupResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseAdminGetReportsRollupResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcshowcase_admin_get_reports_rollup_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseAdminGetReportsRollupResponse.rollup)
    pub rollup: ::steam_vent_proto_common::protobuf::MessageField<CMsgShowcaseReportsRollup>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseAdminGetReportsRollupResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseAdminGetReportsRollupResponse {
    fn default() -> &'a CMsgClientToGCShowcaseAdminGetReportsRollupResponse {
        <CMsgClientToGCShowcaseAdminGetReportsRollupResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseAdminGetReportsRollupResponse {
    pub fn new() -> CMsgClientToGCShowcaseAdminGetReportsRollupResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCShowcaseAdminGetReportsRollupResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcshowcase_admin_get_reports_rollup_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcshowcase_admin_get_reports_rollup_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcshowcase_admin_get_reports_rollup_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcshowcase_admin_get_reports_rollup_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseAdminGetReportsRollupResponse {
    const NAME: &'static str = "CMsgClientToGCShowcaseAdminGetReportsRollupResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.rollup)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.rollup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.rollup.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseAdminGetReportsRollupResponse {
        CMsgClientToGCShowcaseAdminGetReportsRollupResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.rollup.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseAdminGetReportsRollupResponse {
        static instance: CMsgClientToGCShowcaseAdminGetReportsRollupResponse = CMsgClientToGCShowcaseAdminGetReportsRollupResponse {
            response: ::std::option::Option::None,
            rollup: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCShowcaseAdminGetReportsRollupResponse`
pub mod cmsg_client_to_gcshowcase_admin_get_reports_rollup_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCShowcaseAdminGetReportsRollupResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminGetReportsRollupResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminGetReportsRollupResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminGetReportsRollupResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminGetReportsRollupResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminGetReportsRollupResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminGetReportsRollupResponse.EResponse.k_eNoPermission)
        k_eNoPermission = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminGetReportsRollupResponse.EResponse.k_eNotFound)
        k_eNotFound = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNoPermission),
                6 => ::std::option::Option::Some(EResponse::k_eNotFound),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNoPermission" => ::std::option::Option::Some(EResponse::k_eNoPermission),
                "k_eNotFound" => ::std::option::Option::Some(EResponse::k_eNotFound),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNoPermission,
            EResponse::k_eNotFound,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgShowcaseAuditEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseAuditEntry {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseAuditEntry.showcase_type)
    pub showcase_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EShowcaseType>>,
    // @@protoc_insertion_point(field:CMsgShowcaseAuditEntry.audit_action)
    pub audit_action: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EShowcaseAuditAction>>,
    // @@protoc_insertion_point(field:CMsgShowcaseAuditEntry.audit_data)
    pub audit_data: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgShowcaseAuditEntry.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseAuditEntry.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseAuditEntry {
    fn default() -> &'a CMsgShowcaseAuditEntry {
        <CMsgShowcaseAuditEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseAuditEntry {
    pub fn new() -> CMsgShowcaseAuditEntry {
        ::std::default::Default::default()
    }

    // optional .EShowcaseType showcase_type = 1;

    pub fn showcase_type(&self) -> EShowcaseType {
        match self.showcase_type {
            Some(e) => e.enum_value_or(EShowcaseType::k_eShowcaseType_Invalid),
            None => EShowcaseType::k_eShowcaseType_Invalid,
        }
    }

    pub fn clear_showcase_type(&mut self) {
        self.showcase_type = ::std::option::Option::None;
    }

    pub fn has_showcase_type(&self) -> bool {
        self.showcase_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showcase_type(&mut self, v: EShowcaseType) {
        self.showcase_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .EShowcaseAuditAction audit_action = 2;

    pub fn audit_action(&self) -> EShowcaseAuditAction {
        match self.audit_action {
            Some(e) => e.enum_value_or(EShowcaseAuditAction::k_eShowcaseAuditAction_Invalid),
            None => EShowcaseAuditAction::k_eShowcaseAuditAction_Invalid,
        }
    }

    pub fn clear_audit_action(&mut self) {
        self.audit_action = ::std::option::Option::None;
    }

    pub fn has_audit_action(&self) -> bool {
        self.audit_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audit_action(&mut self, v: EShowcaseAuditAction) {
        self.audit_action = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 audit_data = 3;

    pub fn audit_data(&self) -> u64 {
        self.audit_data.unwrap_or(0)
    }

    pub fn clear_audit_data(&mut self) {
        self.audit_data = ::std::option::Option::None;
    }

    pub fn has_audit_data(&self) -> bool {
        self.audit_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audit_data(&mut self, v: u64) {
        self.audit_data = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 4;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseAuditEntry {
    const NAME: &'static str = "CMsgShowcaseAuditEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.showcase_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.audit_action = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.audit_data = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.showcase_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.audit_action {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.audit_data {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.showcase_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.audit_action {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.audit_data {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseAuditEntry {
        CMsgShowcaseAuditEntry::new()
    }

    fn clear(&mut self) {
        self.showcase_type = ::std::option::Option::None;
        self.audit_action = ::std::option::Option::None;
        self.audit_data = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseAuditEntry {
        static instance: CMsgShowcaseAuditEntry = CMsgShowcaseAuditEntry {
            showcase_type: ::std::option::Option::None,
            audit_action: ::std::option::Option::None,
            audit_data: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgShowcaseReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseReport {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseReport.reporter_account_id)
    pub reporter_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseReport.showcase_type)
    pub showcase_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EShowcaseType>>,
    // @@protoc_insertion_point(field:CMsgShowcaseReport.report_timestamp)
    pub report_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseReport.report_comment)
    pub report_comment: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseReport.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseReport {
    fn default() -> &'a CMsgShowcaseReport {
        <CMsgShowcaseReport as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseReport {
    pub fn new() -> CMsgShowcaseReport {
        ::std::default::Default::default()
    }

    // optional uint32 reporter_account_id = 1;

    pub fn reporter_account_id(&self) -> u32 {
        self.reporter_account_id.unwrap_or(0)
    }

    pub fn clear_reporter_account_id(&mut self) {
        self.reporter_account_id = ::std::option::Option::None;
    }

    pub fn has_reporter_account_id(&self) -> bool {
        self.reporter_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reporter_account_id(&mut self, v: u32) {
        self.reporter_account_id = ::std::option::Option::Some(v);
    }

    // optional .EShowcaseType showcase_type = 2;

    pub fn showcase_type(&self) -> EShowcaseType {
        match self.showcase_type {
            Some(e) => e.enum_value_or(EShowcaseType::k_eShowcaseType_Invalid),
            None => EShowcaseType::k_eShowcaseType_Invalid,
        }
    }

    pub fn clear_showcase_type(&mut self) {
        self.showcase_type = ::std::option::Option::None;
    }

    pub fn has_showcase_type(&self) -> bool {
        self.showcase_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showcase_type(&mut self, v: EShowcaseType) {
        self.showcase_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 report_timestamp = 3;

    pub fn report_timestamp(&self) -> u32 {
        self.report_timestamp.unwrap_or(0)
    }

    pub fn clear_report_timestamp(&mut self) {
        self.report_timestamp = ::std::option::Option::None;
    }

    pub fn has_report_timestamp(&self) -> bool {
        self.report_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_timestamp(&mut self, v: u32) {
        self.report_timestamp = ::std::option::Option::Some(v);
    }

    // optional string report_comment = 4;

    pub fn report_comment(&self) -> &str {
        match self.report_comment.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_report_comment(&mut self) {
        self.report_comment = ::std::option::Option::None;
    }

    pub fn has_report_comment(&self) -> bool {
        self.report_comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_comment(&mut self, v: ::std::string::String) {
        self.report_comment = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_report_comment(&mut self) -> &mut ::std::string::String {
        if self.report_comment.is_none() {
            self.report_comment = ::std::option::Option::Some(::std::string::String::new());
        }
        self.report_comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_report_comment(&mut self) -> ::std::string::String {
        self.report_comment.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseReport {
    const NAME: &'static str = "CMsgShowcaseReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reporter_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.showcase_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.report_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.report_comment = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reporter_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.showcase_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.report_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.report_comment.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.reporter_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.showcase_type {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.report_timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.report_comment.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseReport {
        CMsgShowcaseReport::new()
    }

    fn clear(&mut self) {
        self.reporter_account_id = ::std::option::Option::None;
        self.showcase_type = ::std::option::Option::None;
        self.report_timestamp = ::std::option::Option::None;
        self.report_comment = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseReport {
        static instance: CMsgShowcaseReport = CMsgShowcaseReport {
            reporter_account_id: ::std::option::Option::None,
            showcase_type: ::std::option::Option::None,
            report_timestamp: ::std::option::Option::None,
            report_comment: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgShowcaseAdminUserDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseAdminUserDetails {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseAdminUserDetails.locked_until_timestamp)
    pub locked_until_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseAdminUserDetails.audit_entries)
    pub audit_entries: ::std::vec::Vec<CMsgShowcaseAuditEntry>,
    // @@protoc_insertion_point(field:CMsgShowcaseAdminUserDetails.reports)
    pub reports: ::std::vec::Vec<CMsgShowcaseReport>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseAdminUserDetails.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseAdminUserDetails {
    fn default() -> &'a CMsgShowcaseAdminUserDetails {
        <CMsgShowcaseAdminUserDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseAdminUserDetails {
    pub fn new() -> CMsgShowcaseAdminUserDetails {
        ::std::default::Default::default()
    }

    // optional uint32 locked_until_timestamp = 1;

    pub fn locked_until_timestamp(&self) -> u32 {
        self.locked_until_timestamp.unwrap_or(0)
    }

    pub fn clear_locked_until_timestamp(&mut self) {
        self.locked_until_timestamp = ::std::option::Option::None;
    }

    pub fn has_locked_until_timestamp(&self) -> bool {
        self.locked_until_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locked_until_timestamp(&mut self, v: u32) {
        self.locked_until_timestamp = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseAdminUserDetails {
    const NAME: &'static str = "CMsgShowcaseAdminUserDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.locked_until_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.audit_entries.push(is.read_message()?);
                },
                26 => {
                    self.reports.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.locked_until_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.audit_entries {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.reports {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.locked_until_timestamp {
            os.write_uint32(1, v)?;
        }
        for v in &self.audit_entries {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.reports {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseAdminUserDetails {
        CMsgShowcaseAdminUserDetails::new()
    }

    fn clear(&mut self) {
        self.locked_until_timestamp = ::std::option::Option::None;
        self.audit_entries.clear();
        self.reports.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseAdminUserDetails {
        static instance: CMsgShowcaseAdminUserDetails = CMsgShowcaseAdminUserDetails {
            locked_until_timestamp: ::std::option::Option::None,
            audit_entries: ::std::vec::Vec::new(),
            reports: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseAdminGetUserDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseAdminGetUserDetails {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseAdminGetUserDetails.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseAdminGetUserDetails.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseAdminGetUserDetails {
    fn default() -> &'a CMsgClientToGCShowcaseAdminGetUserDetails {
        <CMsgClientToGCShowcaseAdminGetUserDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseAdminGetUserDetails {
    pub fn new() -> CMsgClientToGCShowcaseAdminGetUserDetails {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseAdminGetUserDetails {
    const NAME: &'static str = "CMsgClientToGCShowcaseAdminGetUserDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseAdminGetUserDetails {
        CMsgClientToGCShowcaseAdminGetUserDetails::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseAdminGetUserDetails {
        static instance: CMsgClientToGCShowcaseAdminGetUserDetails = CMsgClientToGCShowcaseAdminGetUserDetails {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseAdminGetUserDetailsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseAdminGetUserDetailsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseAdminGetUserDetailsResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcshowcase_admin_get_user_details_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseAdminGetUserDetailsResponse.user_details)
    pub user_details: ::steam_vent_proto_common::protobuf::MessageField<CMsgShowcaseAdminUserDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseAdminGetUserDetailsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseAdminGetUserDetailsResponse {
    fn default() -> &'a CMsgClientToGCShowcaseAdminGetUserDetailsResponse {
        <CMsgClientToGCShowcaseAdminGetUserDetailsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseAdminGetUserDetailsResponse {
    pub fn new() -> CMsgClientToGCShowcaseAdminGetUserDetailsResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCShowcaseAdminGetUserDetailsResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcshowcase_admin_get_user_details_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcshowcase_admin_get_user_details_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcshowcase_admin_get_user_details_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcshowcase_admin_get_user_details_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseAdminGetUserDetailsResponse {
    const NAME: &'static str = "CMsgClientToGCShowcaseAdminGetUserDetailsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.user_details)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.user_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.user_details.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseAdminGetUserDetailsResponse {
        CMsgClientToGCShowcaseAdminGetUserDetailsResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.user_details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseAdminGetUserDetailsResponse {
        static instance: CMsgClientToGCShowcaseAdminGetUserDetailsResponse = CMsgClientToGCShowcaseAdminGetUserDetailsResponse {
            response: ::std::option::Option::None,
            user_details: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCShowcaseAdminGetUserDetailsResponse`
pub mod cmsg_client_to_gcshowcase_admin_get_user_details_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCShowcaseAdminGetUserDetailsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminGetUserDetailsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminGetUserDetailsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminGetUserDetailsResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminGetUserDetailsResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminGetUserDetailsResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminGetUserDetailsResponse.EResponse.k_eNoPermission)
        k_eNoPermission = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNoPermission),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNoPermission" => ::std::option::Option::Some(EResponse::k_eNoPermission),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNoPermission,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseAdminReset)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseAdminReset {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseAdminReset.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseAdminReset.showcase_type)
    pub showcase_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EShowcaseType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseAdminReset.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseAdminReset {
    fn default() -> &'a CMsgClientToGCShowcaseAdminReset {
        <CMsgClientToGCShowcaseAdminReset as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseAdminReset {
    pub fn new() -> CMsgClientToGCShowcaseAdminReset {
        ::std::default::Default::default()
    }

    // optional uint32 target_account_id = 1;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    // optional .EShowcaseType showcase_type = 2;

    pub fn showcase_type(&self) -> EShowcaseType {
        match self.showcase_type {
            Some(e) => e.enum_value_or(EShowcaseType::k_eShowcaseType_Invalid),
            None => EShowcaseType::k_eShowcaseType_Invalid,
        }
    }

    pub fn clear_showcase_type(&mut self) {
        self.showcase_type = ::std::option::Option::None;
    }

    pub fn has_showcase_type(&self) -> bool {
        self.showcase_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showcase_type(&mut self, v: EShowcaseType) {
        self.showcase_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseAdminReset {
    const NAME: &'static str = "CMsgClientToGCShowcaseAdminReset";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.showcase_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.showcase_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.showcase_type {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseAdminReset {
        CMsgClientToGCShowcaseAdminReset::new()
    }

    fn clear(&mut self) {
        self.target_account_id = ::std::option::Option::None;
        self.showcase_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseAdminReset {
        static instance: CMsgClientToGCShowcaseAdminReset = CMsgClientToGCShowcaseAdminReset {
            target_account_id: ::std::option::Option::None,
            showcase_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseAdminResetResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseAdminResetResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseAdminResetResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcshowcase_admin_reset_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseAdminResetResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseAdminResetResponse {
    fn default() -> &'a CMsgClientToGCShowcaseAdminResetResponse {
        <CMsgClientToGCShowcaseAdminResetResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseAdminResetResponse {
    pub fn new() -> CMsgClientToGCShowcaseAdminResetResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCShowcaseAdminResetResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcshowcase_admin_reset_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcshowcase_admin_reset_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcshowcase_admin_reset_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcshowcase_admin_reset_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseAdminResetResponse {
    const NAME: &'static str = "CMsgClientToGCShowcaseAdminResetResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseAdminResetResponse {
        CMsgClientToGCShowcaseAdminResetResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseAdminResetResponse {
        static instance: CMsgClientToGCShowcaseAdminResetResponse = CMsgClientToGCShowcaseAdminResetResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCShowcaseAdminResetResponse`
pub mod cmsg_client_to_gcshowcase_admin_reset_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCShowcaseAdminResetResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminResetResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminResetResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminResetResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminResetResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminResetResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminResetResponse.EResponse.k_eNoPermission)
        k_eNoPermission = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNoPermission),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNoPermission" => ::std::option::Option::Some(EResponse::k_eNoPermission),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNoPermission,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseAdminLockAccount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseAdminLockAccount {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseAdminLockAccount.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseAdminLockAccount.locked_until_timestamp)
    pub locked_until_timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseAdminLockAccount.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseAdminLockAccount {
    fn default() -> &'a CMsgClientToGCShowcaseAdminLockAccount {
        <CMsgClientToGCShowcaseAdminLockAccount as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseAdminLockAccount {
    pub fn new() -> CMsgClientToGCShowcaseAdminLockAccount {
        ::std::default::Default::default()
    }

    // optional uint32 target_account_id = 1;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 locked_until_timestamp = 2;

    pub fn locked_until_timestamp(&self) -> u32 {
        self.locked_until_timestamp.unwrap_or(0)
    }

    pub fn clear_locked_until_timestamp(&mut self) {
        self.locked_until_timestamp = ::std::option::Option::None;
    }

    pub fn has_locked_until_timestamp(&self) -> bool {
        self.locked_until_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locked_until_timestamp(&mut self, v: u32) {
        self.locked_until_timestamp = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseAdminLockAccount {
    const NAME: &'static str = "CMsgClientToGCShowcaseAdminLockAccount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.locked_until_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.locked_until_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.locked_until_timestamp {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseAdminLockAccount {
        CMsgClientToGCShowcaseAdminLockAccount::new()
    }

    fn clear(&mut self) {
        self.target_account_id = ::std::option::Option::None;
        self.locked_until_timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseAdminLockAccount {
        static instance: CMsgClientToGCShowcaseAdminLockAccount = CMsgClientToGCShowcaseAdminLockAccount {
            target_account_id: ::std::option::Option::None,
            locked_until_timestamp: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseAdminLockAccountResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseAdminLockAccountResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseAdminLockAccountResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcshowcase_admin_lock_account_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseAdminLockAccountResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseAdminLockAccountResponse {
    fn default() -> &'a CMsgClientToGCShowcaseAdminLockAccountResponse {
        <CMsgClientToGCShowcaseAdminLockAccountResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseAdminLockAccountResponse {
    pub fn new() -> CMsgClientToGCShowcaseAdminLockAccountResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCShowcaseAdminLockAccountResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcshowcase_admin_lock_account_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcshowcase_admin_lock_account_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcshowcase_admin_lock_account_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcshowcase_admin_lock_account_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseAdminLockAccountResponse {
    const NAME: &'static str = "CMsgClientToGCShowcaseAdminLockAccountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseAdminLockAccountResponse {
        CMsgClientToGCShowcaseAdminLockAccountResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseAdminLockAccountResponse {
        static instance: CMsgClientToGCShowcaseAdminLockAccountResponse = CMsgClientToGCShowcaseAdminLockAccountResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCShowcaseAdminLockAccountResponse`
pub mod cmsg_client_to_gcshowcase_admin_lock_account_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCShowcaseAdminLockAccountResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminLockAccountResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminLockAccountResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminLockAccountResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminLockAccountResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminLockAccountResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminLockAccountResponse.EResponse.k_eNoPermission)
        k_eNoPermission = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNoPermission),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNoPermission" => ::std::option::Option::Some(EResponse::k_eNoPermission),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNoPermission,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseAdminConvict)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseAdminConvict {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseAdminConvict.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseAdminConvict.showcase_type)
    pub showcase_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EShowcaseType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseAdminConvict.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseAdminConvict {
    fn default() -> &'a CMsgClientToGCShowcaseAdminConvict {
        <CMsgClientToGCShowcaseAdminConvict as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseAdminConvict {
    pub fn new() -> CMsgClientToGCShowcaseAdminConvict {
        ::std::default::Default::default()
    }

    // optional uint32 target_account_id = 1;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    // optional .EShowcaseType showcase_type = 2;

    pub fn showcase_type(&self) -> EShowcaseType {
        match self.showcase_type {
            Some(e) => e.enum_value_or(EShowcaseType::k_eShowcaseType_Invalid),
            None => EShowcaseType::k_eShowcaseType_Invalid,
        }
    }

    pub fn clear_showcase_type(&mut self) {
        self.showcase_type = ::std::option::Option::None;
    }

    pub fn has_showcase_type(&self) -> bool {
        self.showcase_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showcase_type(&mut self, v: EShowcaseType) {
        self.showcase_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseAdminConvict {
    const NAME: &'static str = "CMsgClientToGCShowcaseAdminConvict";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.showcase_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.showcase_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.showcase_type {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseAdminConvict {
        CMsgClientToGCShowcaseAdminConvict::new()
    }

    fn clear(&mut self) {
        self.target_account_id = ::std::option::Option::None;
        self.showcase_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseAdminConvict {
        static instance: CMsgClientToGCShowcaseAdminConvict = CMsgClientToGCShowcaseAdminConvict {
            target_account_id: ::std::option::Option::None,
            showcase_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseAdminConvictResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseAdminConvictResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseAdminConvictResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcshowcase_admin_convict_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseAdminConvictResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseAdminConvictResponse {
    fn default() -> &'a CMsgClientToGCShowcaseAdminConvictResponse {
        <CMsgClientToGCShowcaseAdminConvictResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseAdminConvictResponse {
    pub fn new() -> CMsgClientToGCShowcaseAdminConvictResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCShowcaseAdminConvictResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcshowcase_admin_convict_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcshowcase_admin_convict_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcshowcase_admin_convict_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcshowcase_admin_convict_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseAdminConvictResponse {
    const NAME: &'static str = "CMsgClientToGCShowcaseAdminConvictResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseAdminConvictResponse {
        CMsgClientToGCShowcaseAdminConvictResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseAdminConvictResponse {
        static instance: CMsgClientToGCShowcaseAdminConvictResponse = CMsgClientToGCShowcaseAdminConvictResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCShowcaseAdminConvictResponse`
pub mod cmsg_client_to_gcshowcase_admin_convict_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCShowcaseAdminConvictResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminConvictResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminConvictResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminConvictResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminConvictResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminConvictResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminConvictResponse.EResponse.k_eNoPermission)
        k_eNoPermission = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminConvictResponse.EResponse.k_eAlreadyConvicted)
        k_eAlreadyConvicted = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNoPermission),
                6 => ::std::option::Option::Some(EResponse::k_eAlreadyConvicted),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNoPermission" => ::std::option::Option::Some(EResponse::k_eNoPermission),
                "k_eAlreadyConvicted" => ::std::option::Option::Some(EResponse::k_eAlreadyConvicted),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNoPermission,
            EResponse::k_eAlreadyConvicted,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseAdminExonerate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseAdminExonerate {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseAdminExonerate.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseAdminExonerate.showcase_type)
    pub showcase_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EShowcaseType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseAdminExonerate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseAdminExonerate {
    fn default() -> &'a CMsgClientToGCShowcaseAdminExonerate {
        <CMsgClientToGCShowcaseAdminExonerate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseAdminExonerate {
    pub fn new() -> CMsgClientToGCShowcaseAdminExonerate {
        ::std::default::Default::default()
    }

    // optional uint32 target_account_id = 1;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    // optional .EShowcaseType showcase_type = 2;

    pub fn showcase_type(&self) -> EShowcaseType {
        match self.showcase_type {
            Some(e) => e.enum_value_or(EShowcaseType::k_eShowcaseType_Invalid),
            None => EShowcaseType::k_eShowcaseType_Invalid,
        }
    }

    pub fn clear_showcase_type(&mut self) {
        self.showcase_type = ::std::option::Option::None;
    }

    pub fn has_showcase_type(&self) -> bool {
        self.showcase_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showcase_type(&mut self, v: EShowcaseType) {
        self.showcase_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseAdminExonerate {
    const NAME: &'static str = "CMsgClientToGCShowcaseAdminExonerate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.showcase_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.showcase_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.showcase_type {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseAdminExonerate {
        CMsgClientToGCShowcaseAdminExonerate::new()
    }

    fn clear(&mut self) {
        self.target_account_id = ::std::option::Option::None;
        self.showcase_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseAdminExonerate {
        static instance: CMsgClientToGCShowcaseAdminExonerate = CMsgClientToGCShowcaseAdminExonerate {
            target_account_id: ::std::option::Option::None,
            showcase_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseAdminExonerateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseAdminExonerateResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseAdminExonerateResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcshowcase_admin_exonerate_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseAdminExonerateResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseAdminExonerateResponse {
    fn default() -> &'a CMsgClientToGCShowcaseAdminExonerateResponse {
        <CMsgClientToGCShowcaseAdminExonerateResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseAdminExonerateResponse {
    pub fn new() -> CMsgClientToGCShowcaseAdminExonerateResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCShowcaseAdminExonerateResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcshowcase_admin_exonerate_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcshowcase_admin_exonerate_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcshowcase_admin_exonerate_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcshowcase_admin_exonerate_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseAdminExonerateResponse {
    const NAME: &'static str = "CMsgClientToGCShowcaseAdminExonerateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseAdminExonerateResponse {
        CMsgClientToGCShowcaseAdminExonerateResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseAdminExonerateResponse {
        static instance: CMsgClientToGCShowcaseAdminExonerateResponse = CMsgClientToGCShowcaseAdminExonerateResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCShowcaseAdminExonerateResponse`
pub mod cmsg_client_to_gcshowcase_admin_exonerate_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCShowcaseAdminExonerateResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminExonerateResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminExonerateResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminExonerateResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminExonerateResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminExonerateResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminExonerateResponse.EResponse.k_eNoPermission)
        k_eNoPermission = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseAdminExonerateResponse.EResponse.k_eAlreadyExonerated)
        k_eAlreadyExonerated = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNoPermission),
                6 => ::std::option::Option::Some(EResponse::k_eAlreadyExonerated),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNoPermission" => ::std::option::Option::Some(EResponse::k_eNoPermission),
                "k_eAlreadyExonerated" => ::std::option::Option::Some(EResponse::k_eAlreadyExonerated),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNoPermission,
            EResponse::k_eAlreadyExonerated,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgShowcaseModerationInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgShowcaseModerationInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgShowcaseModerationInfo.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgShowcaseModerationInfo.showcase_type)
    pub showcase_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EShowcaseType>>,
    // @@protoc_insertion_point(field:CMsgShowcaseModerationInfo.showcase_timestamp)
    pub showcase_timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgShowcaseModerationInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgShowcaseModerationInfo {
    fn default() -> &'a CMsgShowcaseModerationInfo {
        <CMsgShowcaseModerationInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgShowcaseModerationInfo {
    pub fn new() -> CMsgShowcaseModerationInfo {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional .EShowcaseType showcase_type = 2;

    pub fn showcase_type(&self) -> EShowcaseType {
        match self.showcase_type {
            Some(e) => e.enum_value_or(EShowcaseType::k_eShowcaseType_Invalid),
            None => EShowcaseType::k_eShowcaseType_Invalid,
        }
    }

    pub fn clear_showcase_type(&mut self) {
        self.showcase_type = ::std::option::Option::None;
    }

    pub fn has_showcase_type(&self) -> bool {
        self.showcase_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showcase_type(&mut self, v: EShowcaseType) {
        self.showcase_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 showcase_timestamp = 3;

    pub fn showcase_timestamp(&self) -> u32 {
        self.showcase_timestamp.unwrap_or(0)
    }

    pub fn clear_showcase_timestamp(&mut self) {
        self.showcase_timestamp = ::std::option::Option::None;
    }

    pub fn has_showcase_timestamp(&self) -> bool {
        self.showcase_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showcase_timestamp(&mut self, v: u32) {
        self.showcase_timestamp = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgShowcaseModerationInfo {
    const NAME: &'static str = "CMsgShowcaseModerationInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.showcase_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.showcase_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.showcase_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.showcase_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.showcase_type {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.showcase_timestamp {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgShowcaseModerationInfo {
        CMsgShowcaseModerationInfo::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.showcase_type = ::std::option::Option::None;
        self.showcase_timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgShowcaseModerationInfo {
        static instance: CMsgShowcaseModerationInfo = CMsgShowcaseModerationInfo {
            account_id: ::std::option::Option::None,
            showcase_type: ::std::option::Option::None,
            showcase_timestamp: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseModerationGetQueue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseModerationGetQueue {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseModerationGetQueue.start_timestamp)
    pub start_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseModerationGetQueue.result_count)
    pub result_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseModerationGetQueue.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseModerationGetQueue {
    fn default() -> &'a CMsgClientToGCShowcaseModerationGetQueue {
        <CMsgClientToGCShowcaseModerationGetQueue as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseModerationGetQueue {
    pub fn new() -> CMsgClientToGCShowcaseModerationGetQueue {
        ::std::default::Default::default()
    }

    // optional uint32 start_timestamp = 1;

    pub fn start_timestamp(&self) -> u32 {
        self.start_timestamp.unwrap_or(0)
    }

    pub fn clear_start_timestamp(&mut self) {
        self.start_timestamp = ::std::option::Option::None;
    }

    pub fn has_start_timestamp(&self) -> bool {
        self.start_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_timestamp(&mut self, v: u32) {
        self.start_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 result_count = 2;

    pub fn result_count(&self) -> u32 {
        self.result_count.unwrap_or(0)
    }

    pub fn clear_result_count(&mut self) {
        self.result_count = ::std::option::Option::None;
    }

    pub fn has_result_count(&self) -> bool {
        self.result_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_count(&mut self, v: u32) {
        self.result_count = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseModerationGetQueue {
    const NAME: &'static str = "CMsgClientToGCShowcaseModerationGetQueue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.result_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.result_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.start_timestamp {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.result_count {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseModerationGetQueue {
        CMsgClientToGCShowcaseModerationGetQueue::new()
    }

    fn clear(&mut self) {
        self.start_timestamp = ::std::option::Option::None;
        self.result_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseModerationGetQueue {
        static instance: CMsgClientToGCShowcaseModerationGetQueue = CMsgClientToGCShowcaseModerationGetQueue {
            start_timestamp: ::std::option::Option::None,
            result_count: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseModerationGetQueueResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseModerationGetQueueResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseModerationGetQueueResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcshowcase_moderation_get_queue_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseModerationGetQueueResponse.showcases)
    pub showcases: ::std::vec::Vec<CMsgShowcaseModerationInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseModerationGetQueueResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseModerationGetQueueResponse {
    fn default() -> &'a CMsgClientToGCShowcaseModerationGetQueueResponse {
        <CMsgClientToGCShowcaseModerationGetQueueResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseModerationGetQueueResponse {
    pub fn new() -> CMsgClientToGCShowcaseModerationGetQueueResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCShowcaseModerationGetQueueResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcshowcase_moderation_get_queue_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcshowcase_moderation_get_queue_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcshowcase_moderation_get_queue_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcshowcase_moderation_get_queue_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseModerationGetQueueResponse {
    const NAME: &'static str = "CMsgClientToGCShowcaseModerationGetQueueResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.showcases.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.showcases {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.showcases {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseModerationGetQueueResponse {
        CMsgClientToGCShowcaseModerationGetQueueResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.showcases.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseModerationGetQueueResponse {
        static instance: CMsgClientToGCShowcaseModerationGetQueueResponse = CMsgClientToGCShowcaseModerationGetQueueResponse {
            response: ::std::option::Option::None,
            showcases: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCShowcaseModerationGetQueueResponse`
pub mod cmsg_client_to_gcshowcase_moderation_get_queue_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCShowcaseModerationGetQueueResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseModerationGetQueueResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseModerationGetQueueResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseModerationGetQueueResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseModerationGetQueueResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseModerationGetQueueResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseModerationGetQueueResponse.EResponse.k_eNoPermission)
        k_eNoPermission = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNoPermission),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNoPermission" => ::std::option::Option::Some(EResponse::k_eNoPermission),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNoPermission,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseModerationApplyModeration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseModerationApplyModeration {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseModerationApplyModeration.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseModerationApplyModeration.showcase_type)
    pub showcase_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EShowcaseType>>,
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseModerationApplyModeration.showcase_timestamp)
    pub showcase_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseModerationApplyModeration.approve)
    pub approve: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseModerationApplyModeration.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseModerationApplyModeration {
    fn default() -> &'a CMsgClientToGCShowcaseModerationApplyModeration {
        <CMsgClientToGCShowcaseModerationApplyModeration as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseModerationApplyModeration {
    pub fn new() -> CMsgClientToGCShowcaseModerationApplyModeration {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional .EShowcaseType showcase_type = 2;

    pub fn showcase_type(&self) -> EShowcaseType {
        match self.showcase_type {
            Some(e) => e.enum_value_or(EShowcaseType::k_eShowcaseType_Invalid),
            None => EShowcaseType::k_eShowcaseType_Invalid,
        }
    }

    pub fn clear_showcase_type(&mut self) {
        self.showcase_type = ::std::option::Option::None;
    }

    pub fn has_showcase_type(&self) -> bool {
        self.showcase_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showcase_type(&mut self, v: EShowcaseType) {
        self.showcase_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 showcase_timestamp = 3;

    pub fn showcase_timestamp(&self) -> u32 {
        self.showcase_timestamp.unwrap_or(0)
    }

    pub fn clear_showcase_timestamp(&mut self) {
        self.showcase_timestamp = ::std::option::Option::None;
    }

    pub fn has_showcase_timestamp(&self) -> bool {
        self.showcase_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showcase_timestamp(&mut self, v: u32) {
        self.showcase_timestamp = ::std::option::Option::Some(v);
    }

    // optional bool approve = 4;

    pub fn approve(&self) -> bool {
        self.approve.unwrap_or(false)
    }

    pub fn clear_approve(&mut self) {
        self.approve = ::std::option::Option::None;
    }

    pub fn has_approve(&self) -> bool {
        self.approve.is_some()
    }

    // Param is passed by value, moved
    pub fn set_approve(&mut self, v: bool) {
        self.approve = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseModerationApplyModeration {
    const NAME: &'static str = "CMsgClientToGCShowcaseModerationApplyModeration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.showcase_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.showcase_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.approve = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.showcase_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.showcase_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.approve {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.showcase_type {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.showcase_timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.approve {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseModerationApplyModeration {
        CMsgClientToGCShowcaseModerationApplyModeration::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.showcase_type = ::std::option::Option::None;
        self.showcase_timestamp = ::std::option::Option::None;
        self.approve = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseModerationApplyModeration {
        static instance: CMsgClientToGCShowcaseModerationApplyModeration = CMsgClientToGCShowcaseModerationApplyModeration {
            account_id: ::std::option::Option::None,
            showcase_type: ::std::option::Option::None,
            showcase_timestamp: ::std::option::Option::None,
            approve: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCShowcaseModerationApplyModerationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCShowcaseModerationApplyModerationResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCShowcaseModerationApplyModerationResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcshowcase_moderation_apply_moderation_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCShowcaseModerationApplyModerationResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCShowcaseModerationApplyModerationResponse {
    fn default() -> &'a CMsgClientToGCShowcaseModerationApplyModerationResponse {
        <CMsgClientToGCShowcaseModerationApplyModerationResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCShowcaseModerationApplyModerationResponse {
    pub fn new() -> CMsgClientToGCShowcaseModerationApplyModerationResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCShowcaseModerationApplyModerationResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcshowcase_moderation_apply_moderation_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcshowcase_moderation_apply_moderation_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcshowcase_moderation_apply_moderation_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcshowcase_moderation_apply_moderation_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCShowcaseModerationApplyModerationResponse {
    const NAME: &'static str = "CMsgClientToGCShowcaseModerationApplyModerationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCShowcaseModerationApplyModerationResponse {
        CMsgClientToGCShowcaseModerationApplyModerationResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCShowcaseModerationApplyModerationResponse {
        static instance: CMsgClientToGCShowcaseModerationApplyModerationResponse = CMsgClientToGCShowcaseModerationApplyModerationResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCShowcaseModerationApplyModerationResponse`
pub mod cmsg_client_to_gcshowcase_moderation_apply_moderation_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCShowcaseModerationApplyModerationResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseModerationApplyModerationResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseModerationApplyModerationResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseModerationApplyModerationResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseModerationApplyModerationResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseModerationApplyModerationResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseModerationApplyModerationResponse.EResponse.k_eNoPermission)
        k_eNoPermission = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCShowcaseModerationApplyModerationResponse.EResponse.k_eGone)
        k_eGone = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNoPermission),
                6 => ::std::option::Option::Some(EResponse::k_eGone),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNoPermission" => ::std::option::Option::Some(EResponse::k_eNoPermission),
                "k_eGone" => ::std::option::Option::Some(EResponse::k_eGone),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNoPermission,
            EResponse::k_eGone,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EShowcaseHeroPlusFlag)
pub enum EShowcaseHeroPlusFlag {
    // @@protoc_insertion_point(enum_value:EShowcaseHeroPlusFlag.k_eShowcaseHeroPlusFlag_None)
    k_eShowcaseHeroPlusFlag_None = 0,
    // @@protoc_insertion_point(enum_value:EShowcaseHeroPlusFlag.k_eShowcaseHeroPlusFlag_BadgePosTop)
    k_eShowcaseHeroPlusFlag_BadgePosTop = 1,
    // @@protoc_insertion_point(enum_value:EShowcaseHeroPlusFlag.k_eShowcaseHeroPlusFlag_BadgePosBottom)
    k_eShowcaseHeroPlusFlag_BadgePosBottom = 2,
    // @@protoc_insertion_point(enum_value:EShowcaseHeroPlusFlag.k_eShowcaseHeroPlusFlag_BadgePosLeft)
    k_eShowcaseHeroPlusFlag_BadgePosLeft = 4,
    // @@protoc_insertion_point(enum_value:EShowcaseHeroPlusFlag.k_eShowcaseHeroPlusFlag_BadgePosRight)
    k_eShowcaseHeroPlusFlag_BadgePosRight = 8,
    // @@protoc_insertion_point(enum_value:EShowcaseHeroPlusFlag.k_eShowcaseHeroPlusFlag_ShowRelics)
    k_eShowcaseHeroPlusFlag_ShowRelics = 16,
}

impl ::steam_vent_proto_common::protobuf::Enum for EShowcaseHeroPlusFlag {
    const NAME: &'static str = "EShowcaseHeroPlusFlag";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EShowcaseHeroPlusFlag> {
        match value {
            0 => ::std::option::Option::Some(EShowcaseHeroPlusFlag::k_eShowcaseHeroPlusFlag_None),
            1 => ::std::option::Option::Some(EShowcaseHeroPlusFlag::k_eShowcaseHeroPlusFlag_BadgePosTop),
            2 => ::std::option::Option::Some(EShowcaseHeroPlusFlag::k_eShowcaseHeroPlusFlag_BadgePosBottom),
            4 => ::std::option::Option::Some(EShowcaseHeroPlusFlag::k_eShowcaseHeroPlusFlag_BadgePosLeft),
            8 => ::std::option::Option::Some(EShowcaseHeroPlusFlag::k_eShowcaseHeroPlusFlag_BadgePosRight),
            16 => ::std::option::Option::Some(EShowcaseHeroPlusFlag::k_eShowcaseHeroPlusFlag_ShowRelics),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EShowcaseHeroPlusFlag> {
        match str {
            "k_eShowcaseHeroPlusFlag_None" => ::std::option::Option::Some(EShowcaseHeroPlusFlag::k_eShowcaseHeroPlusFlag_None),
            "k_eShowcaseHeroPlusFlag_BadgePosTop" => ::std::option::Option::Some(EShowcaseHeroPlusFlag::k_eShowcaseHeroPlusFlag_BadgePosTop),
            "k_eShowcaseHeroPlusFlag_BadgePosBottom" => ::std::option::Option::Some(EShowcaseHeroPlusFlag::k_eShowcaseHeroPlusFlag_BadgePosBottom),
            "k_eShowcaseHeroPlusFlag_BadgePosLeft" => ::std::option::Option::Some(EShowcaseHeroPlusFlag::k_eShowcaseHeroPlusFlag_BadgePosLeft),
            "k_eShowcaseHeroPlusFlag_BadgePosRight" => ::std::option::Option::Some(EShowcaseHeroPlusFlag::k_eShowcaseHeroPlusFlag_BadgePosRight),
            "k_eShowcaseHeroPlusFlag_ShowRelics" => ::std::option::Option::Some(EShowcaseHeroPlusFlag::k_eShowcaseHeroPlusFlag_ShowRelics),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EShowcaseHeroPlusFlag] = &[
        EShowcaseHeroPlusFlag::k_eShowcaseHeroPlusFlag_None,
        EShowcaseHeroPlusFlag::k_eShowcaseHeroPlusFlag_BadgePosTop,
        EShowcaseHeroPlusFlag::k_eShowcaseHeroPlusFlag_BadgePosBottom,
        EShowcaseHeroPlusFlag::k_eShowcaseHeroPlusFlag_BadgePosLeft,
        EShowcaseHeroPlusFlag::k_eShowcaseHeroPlusFlag_BadgePosRight,
        EShowcaseHeroPlusFlag::k_eShowcaseHeroPlusFlag_ShowRelics,
    ];
}

impl ::std::default::Default for EShowcaseHeroPlusFlag {
    fn default() -> Self {
        EShowcaseHeroPlusFlag::k_eShowcaseHeroPlusFlag_None
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EShowcaseType)
pub enum EShowcaseType {
    // @@protoc_insertion_point(enum_value:EShowcaseType.k_eShowcaseType_Invalid)
    k_eShowcaseType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EShowcaseType.k_eShowcaseType_Profile)
    k_eShowcaseType_Profile = 1,
    // @@protoc_insertion_point(enum_value:EShowcaseType.k_eShowcaseType_MiniProfile)
    k_eShowcaseType_MiniProfile = 2,
    // @@protoc_insertion_point(enum_value:EShowcaseType.k_eShowcaseType_DefaultProfile)
    k_eShowcaseType_DefaultProfile = 3,
    // @@protoc_insertion_point(enum_value:EShowcaseType.k_eShowcaseType_DefaultMiniProfile)
    k_eShowcaseType_DefaultMiniProfile = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for EShowcaseType {
    const NAME: &'static str = "EShowcaseType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EShowcaseType> {
        match value {
            0 => ::std::option::Option::Some(EShowcaseType::k_eShowcaseType_Invalid),
            1 => ::std::option::Option::Some(EShowcaseType::k_eShowcaseType_Profile),
            2 => ::std::option::Option::Some(EShowcaseType::k_eShowcaseType_MiniProfile),
            3 => ::std::option::Option::Some(EShowcaseType::k_eShowcaseType_DefaultProfile),
            4 => ::std::option::Option::Some(EShowcaseType::k_eShowcaseType_DefaultMiniProfile),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EShowcaseType> {
        match str {
            "k_eShowcaseType_Invalid" => ::std::option::Option::Some(EShowcaseType::k_eShowcaseType_Invalid),
            "k_eShowcaseType_Profile" => ::std::option::Option::Some(EShowcaseType::k_eShowcaseType_Profile),
            "k_eShowcaseType_MiniProfile" => ::std::option::Option::Some(EShowcaseType::k_eShowcaseType_MiniProfile),
            "k_eShowcaseType_DefaultProfile" => ::std::option::Option::Some(EShowcaseType::k_eShowcaseType_DefaultProfile),
            "k_eShowcaseType_DefaultMiniProfile" => ::std::option::Option::Some(EShowcaseType::k_eShowcaseType_DefaultMiniProfile),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EShowcaseType] = &[
        EShowcaseType::k_eShowcaseType_Invalid,
        EShowcaseType::k_eShowcaseType_Profile,
        EShowcaseType::k_eShowcaseType_MiniProfile,
        EShowcaseType::k_eShowcaseType_DefaultProfile,
        EShowcaseType::k_eShowcaseType_DefaultMiniProfile,
    ];
}

impl ::std::default::Default for EShowcaseType {
    fn default() -> Self {
        EShowcaseType::k_eShowcaseType_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EShowcaseItemState)
pub enum EShowcaseItemState {
    // @@protoc_insertion_point(enum_value:EShowcaseItemState.k_eShowcaseItemState_Ok)
    k_eShowcaseItemState_Ok = 0,
    // @@protoc_insertion_point(enum_value:EShowcaseItemState.k_eShowcaseItemState_MinorModifications)
    k_eShowcaseItemState_MinorModifications = 1,
    // @@protoc_insertion_point(enum_value:EShowcaseItemState.k_eShowcaseItemState_ValidityUnknown)
    k_eShowcaseItemState_ValidityUnknown = 2,
    // @@protoc_insertion_point(enum_value:EShowcaseItemState.k_eShowcaseItemState_PartiallyInvalid)
    k_eShowcaseItemState_PartiallyInvalid = 3,
    // @@protoc_insertion_point(enum_value:EShowcaseItemState.k_eShowcaseItemState_Invalid)
    k_eShowcaseItemState_Invalid = 4,
    // @@protoc_insertion_point(enum_value:EShowcaseItemState.k_eShowcaseItemState_Failure)
    k_eShowcaseItemState_Failure = 5,
}

impl ::steam_vent_proto_common::protobuf::Enum for EShowcaseItemState {
    const NAME: &'static str = "EShowcaseItemState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EShowcaseItemState> {
        match value {
            0 => ::std::option::Option::Some(EShowcaseItemState::k_eShowcaseItemState_Ok),
            1 => ::std::option::Option::Some(EShowcaseItemState::k_eShowcaseItemState_MinorModifications),
            2 => ::std::option::Option::Some(EShowcaseItemState::k_eShowcaseItemState_ValidityUnknown),
            3 => ::std::option::Option::Some(EShowcaseItemState::k_eShowcaseItemState_PartiallyInvalid),
            4 => ::std::option::Option::Some(EShowcaseItemState::k_eShowcaseItemState_Invalid),
            5 => ::std::option::Option::Some(EShowcaseItemState::k_eShowcaseItemState_Failure),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EShowcaseItemState> {
        match str {
            "k_eShowcaseItemState_Ok" => ::std::option::Option::Some(EShowcaseItemState::k_eShowcaseItemState_Ok),
            "k_eShowcaseItemState_MinorModifications" => ::std::option::Option::Some(EShowcaseItemState::k_eShowcaseItemState_MinorModifications),
            "k_eShowcaseItemState_ValidityUnknown" => ::std::option::Option::Some(EShowcaseItemState::k_eShowcaseItemState_ValidityUnknown),
            "k_eShowcaseItemState_PartiallyInvalid" => ::std::option::Option::Some(EShowcaseItemState::k_eShowcaseItemState_PartiallyInvalid),
            "k_eShowcaseItemState_Invalid" => ::std::option::Option::Some(EShowcaseItemState::k_eShowcaseItemState_Invalid),
            "k_eShowcaseItemState_Failure" => ::std::option::Option::Some(EShowcaseItemState::k_eShowcaseItemState_Failure),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EShowcaseItemState] = &[
        EShowcaseItemState::k_eShowcaseItemState_Ok,
        EShowcaseItemState::k_eShowcaseItemState_MinorModifications,
        EShowcaseItemState::k_eShowcaseItemState_ValidityUnknown,
        EShowcaseItemState::k_eShowcaseItemState_PartiallyInvalid,
        EShowcaseItemState::k_eShowcaseItemState_Invalid,
        EShowcaseItemState::k_eShowcaseItemState_Failure,
    ];
}

impl ::std::default::Default for EShowcaseItemState {
    fn default() -> Self {
        EShowcaseItemState::k_eShowcaseItemState_Ok
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EShowcaseAuditAction)
pub enum EShowcaseAuditAction {
    // @@protoc_insertion_point(enum_value:EShowcaseAuditAction.k_eShowcaseAuditAction_Invalid)
    k_eShowcaseAuditAction_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EShowcaseAuditAction.k_eShowcaseAuditAction_ShowcaseChanged)
    k_eShowcaseAuditAction_ShowcaseChanged = 1,
    // @@protoc_insertion_point(enum_value:EShowcaseAuditAction.k_eShowcaseAuditAction_AdminShowcaseReset)
    k_eShowcaseAuditAction_AdminShowcaseReset = 2,
    // @@protoc_insertion_point(enum_value:EShowcaseAuditAction.k_eShowcaseAuditAction_AdminShowcaseAccountLocked)
    k_eShowcaseAuditAction_AdminShowcaseAccountLocked = 3,
    // @@protoc_insertion_point(enum_value:EShowcaseAuditAction.k_eShowcaseAuditAction_AdminShowcaseExonerated)
    k_eShowcaseAuditAction_AdminShowcaseExonerated = 4,
    // @@protoc_insertion_point(enum_value:EShowcaseAuditAction.k_eShowcaseAuditAction_AdminShowcaseConvicted)
    k_eShowcaseAuditAction_AdminShowcaseConvicted = 5,
    // @@protoc_insertion_point(enum_value:EShowcaseAuditAction.k_eShowcaseAuditAction_AdminModerationApproved)
    k_eShowcaseAuditAction_AdminModerationApproved = 6,
    // @@protoc_insertion_point(enum_value:EShowcaseAuditAction.k_eShowcaseAuditAction_AdminModerationRejected)
    k_eShowcaseAuditAction_AdminModerationRejected = 7,
}

impl ::steam_vent_proto_common::protobuf::Enum for EShowcaseAuditAction {
    const NAME: &'static str = "EShowcaseAuditAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EShowcaseAuditAction> {
        match value {
            0 => ::std::option::Option::Some(EShowcaseAuditAction::k_eShowcaseAuditAction_Invalid),
            1 => ::std::option::Option::Some(EShowcaseAuditAction::k_eShowcaseAuditAction_ShowcaseChanged),
            2 => ::std::option::Option::Some(EShowcaseAuditAction::k_eShowcaseAuditAction_AdminShowcaseReset),
            3 => ::std::option::Option::Some(EShowcaseAuditAction::k_eShowcaseAuditAction_AdminShowcaseAccountLocked),
            4 => ::std::option::Option::Some(EShowcaseAuditAction::k_eShowcaseAuditAction_AdminShowcaseExonerated),
            5 => ::std::option::Option::Some(EShowcaseAuditAction::k_eShowcaseAuditAction_AdminShowcaseConvicted),
            6 => ::std::option::Option::Some(EShowcaseAuditAction::k_eShowcaseAuditAction_AdminModerationApproved),
            7 => ::std::option::Option::Some(EShowcaseAuditAction::k_eShowcaseAuditAction_AdminModerationRejected),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EShowcaseAuditAction> {
        match str {
            "k_eShowcaseAuditAction_Invalid" => ::std::option::Option::Some(EShowcaseAuditAction::k_eShowcaseAuditAction_Invalid),
            "k_eShowcaseAuditAction_ShowcaseChanged" => ::std::option::Option::Some(EShowcaseAuditAction::k_eShowcaseAuditAction_ShowcaseChanged),
            "k_eShowcaseAuditAction_AdminShowcaseReset" => ::std::option::Option::Some(EShowcaseAuditAction::k_eShowcaseAuditAction_AdminShowcaseReset),
            "k_eShowcaseAuditAction_AdminShowcaseAccountLocked" => ::std::option::Option::Some(EShowcaseAuditAction::k_eShowcaseAuditAction_AdminShowcaseAccountLocked),
            "k_eShowcaseAuditAction_AdminShowcaseExonerated" => ::std::option::Option::Some(EShowcaseAuditAction::k_eShowcaseAuditAction_AdminShowcaseExonerated),
            "k_eShowcaseAuditAction_AdminShowcaseConvicted" => ::std::option::Option::Some(EShowcaseAuditAction::k_eShowcaseAuditAction_AdminShowcaseConvicted),
            "k_eShowcaseAuditAction_AdminModerationApproved" => ::std::option::Option::Some(EShowcaseAuditAction::k_eShowcaseAuditAction_AdminModerationApproved),
            "k_eShowcaseAuditAction_AdminModerationRejected" => ::std::option::Option::Some(EShowcaseAuditAction::k_eShowcaseAuditAction_AdminModerationRejected),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EShowcaseAuditAction] = &[
        EShowcaseAuditAction::k_eShowcaseAuditAction_Invalid,
        EShowcaseAuditAction::k_eShowcaseAuditAction_ShowcaseChanged,
        EShowcaseAuditAction::k_eShowcaseAuditAction_AdminShowcaseReset,
        EShowcaseAuditAction::k_eShowcaseAuditAction_AdminShowcaseAccountLocked,
        EShowcaseAuditAction::k_eShowcaseAuditAction_AdminShowcaseExonerated,
        EShowcaseAuditAction::k_eShowcaseAuditAction_AdminShowcaseConvicted,
        EShowcaseAuditAction::k_eShowcaseAuditAction_AdminModerationApproved,
        EShowcaseAuditAction::k_eShowcaseAuditAction_AdminModerationRejected,
    ];
}

impl ::std::default::Default for EShowcaseAuditAction {
    fn default() -> Self {
        EShowcaseAuditAction::k_eShowcaseAuditAction_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EShowcaseItemFlag)
pub enum EShowcaseItemFlag {
    // @@protoc_insertion_point(enum_value:EShowcaseItemFlag.k_eShowcaseItemFlag_None)
    k_eShowcaseItemFlag_None = 0,
    // @@protoc_insertion_point(enum_value:EShowcaseItemFlag.k_eShowcaseItemFlag_FlipHorizontally)
    k_eShowcaseItemFlag_FlipHorizontally = 1,
}

impl ::steam_vent_proto_common::protobuf::Enum for EShowcaseItemFlag {
    const NAME: &'static str = "EShowcaseItemFlag";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EShowcaseItemFlag> {
        match value {
            0 => ::std::option::Option::Some(EShowcaseItemFlag::k_eShowcaseItemFlag_None),
            1 => ::std::option::Option::Some(EShowcaseItemFlag::k_eShowcaseItemFlag_FlipHorizontally),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EShowcaseItemFlag> {
        match str {
            "k_eShowcaseItemFlag_None" => ::std::option::Option::Some(EShowcaseItemFlag::k_eShowcaseItemFlag_None),
            "k_eShowcaseItemFlag_FlipHorizontally" => ::std::option::Option::Some(EShowcaseItemFlag::k_eShowcaseItemFlag_FlipHorizontally),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EShowcaseItemFlag] = &[
        EShowcaseItemFlag::k_eShowcaseItemFlag_None,
        EShowcaseItemFlag::k_eShowcaseItemFlag_FlipHorizontally,
    ];
}

impl ::std::default::Default for EShowcaseItemFlag {
    fn default() -> Self {
        EShowcaseItemFlag::k_eShowcaseItemFlag_None
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EShowcaseItemFlag_Hero)
pub enum EShowcaseItemFlag_Hero {
    // @@protoc_insertion_point(enum_value:EShowcaseItemFlag_Hero.k_eShowcaseItemFlag_Hero_None)
    k_eShowcaseItemFlag_Hero_None = 0,
    // @@protoc_insertion_point(enum_value:EShowcaseItemFlag_Hero.k_eShowcaseItemFlag_Hero_ShowPedestal)
    k_eShowcaseItemFlag_Hero_ShowPedestal = 1,
    // @@protoc_insertion_point(enum_value:EShowcaseItemFlag_Hero.k_eShowcaseItemFlag_Hero_UseCurrentLoadout)
    k_eShowcaseItemFlag_Hero_UseCurrentLoadout = 2,
    // @@protoc_insertion_point(enum_value:EShowcaseItemFlag_Hero.k_eShowcaseItemFlag_Hero_ShowHeroCard)
    k_eShowcaseItemFlag_Hero_ShowHeroCard = 4,
    // @@protoc_insertion_point(enum_value:EShowcaseItemFlag_Hero.k_eShowcaseItemFlag_Hero_HeroCardHideName)
    k_eShowcaseItemFlag_Hero_HeroCardHideName = 8,
    // @@protoc_insertion_point(enum_value:EShowcaseItemFlag_Hero.k_eShowcaseItemFlag_Hero_HeroCardUseMovie)
    k_eShowcaseItemFlag_Hero_HeroCardUseMovie = 16,
}

impl ::steam_vent_proto_common::protobuf::Enum for EShowcaseItemFlag_Hero {
    const NAME: &'static str = "EShowcaseItemFlag_Hero";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EShowcaseItemFlag_Hero> {
        match value {
            0 => ::std::option::Option::Some(EShowcaseItemFlag_Hero::k_eShowcaseItemFlag_Hero_None),
            1 => ::std::option::Option::Some(EShowcaseItemFlag_Hero::k_eShowcaseItemFlag_Hero_ShowPedestal),
            2 => ::std::option::Option::Some(EShowcaseItemFlag_Hero::k_eShowcaseItemFlag_Hero_UseCurrentLoadout),
            4 => ::std::option::Option::Some(EShowcaseItemFlag_Hero::k_eShowcaseItemFlag_Hero_ShowHeroCard),
            8 => ::std::option::Option::Some(EShowcaseItemFlag_Hero::k_eShowcaseItemFlag_Hero_HeroCardHideName),
            16 => ::std::option::Option::Some(EShowcaseItemFlag_Hero::k_eShowcaseItemFlag_Hero_HeroCardUseMovie),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EShowcaseItemFlag_Hero> {
        match str {
            "k_eShowcaseItemFlag_Hero_None" => ::std::option::Option::Some(EShowcaseItemFlag_Hero::k_eShowcaseItemFlag_Hero_None),
            "k_eShowcaseItemFlag_Hero_ShowPedestal" => ::std::option::Option::Some(EShowcaseItemFlag_Hero::k_eShowcaseItemFlag_Hero_ShowPedestal),
            "k_eShowcaseItemFlag_Hero_UseCurrentLoadout" => ::std::option::Option::Some(EShowcaseItemFlag_Hero::k_eShowcaseItemFlag_Hero_UseCurrentLoadout),
            "k_eShowcaseItemFlag_Hero_ShowHeroCard" => ::std::option::Option::Some(EShowcaseItemFlag_Hero::k_eShowcaseItemFlag_Hero_ShowHeroCard),
            "k_eShowcaseItemFlag_Hero_HeroCardHideName" => ::std::option::Option::Some(EShowcaseItemFlag_Hero::k_eShowcaseItemFlag_Hero_HeroCardHideName),
            "k_eShowcaseItemFlag_Hero_HeroCardUseMovie" => ::std::option::Option::Some(EShowcaseItemFlag_Hero::k_eShowcaseItemFlag_Hero_HeroCardUseMovie),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EShowcaseItemFlag_Hero] = &[
        EShowcaseItemFlag_Hero::k_eShowcaseItemFlag_Hero_None,
        EShowcaseItemFlag_Hero::k_eShowcaseItemFlag_Hero_ShowPedestal,
        EShowcaseItemFlag_Hero::k_eShowcaseItemFlag_Hero_UseCurrentLoadout,
        EShowcaseItemFlag_Hero::k_eShowcaseItemFlag_Hero_ShowHeroCard,
        EShowcaseItemFlag_Hero::k_eShowcaseItemFlag_Hero_HeroCardHideName,
        EShowcaseItemFlag_Hero::k_eShowcaseItemFlag_Hero_HeroCardUseMovie,
    ];
}

impl ::std::default::Default for EShowcaseItemFlag_Hero {
    fn default() -> Self {
        EShowcaseItemFlag_Hero::k_eShowcaseItemFlag_Hero_None
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::steammessages::*;
#[allow(unused_imports)]
use crate::dota_shared_enums::*;
#[allow(unused_imports)]
use crate::dota_gcmessages_common::*;
#[allow(unused_imports)]
use crate::dota_gcmessages_webapi::*;
#[allow(unused_imports)]
use crate::gcsdk_gcmessages::*;
#[allow(unused_imports)]
use crate::base_gcmessages::*;
#[allow(unused_imports)]
use crate::econ_gcmessages::*;
#[allow(unused_imports)]
use crate::dota_gcmessages_client::*;
#[allow(unused_imports)]
use crate::valveextensions::*;
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseEconItemReference {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgHeroPlusInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseItem_Trophy {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseItem_EconItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseItem_Hero {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseItem_HeroIcon {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseItem_PlayerMatch {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseItem_ChatWheel {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseItem_Emoticon {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseItem_SpiderGraph {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseItem_UserFeed {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseItem_Stat {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseBackground {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseItemData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseItemPosition {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcase {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCShowcaseGetUserData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseGetUserData {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseGetUserData;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCShowcaseGetUserDataResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseGetUserDataResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseGetUserDataResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCShowcaseSetUserData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseSetUserData {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseSetUserData;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCShowcaseSetUserDataResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseSetUserDataResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseSetUserDataResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCShowcaseSubmitReport {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseSubmitReport {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseSubmitReport;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCShowcaseSubmitReportResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseSubmitReportResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseSubmitReportResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseReportsRollupInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseReportsRollupList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseReportsRollupEntry {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseReportsRollup {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCShowcaseAdminGetReportsRollupList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseAdminGetReportsRollupList {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseAdminGetReportsRollupList;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCShowcaseAdminGetReportsRollupListResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseAdminGetReportsRollupListResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseAdminGetReportsRollupListResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCShowcaseAdminGetReportsRollup {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseAdminGetReportsRollup {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseAdminGetReportsRollup;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCShowcaseAdminGetReportsRollupResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseAdminGetReportsRollupResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseAdminGetReportsRollupResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseAuditEntry {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseReport {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseAdminUserDetails {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCShowcaseAdminGetUserDetails {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseAdminGetUserDetails {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseAdminGetUserDetails;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCShowcaseAdminGetUserDetailsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseAdminGetUserDetailsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseAdminGetUserDetailsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCShowcaseAdminReset {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCShowcaseAdminReset {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseAdminReset;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCShowcaseAdminResetResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseAdminResetResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseAdminResetResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCShowcaseAdminLockAccount {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseAdminLockAccount {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseAdminLockAccount;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCShowcaseAdminLockAccountResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseAdminLockAccountResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseAdminLockAccountResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCShowcaseAdminConvict {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseAdminConvict {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseAdminConvict;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCShowcaseAdminConvictResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseAdminConvictResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseAdminConvictResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCShowcaseAdminExonerate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseAdminExonerate {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseAdminExonerate;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCShowcaseAdminExonerateResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseAdminExonerateResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseAdminExonerateResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgShowcaseModerationInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCShowcaseModerationGetQueue {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseModerationGetQueue {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseModerationGetQueue;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCShowcaseModerationGetQueueResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseModerationGetQueueResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseModerationGetQueueResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCShowcaseModerationApplyModeration {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseModerationApplyModeration {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseModerationApplyModeration;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCShowcaseModerationApplyModerationResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCShowcaseModerationApplyModerationResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCShowcaseModerationApplyModerationResponse;
}
