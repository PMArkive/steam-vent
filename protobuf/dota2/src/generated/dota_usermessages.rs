// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_usermessages.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CDOTAUserMsg_AIDebugLine)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_AIDebugLine {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_AIDebugLine.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_AIDebugLine.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_AIDebugLine {
    fn default() -> &'a CDOTAUserMsg_AIDebugLine {
        <CDOTAUserMsg_AIDebugLine as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_AIDebugLine {
    pub fn new() -> CDOTAUserMsg_AIDebugLine {
        ::std::default::Default::default()
    }

    // optional string message = 1;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_AIDebugLine {
    const NAME: &'static str = "CDOTAUserMsg_AIDebugLine";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_AIDebugLine {
        CDOTAUserMsg_AIDebugLine::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_AIDebugLine {
        static instance: CDOTAUserMsg_AIDebugLine = CDOTAUserMsg_AIDebugLine {
            message: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_Ping)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_Ping {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_Ping.ping)
    pub ping: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_Ping.loss)
    pub loss: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_Ping.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_Ping {
    fn default() -> &'a CDOTAUserMsg_Ping {
        <CDOTAUserMsg_Ping as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_Ping {
    pub fn new() -> CDOTAUserMsg_Ping {
        ::std::default::Default::default()
    }

    // optional uint32 ping = 2;

    pub fn ping(&self) -> u32 {
        self.ping.unwrap_or(0)
    }

    pub fn clear_ping(&mut self) {
        self.ping = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        self.ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: u32) {
        self.ping = ::std::option::Option::Some(v);
    }

    // optional uint32 loss = 3;

    pub fn loss(&self) -> u32 {
        self.loss.unwrap_or(0)
    }

    pub fn clear_loss(&mut self) {
        self.loss = ::std::option::Option::None;
    }

    pub fn has_loss(&self) -> bool {
        self.loss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loss(&mut self, v: u32) {
        self.loss = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_Ping {
    const NAME: &'static str = "CDOTAUserMsg_Ping";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.ping = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.loss = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ping {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.loss {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ping {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.loss {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_Ping {
        CDOTAUserMsg_Ping::new()
    }

    fn clear(&mut self) {
        self.ping = ::std::option::Option::None;
        self.loss = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_Ping {
        static instance: CDOTAUserMsg_Ping = CDOTAUserMsg_Ping {
            ping: ::std::option::Option::None,
            loss: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_SwapVerify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SwapVerify {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_SwapVerify.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_SwapVerify.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SwapVerify {
    fn default() -> &'a CDOTAUserMsg_SwapVerify {
        <CDOTAUserMsg_SwapVerify as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SwapVerify {
    pub fn new() -> CDOTAUserMsg_SwapVerify {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_SwapVerify {
    const NAME: &'static str = "CDOTAUserMsg_SwapVerify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SwapVerify {
        CDOTAUserMsg_SwapVerify::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SwapVerify {
        static instance: CDOTAUserMsg_SwapVerify = CDOTAUserMsg_SwapVerify {
            player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_ChatEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ChatEvent {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_ChatEvent.type)
    pub type_: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<DOTA_CHAT_MESSAGE>>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ChatEvent.value)
    pub value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ChatEvent.playerid_1)
    pub playerid_1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ChatEvent.playerid_2)
    pub playerid_2: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ChatEvent.playerid_3)
    pub playerid_3: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ChatEvent.playerid_4)
    pub playerid_4: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ChatEvent.playerid_5)
    pub playerid_5: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ChatEvent.playerid_6)
    pub playerid_6: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ChatEvent.value2)
    pub value2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ChatEvent.value3)
    pub value3: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_ChatEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ChatEvent {
    fn default() -> &'a CDOTAUserMsg_ChatEvent {
        <CDOTAUserMsg_ChatEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ChatEvent {
    pub fn new() -> CDOTAUserMsg_ChatEvent {
        ::std::default::Default::default()
    }

    // required .DOTA_CHAT_MESSAGE type = 1;

    pub fn type_(&self) -> DOTA_CHAT_MESSAGE {
        match self.type_ {
            Some(e) => e.enum_value_or(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INVALID),
            None => DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INVALID,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: DOTA_CHAT_MESSAGE) {
        self.type_ = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 value = 2;

    pub fn value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional sint32 playerid_1 = 3;

    pub fn playerid_1(&self) -> i32 {
        self.playerid_1.unwrap_or(-1i32)
    }

    pub fn clear_playerid_1(&mut self) {
        self.playerid_1 = ::std::option::Option::None;
    }

    pub fn has_playerid_1(&self) -> bool {
        self.playerid_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_1(&mut self, v: i32) {
        self.playerid_1 = ::std::option::Option::Some(v);
    }

    // optional sint32 playerid_2 = 4;

    pub fn playerid_2(&self) -> i32 {
        self.playerid_2.unwrap_or(-1i32)
    }

    pub fn clear_playerid_2(&mut self) {
        self.playerid_2 = ::std::option::Option::None;
    }

    pub fn has_playerid_2(&self) -> bool {
        self.playerid_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_2(&mut self, v: i32) {
        self.playerid_2 = ::std::option::Option::Some(v);
    }

    // optional sint32 playerid_3 = 5;

    pub fn playerid_3(&self) -> i32 {
        self.playerid_3.unwrap_or(-1i32)
    }

    pub fn clear_playerid_3(&mut self) {
        self.playerid_3 = ::std::option::Option::None;
    }

    pub fn has_playerid_3(&self) -> bool {
        self.playerid_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_3(&mut self, v: i32) {
        self.playerid_3 = ::std::option::Option::Some(v);
    }

    // optional sint32 playerid_4 = 6;

    pub fn playerid_4(&self) -> i32 {
        self.playerid_4.unwrap_or(-1i32)
    }

    pub fn clear_playerid_4(&mut self) {
        self.playerid_4 = ::std::option::Option::None;
    }

    pub fn has_playerid_4(&self) -> bool {
        self.playerid_4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_4(&mut self, v: i32) {
        self.playerid_4 = ::std::option::Option::Some(v);
    }

    // optional sint32 playerid_5 = 7;

    pub fn playerid_5(&self) -> i32 {
        self.playerid_5.unwrap_or(-1i32)
    }

    pub fn clear_playerid_5(&mut self) {
        self.playerid_5 = ::std::option::Option::None;
    }

    pub fn has_playerid_5(&self) -> bool {
        self.playerid_5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_5(&mut self, v: i32) {
        self.playerid_5 = ::std::option::Option::Some(v);
    }

    // optional sint32 playerid_6 = 8;

    pub fn playerid_6(&self) -> i32 {
        self.playerid_6.unwrap_or(-1i32)
    }

    pub fn clear_playerid_6(&mut self) {
        self.playerid_6 = ::std::option::Option::None;
    }

    pub fn has_playerid_6(&self) -> bool {
        self.playerid_6.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_6(&mut self, v: i32) {
        self.playerid_6 = ::std::option::Option::Some(v);
    }

    // optional uint32 value2 = 9;

    pub fn value2(&self) -> u32 {
        self.value2.unwrap_or(0)
    }

    pub fn clear_value2(&mut self) {
        self.value2 = ::std::option::Option::None;
    }

    pub fn has_value2(&self) -> bool {
        self.value2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value2(&mut self, v: u32) {
        self.value2 = ::std::option::Option::Some(v);
    }

    // optional uint32 value3 = 10;

    pub fn value3(&self) -> u32 {
        self.value3.unwrap_or(0)
    }

    pub fn clear_value3(&mut self) {
        self.value3 = ::std::option::Option::None;
    }

    pub fn has_value3(&self) -> bool {
        self.value3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value3(&mut self, v: u32) {
        self.value3 = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_ChatEvent {
    const NAME: &'static str = "CDOTAUserMsg_ChatEvent";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.value = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.playerid_1 = ::std::option::Option::Some(is.read_sint32()?);
                },
                32 => {
                    self.playerid_2 = ::std::option::Option::Some(is.read_sint32()?);
                },
                40 => {
                    self.playerid_3 = ::std::option::Option::Some(is.read_sint32()?);
                },
                48 => {
                    self.playerid_4 = ::std::option::Option::Some(is.read_sint32()?);
                },
                56 => {
                    self.playerid_5 = ::std::option::Option::Some(is.read_sint32()?);
                },
                64 => {
                    self.playerid_6 = ::std::option::Option::Some(is.read_sint32()?);
                },
                72 => {
                    self.value2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.value3 = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.playerid_1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(3, v);
        }
        if let Some(v) = self.playerid_2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(4, v);
        }
        if let Some(v) = self.playerid_3 {
            my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(5, v);
        }
        if let Some(v) = self.playerid_4 {
            my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(6, v);
        }
        if let Some(v) = self.playerid_5 {
            my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(7, v);
        }
        if let Some(v) = self.playerid_6 {
            my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(8, v);
        }
        if let Some(v) = self.value2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.value3 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.value {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.playerid_1 {
            os.write_sint32(3, v)?;
        }
        if let Some(v) = self.playerid_2 {
            os.write_sint32(4, v)?;
        }
        if let Some(v) = self.playerid_3 {
            os.write_sint32(5, v)?;
        }
        if let Some(v) = self.playerid_4 {
            os.write_sint32(6, v)?;
        }
        if let Some(v) = self.playerid_5 {
            os.write_sint32(7, v)?;
        }
        if let Some(v) = self.playerid_6 {
            os.write_sint32(8, v)?;
        }
        if let Some(v) = self.value2 {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.value3 {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ChatEvent {
        CDOTAUserMsg_ChatEvent::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.playerid_1 = ::std::option::Option::None;
        self.playerid_2 = ::std::option::Option::None;
        self.playerid_3 = ::std::option::Option::None;
        self.playerid_4 = ::std::option::Option::None;
        self.playerid_5 = ::std::option::Option::None;
        self.playerid_6 = ::std::option::Option::None;
        self.value2 = ::std::option::Option::None;
        self.value3 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ChatEvent {
        static instance: CDOTAUserMsg_ChatEvent = CDOTAUserMsg_ChatEvent {
            type_: ::std::option::Option::None,
            value: ::std::option::Option::None,
            playerid_1: ::std::option::Option::None,
            playerid_2: ::std::option::Option::None,
            playerid_3: ::std::option::Option::None,
            playerid_4: ::std::option::Option::None,
            playerid_5: ::std::option::Option::None,
            playerid_6: ::std::option::Option::None,
            value2: ::std::option::Option::None,
            value3: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_BotChat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_BotChat {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_BotChat.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_BotChat.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_BotChat.target)
    pub target: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_BotChat.team_only)
    pub team_only: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_BotChat.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_BotChat {
    fn default() -> &'a CDOTAUserMsg_BotChat {
        <CDOTAUserMsg_BotChat as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_BotChat {
    pub fn new() -> CDOTAUserMsg_BotChat {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional string message = 3;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string target = 4;

    pub fn target(&self) -> &str {
        match self.target.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_target(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ::std::string::String) {
        self.target = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut ::std::string::String {
        if self.target.is_none() {
            self.target = ::std::option::Option::Some(::std::string::String::new());
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> ::std::string::String {
        self.target.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool team_only = 5;

    pub fn team_only(&self) -> bool {
        self.team_only.unwrap_or(false)
    }

    pub fn clear_team_only(&mut self) {
        self.team_only = ::std::option::Option::None;
    }

    pub fn has_team_only(&self) -> bool {
        self.team_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_only(&mut self, v: bool) {
        self.team_only = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_BotChat {
    const NAME: &'static str = "CDOTAUserMsg_BotChat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.target = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.team_only = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.target.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.team_only {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.target.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.team_only {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_BotChat {
        CDOTAUserMsg_BotChat::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.team_only = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_BotChat {
        static instance: CDOTAUserMsg_BotChat = CDOTAUserMsg_BotChat {
            player_id: ::std::option::Option::None,
            message: ::std::option::Option::None,
            target: ::std::option::Option::None,
            team_only: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_CombatHeroPositions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CombatHeroPositions {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_CombatHeroPositions.index)
    pub index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CombatHeroPositions.time)
    pub time: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CombatHeroPositions.world_pos)
    pub world_pos: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector2D>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CombatHeroPositions.health)
    pub health: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_CombatHeroPositions.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CombatHeroPositions {
    fn default() -> &'a CDOTAUserMsg_CombatHeroPositions {
        <CDOTAUserMsg_CombatHeroPositions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CombatHeroPositions {
    pub fn new() -> CDOTAUserMsg_CombatHeroPositions {
        ::std::default::Default::default()
    }

    // optional uint32 index = 1;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional int32 time = 2;

    pub fn time(&self) -> i32 {
        self.time.unwrap_or(0)
    }

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i32) {
        self.time = ::std::option::Option::Some(v);
    }

    // optional int32 health = 4;

    pub fn health(&self) -> i32 {
        self.health.unwrap_or(0)
    }

    pub fn clear_health(&mut self) {
        self.health = ::std::option::Option::None;
    }

    pub fn has_health(&self) -> bool {
        self.health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health(&mut self, v: i32) {
        self.health = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_CombatHeroPositions {
    const NAME: &'static str = "CDOTAUserMsg_CombatHeroPositions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.time = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.world_pos)?;
                },
                32 => {
                    self.health = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.time {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.world_pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.health {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.time {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.world_pos.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.health {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CombatHeroPositions {
        CDOTAUserMsg_CombatHeroPositions::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.time = ::std::option::Option::None;
        self.world_pos.clear();
        self.health = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CombatHeroPositions {
        static instance: CDOTAUserMsg_CombatHeroPositions = CDOTAUserMsg_CombatHeroPositions {
            index: ::std::option::Option::None,
            time: ::std::option::Option::None,
            world_pos: ::steam_vent_proto_common::protobuf::MessageField::none(),
            health: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_CombatLogBulkData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CombatLogBulkData {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_CombatLogBulkData.combat_entries)
    pub combat_entries: ::std::vec::Vec<super::dota_shared_enums::CMsgDOTACombatLogEntry>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CombatLogBulkData.timestamp)
    pub timestamp: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CombatLogBulkData.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CombatLogBulkData.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CombatLogBulkData.request_time)
    pub request_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_CombatLogBulkData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CombatLogBulkData {
    fn default() -> &'a CDOTAUserMsg_CombatLogBulkData {
        <CDOTAUserMsg_CombatLogBulkData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CombatLogBulkData {
    pub fn new() -> CDOTAUserMsg_CombatLogBulkData {
        ::std::default::Default::default()
    }

    // optional float timestamp = 2;

    pub fn timestamp(&self) -> f32 {
        self.timestamp.unwrap_or(0.)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional float duration = 3;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional int32 player_id = 4;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional float request_time = 5;

    pub fn request_time(&self) -> f32 {
        self.request_time.unwrap_or(0.)
    }

    pub fn clear_request_time(&mut self) {
        self.request_time = ::std::option::Option::None;
    }

    pub fn has_request_time(&self) -> bool {
        self.request_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_time(&mut self, v: f32) {
        self.request_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_CombatLogBulkData {
    const NAME: &'static str = "CDOTAUserMsg_CombatLogBulkData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.combat_entries.push(is.read_message()?);
                },
                21 => {
                    self.timestamp = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                45 => {
                    self.request_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.combat_entries {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.request_time {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.combat_entries {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.timestamp {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.player_id {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.request_time {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CombatLogBulkData {
        CDOTAUserMsg_CombatLogBulkData::new()
    }

    fn clear(&mut self) {
        self.combat_entries.clear();
        self.timestamp = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.player_id = ::std::option::Option::None;
        self.request_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CombatLogBulkData {
        static instance: CDOTAUserMsg_CombatLogBulkData = CDOTAUserMsg_CombatLogBulkData {
            combat_entries: ::std::vec::Vec::new(),
            timestamp: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            player_id: ::std::option::Option::None,
            request_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_ProjectileParticleCPData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ProjectileParticleCPData {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_ProjectileParticleCPData.control_point)
    pub control_point: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ProjectileParticleCPData.vector)
    pub vector: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_ProjectileParticleCPData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ProjectileParticleCPData {
    fn default() -> &'a CDOTAUserMsg_ProjectileParticleCPData {
        <CDOTAUserMsg_ProjectileParticleCPData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ProjectileParticleCPData {
    pub fn new() -> CDOTAUserMsg_ProjectileParticleCPData {
        ::std::default::Default::default()
    }

    // optional int32 control_point = 1;

    pub fn control_point(&self) -> i32 {
        self.control_point.unwrap_or(0)
    }

    pub fn clear_control_point(&mut self) {
        self.control_point = ::std::option::Option::None;
    }

    pub fn has_control_point(&self) -> bool {
        self.control_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_control_point(&mut self, v: i32) {
        self.control_point = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_ProjectileParticleCPData {
    const NAME: &'static str = "CDOTAUserMsg_ProjectileParticleCPData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.control_point = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.vector)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.control_point {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.vector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.control_point {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.vector.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ProjectileParticleCPData {
        CDOTAUserMsg_ProjectileParticleCPData::new()
    }

    fn clear(&mut self) {
        self.control_point = ::std::option::Option::None;
        self.vector.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ProjectileParticleCPData {
        static instance: CDOTAUserMsg_ProjectileParticleCPData = CDOTAUserMsg_ProjectileParticleCPData {
            control_point: ::std::option::Option::None,
            vector: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_UpdateLinearProjectileCPData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_UpdateLinearProjectileCPData {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_UpdateLinearProjectileCPData.handle)
    pub handle: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_UpdateLinearProjectileCPData.control_point)
    pub control_point: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_UpdateLinearProjectileCPData.vector)
    pub vector: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_UpdateLinearProjectileCPData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_UpdateLinearProjectileCPData {
    fn default() -> &'a CDOTAUserMsg_UpdateLinearProjectileCPData {
        <CDOTAUserMsg_UpdateLinearProjectileCPData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_UpdateLinearProjectileCPData {
    pub fn new() -> CDOTAUserMsg_UpdateLinearProjectileCPData {
        ::std::default::Default::default()
    }

    // optional int32 handle = 1;

    pub fn handle(&self) -> i32 {
        self.handle.unwrap_or(0)
    }

    pub fn clear_handle(&mut self) {
        self.handle = ::std::option::Option::None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: i32) {
        self.handle = ::std::option::Option::Some(v);
    }

    // optional int32 control_point = 2;

    pub fn control_point(&self) -> i32 {
        self.control_point.unwrap_or(0)
    }

    pub fn clear_control_point(&mut self) {
        self.control_point = ::std::option::Option::None;
    }

    pub fn has_control_point(&self) -> bool {
        self.control_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_control_point(&mut self, v: i32) {
        self.control_point = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_UpdateLinearProjectileCPData {
    const NAME: &'static str = "CDOTAUserMsg_UpdateLinearProjectileCPData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.handle = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.control_point = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.vector)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.handle {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.control_point {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.vector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.handle {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.control_point {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.vector.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_UpdateLinearProjectileCPData {
        CDOTAUserMsg_UpdateLinearProjectileCPData::new()
    }

    fn clear(&mut self) {
        self.handle = ::std::option::Option::None;
        self.control_point = ::std::option::Option::None;
        self.vector.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_UpdateLinearProjectileCPData {
        static instance: CDOTAUserMsg_UpdateLinearProjectileCPData = CDOTAUserMsg_UpdateLinearProjectileCPData {
            handle: ::std::option::Option::None,
            control_point: ::std::option::Option::None,
            vector: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_MiniKillCamInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_MiniKillCamInfo {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_MiniKillCamInfo.attackers)
    pub attackers: ::std::vec::Vec<cdotauser_msg_mini_kill_cam_info::Attacker>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_MiniKillCamInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_MiniKillCamInfo {
    fn default() -> &'a CDOTAUserMsg_MiniKillCamInfo {
        <CDOTAUserMsg_MiniKillCamInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_MiniKillCamInfo {
    pub fn new() -> CDOTAUserMsg_MiniKillCamInfo {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_MiniKillCamInfo {
    const NAME: &'static str = "CDOTAUserMsg_MiniKillCamInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.attackers.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.attackers {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.attackers {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_MiniKillCamInfo {
        CDOTAUserMsg_MiniKillCamInfo::new()
    }

    fn clear(&mut self) {
        self.attackers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_MiniKillCamInfo {
        static instance: CDOTAUserMsg_MiniKillCamInfo = CDOTAUserMsg_MiniKillCamInfo {
            attackers: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CDOTAUserMsg_MiniKillCamInfo`
pub mod cdotauser_msg_mini_kill_cam_info {
    // @@protoc_insertion_point(message:CDOTAUserMsg_MiniKillCamInfo.Attacker)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Attacker {
        // message fields
        // @@protoc_insertion_point(field:CDOTAUserMsg_MiniKillCamInfo.Attacker.attacker)
        pub attacker: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_MiniKillCamInfo.Attacker.total_damage)
        pub total_damage: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_MiniKillCamInfo.Attacker.abilities)
        pub abilities: ::std::vec::Vec<attacker::Ability>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_MiniKillCamInfo.Attacker.attacker_name)
        pub attacker_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAUserMsg_MiniKillCamInfo.Attacker.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Attacker {
        fn default() -> &'a Attacker {
            <Attacker as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Attacker {
        pub fn new() -> Attacker {
            ::std::default::Default::default()
        }

        // optional uint32 attacker = 1;

        pub fn attacker(&self) -> u32 {
            self.attacker.unwrap_or(16777215u32)
        }

        pub fn clear_attacker(&mut self) {
            self.attacker = ::std::option::Option::None;
        }

        pub fn has_attacker(&self) -> bool {
            self.attacker.is_some()
        }

        // Param is passed by value, moved
        pub fn set_attacker(&mut self, v: u32) {
            self.attacker = ::std::option::Option::Some(v);
        }

        // optional int32 total_damage = 2;

        pub fn total_damage(&self) -> i32 {
            self.total_damage.unwrap_or(0)
        }

        pub fn clear_total_damage(&mut self) {
            self.total_damage = ::std::option::Option::None;
        }

        pub fn has_total_damage(&self) -> bool {
            self.total_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_damage(&mut self, v: i32) {
            self.total_damage = ::std::option::Option::Some(v);
        }

        // optional string attacker_name = 4;

        pub fn attacker_name(&self) -> &str {
            match self.attacker_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_attacker_name(&mut self) {
            self.attacker_name = ::std::option::Option::None;
        }

        pub fn has_attacker_name(&self) -> bool {
            self.attacker_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_attacker_name(&mut self, v: ::std::string::String) {
            self.attacker_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_attacker_name(&mut self) -> &mut ::std::string::String {
            if self.attacker_name.is_none() {
                self.attacker_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.attacker_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_attacker_name(&mut self) -> ::std::string::String {
            self.attacker_name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Attacker {
        const NAME: &'static str = "Attacker";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.attacker = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.total_damage = ::std::option::Option::Some(is.read_int32()?);
                    },
                    26 => {
                        self.abilities.push(is.read_message()?);
                    },
                    34 => {
                        self.attacker_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.attacker {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.total_damage {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            for value in &self.abilities {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.attacker_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.attacker {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.total_damage {
                os.write_int32(2, v)?;
            }
            for v in &self.abilities {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            if let Some(v) = self.attacker_name.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Attacker {
            Attacker::new()
        }

        fn clear(&mut self) {
            self.attacker = ::std::option::Option::None;
            self.total_damage = ::std::option::Option::None;
            self.abilities.clear();
            self.attacker_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Attacker {
            static instance: Attacker = Attacker {
                attacker: ::std::option::Option::None,
                total_damage: ::std::option::Option::None,
                abilities: ::std::vec::Vec::new(),
                attacker_name: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Attacker`
    pub mod attacker {
        // @@protoc_insertion_point(message:CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Ability {
            // message fields
            // @@protoc_insertion_point(field:CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability.ability_id)
            pub ability_id: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability.damage)
            pub damage: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Ability {
            fn default() -> &'a Ability {
                <Ability as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl Ability {
            pub fn new() -> Ability {
                ::std::default::Default::default()
            }

            // optional int32 ability_id = 1;

            pub fn ability_id(&self) -> i32 {
                self.ability_id.unwrap_or(-1i32)
            }

            pub fn clear_ability_id(&mut self) {
                self.ability_id = ::std::option::Option::None;
            }

            pub fn has_ability_id(&self) -> bool {
                self.ability_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_ability_id(&mut self, v: i32) {
                self.ability_id = ::std::option::Option::Some(v);
            }

            // optional int32 damage = 2;

            pub fn damage(&self) -> i32 {
                self.damage.unwrap_or(0)
            }

            pub fn clear_damage(&mut self) {
                self.damage = ::std::option::Option::None;
            }

            pub fn has_damage(&self) -> bool {
                self.damage.is_some()
            }

            // Param is passed by value, moved
            pub fn set_damage(&mut self, v: i32) {
                self.damage = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for Ability {
            const NAME: &'static str = "Ability";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                        },
                        16 => {
                            self.damage = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.ability_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
                }
                if let Some(v) = self.damage {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.ability_id {
                    os.write_int32(1, v)?;
                }
                if let Some(v) = self.damage {
                    os.write_int32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Ability {
                Ability::new()
            }

            fn clear(&mut self) {
                self.ability_id = ::std::option::Option::None;
                self.damage = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Ability {
                static instance: Ability = Ability {
                    ability_id: ::std::option::Option::None,
                    damage: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_GlobalLightColor)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_GlobalLightColor {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_GlobalLightColor.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_GlobalLightColor.duration)
    pub duration: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_GlobalLightColor.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_GlobalLightColor {
    fn default() -> &'a CDOTAUserMsg_GlobalLightColor {
        <CDOTAUserMsg_GlobalLightColor as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_GlobalLightColor {
    pub fn new() -> CDOTAUserMsg_GlobalLightColor {
        ::std::default::Default::default()
    }

    // optional uint32 color = 1;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional float duration = 2;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_GlobalLightColor {
    const NAME: &'static str = "CDOTAUserMsg_GlobalLightColor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.color = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.color {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.color {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_GlobalLightColor {
        CDOTAUserMsg_GlobalLightColor::new()
    }

    fn clear(&mut self) {
        self.color = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_GlobalLightColor {
        static instance: CDOTAUserMsg_GlobalLightColor = CDOTAUserMsg_GlobalLightColor {
            color: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_GlobalLightDirection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_GlobalLightDirection {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_GlobalLightDirection.direction)
    pub direction: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_GlobalLightDirection.duration)
    pub duration: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_GlobalLightDirection.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_GlobalLightDirection {
    fn default() -> &'a CDOTAUserMsg_GlobalLightDirection {
        <CDOTAUserMsg_GlobalLightDirection as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_GlobalLightDirection {
    pub fn new() -> CDOTAUserMsg_GlobalLightDirection {
        ::std::default::Default::default()
    }

    // optional float duration = 2;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_GlobalLightDirection {
    const NAME: &'static str = "CDOTAUserMsg_GlobalLightDirection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.direction)?;
                },
                21 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.direction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.direction.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_GlobalLightDirection {
        CDOTAUserMsg_GlobalLightDirection::new()
    }

    fn clear(&mut self) {
        self.direction.clear();
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_GlobalLightDirection {
        static instance: CDOTAUserMsg_GlobalLightDirection = CDOTAUserMsg_GlobalLightDirection {
            direction: ::steam_vent_proto_common::protobuf::MessageField::none(),
            duration: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_LocationPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_LocationPing {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_LocationPing.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_LocationPing.location_ping)
    pub location_ping: ::steam_vent_proto_common::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_LocationPing>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_LocationPing.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_LocationPing {
    fn default() -> &'a CDOTAUserMsg_LocationPing {
        <CDOTAUserMsg_LocationPing as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_LocationPing {
    pub fn new() -> CDOTAUserMsg_LocationPing {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_LocationPing {
    const NAME: &'static str = "CDOTAUserMsg_LocationPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.location_ping)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.location_ping.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.location_ping.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_LocationPing {
        CDOTAUserMsg_LocationPing::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.location_ping.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_LocationPing {
        static instance: CDOTAUserMsg_LocationPing = CDOTAUserMsg_LocationPing {
            player_id: ::std::option::Option::None,
            location_ping: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_PingConfirmation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_PingConfirmation {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_PingConfirmation.player_id_of_original_pinger)
    pub player_id_of_original_pinger: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_PingConfirmation.entity_index)
    pub entity_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_PingConfirmation.icon_type)
    pub icon_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_PingConfirmation.location)
    pub location: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_PingConfirmation.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_PingConfirmation {
    fn default() -> &'a CDOTAUserMsg_PingConfirmation {
        <CDOTAUserMsg_PingConfirmation as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_PingConfirmation {
    pub fn new() -> CDOTAUserMsg_PingConfirmation {
        ::std::default::Default::default()
    }

    // optional int32 player_id_of_original_pinger = 1;

    pub fn player_id_of_original_pinger(&self) -> i32 {
        self.player_id_of_original_pinger.unwrap_or(-1i32)
    }

    pub fn clear_player_id_of_original_pinger(&mut self) {
        self.player_id_of_original_pinger = ::std::option::Option::None;
    }

    pub fn has_player_id_of_original_pinger(&self) -> bool {
        self.player_id_of_original_pinger.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_of_original_pinger(&mut self, v: i32) {
        self.player_id_of_original_pinger = ::std::option::Option::Some(v);
    }

    // optional uint32 entity_index = 2;

    pub fn entity_index(&self) -> u32 {
        self.entity_index.unwrap_or(0)
    }

    pub fn clear_entity_index(&mut self) {
        self.entity_index = ::std::option::Option::None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: u32) {
        self.entity_index = ::std::option::Option::Some(v);
    }

    // optional uint32 icon_type = 3;

    pub fn icon_type(&self) -> u32 {
        self.icon_type.unwrap_or(0)
    }

    pub fn clear_icon_type(&mut self) {
        self.icon_type = ::std::option::Option::None;
    }

    pub fn has_icon_type(&self) -> bool {
        self.icon_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon_type(&mut self, v: u32) {
        self.icon_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_PingConfirmation {
    const NAME: &'static str = "CDOTAUserMsg_PingConfirmation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id_of_original_pinger = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.entity_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.icon_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.location)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id_of_original_pinger {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.entity_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.icon_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id_of_original_pinger {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.entity_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.icon_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.location.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_PingConfirmation {
        CDOTAUserMsg_PingConfirmation::new()
    }

    fn clear(&mut self) {
        self.player_id_of_original_pinger = ::std::option::Option::None;
        self.entity_index = ::std::option::Option::None;
        self.icon_type = ::std::option::Option::None;
        self.location.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_PingConfirmation {
        static instance: CDOTAUserMsg_PingConfirmation = CDOTAUserMsg_PingConfirmation {
            player_id_of_original_pinger: ::std::option::Option::None,
            entity_index: ::std::option::Option::None,
            icon_type: ::std::option::Option::None,
            location: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_ItemAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ItemAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_ItemAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ItemAlert.item_alert)
    pub item_alert: ::steam_vent_proto_common::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_ItemAlert>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_ItemAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ItemAlert {
    fn default() -> &'a CDOTAUserMsg_ItemAlert {
        <CDOTAUserMsg_ItemAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ItemAlert {
    pub fn new() -> CDOTAUserMsg_ItemAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_ItemAlert {
    const NAME: &'static str = "CDOTAUserMsg_ItemAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.item_alert)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.item_alert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.item_alert.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ItemAlert {
        CDOTAUserMsg_ItemAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.item_alert.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ItemAlert {
        static instance: CDOTAUserMsg_ItemAlert = CDOTAUserMsg_ItemAlert {
            player_id: ::std::option::Option::None,
            item_alert: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_EnemyItemAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_EnemyItemAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_EnemyItemAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_EnemyItemAlert.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_EnemyItemAlert.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_EnemyItemAlert.rune_type)
    pub rune_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_EnemyItemAlert.entity_id)
    pub entity_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_EnemyItemAlert.item_level)
    pub item_level: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_EnemyItemAlert.primary_charges)
    pub primary_charges: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_EnemyItemAlert.secondary_charges)
    pub secondary_charges: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_EnemyItemAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_EnemyItemAlert {
    fn default() -> &'a CDOTAUserMsg_EnemyItemAlert {
        <CDOTAUserMsg_EnemyItemAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_EnemyItemAlert {
    pub fn new() -> CDOTAUserMsg_EnemyItemAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_player_id = 2;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(-1i32)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 item_ability_id = 3;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(-1i32)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    // optional int32 rune_type = 4;

    pub fn rune_type(&self) -> i32 {
        self.rune_type.unwrap_or(-1i32)
    }

    pub fn clear_rune_type(&mut self) {
        self.rune_type = ::std::option::Option::None;
    }

    pub fn has_rune_type(&self) -> bool {
        self.rune_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rune_type(&mut self, v: i32) {
        self.rune_type = ::std::option::Option::Some(v);
    }

    // optional int32 entity_id = 5;

    pub fn entity_id(&self) -> i32 {
        self.entity_id.unwrap_or(0)
    }

    pub fn clear_entity_id(&mut self) {
        self.entity_id = ::std::option::Option::None;
    }

    pub fn has_entity_id(&self) -> bool {
        self.entity_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_id(&mut self, v: i32) {
        self.entity_id = ::std::option::Option::Some(v);
    }

    // optional int32 item_level = 6;

    pub fn item_level(&self) -> i32 {
        self.item_level.unwrap_or(-1i32)
    }

    pub fn clear_item_level(&mut self) {
        self.item_level = ::std::option::Option::None;
    }

    pub fn has_item_level(&self) -> bool {
        self.item_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_level(&mut self, v: i32) {
        self.item_level = ::std::option::Option::Some(v);
    }

    // optional int32 primary_charges = 7;

    pub fn primary_charges(&self) -> i32 {
        self.primary_charges.unwrap_or(-1i32)
    }

    pub fn clear_primary_charges(&mut self) {
        self.primary_charges = ::std::option::Option::None;
    }

    pub fn has_primary_charges(&self) -> bool {
        self.primary_charges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_charges(&mut self, v: i32) {
        self.primary_charges = ::std::option::Option::Some(v);
    }

    // optional int32 secondary_charges = 8;

    pub fn secondary_charges(&self) -> i32 {
        self.secondary_charges.unwrap_or(-1i32)
    }

    pub fn clear_secondary_charges(&mut self) {
        self.secondary_charges = ::std::option::Option::None;
    }

    pub fn has_secondary_charges(&self) -> bool {
        self.secondary_charges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondary_charges(&mut self, v: i32) {
        self.secondary_charges = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_EnemyItemAlert {
    const NAME: &'static str = "CDOTAUserMsg_EnemyItemAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.rune_type = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.entity_id = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.item_level = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.primary_charges = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.secondary_charges = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.item_ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.rune_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.entity_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.item_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.primary_charges {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.secondary_charges {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.item_ability_id {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.rune_type {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.entity_id {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.item_level {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.primary_charges {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.secondary_charges {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_EnemyItemAlert {
        CDOTAUserMsg_EnemyItemAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.target_player_id = ::std::option::Option::None;
        self.item_ability_id = ::std::option::Option::None;
        self.rune_type = ::std::option::Option::None;
        self.entity_id = ::std::option::Option::None;
        self.item_level = ::std::option::Option::None;
        self.primary_charges = ::std::option::Option::None;
        self.secondary_charges = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_EnemyItemAlert {
        static instance: CDOTAUserMsg_EnemyItemAlert = CDOTAUserMsg_EnemyItemAlert {
            player_id: ::std::option::Option::None,
            target_player_id: ::std::option::Option::None,
            item_ability_id: ::std::option::Option::None,
            rune_type: ::std::option::Option::None,
            entity_id: ::std::option::Option::None,
            item_level: ::std::option::Option::None,
            primary_charges: ::std::option::Option::None,
            secondary_charges: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_ModifierAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ModifierAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_ModifierAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ModifierAlert.class_name)
    pub class_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ModifierAlert.stack_count)
    pub stack_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ModifierAlert.is_debuff)
    pub is_debuff: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ModifierAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ModifierAlert.seconds_remaining)
    pub seconds_remaining: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_ModifierAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ModifierAlert {
    fn default() -> &'a CDOTAUserMsg_ModifierAlert {
        <CDOTAUserMsg_ModifierAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ModifierAlert {
    pub fn new() -> CDOTAUserMsg_ModifierAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional string class_name = 2;

    pub fn class_name(&self) -> &str {
        match self.class_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_class_name(&mut self) {
        self.class_name = ::std::option::Option::None;
    }

    pub fn has_class_name(&self) -> bool {
        self.class_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_name(&mut self, v: ::std::string::String) {
        self.class_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_class_name(&mut self) -> &mut ::std::string::String {
        if self.class_name.is_none() {
            self.class_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.class_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_class_name(&mut self) -> ::std::string::String {
        self.class_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 stack_count = 3;

    pub fn stack_count(&self) -> u32 {
        self.stack_count.unwrap_or(0)
    }

    pub fn clear_stack_count(&mut self) {
        self.stack_count = ::std::option::Option::None;
    }

    pub fn has_stack_count(&self) -> bool {
        self.stack_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_count(&mut self, v: u32) {
        self.stack_count = ::std::option::Option::Some(v);
    }

    // optional bool is_debuff = 4;

    pub fn is_debuff(&self) -> bool {
        self.is_debuff.unwrap_or(false)
    }

    pub fn clear_is_debuff(&mut self) {
        self.is_debuff = ::std::option::Option::None;
    }

    pub fn has_is_debuff(&self) -> bool {
        self.is_debuff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_debuff(&mut self, v: bool) {
        self.is_debuff = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 5;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(-1i32)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional float seconds_remaining = 6;

    pub fn seconds_remaining(&self) -> f32 {
        self.seconds_remaining.unwrap_or(0.)
    }

    pub fn clear_seconds_remaining(&mut self) {
        self.seconds_remaining = ::std::option::Option::None;
    }

    pub fn has_seconds_remaining(&self) -> bool {
        self.seconds_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_remaining(&mut self, v: f32) {
        self.seconds_remaining = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_ModifierAlert {
    const NAME: &'static str = "CDOTAUserMsg_ModifierAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.class_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.stack_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.is_debuff = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                53 => {
                    self.seconds_remaining = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.class_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.stack_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.is_debuff {
            my_size += 1 + 1;
        }
        if let Some(v) = self.target_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.seconds_remaining {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.class_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.stack_count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.is_debuff {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.seconds_remaining {
            os.write_float(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ModifierAlert {
        CDOTAUserMsg_ModifierAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.class_name = ::std::option::Option::None;
        self.stack_count = ::std::option::Option::None;
        self.is_debuff = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.seconds_remaining = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ModifierAlert {
        static instance: CDOTAUserMsg_ModifierAlert = CDOTAUserMsg_ModifierAlert {
            player_id: ::std::option::Option::None,
            class_name: ::std::option::Option::None,
            stack_count: ::std::option::Option::None,
            is_debuff: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            seconds_remaining: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_HPManaAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_HPManaAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_HPManaAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_HPManaAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_HPManaAlert.show_raw_values)
    pub show_raw_values: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_HPManaAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_HPManaAlert {
    fn default() -> &'a CDOTAUserMsg_HPManaAlert {
        <CDOTAUserMsg_HPManaAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_HPManaAlert {
    pub fn new() -> CDOTAUserMsg_HPManaAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 2;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(-1i32)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional bool show_raw_values = 3;

    pub fn show_raw_values(&self) -> bool {
        self.show_raw_values.unwrap_or(false)
    }

    pub fn clear_show_raw_values(&mut self) {
        self.show_raw_values = ::std::option::Option::None;
    }

    pub fn has_show_raw_values(&self) -> bool {
        self.show_raw_values.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_raw_values(&mut self, v: bool) {
        self.show_raw_values = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_HPManaAlert {
    const NAME: &'static str = "CDOTAUserMsg_HPManaAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.show_raw_values = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.show_raw_values {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.show_raw_values {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_HPManaAlert {
        CDOTAUserMsg_HPManaAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.show_raw_values = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_HPManaAlert {
        static instance: CDOTAUserMsg_HPManaAlert = CDOTAUserMsg_HPManaAlert {
            player_id: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            show_raw_values: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_NeutralCampAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_NeutralCampAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_NeutralCampAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_NeutralCampAlert.spawner_entindex)
    pub spawner_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_NeutralCampAlert.unit_entindex)
    pub unit_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_NeutralCampAlert.stack_count)
    pub stack_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_NeutralCampAlert.camp_type)
    pub camp_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_NeutralCampAlert.stack_request)
    pub stack_request: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_NeutralCampAlert.stack_intention)
    pub stack_intention: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_NeutralCampAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_NeutralCampAlert {
    fn default() -> &'a CDOTAUserMsg_NeutralCampAlert {
        <CDOTAUserMsg_NeutralCampAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_NeutralCampAlert {
    pub fn new() -> CDOTAUserMsg_NeutralCampAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 spawner_entindex = 2;

    pub fn spawner_entindex(&self) -> i32 {
        self.spawner_entindex.unwrap_or(-1i32)
    }

    pub fn clear_spawner_entindex(&mut self) {
        self.spawner_entindex = ::std::option::Option::None;
    }

    pub fn has_spawner_entindex(&self) -> bool {
        self.spawner_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawner_entindex(&mut self, v: i32) {
        self.spawner_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 unit_entindex = 3;

    pub fn unit_entindex(&self) -> i32 {
        self.unit_entindex.unwrap_or(-1i32)
    }

    pub fn clear_unit_entindex(&mut self) {
        self.unit_entindex = ::std::option::Option::None;
    }

    pub fn has_unit_entindex(&self) -> bool {
        self.unit_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_entindex(&mut self, v: i32) {
        self.unit_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 stack_count = 4;

    pub fn stack_count(&self) -> i32 {
        self.stack_count.unwrap_or(0)
    }

    pub fn clear_stack_count(&mut self) {
        self.stack_count = ::std::option::Option::None;
    }

    pub fn has_stack_count(&self) -> bool {
        self.stack_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_count(&mut self, v: i32) {
        self.stack_count = ::std::option::Option::Some(v);
    }

    // optional int32 camp_type = 5;

    pub fn camp_type(&self) -> i32 {
        self.camp_type.unwrap_or(0)
    }

    pub fn clear_camp_type(&mut self) {
        self.camp_type = ::std::option::Option::None;
    }

    pub fn has_camp_type(&self) -> bool {
        self.camp_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camp_type(&mut self, v: i32) {
        self.camp_type = ::std::option::Option::Some(v);
    }

    // optional bool stack_request = 6;

    pub fn stack_request(&self) -> bool {
        self.stack_request.unwrap_or(false)
    }

    pub fn clear_stack_request(&mut self) {
        self.stack_request = ::std::option::Option::None;
    }

    pub fn has_stack_request(&self) -> bool {
        self.stack_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_request(&mut self, v: bool) {
        self.stack_request = ::std::option::Option::Some(v);
    }

    // optional bool stack_intention = 7;

    pub fn stack_intention(&self) -> bool {
        self.stack_intention.unwrap_or(false)
    }

    pub fn clear_stack_intention(&mut self) {
        self.stack_intention = ::std::option::Option::None;
    }

    pub fn has_stack_intention(&self) -> bool {
        self.stack_intention.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_intention(&mut self, v: bool) {
        self.stack_intention = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_NeutralCampAlert {
    const NAME: &'static str = "CDOTAUserMsg_NeutralCampAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.spawner_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.unit_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.stack_count = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.camp_type = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.stack_request = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.stack_intention = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.spawner_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.unit_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.stack_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.camp_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.stack_request {
            my_size += 1 + 1;
        }
        if let Some(v) = self.stack_intention {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.spawner_entindex {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.unit_entindex {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.stack_count {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.camp_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.stack_request {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.stack_intention {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_NeutralCampAlert {
        CDOTAUserMsg_NeutralCampAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.spawner_entindex = ::std::option::Option::None;
        self.unit_entindex = ::std::option::Option::None;
        self.stack_count = ::std::option::Option::None;
        self.camp_type = ::std::option::Option::None;
        self.stack_request = ::std::option::Option::None;
        self.stack_intention = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_NeutralCampAlert {
        static instance: CDOTAUserMsg_NeutralCampAlert = CDOTAUserMsg_NeutralCampAlert {
            player_id: ::std::option::Option::None,
            spawner_entindex: ::std::option::Option::None,
            unit_entindex: ::std::option::Option::None,
            stack_count: ::std::option::Option::None,
            camp_type: ::std::option::Option::None,
            stack_request: ::std::option::Option::None,
            stack_intention: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_GlyphAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_GlyphAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_GlyphAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_GlyphAlert.negative)
    pub negative: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_GlyphAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_GlyphAlert {
    fn default() -> &'a CDOTAUserMsg_GlyphAlert {
        <CDOTAUserMsg_GlyphAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_GlyphAlert {
    pub fn new() -> CDOTAUserMsg_GlyphAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional bool negative = 2;

    pub fn negative(&self) -> bool {
        self.negative.unwrap_or(false)
    }

    pub fn clear_negative(&mut self) {
        self.negative = ::std::option::Option::None;
    }

    pub fn has_negative(&self) -> bool {
        self.negative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negative(&mut self, v: bool) {
        self.negative = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_GlyphAlert {
    const NAME: &'static str = "CDOTAUserMsg_GlyphAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.negative = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.negative {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.negative {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_GlyphAlert {
        CDOTAUserMsg_GlyphAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.negative = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_GlyphAlert {
        static instance: CDOTAUserMsg_GlyphAlert = CDOTAUserMsg_GlyphAlert {
            player_id: ::std::option::Option::None,
            negative: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_RadarAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_RadarAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_RadarAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_RadarAlert.negative)
    pub negative: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_RadarAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_RadarAlert {
    fn default() -> &'a CDOTAUserMsg_RadarAlert {
        <CDOTAUserMsg_RadarAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_RadarAlert {
    pub fn new() -> CDOTAUserMsg_RadarAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional bool negative = 2;

    pub fn negative(&self) -> bool {
        self.negative.unwrap_or(false)
    }

    pub fn clear_negative(&mut self) {
        self.negative = ::std::option::Option::None;
    }

    pub fn has_negative(&self) -> bool {
        self.negative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negative(&mut self, v: bool) {
        self.negative = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_RadarAlert {
    const NAME: &'static str = "CDOTAUserMsg_RadarAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.negative = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.negative {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.negative {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_RadarAlert {
        CDOTAUserMsg_RadarAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.negative = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_RadarAlert {
        static instance: CDOTAUserMsg_RadarAlert = CDOTAUserMsg_RadarAlert {
            player_id: ::std::option::Option::None,
            negative: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_WillPurchaseAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_WillPurchaseAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_WillPurchaseAlert.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_WillPurchaseAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_WillPurchaseAlert.gold_remaining)
    pub gold_remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_WillPurchaseAlert.suggestion_player_id)
    pub suggestion_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_WillPurchaseAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_WillPurchaseAlert {
    fn default() -> &'a CDOTAUserMsg_WillPurchaseAlert {
        <CDOTAUserMsg_WillPurchaseAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_WillPurchaseAlert {
    pub fn new() -> CDOTAUserMsg_WillPurchaseAlert {
        ::std::default::Default::default()
    }

    // optional int32 item_ability_id = 1;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(-1i32)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    // optional int32 player_id = 2;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 gold_remaining = 3;

    pub fn gold_remaining(&self) -> u32 {
        self.gold_remaining.unwrap_or(0)
    }

    pub fn clear_gold_remaining(&mut self) {
        self.gold_remaining = ::std::option::Option::None;
    }

    pub fn has_gold_remaining(&self) -> bool {
        self.gold_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_remaining(&mut self, v: u32) {
        self.gold_remaining = ::std::option::Option::Some(v);
    }

    // optional int32 suggestion_player_id = 4;

    pub fn suggestion_player_id(&self) -> i32 {
        self.suggestion_player_id.unwrap_or(-1i32)
    }

    pub fn clear_suggestion_player_id(&mut self) {
        self.suggestion_player_id = ::std::option::Option::None;
    }

    pub fn has_suggestion_player_id(&self) -> bool {
        self.suggestion_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suggestion_player_id(&mut self, v: i32) {
        self.suggestion_player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_WillPurchaseAlert {
    const NAME: &'static str = "CDOTAUserMsg_WillPurchaseAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.gold_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.suggestion_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.gold_remaining {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.suggestion_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_ability_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.gold_remaining {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.suggestion_player_id {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_WillPurchaseAlert {
        CDOTAUserMsg_WillPurchaseAlert::new()
    }

    fn clear(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
        self.player_id = ::std::option::Option::None;
        self.gold_remaining = ::std::option::Option::None;
        self.suggestion_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_WillPurchaseAlert {
        static instance: CDOTAUserMsg_WillPurchaseAlert = CDOTAUserMsg_WillPurchaseAlert {
            item_ability_id: ::std::option::Option::None,
            player_id: ::std::option::Option::None,
            gold_remaining: ::std::option::Option::None,
            suggestion_player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_EmptyTeleportAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_EmptyTeleportAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_EmptyTeleportAlert.source_player_id)
    pub source_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_EmptyTeleportAlert.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_EmptyTeleportAlert.cooldown_seconds)
    pub cooldown_seconds: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_EmptyTeleportAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_EmptyTeleportAlert {
    fn default() -> &'a CDOTAUserMsg_EmptyTeleportAlert {
        <CDOTAUserMsg_EmptyTeleportAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_EmptyTeleportAlert {
    pub fn new() -> CDOTAUserMsg_EmptyTeleportAlert {
        ::std::default::Default::default()
    }

    // optional int32 source_player_id = 1;

    pub fn source_player_id(&self) -> i32 {
        self.source_player_id.unwrap_or(-1i32)
    }

    pub fn clear_source_player_id(&mut self) {
        self.source_player_id = ::std::option::Option::None;
    }

    pub fn has_source_player_id(&self) -> bool {
        self.source_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_player_id(&mut self, v: i32) {
        self.source_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_player_id = 2;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(-1i32)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 cooldown_seconds = 3;

    pub fn cooldown_seconds(&self) -> i32 {
        self.cooldown_seconds.unwrap_or(0)
    }

    pub fn clear_cooldown_seconds(&mut self) {
        self.cooldown_seconds = ::std::option::Option::None;
    }

    pub fn has_cooldown_seconds(&self) -> bool {
        self.cooldown_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown_seconds(&mut self, v: i32) {
        self.cooldown_seconds = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_EmptyTeleportAlert {
    const NAME: &'static str = "CDOTAUserMsg_EmptyTeleportAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.cooldown_seconds = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.cooldown_seconds {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.source_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.cooldown_seconds {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_EmptyTeleportAlert {
        CDOTAUserMsg_EmptyTeleportAlert::new()
    }

    fn clear(&mut self) {
        self.source_player_id = ::std::option::Option::None;
        self.target_player_id = ::std::option::Option::None;
        self.cooldown_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_EmptyTeleportAlert {
        static instance: CDOTAUserMsg_EmptyTeleportAlert = CDOTAUserMsg_EmptyTeleportAlert {
            source_player_id: ::std::option::Option::None,
            target_player_id: ::std::option::Option::None,
            cooldown_seconds: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_MarsArenaOfBloodAttack)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_MarsArenaOfBloodAttack {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_MarsArenaOfBloodAttack.source_ehandle)
    pub source_ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_MarsArenaOfBloodAttack.target_ehandle)
    pub target_ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_MarsArenaOfBloodAttack.warrior_index)
    pub warrior_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_MarsArenaOfBloodAttack.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_MarsArenaOfBloodAttack {
    fn default() -> &'a CDOTAUserMsg_MarsArenaOfBloodAttack {
        <CDOTAUserMsg_MarsArenaOfBloodAttack as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_MarsArenaOfBloodAttack {
    pub fn new() -> CDOTAUserMsg_MarsArenaOfBloodAttack {
        ::std::default::Default::default()
    }

    // optional uint32 source_ehandle = 1;

    pub fn source_ehandle(&self) -> u32 {
        self.source_ehandle.unwrap_or(16777215u32)
    }

    pub fn clear_source_ehandle(&mut self) {
        self.source_ehandle = ::std::option::Option::None;
    }

    pub fn has_source_ehandle(&self) -> bool {
        self.source_ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_ehandle(&mut self, v: u32) {
        self.source_ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 target_ehandle = 2;

    pub fn target_ehandle(&self) -> u32 {
        self.target_ehandle.unwrap_or(16777215u32)
    }

    pub fn clear_target_ehandle(&mut self) {
        self.target_ehandle = ::std::option::Option::None;
    }

    pub fn has_target_ehandle(&self) -> bool {
        self.target_ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_ehandle(&mut self, v: u32) {
        self.target_ehandle = ::std::option::Option::Some(v);
    }

    // optional int32 warrior_index = 3;

    pub fn warrior_index(&self) -> i32 {
        self.warrior_index.unwrap_or(0)
    }

    pub fn clear_warrior_index(&mut self) {
        self.warrior_index = ::std::option::Option::None;
    }

    pub fn has_warrior_index(&self) -> bool {
        self.warrior_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_warrior_index(&mut self, v: i32) {
        self.warrior_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_MarsArenaOfBloodAttack {
    const NAME: &'static str = "CDOTAUserMsg_MarsArenaOfBloodAttack";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target_ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.warrior_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_ehandle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_ehandle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.warrior_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.source_ehandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_ehandle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.warrior_index {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_MarsArenaOfBloodAttack {
        CDOTAUserMsg_MarsArenaOfBloodAttack::new()
    }

    fn clear(&mut self) {
        self.source_ehandle = ::std::option::Option::None;
        self.target_ehandle = ::std::option::Option::None;
        self.warrior_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_MarsArenaOfBloodAttack {
        static instance: CDOTAUserMsg_MarsArenaOfBloodAttack = CDOTAUserMsg_MarsArenaOfBloodAttack {
            source_ehandle: ::std::option::Option::None,
            target_ehandle: ::std::option::Option::None,
            warrior_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAEntityMsg_InvokerSpellCast)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAEntityMsg_InvokerSpellCast {
    // message fields
    // @@protoc_insertion_point(field:CDOTAEntityMsg_InvokerSpellCast.entity_msg)
    pub entity_msg: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CEntityMsg>,
    // @@protoc_insertion_point(field:CDOTAEntityMsg_InvokerSpellCast.cast_activity)
    pub cast_activity: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAEntityMsg_InvokerSpellCast.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAEntityMsg_InvokerSpellCast {
    fn default() -> &'a CDOTAEntityMsg_InvokerSpellCast {
        <CDOTAEntityMsg_InvokerSpellCast as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAEntityMsg_InvokerSpellCast {
    pub fn new() -> CDOTAEntityMsg_InvokerSpellCast {
        ::std::default::Default::default()
    }

    // optional int32 cast_activity = 2;

    pub fn cast_activity(&self) -> i32 {
        self.cast_activity.unwrap_or(0)
    }

    pub fn clear_cast_activity(&mut self) {
        self.cast_activity = ::std::option::Option::None;
    }

    pub fn has_cast_activity(&self) -> bool {
        self.cast_activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cast_activity(&mut self, v: i32) {
        self.cast_activity = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAEntityMsg_InvokerSpellCast {
    const NAME: &'static str = "CDOTAEntityMsg_InvokerSpellCast";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.entity_msg)?;
                },
                16 => {
                    self.cast_activity = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entity_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cast_activity {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.entity_msg.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.cast_activity {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAEntityMsg_InvokerSpellCast {
        CDOTAEntityMsg_InvokerSpellCast::new()
    }

    fn clear(&mut self) {
        self.entity_msg.clear();
        self.cast_activity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAEntityMsg_InvokerSpellCast {
        static instance: CDOTAEntityMsg_InvokerSpellCast = CDOTAEntityMsg_InvokerSpellCast {
            entity_msg: ::steam_vent_proto_common::protobuf::MessageField::none(),
            cast_activity: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_BuyBackStateAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_BuyBackStateAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_BuyBackStateAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_BuyBackStateAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_BuyBackStateAlert {
    fn default() -> &'a CDOTAUserMsg_BuyBackStateAlert {
        <CDOTAUserMsg_BuyBackStateAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_BuyBackStateAlert {
    pub fn new() -> CDOTAUserMsg_BuyBackStateAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_BuyBackStateAlert {
    const NAME: &'static str = "CDOTAUserMsg_BuyBackStateAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_BuyBackStateAlert {
        CDOTAUserMsg_BuyBackStateAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_BuyBackStateAlert {
        static instance: CDOTAUserMsg_BuyBackStateAlert = CDOTAUserMsg_BuyBackStateAlert {
            player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_QuickBuyAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_QuickBuyAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_QuickBuyAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_QuickBuyAlert.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_QuickBuyAlert.gold_cost)
    pub gold_cost: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_QuickBuyAlert.item_cooldown_seconds)
    pub item_cooldown_seconds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_QuickBuyAlert.show_buyback)
    pub show_buyback: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_QuickBuyAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_QuickBuyAlert {
    fn default() -> &'a CDOTAUserMsg_QuickBuyAlert {
        <CDOTAUserMsg_QuickBuyAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_QuickBuyAlert {
    pub fn new() -> CDOTAUserMsg_QuickBuyAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 item_ability_id = 2;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(-1i32)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    // optional int32 gold_cost = 3;

    pub fn gold_cost(&self) -> i32 {
        self.gold_cost.unwrap_or(0)
    }

    pub fn clear_gold_cost(&mut self) {
        self.gold_cost = ::std::option::Option::None;
    }

    pub fn has_gold_cost(&self) -> bool {
        self.gold_cost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_cost(&mut self, v: i32) {
        self.gold_cost = ::std::option::Option::Some(v);
    }

    // optional int32 item_cooldown_seconds = 4;

    pub fn item_cooldown_seconds(&self) -> i32 {
        self.item_cooldown_seconds.unwrap_or(0)
    }

    pub fn clear_item_cooldown_seconds(&mut self) {
        self.item_cooldown_seconds = ::std::option::Option::None;
    }

    pub fn has_item_cooldown_seconds(&self) -> bool {
        self.item_cooldown_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_cooldown_seconds(&mut self, v: i32) {
        self.item_cooldown_seconds = ::std::option::Option::Some(v);
    }

    // optional bool show_buyback = 5;

    pub fn show_buyback(&self) -> bool {
        self.show_buyback.unwrap_or(false)
    }

    pub fn clear_show_buyback(&mut self) {
        self.show_buyback = ::std::option::Option::None;
    }

    pub fn has_show_buyback(&self) -> bool {
        self.show_buyback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_buyback(&mut self, v: bool) {
        self.show_buyback = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_QuickBuyAlert {
    const NAME: &'static str = "CDOTAUserMsg_QuickBuyAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.gold_cost = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.item_cooldown_seconds = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.show_buyback = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.item_ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.gold_cost {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.item_cooldown_seconds {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.show_buyback {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.item_ability_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.gold_cost {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.item_cooldown_seconds {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.show_buyback {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_QuickBuyAlert {
        CDOTAUserMsg_QuickBuyAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.item_ability_id = ::std::option::Option::None;
        self.gold_cost = ::std::option::Option::None;
        self.item_cooldown_seconds = ::std::option::Option::None;
        self.show_buyback = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_QuickBuyAlert {
        static instance: CDOTAUserMsg_QuickBuyAlert = CDOTAUserMsg_QuickBuyAlert {
            player_id: ::std::option::Option::None,
            item_ability_id: ::std::option::Option::None,
            gold_cost: ::std::option::Option::None,
            item_cooldown_seconds: ::std::option::Option::None,
            show_buyback: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_CourierKilledAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CourierKilledAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_CourierKilledAlert.team)
    pub team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CourierKilledAlert.gold_value)
    pub gold_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CourierKilledAlert.entity_handle)
    pub entity_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CourierKilledAlert.timestamp)
    pub timestamp: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CourierKilledAlert.lost_items)
    pub lost_items: ::std::vec::Vec<cdotauser_msg_courier_killed_alert::LostItem>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CourierKilledAlert.killer_player_id)
    pub killer_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CourierKilledAlert.owning_player_id)
    pub owning_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_CourierKilledAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CourierKilledAlert {
    fn default() -> &'a CDOTAUserMsg_CourierKilledAlert {
        <CDOTAUserMsg_CourierKilledAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CourierKilledAlert {
    pub fn new() -> CDOTAUserMsg_CourierKilledAlert {
        ::std::default::Default::default()
    }

    // optional uint32 team = 1;

    pub fn team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional uint32 gold_value = 2;

    pub fn gold_value(&self) -> u32 {
        self.gold_value.unwrap_or(0)
    }

    pub fn clear_gold_value(&mut self) {
        self.gold_value = ::std::option::Option::None;
    }

    pub fn has_gold_value(&self) -> bool {
        self.gold_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_value(&mut self, v: u32) {
        self.gold_value = ::std::option::Option::Some(v);
    }

    // optional uint32 entity_handle = 3;

    pub fn entity_handle(&self) -> u32 {
        self.entity_handle.unwrap_or(16777215u32)
    }

    pub fn clear_entity_handle(&mut self) {
        self.entity_handle = ::std::option::Option::None;
    }

    pub fn has_entity_handle(&self) -> bool {
        self.entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_handle(&mut self, v: u32) {
        self.entity_handle = ::std::option::Option::Some(v);
    }

    // optional int32 timestamp = 4;

    pub fn timestamp(&self) -> i32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional int32 killer_player_id = 6;

    pub fn killer_player_id(&self) -> i32 {
        self.killer_player_id.unwrap_or(-1i32)
    }

    pub fn clear_killer_player_id(&mut self) {
        self.killer_player_id = ::std::option::Option::None;
    }

    pub fn has_killer_player_id(&self) -> bool {
        self.killer_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_player_id(&mut self, v: i32) {
        self.killer_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 owning_player_id = 7;

    pub fn owning_player_id(&self) -> i32 {
        self.owning_player_id.unwrap_or(-1i32)
    }

    pub fn clear_owning_player_id(&mut self) {
        self.owning_player_id = ::std::option::Option::None;
    }

    pub fn has_owning_player_id(&self) -> bool {
        self.owning_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owning_player_id(&mut self, v: i32) {
        self.owning_player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_CourierKilledAlert {
    const NAME: &'static str = "CDOTAUserMsg_CourierKilledAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gold_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.lost_items.push(is.read_message()?);
                },
                48 => {
                    self.killer_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.owning_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.gold_value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.entity_handle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        for value in &self.lost_items {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.killer_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.owning_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.team {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gold_value {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.entity_handle {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_int32(4, v)?;
        }
        for v in &self.lost_items {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.killer_player_id {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.owning_player_id {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CourierKilledAlert {
        CDOTAUserMsg_CourierKilledAlert::new()
    }

    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.gold_value = ::std::option::Option::None;
        self.entity_handle = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.lost_items.clear();
        self.killer_player_id = ::std::option::Option::None;
        self.owning_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CourierKilledAlert {
        static instance: CDOTAUserMsg_CourierKilledAlert = CDOTAUserMsg_CourierKilledAlert {
            team: ::std::option::Option::None,
            gold_value: ::std::option::Option::None,
            entity_handle: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            lost_items: ::std::vec::Vec::new(),
            killer_player_id: ::std::option::Option::None,
            owning_player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CDOTAUserMsg_CourierKilledAlert`
pub mod cdotauser_msg_courier_killed_alert {
    // @@protoc_insertion_point(message:CDOTAUserMsg_CourierKilledAlert.LostItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LostItem {
        // message fields
        // @@protoc_insertion_point(field:CDOTAUserMsg_CourierKilledAlert.LostItem.item_ability_id)
        pub item_ability_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_CourierKilledAlert.LostItem.quantity)
        pub quantity: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAUserMsg_CourierKilledAlert.LostItem.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LostItem {
        fn default() -> &'a LostItem {
            <LostItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl LostItem {
        pub fn new() -> LostItem {
            ::std::default::Default::default()
        }

        // optional int32 item_ability_id = 1;

        pub fn item_ability_id(&self) -> i32 {
            self.item_ability_id.unwrap_or(-1i32)
        }

        pub fn clear_item_ability_id(&mut self) {
            self.item_ability_id = ::std::option::Option::None;
        }

        pub fn has_item_ability_id(&self) -> bool {
            self.item_ability_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_ability_id(&mut self, v: i32) {
            self.item_ability_id = ::std::option::Option::Some(v);
        }

        // optional uint32 quantity = 2;

        pub fn quantity(&self) -> u32 {
            self.quantity.unwrap_or(0)
        }

        pub fn clear_quantity(&mut self) {
            self.quantity = ::std::option::Option::None;
        }

        pub fn has_quantity(&self) -> bool {
            self.quantity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quantity(&mut self, v: u32) {
            self.quantity = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for LostItem {
        const NAME: &'static str = "LostItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_ability_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.quantity {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item_ability_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.quantity {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LostItem {
            LostItem::new()
        }

        fn clear(&mut self) {
            self.item_ability_id = ::std::option::Option::None;
            self.quantity = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LostItem {
            static instance: LostItem = LostItem {
                item_ability_id: ::std::option::Option::None,
                quantity: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_MinimapEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_MinimapEvent {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_MinimapEvent.event_type)
    pub event_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_MinimapEvent.entity_handle)
    pub entity_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_MinimapEvent.x)
    pub x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_MinimapEvent.y)
    pub y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_MinimapEvent.duration)
    pub duration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_MinimapEvent.target_entity_handle)
    pub target_entity_handle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_MinimapEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_MinimapEvent {
    fn default() -> &'a CDOTAUserMsg_MinimapEvent {
        <CDOTAUserMsg_MinimapEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_MinimapEvent {
    pub fn new() -> CDOTAUserMsg_MinimapEvent {
        ::std::default::Default::default()
    }

    // optional int32 event_type = 1;

    pub fn event_type(&self) -> i32 {
        self.event_type.unwrap_or(0)
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: i32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    // optional uint32 entity_handle = 2;

    pub fn entity_handle(&self) -> u32 {
        self.entity_handle.unwrap_or(16777215u32)
    }

    pub fn clear_entity_handle(&mut self) {
        self.entity_handle = ::std::option::Option::None;
    }

    pub fn has_entity_handle(&self) -> bool {
        self.entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_handle(&mut self, v: u32) {
        self.entity_handle = ::std::option::Option::Some(v);
    }

    // optional int32 x = 3;

    pub fn x(&self) -> i32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 4;

    pub fn y(&self) -> i32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional int32 duration = 5;

    pub fn duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional uint32 target_entity_handle = 6;

    pub fn target_entity_handle(&self) -> u32 {
        self.target_entity_handle.unwrap_or(16777215u32)
    }

    pub fn clear_target_entity_handle(&mut self) {
        self.target_entity_handle = ::std::option::Option::None;
    }

    pub fn has_target_entity_handle(&self) -> bool {
        self.target_entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entity_handle(&mut self, v: u32) {
        self.target_entity_handle = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_MinimapEvent {
    const NAME: &'static str = "CDOTAUserMsg_MinimapEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_type = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.x = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.y = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.duration = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.target_entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.entity_handle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.x {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.y {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.target_entity_handle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.entity_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.duration {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.target_entity_handle {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_MinimapEvent {
        CDOTAUserMsg_MinimapEvent::new()
    }

    fn clear(&mut self) {
        self.event_type = ::std::option::Option::None;
        self.entity_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.target_entity_handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_MinimapEvent {
        static instance: CDOTAUserMsg_MinimapEvent = CDOTAUserMsg_MinimapEvent {
            event_type: ::std::option::Option::None,
            entity_handle: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            target_entity_handle: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_MapLine)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_MapLine {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_MapLine.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_MapLine.mapline)
    pub mapline: ::steam_vent_proto_common::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_MapLine>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_MapLine.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_MapLine {
    fn default() -> &'a CDOTAUserMsg_MapLine {
        <CDOTAUserMsg_MapLine as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_MapLine {
    pub fn new() -> CDOTAUserMsg_MapLine {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_MapLine {
    const NAME: &'static str = "CDOTAUserMsg_MapLine";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.mapline)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.mapline.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.mapline.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_MapLine {
        CDOTAUserMsg_MapLine::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.mapline.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_MapLine {
        static instance: CDOTAUserMsg_MapLine = CDOTAUserMsg_MapLine {
            player_id: ::std::option::Option::None,
            mapline: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_MinimapDebugPoint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_MinimapDebugPoint {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_MinimapDebugPoint.location)
    pub location: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_MinimapDebugPoint.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_MinimapDebugPoint.size)
    pub size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_MinimapDebugPoint.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_MinimapDebugPoint.index)
    pub index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_MinimapDebugPoint.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_MinimapDebugPoint {
    fn default() -> &'a CDOTAUserMsg_MinimapDebugPoint {
        <CDOTAUserMsg_MinimapDebugPoint as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_MinimapDebugPoint {
    pub fn new() -> CDOTAUserMsg_MinimapDebugPoint {
        ::std::default::Default::default()
    }

    // optional uint32 color = 2;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional int32 size = 3;

    pub fn size(&self) -> i32 {
        self.size.unwrap_or(0)
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i32) {
        self.size = ::std::option::Option::Some(v);
    }

    // optional float duration = 4;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional int32 index = 5;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_MinimapDebugPoint {
    const NAME: &'static str = "CDOTAUserMsg_MinimapDebugPoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.location)?;
                },
                16 => {
                    self.color = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.size = ::std::option::Option::Some(is.read_int32()?);
                },
                37 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                40 => {
                    self.index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.color {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.size {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.location.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.color {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.size {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.index {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_MinimapDebugPoint {
        CDOTAUserMsg_MinimapDebugPoint::new()
    }

    fn clear(&mut self) {
        self.location.clear();
        self.color = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_MinimapDebugPoint {
        static instance: CDOTAUserMsg_MinimapDebugPoint = CDOTAUserMsg_MinimapDebugPoint {
            location: ::steam_vent_proto_common::protobuf::MessageField::none(),
            color: ::std::option::Option::None,
            size: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_CreateLinearProjectile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CreateLinearProjectile {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_CreateLinearProjectile.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CreateLinearProjectile.velocity)
    pub velocity: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector2D>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CreateLinearProjectile.entindex)
    pub entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CreateLinearProjectile.particle_index)
    pub particle_index: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CreateLinearProjectile.handle)
    pub handle: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CreateLinearProjectile.acceleration)
    pub acceleration: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector2D>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CreateLinearProjectile.max_speed)
    pub max_speed: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CreateLinearProjectile.fow_radius)
    pub fow_radius: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CreateLinearProjectile.sticky_fow_reveal)
    pub sticky_fow_reveal: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CreateLinearProjectile.distance)
    pub distance: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CreateLinearProjectile.colorgemcolor)
    pub colorgemcolor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CreateLinearProjectile.particle_cp_data)
    pub particle_cp_data: ::std::vec::Vec<CDOTAUserMsg_ProjectileParticleCPData>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_CreateLinearProjectile.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CreateLinearProjectile {
    fn default() -> &'a CDOTAUserMsg_CreateLinearProjectile {
        <CDOTAUserMsg_CreateLinearProjectile as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CreateLinearProjectile {
    pub fn new() -> CDOTAUserMsg_CreateLinearProjectile {
        ::std::default::Default::default()
    }

    // optional int32 entindex = 4;

    pub fn entindex(&self) -> i32 {
        self.entindex.unwrap_or(-1i32)
    }

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    // optional uint64 particle_index = 5;

    pub fn particle_index(&self) -> u64 {
        self.particle_index.unwrap_or(0)
    }

    pub fn clear_particle_index(&mut self) {
        self.particle_index = ::std::option::Option::None;
    }

    pub fn has_particle_index(&self) -> bool {
        self.particle_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_index(&mut self, v: u64) {
        self.particle_index = ::std::option::Option::Some(v);
    }

    // optional int32 handle = 6;

    pub fn handle(&self) -> i32 {
        self.handle.unwrap_or(0)
    }

    pub fn clear_handle(&mut self) {
        self.handle = ::std::option::Option::None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: i32) {
        self.handle = ::std::option::Option::Some(v);
    }

    // optional float max_speed = 8;

    pub fn max_speed(&self) -> f32 {
        self.max_speed.unwrap_or(0.)
    }

    pub fn clear_max_speed(&mut self) {
        self.max_speed = ::std::option::Option::None;
    }

    pub fn has_max_speed(&self) -> bool {
        self.max_speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_speed(&mut self, v: f32) {
        self.max_speed = ::std::option::Option::Some(v);
    }

    // optional float fow_radius = 9;

    pub fn fow_radius(&self) -> f32 {
        self.fow_radius.unwrap_or(0.)
    }

    pub fn clear_fow_radius(&mut self) {
        self.fow_radius = ::std::option::Option::None;
    }

    pub fn has_fow_radius(&self) -> bool {
        self.fow_radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fow_radius(&mut self, v: f32) {
        self.fow_radius = ::std::option::Option::Some(v);
    }

    // optional bool sticky_fow_reveal = 10;

    pub fn sticky_fow_reveal(&self) -> bool {
        self.sticky_fow_reveal.unwrap_or(false)
    }

    pub fn clear_sticky_fow_reveal(&mut self) {
        self.sticky_fow_reveal = ::std::option::Option::None;
    }

    pub fn has_sticky_fow_reveal(&self) -> bool {
        self.sticky_fow_reveal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sticky_fow_reveal(&mut self, v: bool) {
        self.sticky_fow_reveal = ::std::option::Option::Some(v);
    }

    // optional float distance = 11;

    pub fn distance(&self) -> f32 {
        self.distance.unwrap_or(0.)
    }

    pub fn clear_distance(&mut self) {
        self.distance = ::std::option::Option::None;
    }

    pub fn has_distance(&self) -> bool {
        self.distance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: f32) {
        self.distance = ::std::option::Option::Some(v);
    }

    // optional fixed32 colorgemcolor = 12;

    pub fn colorgemcolor(&self) -> u32 {
        self.colorgemcolor.unwrap_or(0)
    }

    pub fn clear_colorgemcolor(&mut self) {
        self.colorgemcolor = ::std::option::Option::None;
    }

    pub fn has_colorgemcolor(&self) -> bool {
        self.colorgemcolor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_colorgemcolor(&mut self, v: u32) {
        self.colorgemcolor = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_CreateLinearProjectile {
    const NAME: &'static str = "CDOTAUserMsg_CreateLinearProjectile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.velocity)?;
                },
                32 => {
                    self.entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.particle_index = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.handle = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.acceleration)?;
                },
                69 => {
                    self.max_speed = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.fow_radius = ::std::option::Option::Some(is.read_float()?);
                },
                80 => {
                    self.sticky_fow_reveal = ::std::option::Option::Some(is.read_bool()?);
                },
                93 => {
                    self.distance = ::std::option::Option::Some(is.read_float()?);
                },
                101 => {
                    self.colorgemcolor = ::std::option::Option::Some(is.read_fixed32()?);
                },
                106 => {
                    self.particle_cp_data.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.velocity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.particle_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.handle {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.acceleration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.max_speed {
            my_size += 1 + 4;
        }
        if let Some(v) = self.fow_radius {
            my_size += 1 + 4;
        }
        if let Some(v) = self.sticky_fow_reveal {
            my_size += 1 + 1;
        }
        if let Some(v) = self.distance {
            my_size += 1 + 4;
        }
        if let Some(v) = self.colorgemcolor {
            my_size += 1 + 4;
        }
        for value in &self.particle_cp_data {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.velocity.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.entindex {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.particle_index {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.handle {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.acceleration.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.max_speed {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.fow_radius {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.sticky_fow_reveal {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.distance {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.colorgemcolor {
            os.write_fixed32(12, v)?;
        }
        for v in &self.particle_cp_data {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CreateLinearProjectile {
        CDOTAUserMsg_CreateLinearProjectile::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.velocity.clear();
        self.entindex = ::std::option::Option::None;
        self.particle_index = ::std::option::Option::None;
        self.handle = ::std::option::Option::None;
        self.acceleration.clear();
        self.max_speed = ::std::option::Option::None;
        self.fow_radius = ::std::option::Option::None;
        self.sticky_fow_reveal = ::std::option::Option::None;
        self.distance = ::std::option::Option::None;
        self.colorgemcolor = ::std::option::Option::None;
        self.particle_cp_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CreateLinearProjectile {
        static instance: CDOTAUserMsg_CreateLinearProjectile = CDOTAUserMsg_CreateLinearProjectile {
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            velocity: ::steam_vent_proto_common::protobuf::MessageField::none(),
            entindex: ::std::option::Option::None,
            particle_index: ::std::option::Option::None,
            handle: ::std::option::Option::None,
            acceleration: ::steam_vent_proto_common::protobuf::MessageField::none(),
            max_speed: ::std::option::Option::None,
            fow_radius: ::std::option::Option::None,
            sticky_fow_reveal: ::std::option::Option::None,
            distance: ::std::option::Option::None,
            colorgemcolor: ::std::option::Option::None,
            particle_cp_data: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_DestroyLinearProjectile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_DestroyLinearProjectile {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_DestroyLinearProjectile.handle)
    pub handle: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_DestroyLinearProjectile.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_DestroyLinearProjectile {
    fn default() -> &'a CDOTAUserMsg_DestroyLinearProjectile {
        <CDOTAUserMsg_DestroyLinearProjectile as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_DestroyLinearProjectile {
    pub fn new() -> CDOTAUserMsg_DestroyLinearProjectile {
        ::std::default::Default::default()
    }

    // optional int32 handle = 1;

    pub fn handle(&self) -> i32 {
        self.handle.unwrap_or(0)
    }

    pub fn clear_handle(&mut self) {
        self.handle = ::std::option::Option::None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: i32) {
        self.handle = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_DestroyLinearProjectile {
    const NAME: &'static str = "CDOTAUserMsg_DestroyLinearProjectile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.handle = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.handle {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.handle {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_DestroyLinearProjectile {
        CDOTAUserMsg_DestroyLinearProjectile::new()
    }

    fn clear(&mut self) {
        self.handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_DestroyLinearProjectile {
        static instance: CDOTAUserMsg_DestroyLinearProjectile = CDOTAUserMsg_DestroyLinearProjectile {
            handle: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_DodgeTrackingProjectiles)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_DodgeTrackingProjectiles {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_DodgeTrackingProjectiles.entindex)
    pub entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_DodgeTrackingProjectiles.attacks_only)
    pub attacks_only: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_DodgeTrackingProjectiles.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_DodgeTrackingProjectiles {
    fn default() -> &'a CDOTAUserMsg_DodgeTrackingProjectiles {
        <CDOTAUserMsg_DodgeTrackingProjectiles as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_DodgeTrackingProjectiles {
    pub fn new() -> CDOTAUserMsg_DodgeTrackingProjectiles {
        ::std::default::Default::default()
    }

    // required int32 entindex = 1;

    pub fn entindex(&self) -> i32 {
        self.entindex.unwrap_or(-1i32)
    }

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    // optional bool attacks_only = 2;

    pub fn attacks_only(&self) -> bool {
        self.attacks_only.unwrap_or(false)
    }

    pub fn clear_attacks_only(&mut self) {
        self.attacks_only = ::std::option::Option::None;
    }

    pub fn has_attacks_only(&self) -> bool {
        self.attacks_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attacks_only(&mut self, v: bool) {
        self.attacks_only = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_DodgeTrackingProjectiles {
    const NAME: &'static str = "CDOTAUserMsg_DodgeTrackingProjectiles";

    fn is_initialized(&self) -> bool {
        if self.entindex.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.attacks_only = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.attacks_only {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.attacks_only {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_DodgeTrackingProjectiles {
        CDOTAUserMsg_DodgeTrackingProjectiles::new()
    }

    fn clear(&mut self) {
        self.entindex = ::std::option::Option::None;
        self.attacks_only = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_DodgeTrackingProjectiles {
        static instance: CDOTAUserMsg_DodgeTrackingProjectiles = CDOTAUserMsg_DodgeTrackingProjectiles {
            entindex: ::std::option::Option::None,
            attacks_only: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_SpectatorPlayerClick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SpectatorPlayerClick {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_SpectatorPlayerClick.entindex)
    pub entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SpectatorPlayerClick.order_type)
    pub order_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SpectatorPlayerClick.target_index)
    pub target_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_SpectatorPlayerClick.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SpectatorPlayerClick {
    fn default() -> &'a CDOTAUserMsg_SpectatorPlayerClick {
        <CDOTAUserMsg_SpectatorPlayerClick as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SpectatorPlayerClick {
    pub fn new() -> CDOTAUserMsg_SpectatorPlayerClick {
        ::std::default::Default::default()
    }

    // required int32 entindex = 1;

    pub fn entindex(&self) -> i32 {
        self.entindex.unwrap_or(-1i32)
    }

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    // optional int32 order_type = 2;

    pub fn order_type(&self) -> i32 {
        self.order_type.unwrap_or(0)
    }

    pub fn clear_order_type(&mut self) {
        self.order_type = ::std::option::Option::None;
    }

    pub fn has_order_type(&self) -> bool {
        self.order_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: i32) {
        self.order_type = ::std::option::Option::Some(v);
    }

    // optional int32 target_index = 3;

    pub fn target_index(&self) -> i32 {
        self.target_index.unwrap_or(0i32)
    }

    pub fn clear_target_index(&mut self) {
        self.target_index = ::std::option::Option::None;
    }

    pub fn has_target_index(&self) -> bool {
        self.target_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_index(&mut self, v: i32) {
        self.target_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_SpectatorPlayerClick {
    const NAME: &'static str = "CDOTAUserMsg_SpectatorPlayerClick";

    fn is_initialized(&self) -> bool {
        if self.entindex.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.order_type = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.target_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.order_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.target_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.order_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.target_index {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SpectatorPlayerClick {
        CDOTAUserMsg_SpectatorPlayerClick::new()
    }

    fn clear(&mut self) {
        self.entindex = ::std::option::Option::None;
        self.order_type = ::std::option::Option::None;
        self.target_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SpectatorPlayerClick {
        static instance: CDOTAUserMsg_SpectatorPlayerClick = CDOTAUserMsg_SpectatorPlayerClick {
            entindex: ::std::option::Option::None,
            order_type: ::std::option::Option::None,
            target_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_SpectatorPlayerUnitOrders)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SpectatorPlayerUnitOrders {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_SpectatorPlayerUnitOrders.entindex)
    pub entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SpectatorPlayerUnitOrders.order_type)
    pub order_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SpectatorPlayerUnitOrders.units)
    pub units: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SpectatorPlayerUnitOrders.target_index)
    pub target_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SpectatorPlayerUnitOrders.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SpectatorPlayerUnitOrders.position)
    pub position: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SpectatorPlayerUnitOrders.queue)
    pub queue: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SpectatorPlayerUnitOrders.sequence_number)
    pub sequence_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SpectatorPlayerUnitOrders.flags)
    pub flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_SpectatorPlayerUnitOrders.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SpectatorPlayerUnitOrders {
    fn default() -> &'a CDOTAUserMsg_SpectatorPlayerUnitOrders {
        <CDOTAUserMsg_SpectatorPlayerUnitOrders as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SpectatorPlayerUnitOrders {
    pub fn new() -> CDOTAUserMsg_SpectatorPlayerUnitOrders {
        ::std::default::Default::default()
    }

    // optional int32 entindex = 1;

    pub fn entindex(&self) -> i32 {
        self.entindex.unwrap_or(-1i32)
    }

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    // optional int32 order_type = 2;

    pub fn order_type(&self) -> i32 {
        self.order_type.unwrap_or(0)
    }

    pub fn clear_order_type(&mut self) {
        self.order_type = ::std::option::Option::None;
    }

    pub fn has_order_type(&self) -> bool {
        self.order_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: i32) {
        self.order_type = ::std::option::Option::Some(v);
    }

    // optional int32 target_index = 4;

    pub fn target_index(&self) -> i32 {
        self.target_index.unwrap_or(0i32)
    }

    pub fn clear_target_index(&mut self) {
        self.target_index = ::std::option::Option::None;
    }

    pub fn has_target_index(&self) -> bool {
        self.target_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_index(&mut self, v: i32) {
        self.target_index = ::std::option::Option::Some(v);
    }

    // optional int32 ability_id = 5;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(-1i32)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional bool queue = 7;

    pub fn queue(&self) -> bool {
        self.queue.unwrap_or(false)
    }

    pub fn clear_queue(&mut self) {
        self.queue = ::std::option::Option::None;
    }

    pub fn has_queue(&self) -> bool {
        self.queue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue(&mut self, v: bool) {
        self.queue = ::std::option::Option::Some(v);
    }

    // optional int32 sequence_number = 8;

    pub fn sequence_number(&self) -> i32 {
        self.sequence_number.unwrap_or(0)
    }

    pub fn clear_sequence_number(&mut self) {
        self.sequence_number = ::std::option::Option::None;
    }

    pub fn has_sequence_number(&self) -> bool {
        self.sequence_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_number(&mut self, v: i32) {
        self.sequence_number = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 9;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_SpectatorPlayerUnitOrders {
    const NAME: &'static str = "CDOTAUserMsg_SpectatorPlayerUnitOrders";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.order_type = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    is.read_repeated_packed_int32_into(&mut self.units)?;
                },
                24 => {
                    self.units.push(is.read_int32()?);
                },
                32 => {
                    self.target_index = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                56 => {
                    self.queue = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.sequence_number = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.order_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        for value in &self.units {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, *value);
        };
        if let Some(v) = self.target_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.queue {
            my_size += 1 + 1;
        }
        if let Some(v) = self.sequence_number {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.order_type {
            os.write_int32(2, v)?;
        }
        for v in &self.units {
            os.write_int32(3, *v)?;
        };
        if let Some(v) = self.target_index {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.ability_id {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.position.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.queue {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.sequence_number {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SpectatorPlayerUnitOrders {
        CDOTAUserMsg_SpectatorPlayerUnitOrders::new()
    }

    fn clear(&mut self) {
        self.entindex = ::std::option::Option::None;
        self.order_type = ::std::option::Option::None;
        self.units.clear();
        self.target_index = ::std::option::Option::None;
        self.ability_id = ::std::option::Option::None;
        self.position.clear();
        self.queue = ::std::option::Option::None;
        self.sequence_number = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SpectatorPlayerUnitOrders {
        static instance: CDOTAUserMsg_SpectatorPlayerUnitOrders = CDOTAUserMsg_SpectatorPlayerUnitOrders {
            entindex: ::std::option::Option::None,
            order_type: ::std::option::Option::None,
            units: ::std::vec::Vec::new(),
            target_index: ::std::option::Option::None,
            ability_id: ::std::option::Option::None,
            position: ::steam_vent_proto_common::protobuf::MessageField::none(),
            queue: ::std::option::Option::None,
            sequence_number: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_NevermoreRequiem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_NevermoreRequiem {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_NevermoreRequiem.entity_handle)
    pub entity_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_NevermoreRequiem.lines)
    pub lines: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_NevermoreRequiem.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_NevermoreRequiem.reverse)
    pub reverse: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_NevermoreRequiem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_NevermoreRequiem {
    fn default() -> &'a CDOTAUserMsg_NevermoreRequiem {
        <CDOTAUserMsg_NevermoreRequiem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_NevermoreRequiem {
    pub fn new() -> CDOTAUserMsg_NevermoreRequiem {
        ::std::default::Default::default()
    }

    // optional uint32 entity_handle = 1;

    pub fn entity_handle(&self) -> u32 {
        self.entity_handle.unwrap_or(16777215u32)
    }

    pub fn clear_entity_handle(&mut self) {
        self.entity_handle = ::std::option::Option::None;
    }

    pub fn has_entity_handle(&self) -> bool {
        self.entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_handle(&mut self, v: u32) {
        self.entity_handle = ::std::option::Option::Some(v);
    }

    // optional int32 lines = 2;

    pub fn lines(&self) -> i32 {
        self.lines.unwrap_or(0)
    }

    pub fn clear_lines(&mut self) {
        self.lines = ::std::option::Option::None;
    }

    pub fn has_lines(&self) -> bool {
        self.lines.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lines(&mut self, v: i32) {
        self.lines = ::std::option::Option::Some(v);
    }

    // optional bool reverse = 4;

    pub fn reverse(&self) -> bool {
        self.reverse.unwrap_or(false)
    }

    pub fn clear_reverse(&mut self) {
        self.reverse = ::std::option::Option::None;
    }

    pub fn has_reverse(&self) -> bool {
        self.reverse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_NevermoreRequiem {
    const NAME: &'static str = "CDOTAUserMsg_NevermoreRequiem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.lines = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                32 => {
                    self.reverse = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entity_handle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.lines {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reverse {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.entity_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.lines {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.reverse {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_NevermoreRequiem {
        CDOTAUserMsg_NevermoreRequiem::new()
    }

    fn clear(&mut self) {
        self.entity_handle = ::std::option::Option::None;
        self.lines = ::std::option::Option::None;
        self.origin.clear();
        self.reverse = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_NevermoreRequiem {
        static instance: CDOTAUserMsg_NevermoreRequiem = CDOTAUserMsg_NevermoreRequiem {
            entity_handle: ::std::option::Option::None,
            lines: ::std::option::Option::None,
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            reverse: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_InvalidCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_InvalidCommand {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_InvalidCommand.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_InvalidCommand.sequence_number)
    pub sequence_number: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_InvalidCommand.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_InvalidCommand {
    fn default() -> &'a CDOTAUserMsg_InvalidCommand {
        <CDOTAUserMsg_InvalidCommand as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_InvalidCommand {
    pub fn new() -> CDOTAUserMsg_InvalidCommand {
        ::std::default::Default::default()
    }

    // optional string message = 1;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 sequence_number = 2;

    pub fn sequence_number(&self) -> i32 {
        self.sequence_number.unwrap_or(0)
    }

    pub fn clear_sequence_number(&mut self) {
        self.sequence_number = ::std::option::Option::None;
    }

    pub fn has_sequence_number(&self) -> bool {
        self.sequence_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_number(&mut self, v: i32) {
        self.sequence_number = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_InvalidCommand {
    const NAME: &'static str = "CDOTAUserMsg_InvalidCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.sequence_number = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.sequence_number {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.sequence_number {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_InvalidCommand {
        CDOTAUserMsg_InvalidCommand::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.sequence_number = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_InvalidCommand {
        static instance: CDOTAUserMsg_InvalidCommand = CDOTAUserMsg_InvalidCommand {
            message: ::std::option::Option::None,
            sequence_number: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_HudError)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_HudError {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_HudError.order_id)
    pub order_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_HudError.sequence_number)
    pub sequence_number: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_HudError.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_HudError {
    fn default() -> &'a CDOTAUserMsg_HudError {
        <CDOTAUserMsg_HudError as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_HudError {
    pub fn new() -> CDOTAUserMsg_HudError {
        ::std::default::Default::default()
    }

    // optional int32 order_id = 1;

    pub fn order_id(&self) -> i32 {
        self.order_id.unwrap_or(0)
    }

    pub fn clear_order_id(&mut self) {
        self.order_id = ::std::option::Option::None;
    }

    pub fn has_order_id(&self) -> bool {
        self.order_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_id(&mut self, v: i32) {
        self.order_id = ::std::option::Option::Some(v);
    }

    // optional int32 sequence_number = 2;

    pub fn sequence_number(&self) -> i32 {
        self.sequence_number.unwrap_or(0)
    }

    pub fn clear_sequence_number(&mut self) {
        self.sequence_number = ::std::option::Option::None;
    }

    pub fn has_sequence_number(&self) -> bool {
        self.sequence_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_number(&mut self, v: i32) {
        self.sequence_number = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_HudError {
    const NAME: &'static str = "CDOTAUserMsg_HudError";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.order_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.sequence_number = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.order_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.sequence_number {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.order_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.sequence_number {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_HudError {
        CDOTAUserMsg_HudError::new()
    }

    fn clear(&mut self) {
        self.order_id = ::std::option::Option::None;
        self.sequence_number = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_HudError {
        static instance: CDOTAUserMsg_HudError = CDOTAUserMsg_HudError {
            order_id: ::std::option::Option::None,
            sequence_number: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_SharedCooldown)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SharedCooldown {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_SharedCooldown.entindex)
    pub entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SharedCooldown.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SharedCooldown.cooldown)
    pub cooldown: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SharedCooldown.name_index)
    pub name_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_SharedCooldown.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SharedCooldown {
    fn default() -> &'a CDOTAUserMsg_SharedCooldown {
        <CDOTAUserMsg_SharedCooldown as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SharedCooldown {
    pub fn new() -> CDOTAUserMsg_SharedCooldown {
        ::std::default::Default::default()
    }

    // optional int32 entindex = 1;

    pub fn entindex(&self) -> i32 {
        self.entindex.unwrap_or(-1i32)
    }

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float cooldown = 3;

    pub fn cooldown(&self) -> f32 {
        self.cooldown.unwrap_or(0.)
    }

    pub fn clear_cooldown(&mut self) {
        self.cooldown = ::std::option::Option::None;
    }

    pub fn has_cooldown(&self) -> bool {
        self.cooldown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown(&mut self, v: f32) {
        self.cooldown = ::std::option::Option::Some(v);
    }

    // optional int32 name_index = 4;

    pub fn name_index(&self) -> i32 {
        self.name_index.unwrap_or(0)
    }

    pub fn clear_name_index(&mut self) {
        self.name_index = ::std::option::Option::None;
    }

    pub fn has_name_index(&self) -> bool {
        self.name_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_index(&mut self, v: i32) {
        self.name_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_SharedCooldown {
    const NAME: &'static str = "CDOTAUserMsg_SharedCooldown";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                29 => {
                    self.cooldown = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.name_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.cooldown {
            my_size += 1 + 4;
        }
        if let Some(v) = self.name_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.cooldown {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.name_index {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SharedCooldown {
        CDOTAUserMsg_SharedCooldown::new()
    }

    fn clear(&mut self) {
        self.entindex = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.cooldown = ::std::option::Option::None;
        self.name_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SharedCooldown {
        static instance: CDOTAUserMsg_SharedCooldown = CDOTAUserMsg_SharedCooldown {
            entindex: ::std::option::Option::None,
            name: ::std::option::Option::None,
            cooldown: ::std::option::Option::None,
            name_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_SetNextAutobuyItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SetNextAutobuyItem {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_SetNextAutobuyItem.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_SetNextAutobuyItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SetNextAutobuyItem {
    fn default() -> &'a CDOTAUserMsg_SetNextAutobuyItem {
        <CDOTAUserMsg_SetNextAutobuyItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SetNextAutobuyItem {
    pub fn new() -> CDOTAUserMsg_SetNextAutobuyItem {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_SetNextAutobuyItem {
    const NAME: &'static str = "CDOTAUserMsg_SetNextAutobuyItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SetNextAutobuyItem {
        CDOTAUserMsg_SetNextAutobuyItem::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SetNextAutobuyItem {
        static instance: CDOTAUserMsg_SetNextAutobuyItem = CDOTAUserMsg_SetNextAutobuyItem {
            name: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_HalloweenDrops)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_HalloweenDrops {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_HalloweenDrops.item_defs)
    pub item_defs: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_HalloweenDrops.player_ids)
    pub player_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_HalloweenDrops.prize_list)
    pub prize_list: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_HalloweenDrops.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_HalloweenDrops {
    fn default() -> &'a CDOTAUserMsg_HalloweenDrops {
        <CDOTAUserMsg_HalloweenDrops as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_HalloweenDrops {
    pub fn new() -> CDOTAUserMsg_HalloweenDrops {
        ::std::default::Default::default()
    }

    // optional uint32 prize_list = 3;

    pub fn prize_list(&self) -> u32 {
        self.prize_list.unwrap_or(0)
    }

    pub fn clear_prize_list(&mut self) {
        self.prize_list = ::std::option::Option::None;
    }

    pub fn has_prize_list(&self) -> bool {
        self.prize_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prize_list(&mut self, v: u32) {
        self.prize_list = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_HalloweenDrops {
    const NAME: &'static str = "CDOTAUserMsg_HalloweenDrops";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.item_defs)?;
                },
                8 => {
                    self.item_defs.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.player_ids)?;
                },
                16 => {
                    self.player_ids.push(is.read_int32()?);
                },
                24 => {
                    self.prize_list = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_defs {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.player_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, *value);
        };
        if let Some(v) = self.prize_list {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.item_defs {
            os.write_uint32(1, *v)?;
        };
        for v in &self.player_ids {
            os.write_int32(2, *v)?;
        };
        if let Some(v) = self.prize_list {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_HalloweenDrops {
        CDOTAUserMsg_HalloweenDrops::new()
    }

    fn clear(&mut self) {
        self.item_defs.clear();
        self.player_ids.clear();
        self.prize_list = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_HalloweenDrops {
        static instance: CDOTAUserMsg_HalloweenDrops = CDOTAUserMsg_HalloweenDrops {
            item_defs: ::std::vec::Vec::new(),
            player_ids: ::std::vec::Vec::new(),
            prize_list: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAResponseQuerySerialized)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAResponseQuerySerialized {
    // message fields
    // @@protoc_insertion_point(field:CDOTAResponseQuerySerialized.facts)
    pub facts: ::std::vec::Vec<cdotaresponse_query_serialized::Fact>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAResponseQuerySerialized.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAResponseQuerySerialized {
    fn default() -> &'a CDOTAResponseQuerySerialized {
        <CDOTAResponseQuerySerialized as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAResponseQuerySerialized {
    pub fn new() -> CDOTAResponseQuerySerialized {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAResponseQuerySerialized {
    const NAME: &'static str = "CDOTAResponseQuerySerialized";

    fn is_initialized(&self) -> bool {
        for v in &self.facts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.facts.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.facts {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.facts {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAResponseQuerySerialized {
        CDOTAResponseQuerySerialized::new()
    }

    fn clear(&mut self) {
        self.facts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAResponseQuerySerialized {
        static instance: CDOTAResponseQuerySerialized = CDOTAResponseQuerySerialized {
            facts: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CDOTAResponseQuerySerialized`
pub mod cdotaresponse_query_serialized {
    // @@protoc_insertion_point(message:CDOTAResponseQuerySerialized.Fact)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Fact {
        // message fields
        // @@protoc_insertion_point(field:CDOTAResponseQuerySerialized.Fact.key)
        pub key: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CDOTAResponseQuerySerialized.Fact.valtype)
        pub valtype: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<fact::ValueType>>,
        // @@protoc_insertion_point(field:CDOTAResponseQuerySerialized.Fact.val_numeric)
        pub val_numeric: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CDOTAResponseQuerySerialized.Fact.val_string)
        pub val_string: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CDOTAResponseQuerySerialized.Fact.val_stringtable_index)
        pub val_stringtable_index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CDOTAResponseQuerySerialized.Fact.val_int_numeric)
        pub val_int_numeric: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAResponseQuerySerialized.Fact.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Fact {
        fn default() -> &'a Fact {
            <Fact as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Fact {
        pub fn new() -> Fact {
            ::std::default::Default::default()
        }

        // required int32 key = 1;

        pub fn key(&self) -> i32 {
            self.key.unwrap_or(0)
        }

        pub fn clear_key(&mut self) {
            self.key = ::std::option::Option::None;
        }

        pub fn has_key(&self) -> bool {
            self.key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_key(&mut self, v: i32) {
            self.key = ::std::option::Option::Some(v);
        }

        // required .CDOTAResponseQuerySerialized.Fact.ValueType valtype = 2;

        pub fn valtype(&self) -> fact::ValueType {
            match self.valtype {
                Some(e) => e.enum_value_or(fact::ValueType::NUMERIC),
                None => fact::ValueType::NUMERIC,
            }
        }

        pub fn clear_valtype(&mut self) {
            self.valtype = ::std::option::Option::None;
        }

        pub fn has_valtype(&self) -> bool {
            self.valtype.is_some()
        }

        // Param is passed by value, moved
        pub fn set_valtype(&mut self, v: fact::ValueType) {
            self.valtype = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional float val_numeric = 3;

        pub fn val_numeric(&self) -> f32 {
            self.val_numeric.unwrap_or(0.)
        }

        pub fn clear_val_numeric(&mut self) {
            self.val_numeric = ::std::option::Option::None;
        }

        pub fn has_val_numeric(&self) -> bool {
            self.val_numeric.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_numeric(&mut self, v: f32) {
            self.val_numeric = ::std::option::Option::Some(v);
        }

        // optional string val_string = 4;

        pub fn val_string(&self) -> &str {
            match self.val_string.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_val_string(&mut self) {
            self.val_string = ::std::option::Option::None;
        }

        pub fn has_val_string(&self) -> bool {
            self.val_string.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_string(&mut self, v: ::std::string::String) {
            self.val_string = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_val_string(&mut self) -> &mut ::std::string::String {
            if self.val_string.is_none() {
                self.val_string = ::std::option::Option::Some(::std::string::String::new());
            }
            self.val_string.as_mut().unwrap()
        }

        // Take field
        pub fn take_val_string(&mut self) -> ::std::string::String {
            self.val_string.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 val_stringtable_index = 5;

        pub fn val_stringtable_index(&self) -> i32 {
            self.val_stringtable_index.unwrap_or(0)
        }

        pub fn clear_val_stringtable_index(&mut self) {
            self.val_stringtable_index = ::std::option::Option::None;
        }

        pub fn has_val_stringtable_index(&self) -> bool {
            self.val_stringtable_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_stringtable_index(&mut self, v: i32) {
            self.val_stringtable_index = ::std::option::Option::Some(v);
        }

        // optional sint32 val_int_numeric = 6;

        pub fn val_int_numeric(&self) -> i32 {
            self.val_int_numeric.unwrap_or(0)
        }

        pub fn clear_val_int_numeric(&mut self) {
            self.val_int_numeric = ::std::option::Option::None;
        }

        pub fn has_val_int_numeric(&self) -> bool {
            self.val_int_numeric.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_int_numeric(&mut self, v: i32) {
            self.val_int_numeric = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Fact {
        const NAME: &'static str = "Fact";

        fn is_initialized(&self) -> bool {
            if self.key.is_none() {
                return false;
            }
            if self.valtype.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.key = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.valtype = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    29 => {
                        self.val_numeric = ::std::option::Option::Some(is.read_float()?);
                    },
                    34 => {
                        self.val_string = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.val_stringtable_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.val_int_numeric = ::std::option::Option::Some(is.read_sint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.key {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.valtype {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.val_numeric {
                my_size += 1 + 4;
            }
            if let Some(v) = self.val_string.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.val_stringtable_index {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.val_int_numeric {
                my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(6, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.key {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.valtype {
                os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.val_numeric {
                os.write_float(3, v)?;
            }
            if let Some(v) = self.val_string.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.val_stringtable_index {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.val_int_numeric {
                os.write_sint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Fact {
            Fact::new()
        }

        fn clear(&mut self) {
            self.key = ::std::option::Option::None;
            self.valtype = ::std::option::Option::None;
            self.val_numeric = ::std::option::Option::None;
            self.val_string = ::std::option::Option::None;
            self.val_stringtable_index = ::std::option::Option::None;
            self.val_int_numeric = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Fact {
            static instance: Fact = Fact {
                key: ::std::option::Option::None,
                valtype: ::std::option::Option::None,
                val_numeric: ::std::option::Option::None,
                val_string: ::std::option::Option::None,
                val_stringtable_index: ::std::option::Option::None,
                val_int_numeric: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Fact`
    pub mod fact {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:CDOTAResponseQuerySerialized.Fact.ValueType)
        pub enum ValueType {
            // @@protoc_insertion_point(enum_value:CDOTAResponseQuerySerialized.Fact.ValueType.NUMERIC)
            NUMERIC = 1,
            // @@protoc_insertion_point(enum_value:CDOTAResponseQuerySerialized.Fact.ValueType.STRING)
            STRING = 2,
            // @@protoc_insertion_point(enum_value:CDOTAResponseQuerySerialized.Fact.ValueType.STRINGTABLE_INDEX)
            STRINGTABLE_INDEX = 3,
            // @@protoc_insertion_point(enum_value:CDOTAResponseQuerySerialized.Fact.ValueType.INT_NUMERIC)
            INT_NUMERIC = 4,
        }

        impl ::steam_vent_proto_common::protobuf::Enum for ValueType {
            const NAME: &'static str = "ValueType";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<ValueType> {
                match value {
                    1 => ::std::option::Option::Some(ValueType::NUMERIC),
                    2 => ::std::option::Option::Some(ValueType::STRING),
                    3 => ::std::option::Option::Some(ValueType::STRINGTABLE_INDEX),
                    4 => ::std::option::Option::Some(ValueType::INT_NUMERIC),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<ValueType> {
                match str {
                    "NUMERIC" => ::std::option::Option::Some(ValueType::NUMERIC),
                    "STRING" => ::std::option::Option::Some(ValueType::STRING),
                    "STRINGTABLE_INDEX" => ::std::option::Option::Some(ValueType::STRINGTABLE_INDEX),
                    "INT_NUMERIC" => ::std::option::Option::Some(ValueType::INT_NUMERIC),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [ValueType] = &[
                ValueType::NUMERIC,
                ValueType::STRING,
                ValueType::STRINGTABLE_INDEX,
                ValueType::INT_NUMERIC,
            ];
        }

        // Note, `Default` is implemented although default value is not 0
        impl ::std::default::Default for ValueType {
            fn default() -> Self {
                ValueType::NUMERIC
            }
        }

    }
}

// @@protoc_insertion_point(message:CDOTASpeechMatchOnClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTASpeechMatchOnClient {
    // message fields
    // @@protoc_insertion_point(field:CDOTASpeechMatchOnClient.speech_concept)
    pub speech_concept: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTASpeechMatchOnClient.recipient_type)
    pub recipient_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTASpeechMatchOnClient.responsequery)
    pub responsequery: ::steam_vent_proto_common::protobuf::MessageField<CDOTAResponseQuerySerialized>,
    // @@protoc_insertion_point(field:CDOTASpeechMatchOnClient.randomseed)
    pub randomseed: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTASpeechMatchOnClient.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTASpeechMatchOnClient {
    fn default() -> &'a CDOTASpeechMatchOnClient {
        <CDOTASpeechMatchOnClient as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTASpeechMatchOnClient {
    pub fn new() -> CDOTASpeechMatchOnClient {
        ::std::default::Default::default()
    }

    // optional int32 speech_concept = 1;

    pub fn speech_concept(&self) -> i32 {
        self.speech_concept.unwrap_or(0)
    }

    pub fn clear_speech_concept(&mut self) {
        self.speech_concept = ::std::option::Option::None;
    }

    pub fn has_speech_concept(&self) -> bool {
        self.speech_concept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speech_concept(&mut self, v: i32) {
        self.speech_concept = ::std::option::Option::Some(v);
    }

    // optional int32 recipient_type = 2;

    pub fn recipient_type(&self) -> i32 {
        self.recipient_type.unwrap_or(0)
    }

    pub fn clear_recipient_type(&mut self) {
        self.recipient_type = ::std::option::Option::None;
    }

    pub fn has_recipient_type(&self) -> bool {
        self.recipient_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_type(&mut self, v: i32) {
        self.recipient_type = ::std::option::Option::Some(v);
    }

    // optional sfixed32 randomseed = 4;

    pub fn randomseed(&self) -> i32 {
        self.randomseed.unwrap_or(0i32)
    }

    pub fn clear_randomseed(&mut self) {
        self.randomseed = ::std::option::Option::None;
    }

    pub fn has_randomseed(&self) -> bool {
        self.randomseed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_randomseed(&mut self, v: i32) {
        self.randomseed = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTASpeechMatchOnClient {
    const NAME: &'static str = "CDOTASpeechMatchOnClient";

    fn is_initialized(&self) -> bool {
        for v in &self.responsequery {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.speech_concept = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.recipient_type = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.responsequery)?;
                },
                37 => {
                    self.randomseed = ::std::option::Option::Some(is.read_sfixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.speech_concept {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.recipient_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.responsequery.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.randomseed {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.speech_concept {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.recipient_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.responsequery.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.randomseed {
            os.write_sfixed32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTASpeechMatchOnClient {
        CDOTASpeechMatchOnClient::new()
    }

    fn clear(&mut self) {
        self.speech_concept = ::std::option::Option::None;
        self.recipient_type = ::std::option::Option::None;
        self.responsequery.clear();
        self.randomseed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTASpeechMatchOnClient {
        static instance: CDOTASpeechMatchOnClient = CDOTASpeechMatchOnClient {
            speech_concept: ::std::option::Option::None,
            recipient_type: ::std::option::Option::None,
            responsequery: ::steam_vent_proto_common::protobuf::MessageField::none(),
            randomseed: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_UnitEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_UnitEvent {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.msg_type)
    pub msg_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EDotaEntityMessages>>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.entity_index)
    pub entity_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.speech)
    pub speech: ::steam_vent_proto_common::protobuf::MessageField<cdotauser_msg_unit_event::Speech>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.speech_mute)
    pub speech_mute: ::steam_vent_proto_common::protobuf::MessageField<cdotauser_msg_unit_event::SpeechMute>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.add_gesture)
    pub add_gesture: ::steam_vent_proto_common::protobuf::MessageField<cdotauser_msg_unit_event::AddGesture>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.remove_gesture)
    pub remove_gesture: ::steam_vent_proto_common::protobuf::MessageField<cdotauser_msg_unit_event::RemoveGesture>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.blood_impact)
    pub blood_impact: ::steam_vent_proto_common::protobuf::MessageField<cdotauser_msg_unit_event::BloodImpact>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.fade_gesture)
    pub fade_gesture: ::steam_vent_proto_common::protobuf::MessageField<cdotauser_msg_unit_event::FadeGesture>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.speech_match_on_client)
    pub speech_match_on_client: ::steam_vent_proto_common::protobuf::MessageField<CDOTASpeechMatchOnClient>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_UnitEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_UnitEvent {
    fn default() -> &'a CDOTAUserMsg_UnitEvent {
        <CDOTAUserMsg_UnitEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_UnitEvent {
    pub fn new() -> CDOTAUserMsg_UnitEvent {
        ::std::default::Default::default()
    }

    // required .EDotaEntityMessages msg_type = 1;

    pub fn msg_type(&self) -> EDotaEntityMessages {
        match self.msg_type {
            Some(e) => e.enum_value_or(EDotaEntityMessages::DOTA_UNIT_SPEECH),
            None => EDotaEntityMessages::DOTA_UNIT_SPEECH,
        }
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: EDotaEntityMessages) {
        self.msg_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // required int32 entity_index = 2;

    pub fn entity_index(&self) -> i32 {
        self.entity_index.unwrap_or(0)
    }

    pub fn clear_entity_index(&mut self) {
        self.entity_index = ::std::option::Option::None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: i32) {
        self.entity_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_UnitEvent {
    const NAME: &'static str = "CDOTAUserMsg_UnitEvent";

    fn is_initialized(&self) -> bool {
        if self.msg_type.is_none() {
            return false;
        }
        if self.entity_index.is_none() {
            return false;
        }
        for v in &self.speech {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.speech_mute {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.add_gesture {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.remove_gesture {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blood_impact {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fade_gesture {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.speech_match_on_client {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.entity_index = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.speech)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.speech_mute)?;
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.add_gesture)?;
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.remove_gesture)?;
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.blood_impact)?;
                },
                66 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.fade_gesture)?;
                },
                74 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.speech_match_on_client)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.entity_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.speech.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.speech_mute.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.add_gesture.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.remove_gesture.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.blood_impact.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fade_gesture.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.speech_match_on_client.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.msg_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.entity_index {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.speech.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.speech_mute.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.add_gesture.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.remove_gesture.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.blood_impact.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.fade_gesture.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.speech_match_on_client.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_UnitEvent {
        CDOTAUserMsg_UnitEvent::new()
    }

    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.entity_index = ::std::option::Option::None;
        self.speech.clear();
        self.speech_mute.clear();
        self.add_gesture.clear();
        self.remove_gesture.clear();
        self.blood_impact.clear();
        self.fade_gesture.clear();
        self.speech_match_on_client.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_UnitEvent {
        static instance: CDOTAUserMsg_UnitEvent = CDOTAUserMsg_UnitEvent {
            msg_type: ::std::option::Option::None,
            entity_index: ::std::option::Option::None,
            speech: ::steam_vent_proto_common::protobuf::MessageField::none(),
            speech_mute: ::steam_vent_proto_common::protobuf::MessageField::none(),
            add_gesture: ::steam_vent_proto_common::protobuf::MessageField::none(),
            remove_gesture: ::steam_vent_proto_common::protobuf::MessageField::none(),
            blood_impact: ::steam_vent_proto_common::protobuf::MessageField::none(),
            fade_gesture: ::steam_vent_proto_common::protobuf::MessageField::none(),
            speech_match_on_client: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CDOTAUserMsg_UnitEvent`
pub mod cdotauser_msg_unit_event {
    // @@protoc_insertion_point(message:CDOTAUserMsg_UnitEvent.Interval)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Interval {
        // message fields
        // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.Interval.start)
        pub start: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.Interval.range)
        pub range: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAUserMsg_UnitEvent.Interval.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Interval {
        fn default() -> &'a Interval {
            <Interval as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Interval {
        pub fn new() -> Interval {
            ::std::default::Default::default()
        }

        // optional float start = 1;

        pub fn start(&self) -> f32 {
            self.start.unwrap_or(0.)
        }

        pub fn clear_start(&mut self) {
            self.start = ::std::option::Option::None;
        }

        pub fn has_start(&self) -> bool {
            self.start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start(&mut self, v: f32) {
            self.start = ::std::option::Option::Some(v);
        }

        // optional float range = 2;

        pub fn range(&self) -> f32 {
            self.range.unwrap_or(0.)
        }

        pub fn clear_range(&mut self) {
            self.range = ::std::option::Option::None;
        }

        pub fn has_range(&self) -> bool {
            self.range.is_some()
        }

        // Param is passed by value, moved
        pub fn set_range(&mut self, v: f32) {
            self.range = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Interval {
        const NAME: &'static str = "Interval";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.start = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.range = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.start {
                my_size += 1 + 4;
            }
            if let Some(v) = self.range {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.start {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.range {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Interval {
            Interval::new()
        }

        fn clear(&mut self) {
            self.start = ::std::option::Option::None;
            self.range = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Interval {
            static instance: Interval = Interval {
                start: ::std::option::Option::None,
                range: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CDOTAUserMsg_UnitEvent.Speech)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Speech {
        // message fields
        // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.Speech.speech_concept)
        pub speech_concept: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.Speech.response)
        pub response: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.Speech.recipient_type)
        pub recipient_type: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.Speech.muteable)
        pub muteable: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.Speech.predelay)
        pub predelay: ::steam_vent_proto_common::protobuf::MessageField<Interval>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.Speech.flags)
        pub flags: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAUserMsg_UnitEvent.Speech.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Speech {
        fn default() -> &'a Speech {
            <Speech as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Speech {
        pub fn new() -> Speech {
            ::std::default::Default::default()
        }

        // optional int32 speech_concept = 1;

        pub fn speech_concept(&self) -> i32 {
            self.speech_concept.unwrap_or(0)
        }

        pub fn clear_speech_concept(&mut self) {
            self.speech_concept = ::std::option::Option::None;
        }

        pub fn has_speech_concept(&self) -> bool {
            self.speech_concept.is_some()
        }

        // Param is passed by value, moved
        pub fn set_speech_concept(&mut self, v: i32) {
            self.speech_concept = ::std::option::Option::Some(v);
        }

        // optional string response = 2;

        pub fn response(&self) -> &str {
            match self.response.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_response(&mut self) {
            self.response = ::std::option::Option::None;
        }

        pub fn has_response(&self) -> bool {
            self.response.is_some()
        }

        // Param is passed by value, moved
        pub fn set_response(&mut self, v: ::std::string::String) {
            self.response = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_response(&mut self) -> &mut ::std::string::String {
            if self.response.is_none() {
                self.response = ::std::option::Option::Some(::std::string::String::new());
            }
            self.response.as_mut().unwrap()
        }

        // Take field
        pub fn take_response(&mut self) -> ::std::string::String {
            self.response.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 recipient_type = 3;

        pub fn recipient_type(&self) -> i32 {
            self.recipient_type.unwrap_or(0)
        }

        pub fn clear_recipient_type(&mut self) {
            self.recipient_type = ::std::option::Option::None;
        }

        pub fn has_recipient_type(&self) -> bool {
            self.recipient_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_recipient_type(&mut self, v: i32) {
            self.recipient_type = ::std::option::Option::Some(v);
        }

        // optional bool muteable = 5;

        pub fn muteable(&self) -> bool {
            self.muteable.unwrap_or(false)
        }

        pub fn clear_muteable(&mut self) {
            self.muteable = ::std::option::Option::None;
        }

        pub fn has_muteable(&self) -> bool {
            self.muteable.is_some()
        }

        // Param is passed by value, moved
        pub fn set_muteable(&mut self, v: bool) {
            self.muteable = ::std::option::Option::Some(v);
        }

        // optional uint32 flags = 7;

        pub fn flags(&self) -> u32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: u32) {
            self.flags = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Speech {
        const NAME: &'static str = "Speech";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.speech_concept = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.response = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.recipient_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.muteable = ::std::option::Option::Some(is.read_bool()?);
                    },
                    50 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.predelay)?;
                    },
                    56 => {
                        self.flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.speech_concept {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.response.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.recipient_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.muteable {
                my_size += 1 + 1;
            }
            if let Some(v) = self.predelay.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.flags {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.speech_concept {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.response.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.recipient_type {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.muteable {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.predelay.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            if let Some(v) = self.flags {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Speech {
            Speech::new()
        }

        fn clear(&mut self) {
            self.speech_concept = ::std::option::Option::None;
            self.response = ::std::option::Option::None;
            self.recipient_type = ::std::option::Option::None;
            self.muteable = ::std::option::Option::None;
            self.predelay.clear();
            self.flags = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Speech {
            static instance: Speech = Speech {
                speech_concept: ::std::option::Option::None,
                response: ::std::option::Option::None,
                recipient_type: ::std::option::Option::None,
                muteable: ::std::option::Option::None,
                predelay: ::steam_vent_proto_common::protobuf::MessageField::none(),
                flags: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CDOTAUserMsg_UnitEvent.SpeechMute)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SpeechMute {
        // message fields
        // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.SpeechMute.delay)
        pub delay: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAUserMsg_UnitEvent.SpeechMute.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SpeechMute {
        fn default() -> &'a SpeechMute {
            <SpeechMute as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SpeechMute {
        pub fn new() -> SpeechMute {
            ::std::default::Default::default()
        }

        // optional float delay = 1;

        pub fn delay(&self) -> f32 {
            self.delay.unwrap_or(0.5f32)
        }

        pub fn clear_delay(&mut self) {
            self.delay = ::std::option::Option::None;
        }

        pub fn has_delay(&self) -> bool {
            self.delay.is_some()
        }

        // Param is passed by value, moved
        pub fn set_delay(&mut self, v: f32) {
            self.delay = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SpeechMute {
        const NAME: &'static str = "SpeechMute";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.delay = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.delay {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.delay {
                os.write_float(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SpeechMute {
            SpeechMute::new()
        }

        fn clear(&mut self) {
            self.delay = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SpeechMute {
            static instance: SpeechMute = SpeechMute {
                delay: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CDOTAUserMsg_UnitEvent.AddGesture)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AddGesture {
        // message fields
        // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.AddGesture.activity)
        pub activity: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.AddGesture.slot)
        pub slot: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.AddGesture.fade_in)
        pub fade_in: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.AddGesture.fade_out)
        pub fade_out: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.AddGesture.playback_rate)
        pub playback_rate: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.AddGesture.sequence_variant)
        pub sequence_variant: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAUserMsg_UnitEvent.AddGesture.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AddGesture {
        fn default() -> &'a AddGesture {
            <AddGesture as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl AddGesture {
        pub fn new() -> AddGesture {
            ::std::default::Default::default()
        }

        // optional int32 activity = 1;

        pub fn activity(&self) -> i32 {
            self.activity.unwrap_or(0)
        }

        pub fn clear_activity(&mut self) {
            self.activity = ::std::option::Option::None;
        }

        pub fn has_activity(&self) -> bool {
            self.activity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_activity(&mut self, v: i32) {
            self.activity = ::std::option::Option::Some(v);
        }

        // optional int32 slot = 2;

        pub fn slot(&self) -> i32 {
            self.slot.unwrap_or(0)
        }

        pub fn clear_slot(&mut self) {
            self.slot = ::std::option::Option::None;
        }

        pub fn has_slot(&self) -> bool {
            self.slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot(&mut self, v: i32) {
            self.slot = ::std::option::Option::Some(v);
        }

        // optional float fade_in = 3;

        pub fn fade_in(&self) -> f32 {
            self.fade_in.unwrap_or(0.0f32)
        }

        pub fn clear_fade_in(&mut self) {
            self.fade_in = ::std::option::Option::None;
        }

        pub fn has_fade_in(&self) -> bool {
            self.fade_in.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fade_in(&mut self, v: f32) {
            self.fade_in = ::std::option::Option::Some(v);
        }

        // optional float fade_out = 4;

        pub fn fade_out(&self) -> f32 {
            self.fade_out.unwrap_or(0.10000000149011612f32)
        }

        pub fn clear_fade_out(&mut self) {
            self.fade_out = ::std::option::Option::None;
        }

        pub fn has_fade_out(&self) -> bool {
            self.fade_out.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fade_out(&mut self, v: f32) {
            self.fade_out = ::std::option::Option::Some(v);
        }

        // optional float playback_rate = 5;

        pub fn playback_rate(&self) -> f32 {
            self.playback_rate.unwrap_or(1.0f32)
        }

        pub fn clear_playback_rate(&mut self) {
            self.playback_rate = ::std::option::Option::None;
        }

        pub fn has_playback_rate(&self) -> bool {
            self.playback_rate.is_some()
        }

        // Param is passed by value, moved
        pub fn set_playback_rate(&mut self, v: f32) {
            self.playback_rate = ::std::option::Option::Some(v);
        }

        // optional int32 sequence_variant = 6;

        pub fn sequence_variant(&self) -> i32 {
            self.sequence_variant.unwrap_or(0)
        }

        pub fn clear_sequence_variant(&mut self) {
            self.sequence_variant = ::std::option::Option::None;
        }

        pub fn has_sequence_variant(&self) -> bool {
            self.sequence_variant.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sequence_variant(&mut self, v: i32) {
            self.sequence_variant = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for AddGesture {
        const NAME: &'static str = "AddGesture";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.activity = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.slot = ::std::option::Option::Some(is.read_int32()?);
                    },
                    29 => {
                        self.fade_in = ::std::option::Option::Some(is.read_float()?);
                    },
                    37 => {
                        self.fade_out = ::std::option::Option::Some(is.read_float()?);
                    },
                    45 => {
                        self.playback_rate = ::std::option::Option::Some(is.read_float()?);
                    },
                    48 => {
                        self.sequence_variant = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.activity {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.slot {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.fade_in {
                my_size += 1 + 4;
            }
            if let Some(v) = self.fade_out {
                my_size += 1 + 4;
            }
            if let Some(v) = self.playback_rate {
                my_size += 1 + 4;
            }
            if let Some(v) = self.sequence_variant {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.activity {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.slot {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.fade_in {
                os.write_float(3, v)?;
            }
            if let Some(v) = self.fade_out {
                os.write_float(4, v)?;
            }
            if let Some(v) = self.playback_rate {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.sequence_variant {
                os.write_int32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AddGesture {
            AddGesture::new()
        }

        fn clear(&mut self) {
            self.activity = ::std::option::Option::None;
            self.slot = ::std::option::Option::None;
            self.fade_in = ::std::option::Option::None;
            self.fade_out = ::std::option::Option::None;
            self.playback_rate = ::std::option::Option::None;
            self.sequence_variant = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AddGesture {
            static instance: AddGesture = AddGesture {
                activity: ::std::option::Option::None,
                slot: ::std::option::Option::None,
                fade_in: ::std::option::Option::None,
                fade_out: ::std::option::Option::None,
                playback_rate: ::std::option::Option::None,
                sequence_variant: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CDOTAUserMsg_UnitEvent.RemoveGesture)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RemoveGesture {
        // message fields
        // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.RemoveGesture.activity)
        pub activity: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAUserMsg_UnitEvent.RemoveGesture.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RemoveGesture {
        fn default() -> &'a RemoveGesture {
            <RemoveGesture as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl RemoveGesture {
        pub fn new() -> RemoveGesture {
            ::std::default::Default::default()
        }

        // optional int32 activity = 1;

        pub fn activity(&self) -> i32 {
            self.activity.unwrap_or(0)
        }

        pub fn clear_activity(&mut self) {
            self.activity = ::std::option::Option::None;
        }

        pub fn has_activity(&self) -> bool {
            self.activity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_activity(&mut self, v: i32) {
            self.activity = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for RemoveGesture {
        const NAME: &'static str = "RemoveGesture";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.activity = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.activity {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.activity {
                os.write_int32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RemoveGesture {
            RemoveGesture::new()
        }

        fn clear(&mut self) {
            self.activity = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RemoveGesture {
            static instance: RemoveGesture = RemoveGesture {
                activity: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CDOTAUserMsg_UnitEvent.BloodImpact)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BloodImpact {
        // message fields
        // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.BloodImpact.scale)
        pub scale: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.BloodImpact.x_normal)
        pub x_normal: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.BloodImpact.y_normal)
        pub y_normal: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAUserMsg_UnitEvent.BloodImpact.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BloodImpact {
        fn default() -> &'a BloodImpact {
            <BloodImpact as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl BloodImpact {
        pub fn new() -> BloodImpact {
            ::std::default::Default::default()
        }

        // optional int32 scale = 1;

        pub fn scale(&self) -> i32 {
            self.scale.unwrap_or(0)
        }

        pub fn clear_scale(&mut self) {
            self.scale = ::std::option::Option::None;
        }

        pub fn has_scale(&self) -> bool {
            self.scale.is_some()
        }

        // Param is passed by value, moved
        pub fn set_scale(&mut self, v: i32) {
            self.scale = ::std::option::Option::Some(v);
        }

        // optional int32 x_normal = 2;

        pub fn x_normal(&self) -> i32 {
            self.x_normal.unwrap_or(0)
        }

        pub fn clear_x_normal(&mut self) {
            self.x_normal = ::std::option::Option::None;
        }

        pub fn has_x_normal(&self) -> bool {
            self.x_normal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_x_normal(&mut self, v: i32) {
            self.x_normal = ::std::option::Option::Some(v);
        }

        // optional int32 y_normal = 3;

        pub fn y_normal(&self) -> i32 {
            self.y_normal.unwrap_or(0)
        }

        pub fn clear_y_normal(&mut self) {
            self.y_normal = ::std::option::Option::None;
        }

        pub fn has_y_normal(&self) -> bool {
            self.y_normal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_y_normal(&mut self, v: i32) {
            self.y_normal = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for BloodImpact {
        const NAME: &'static str = "BloodImpact";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.scale = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.x_normal = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.y_normal = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.scale {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.x_normal {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.y_normal {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.scale {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.x_normal {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.y_normal {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BloodImpact {
            BloodImpact::new()
        }

        fn clear(&mut self) {
            self.scale = ::std::option::Option::None;
            self.x_normal = ::std::option::Option::None;
            self.y_normal = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BloodImpact {
            static instance: BloodImpact = BloodImpact {
                scale: ::std::option::Option::None,
                x_normal: ::std::option::Option::None,
                y_normal: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CDOTAUserMsg_UnitEvent.FadeGesture)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FadeGesture {
        // message fields
        // @@protoc_insertion_point(field:CDOTAUserMsg_UnitEvent.FadeGesture.activity)
        pub activity: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAUserMsg_UnitEvent.FadeGesture.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FadeGesture {
        fn default() -> &'a FadeGesture {
            <FadeGesture as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl FadeGesture {
        pub fn new() -> FadeGesture {
            ::std::default::Default::default()
        }

        // optional int32 activity = 1;

        pub fn activity(&self) -> i32 {
            self.activity.unwrap_or(0)
        }

        pub fn clear_activity(&mut self) {
            self.activity = ::std::option::Option::None;
        }

        pub fn has_activity(&self) -> bool {
            self.activity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_activity(&mut self, v: i32) {
            self.activity = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for FadeGesture {
        const NAME: &'static str = "FadeGesture";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.activity = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.activity {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.activity {
                os.write_int32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FadeGesture {
            FadeGesture::new()
        }

        fn clear(&mut self) {
            self.activity = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FadeGesture {
            static instance: FadeGesture = FadeGesture {
                activity: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_ItemPurchased)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ItemPurchased {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_ItemPurchased.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_ItemPurchased.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ItemPurchased {
    fn default() -> &'a CDOTAUserMsg_ItemPurchased {
        <CDOTAUserMsg_ItemPurchased as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ItemPurchased {
    pub fn new() -> CDOTAUserMsg_ItemPurchased {
        ::std::default::Default::default()
    }

    // optional int32 item_ability_id = 1;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(-1i32)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_ItemPurchased {
    const NAME: &'static str = "CDOTAUserMsg_ItemPurchased";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_ability_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ItemPurchased {
        CDOTAUserMsg_ItemPurchased::new()
    }

    fn clear(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ItemPurchased {
        static instance: CDOTAUserMsg_ItemPurchased = CDOTAUserMsg_ItemPurchased {
            item_ability_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_ItemSold)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ItemSold {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_ItemSold.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_ItemSold.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ItemSold {
    fn default() -> &'a CDOTAUserMsg_ItemSold {
        <CDOTAUserMsg_ItemSold as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ItemSold {
    pub fn new() -> CDOTAUserMsg_ItemSold {
        ::std::default::Default::default()
    }

    // optional int32 item_ability_id = 1;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(-1i32)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_ItemSold {
    const NAME: &'static str = "CDOTAUserMsg_ItemSold";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_ability_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ItemSold {
        CDOTAUserMsg_ItemSold::new()
    }

    fn clear(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ItemSold {
        static instance: CDOTAUserMsg_ItemSold = CDOTAUserMsg_ItemSold {
            item_ability_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_ItemFound)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ItemFound {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_ItemFound.player)
    pub player: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ItemFound.quality)
    pub quality: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ItemFound.rarity)
    pub rarity: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ItemFound.method)
    pub method: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ItemFound.itemdef)
    pub itemdef: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_ItemFound.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ItemFound {
    fn default() -> &'a CDOTAUserMsg_ItemFound {
        <CDOTAUserMsg_ItemFound as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ItemFound {
    pub fn new() -> CDOTAUserMsg_ItemFound {
        ::std::default::Default::default()
    }

    // optional int32 player = 1;

    pub fn player(&self) -> i32 {
        self.player.unwrap_or(-1i32)
    }

    pub fn clear_player(&mut self) {
        self.player = ::std::option::Option::None;
    }

    pub fn has_player(&self) -> bool {
        self.player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player(&mut self, v: i32) {
        self.player = ::std::option::Option::Some(v);
    }

    // optional int32 quality = 2;

    pub fn quality(&self) -> i32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: i32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional int32 rarity = 3;

    pub fn rarity(&self) -> i32 {
        self.rarity.unwrap_or(0)
    }

    pub fn clear_rarity(&mut self) {
        self.rarity = ::std::option::Option::None;
    }

    pub fn has_rarity(&self) -> bool {
        self.rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rarity(&mut self, v: i32) {
        self.rarity = ::std::option::Option::Some(v);
    }

    // optional int32 method = 4;

    pub fn method(&self) -> i32 {
        self.method.unwrap_or(0)
    }

    pub fn clear_method(&mut self) {
        self.method = ::std::option::Option::None;
    }

    pub fn has_method(&self) -> bool {
        self.method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method(&mut self, v: i32) {
        self.method = ::std::option::Option::Some(v);
    }

    // optional uint32 itemdef = 5;

    pub fn itemdef(&self) -> u32 {
        self.itemdef.unwrap_or(0)
    }

    pub fn clear_itemdef(&mut self) {
        self.itemdef = ::std::option::Option::None;
    }

    pub fn has_itemdef(&self) -> bool {
        self.itemdef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemdef(&mut self, v: u32) {
        self.itemdef = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_ItemFound {
    const NAME: &'static str = "CDOTAUserMsg_ItemFound";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.quality = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.rarity = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.method = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.itemdef = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.quality {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.rarity {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.method {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.itemdef {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.quality {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.rarity {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.method {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.itemdef {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ItemFound {
        CDOTAUserMsg_ItemFound::new()
    }

    fn clear(&mut self) {
        self.player = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.rarity = ::std::option::Option::None;
        self.method = ::std::option::Option::None;
        self.itemdef = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ItemFound {
        static instance: CDOTAUserMsg_ItemFound = CDOTAUserMsg_ItemFound {
            player: ::std::option::Option::None,
            quality: ::std::option::Option::None,
            rarity: ::std::option::Option::None,
            method: ::std::option::Option::None,
            itemdef: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_OverheadEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_OverheadEvent {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_OverheadEvent.message_type)
    pub message_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<DOTA_OVERHEAD_ALERT>>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_OverheadEvent.value)
    pub value: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_OverheadEvent.target_player_entindex)
    pub target_player_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_OverheadEvent.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_OverheadEvent.source_player_entindex)
    pub source_player_entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_OverheadEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_OverheadEvent {
    fn default() -> &'a CDOTAUserMsg_OverheadEvent {
        <CDOTAUserMsg_OverheadEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_OverheadEvent {
    pub fn new() -> CDOTAUserMsg_OverheadEvent {
        ::std::default::Default::default()
    }

    // required .DOTA_OVERHEAD_ALERT message_type = 1;

    pub fn message_type(&self) -> DOTA_OVERHEAD_ALERT {
        match self.message_type {
            Some(e) => e.enum_value_or(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_GOLD),
            None => DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_GOLD,
        }
    }

    pub fn clear_message_type(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_message_type(&self) -> bool {
        self.message_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_type(&mut self, v: DOTA_OVERHEAD_ALERT) {
        self.message_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 value = 2;

    pub fn value(&self) -> i32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional int32 target_player_entindex = 3;

    pub fn target_player_entindex(&self) -> i32 {
        self.target_player_entindex.unwrap_or(-1i32)
    }

    pub fn clear_target_player_entindex(&mut self) {
        self.target_player_entindex = ::std::option::Option::None;
    }

    pub fn has_target_player_entindex(&self) -> bool {
        self.target_player_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_entindex(&mut self, v: i32) {
        self.target_player_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 4;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(-1i32)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 source_player_entindex = 5;

    pub fn source_player_entindex(&self) -> i32 {
        self.source_player_entindex.unwrap_or(-1i32)
    }

    pub fn clear_source_player_entindex(&mut self) {
        self.source_player_entindex = ::std::option::Option::None;
    }

    pub fn has_source_player_entindex(&self) -> bool {
        self.source_player_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_player_entindex(&mut self, v: i32) {
        self.source_player_entindex = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_OverheadEvent {
    const NAME: &'static str = "CDOTAUserMsg_OverheadEvent";

    fn is_initialized(&self) -> bool {
        if self.message_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.message_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.value = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.target_player_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.source_player_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.value {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.target_player_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.source_player_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.message_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.value {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.target_player_entindex {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.source_player_entindex {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_OverheadEvent {
        CDOTAUserMsg_OverheadEvent::new()
    }

    fn clear(&mut self) {
        self.message_type = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.target_player_entindex = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.source_player_entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_OverheadEvent {
        static instance: CDOTAUserMsg_OverheadEvent = CDOTAUserMsg_OverheadEvent {
            message_type: ::std::option::Option::None,
            value: ::std::option::Option::None,
            target_player_entindex: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            source_player_entindex: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_TutorialTipInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TutorialTipInfo {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_TutorialTipInfo.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TutorialTipInfo.progress)
    pub progress: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_TutorialTipInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TutorialTipInfo {
    fn default() -> &'a CDOTAUserMsg_TutorialTipInfo {
        <CDOTAUserMsg_TutorialTipInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TutorialTipInfo {
    pub fn new() -> CDOTAUserMsg_TutorialTipInfo {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 progress = 2;

    pub fn progress(&self) -> i32 {
        self.progress.unwrap_or(0)
    }

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: i32) {
        self.progress = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_TutorialTipInfo {
    const NAME: &'static str = "CDOTAUserMsg_TutorialTipInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.progress = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.progress {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.progress {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TutorialTipInfo {
        CDOTAUserMsg_TutorialTipInfo::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.progress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TutorialTipInfo {
        static instance: CDOTAUserMsg_TutorialTipInfo = CDOTAUserMsg_TutorialTipInfo {
            name: ::std::option::Option::None,
            progress: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_TutorialFinish)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TutorialFinish {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_TutorialFinish.heading)
    pub heading: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TutorialFinish.emblem)
    pub emblem: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TutorialFinish.body)
    pub body: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TutorialFinish.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_TutorialFinish.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TutorialFinish {
    fn default() -> &'a CDOTAUserMsg_TutorialFinish {
        <CDOTAUserMsg_TutorialFinish as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TutorialFinish {
    pub fn new() -> CDOTAUserMsg_TutorialFinish {
        ::std::default::Default::default()
    }

    // optional string heading = 1;

    pub fn heading(&self) -> &str {
        match self.heading.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_heading(&mut self) {
        self.heading = ::std::option::Option::None;
    }

    pub fn has_heading(&self) -> bool {
        self.heading.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heading(&mut self, v: ::std::string::String) {
        self.heading = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_heading(&mut self) -> &mut ::std::string::String {
        if self.heading.is_none() {
            self.heading = ::std::option::Option::Some(::std::string::String::new());
        }
        self.heading.as_mut().unwrap()
    }

    // Take field
    pub fn take_heading(&mut self) -> ::std::string::String {
        self.heading.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string emblem = 2;

    pub fn emblem(&self) -> &str {
        match self.emblem.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_emblem(&mut self) {
        self.emblem = ::std::option::Option::None;
    }

    pub fn has_emblem(&self) -> bool {
        self.emblem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emblem(&mut self, v: ::std::string::String) {
        self.emblem = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_emblem(&mut self) -> &mut ::std::string::String {
        if self.emblem.is_none() {
            self.emblem = ::std::option::Option::Some(::std::string::String::new());
        }
        self.emblem.as_mut().unwrap()
    }

    // Take field
    pub fn take_emblem(&mut self) -> ::std::string::String {
        self.emblem.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string body = 3;

    pub fn body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body = ::std::option::Option::Some(::std::string::String::new());
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool success = 4;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_TutorialFinish {
    const NAME: &'static str = "CDOTAUserMsg_TutorialFinish";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.heading = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.emblem = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.body = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.heading.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.emblem.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.body.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.heading.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.emblem.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.body.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.success {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TutorialFinish {
        CDOTAUserMsg_TutorialFinish::new()
    }

    fn clear(&mut self) {
        self.heading = ::std::option::Option::None;
        self.emblem = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TutorialFinish {
        static instance: CDOTAUserMsg_TutorialFinish = CDOTAUserMsg_TutorialFinish {
            heading: ::std::option::Option::None,
            emblem: ::std::option::Option::None,
            body: ::std::option::Option::None,
            success: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_TutorialMinimapPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TutorialMinimapPosition {
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_TutorialMinimapPosition.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TutorialMinimapPosition {
    fn default() -> &'a CDOTAUserMsg_TutorialMinimapPosition {
        <CDOTAUserMsg_TutorialMinimapPosition as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TutorialMinimapPosition {
    pub fn new() -> CDOTAUserMsg_TutorialMinimapPosition {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_TutorialMinimapPosition {
    const NAME: &'static str = "CDOTAUserMsg_TutorialMinimapPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TutorialMinimapPosition {
        CDOTAUserMsg_TutorialMinimapPosition::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TutorialMinimapPosition {
        static instance: CDOTAUserMsg_TutorialMinimapPosition = CDOTAUserMsg_TutorialMinimapPosition {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_SendGenericToolTip)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SendGenericToolTip {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_SendGenericToolTip.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SendGenericToolTip.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SendGenericToolTip.entindex)
    pub entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SendGenericToolTip.close)
    pub close: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_SendGenericToolTip.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SendGenericToolTip {
    fn default() -> &'a CDOTAUserMsg_SendGenericToolTip {
        <CDOTAUserMsg_SendGenericToolTip as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SendGenericToolTip {
    pub fn new() -> CDOTAUserMsg_SendGenericToolTip {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 entindex = 3;

    pub fn entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    // optional bool close = 4;

    pub fn close(&self) -> bool {
        self.close.unwrap_or(false)
    }

    pub fn clear_close(&mut self) {
        self.close = ::std::option::Option::None;
    }

    pub fn has_close(&self) -> bool {
        self.close.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close(&mut self, v: bool) {
        self.close = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_SendGenericToolTip {
    const NAME: &'static str = "CDOTAUserMsg_SendGenericToolTip";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.close = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.close {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.entindex {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.close {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SendGenericToolTip {
        CDOTAUserMsg_SendGenericToolTip::new()
    }

    fn clear(&mut self) {
        self.title = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.entindex = ::std::option::Option::None;
        self.close = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SendGenericToolTip {
        static instance: CDOTAUserMsg_SendGenericToolTip = CDOTAUserMsg_SendGenericToolTip {
            title: ::std::option::Option::None,
            text: ::std::option::Option::None,
            entindex: ::std::option::Option::None,
            close: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_WorldLine)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_WorldLine {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_WorldLine.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_WorldLine.worldline)
    pub worldline: ::steam_vent_proto_common::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_WorldLine>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_WorldLine.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_WorldLine {
    fn default() -> &'a CDOTAUserMsg_WorldLine {
        <CDOTAUserMsg_WorldLine as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_WorldLine {
    pub fn new() -> CDOTAUserMsg_WorldLine {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_WorldLine {
    const NAME: &'static str = "CDOTAUserMsg_WorldLine";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.worldline)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.worldline.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.worldline.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_WorldLine {
        CDOTAUserMsg_WorldLine::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.worldline.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_WorldLine {
        static instance: CDOTAUserMsg_WorldLine = CDOTAUserMsg_WorldLine {
            player_id: ::std::option::Option::None,
            worldline: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_ChatWheel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ChatWheel {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_ChatWheel.chat_message_id)
    pub chat_message_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ChatWheel.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ChatWheel.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ChatWheel.param_hero_id)
    pub param_hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ChatWheel.emoticon_id)
    pub emoticon_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_ChatWheel.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ChatWheel {
    fn default() -> &'a CDOTAUserMsg_ChatWheel {
        <CDOTAUserMsg_ChatWheel as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ChatWheel {
    pub fn new() -> CDOTAUserMsg_ChatWheel {
        ::std::default::Default::default()
    }

    // optional uint32 chat_message_id = 1;

    pub fn chat_message_id(&self) -> u32 {
        self.chat_message_id.unwrap_or(4294967295u32)
    }

    pub fn clear_chat_message_id(&mut self) {
        self.chat_message_id = ::std::option::Option::None;
    }

    pub fn has_chat_message_id(&self) -> bool {
        self.chat_message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_message_id(&mut self, v: u32) {
        self.chat_message_id = ::std::option::Option::Some(v);
    }

    // optional int32 player_id = 2;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 3;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional int32 param_hero_id = 4;

    pub fn param_hero_id(&self) -> i32 {
        self.param_hero_id.unwrap_or(0)
    }

    pub fn clear_param_hero_id(&mut self) {
        self.param_hero_id = ::std::option::Option::None;
    }

    pub fn has_param_hero_id(&self) -> bool {
        self.param_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_hero_id(&mut self, v: i32) {
        self.param_hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 emoticon_id = 5;

    pub fn emoticon_id(&self) -> u32 {
        self.emoticon_id.unwrap_or(0)
    }

    pub fn clear_emoticon_id(&mut self) {
        self.emoticon_id = ::std::option::Option::None;
    }

    pub fn has_emoticon_id(&self) -> bool {
        self.emoticon_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emoticon_id(&mut self, v: u32) {
        self.emoticon_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_ChatWheel {
    const NAME: &'static str = "CDOTAUserMsg_ChatWheel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_message_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.param_hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.emoticon_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_message_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.param_hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.emoticon_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.chat_message_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.param_hero_id {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.emoticon_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ChatWheel {
        CDOTAUserMsg_ChatWheel::new()
    }

    fn clear(&mut self) {
        self.chat_message_id = ::std::option::Option::None;
        self.player_id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.param_hero_id = ::std::option::Option::None;
        self.emoticon_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ChatWheel {
        static instance: CDOTAUserMsg_ChatWheel = CDOTAUserMsg_ChatWheel {
            chat_message_id: ::std::option::Option::None,
            player_id: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            param_hero_id: ::std::option::Option::None,
            emoticon_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_ReceivedXmasGift)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ReceivedXmasGift {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_ReceivedXmasGift.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ReceivedXmasGift.item_name)
    pub item_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ReceivedXmasGift.inventory_slot)
    pub inventory_slot: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_ReceivedXmasGift.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ReceivedXmasGift {
    fn default() -> &'a CDOTAUserMsg_ReceivedXmasGift {
        <CDOTAUserMsg_ReceivedXmasGift as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ReceivedXmasGift {
    pub fn new() -> CDOTAUserMsg_ReceivedXmasGift {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional string item_name = 2;

    pub fn item_name(&self) -> &str {
        match self.item_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_item_name(&mut self) {
        self.item_name = ::std::option::Option::None;
    }

    pub fn has_item_name(&self) -> bool {
        self.item_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_name(&mut self, v: ::std::string::String) {
        self.item_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_name(&mut self) -> &mut ::std::string::String {
        if self.item_name.is_none() {
            self.item_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.item_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_name(&mut self) -> ::std::string::String {
        self.item_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 inventory_slot = 3;

    pub fn inventory_slot(&self) -> i32 {
        self.inventory_slot.unwrap_or(0)
    }

    pub fn clear_inventory_slot(&mut self) {
        self.inventory_slot = ::std::option::Option::None;
    }

    pub fn has_inventory_slot(&self) -> bool {
        self.inventory_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory_slot(&mut self, v: i32) {
        self.inventory_slot = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_ReceivedXmasGift {
    const NAME: &'static str = "CDOTAUserMsg_ReceivedXmasGift";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.item_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.inventory_slot = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.item_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.inventory_slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.item_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.inventory_slot {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ReceivedXmasGift {
        CDOTAUserMsg_ReceivedXmasGift::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.item_name = ::std::option::Option::None;
        self.inventory_slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ReceivedXmasGift {
        static instance: CDOTAUserMsg_ReceivedXmasGift = CDOTAUserMsg_ReceivedXmasGift {
            player_id: ::std::option::Option::None,
            item_name: ::std::option::Option::None,
            inventory_slot: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_ShowSurvey)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ShowSurvey {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_ShowSurvey.survey_id)
    pub survey_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ShowSurvey.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ShowSurvey.response_style)
    pub response_style: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ShowSurvey.teammate_hero_id)
    pub teammate_hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ShowSurvey.teammate_name)
    pub teammate_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ShowSurvey.teammate_account_id)
    pub teammate_account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_ShowSurvey.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ShowSurvey {
    fn default() -> &'a CDOTAUserMsg_ShowSurvey {
        <CDOTAUserMsg_ShowSurvey as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ShowSurvey {
    pub fn new() -> CDOTAUserMsg_ShowSurvey {
        ::std::default::Default::default()
    }

    // optional int32 survey_id = 1;

    pub fn survey_id(&self) -> i32 {
        self.survey_id.unwrap_or(0)
    }

    pub fn clear_survey_id(&mut self) {
        self.survey_id = ::std::option::Option::None;
    }

    pub fn has_survey_id(&self) -> bool {
        self.survey_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_id(&mut self, v: i32) {
        self.survey_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional string response_style = 3;

    pub fn response_style(&self) -> &str {
        match self.response_style.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_response_style(&mut self) {
        self.response_style = ::std::option::Option::None;
    }

    pub fn has_response_style(&self) -> bool {
        self.response_style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_style(&mut self, v: ::std::string::String) {
        self.response_style = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response_style(&mut self) -> &mut ::std::string::String {
        if self.response_style.is_none() {
            self.response_style = ::std::option::Option::Some(::std::string::String::new());
        }
        self.response_style.as_mut().unwrap()
    }

    // Take field
    pub fn take_response_style(&mut self) -> ::std::string::String {
        self.response_style.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 teammate_hero_id = 4;

    pub fn teammate_hero_id(&self) -> i32 {
        self.teammate_hero_id.unwrap_or(0)
    }

    pub fn clear_teammate_hero_id(&mut self) {
        self.teammate_hero_id = ::std::option::Option::None;
    }

    pub fn has_teammate_hero_id(&self) -> bool {
        self.teammate_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teammate_hero_id(&mut self, v: i32) {
        self.teammate_hero_id = ::std::option::Option::Some(v);
    }

    // optional string teammate_name = 5;

    pub fn teammate_name(&self) -> &str {
        match self.teammate_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_teammate_name(&mut self) {
        self.teammate_name = ::std::option::Option::None;
    }

    pub fn has_teammate_name(&self) -> bool {
        self.teammate_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teammate_name(&mut self, v: ::std::string::String) {
        self.teammate_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_teammate_name(&mut self) -> &mut ::std::string::String {
        if self.teammate_name.is_none() {
            self.teammate_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.teammate_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_teammate_name(&mut self) -> ::std::string::String {
        self.teammate_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 teammate_account_id = 6;

    pub fn teammate_account_id(&self) -> u32 {
        self.teammate_account_id.unwrap_or(0)
    }

    pub fn clear_teammate_account_id(&mut self) {
        self.teammate_account_id = ::std::option::Option::None;
    }

    pub fn has_teammate_account_id(&self) -> bool {
        self.teammate_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teammate_account_id(&mut self, v: u32) {
        self.teammate_account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_ShowSurvey {
    const NAME: &'static str = "CDOTAUserMsg_ShowSurvey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.survey_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.response_style = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.teammate_hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.teammate_name = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.teammate_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.survey_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.response_style.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.teammate_hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.teammate_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.teammate_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.survey_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.response_style.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.teammate_hero_id {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.teammate_name.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.teammate_account_id {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ShowSurvey {
        CDOTAUserMsg_ShowSurvey::new()
    }

    fn clear(&mut self) {
        self.survey_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.response_style = ::std::option::Option::None;
        self.teammate_hero_id = ::std::option::Option::None;
        self.teammate_name = ::std::option::Option::None;
        self.teammate_account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ShowSurvey {
        static instance: CDOTAUserMsg_ShowSurvey = CDOTAUserMsg_ShowSurvey {
            survey_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            response_style: ::std::option::Option::None,
            teammate_hero_id: ::std::option::Option::None,
            teammate_name: ::std::option::Option::None,
            teammate_account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_UpdateSharedContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_UpdateSharedContent {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_UpdateSharedContent.slot_type)
    pub slot_type: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_UpdateSharedContent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_UpdateSharedContent {
    fn default() -> &'a CDOTAUserMsg_UpdateSharedContent {
        <CDOTAUserMsg_UpdateSharedContent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_UpdateSharedContent {
    pub fn new() -> CDOTAUserMsg_UpdateSharedContent {
        ::std::default::Default::default()
    }

    // optional int32 slot_type = 1;

    pub fn slot_type(&self) -> i32 {
        self.slot_type.unwrap_or(0)
    }

    pub fn clear_slot_type(&mut self) {
        self.slot_type = ::std::option::Option::None;
    }

    pub fn has_slot_type(&self) -> bool {
        self.slot_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_type(&mut self, v: i32) {
        self.slot_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_UpdateSharedContent {
    const NAME: &'static str = "CDOTAUserMsg_UpdateSharedContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.slot_type = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.slot_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.slot_type {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_UpdateSharedContent {
        CDOTAUserMsg_UpdateSharedContent::new()
    }

    fn clear(&mut self) {
        self.slot_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_UpdateSharedContent {
        static instance: CDOTAUserMsg_UpdateSharedContent = CDOTAUserMsg_UpdateSharedContent {
            slot_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_TutorialRequestExp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TutorialRequestExp {
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_TutorialRequestExp.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TutorialRequestExp {
    fn default() -> &'a CDOTAUserMsg_TutorialRequestExp {
        <CDOTAUserMsg_TutorialRequestExp as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TutorialRequestExp {
    pub fn new() -> CDOTAUserMsg_TutorialRequestExp {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_TutorialRequestExp {
    const NAME: &'static str = "CDOTAUserMsg_TutorialRequestExp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TutorialRequestExp {
        CDOTAUserMsg_TutorialRequestExp::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TutorialRequestExp {
        static instance: CDOTAUserMsg_TutorialRequestExp = CDOTAUserMsg_TutorialRequestExp {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_TutorialFade)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TutorialFade {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_TutorialFade.tgt_alpha)
    pub tgt_alpha: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_TutorialFade.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TutorialFade {
    fn default() -> &'a CDOTAUserMsg_TutorialFade {
        <CDOTAUserMsg_TutorialFade as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TutorialFade {
    pub fn new() -> CDOTAUserMsg_TutorialFade {
        ::std::default::Default::default()
    }

    // optional int32 tgt_alpha = 1;

    pub fn tgt_alpha(&self) -> i32 {
        self.tgt_alpha.unwrap_or(0)
    }

    pub fn clear_tgt_alpha(&mut self) {
        self.tgt_alpha = ::std::option::Option::None;
    }

    pub fn has_tgt_alpha(&self) -> bool {
        self.tgt_alpha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tgt_alpha(&mut self, v: i32) {
        self.tgt_alpha = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_TutorialFade {
    const NAME: &'static str = "CDOTAUserMsg_TutorialFade";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tgt_alpha = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tgt_alpha {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.tgt_alpha {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TutorialFade {
        CDOTAUserMsg_TutorialFade::new()
    }

    fn clear(&mut self) {
        self.tgt_alpha = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TutorialFade {
        static instance: CDOTAUserMsg_TutorialFade = CDOTAUserMsg_TutorialFade {
            tgt_alpha: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_TutorialPingMinimap)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TutorialPingMinimap {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_TutorialPingMinimap.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TutorialPingMinimap.pos_x)
    pub pos_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TutorialPingMinimap.pos_y)
    pub pos_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TutorialPingMinimap.pos_z)
    pub pos_z: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TutorialPingMinimap.entity_index)
    pub entity_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_TutorialPingMinimap.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TutorialPingMinimap {
    fn default() -> &'a CDOTAUserMsg_TutorialPingMinimap {
        <CDOTAUserMsg_TutorialPingMinimap as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TutorialPingMinimap {
    pub fn new() -> CDOTAUserMsg_TutorialPingMinimap {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional float pos_x = 2;

    pub fn pos_x(&self) -> f32 {
        self.pos_x.unwrap_or(0.)
    }

    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: f32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // optional float pos_y = 3;

    pub fn pos_y(&self) -> f32 {
        self.pos_y.unwrap_or(0.)
    }

    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: f32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // optional float pos_z = 4;

    pub fn pos_z(&self) -> f32 {
        self.pos_z.unwrap_or(0.)
    }

    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: f32) {
        self.pos_z = ::std::option::Option::Some(v);
    }

    // optional int32 entity_index = 5;

    pub fn entity_index(&self) -> i32 {
        self.entity_index.unwrap_or(0)
    }

    pub fn clear_entity_index(&mut self) {
        self.entity_index = ::std::option::Option::None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: i32) {
        self.entity_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_TutorialPingMinimap {
    const NAME: &'static str = "CDOTAUserMsg_TutorialPingMinimap";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.pos_x = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.pos_y = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.pos_z = ::std::option::Option::Some(is.read_float()?);
                },
                40 => {
                    self.entity_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.pos_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pos_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pos_z {
            my_size += 1 + 4;
        }
        if let Some(v) = self.entity_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pos_x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.entity_index {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TutorialPingMinimap {
        CDOTAUserMsg_TutorialPingMinimap::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.entity_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TutorialPingMinimap {
        static instance: CDOTAUserMsg_TutorialPingMinimap = CDOTAUserMsg_TutorialPingMinimap {
            player_id: ::std::option::Option::None,
            pos_x: ::std::option::Option::None,
            pos_y: ::std::option::Option::None,
            pos_z: ::std::option::Option::None,
            entity_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_GamerulesStateChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_GamerulesStateChanged {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_GamerulesStateChanged.state)
    pub state: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_GamerulesStateChanged.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_GamerulesStateChanged {
    fn default() -> &'a CDOTAUserMsg_GamerulesStateChanged {
        <CDOTAUserMsg_GamerulesStateChanged as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_GamerulesStateChanged {
    pub fn new() -> CDOTAUserMsg_GamerulesStateChanged {
        ::std::default::Default::default()
    }

    // optional uint32 state = 1;

    pub fn state(&self) -> u32 {
        self.state.unwrap_or(0)
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: u32) {
        self.state = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_GamerulesStateChanged {
    const NAME: &'static str = "CDOTAUserMsg_GamerulesStateChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.state = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.state {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_GamerulesStateChanged {
        CDOTAUserMsg_GamerulesStateChanged::new()
    }

    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_GamerulesStateChanged {
        static instance: CDOTAUserMsg_GamerulesStateChanged = CDOTAUserMsg_GamerulesStateChanged {
            state: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_AddQuestLogEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_AddQuestLogEntry {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_AddQuestLogEntry.npc_name)
    pub npc_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AddQuestLogEntry.npc_dialog)
    pub npc_dialog: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_AddQuestLogEntry.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_AddQuestLogEntry {
    fn default() -> &'a CDOTAUserMsg_AddQuestLogEntry {
        <CDOTAUserMsg_AddQuestLogEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_AddQuestLogEntry {
    pub fn new() -> CDOTAUserMsg_AddQuestLogEntry {
        ::std::default::Default::default()
    }

    // optional string npc_name = 1;

    pub fn npc_name(&self) -> &str {
        match self.npc_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_npc_name(&mut self) {
        self.npc_name = ::std::option::Option::None;
    }

    pub fn has_npc_name(&self) -> bool {
        self.npc_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_npc_name(&mut self, v: ::std::string::String) {
        self.npc_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_npc_name(&mut self) -> &mut ::std::string::String {
        if self.npc_name.is_none() {
            self.npc_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.npc_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_npc_name(&mut self) -> ::std::string::String {
        self.npc_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string npc_dialog = 2;

    pub fn npc_dialog(&self) -> &str {
        match self.npc_dialog.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_npc_dialog(&mut self) {
        self.npc_dialog = ::std::option::Option::None;
    }

    pub fn has_npc_dialog(&self) -> bool {
        self.npc_dialog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_npc_dialog(&mut self, v: ::std::string::String) {
        self.npc_dialog = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_npc_dialog(&mut self) -> &mut ::std::string::String {
        if self.npc_dialog.is_none() {
            self.npc_dialog = ::std::option::Option::Some(::std::string::String::new());
        }
        self.npc_dialog.as_mut().unwrap()
    }

    // Take field
    pub fn take_npc_dialog(&mut self) -> ::std::string::String {
        self.npc_dialog.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_AddQuestLogEntry {
    const NAME: &'static str = "CDOTAUserMsg_AddQuestLogEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.npc_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.npc_dialog = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.npc_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.npc_dialog.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.npc_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.npc_dialog.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_AddQuestLogEntry {
        CDOTAUserMsg_AddQuestLogEntry::new()
    }

    fn clear(&mut self) {
        self.npc_name = ::std::option::Option::None;
        self.npc_dialog = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_AddQuestLogEntry {
        static instance: CDOTAUserMsg_AddQuestLogEntry = CDOTAUserMsg_AddQuestLogEntry {
            npc_name: ::std::option::Option::None,
            npc_dialog: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_SendStatPopup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SendStatPopup {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_SendStatPopup.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SendStatPopup.statpopup)
    pub statpopup: ::steam_vent_proto_common::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_SendStatPopup>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_SendStatPopup.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SendStatPopup {
    fn default() -> &'a CDOTAUserMsg_SendStatPopup {
        <CDOTAUserMsg_SendStatPopup as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SendStatPopup {
    pub fn new() -> CDOTAUserMsg_SendStatPopup {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_SendStatPopup {
    const NAME: &'static str = "CDOTAUserMsg_SendStatPopup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.statpopup)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.statpopup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.statpopup.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SendStatPopup {
        CDOTAUserMsg_SendStatPopup::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.statpopup.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SendStatPopup {
        static instance: CDOTAUserMsg_SendStatPopup = CDOTAUserMsg_SendStatPopup {
            player_id: ::std::option::Option::None,
            statpopup: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_DismissAllStatPopups)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_DismissAllStatPopups {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_DismissAllStatPopups.dismissallmsg)
    pub dismissallmsg: ::steam_vent_proto_common::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_DismissAllStatPopups>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_DismissAllStatPopups.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_DismissAllStatPopups {
    fn default() -> &'a CDOTAUserMsg_DismissAllStatPopups {
        <CDOTAUserMsg_DismissAllStatPopups as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_DismissAllStatPopups {
    pub fn new() -> CDOTAUserMsg_DismissAllStatPopups {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_DismissAllStatPopups {
    const NAME: &'static str = "CDOTAUserMsg_DismissAllStatPopups";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.dismissallmsg)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dismissallmsg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.dismissallmsg.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_DismissAllStatPopups {
        CDOTAUserMsg_DismissAllStatPopups::new()
    }

    fn clear(&mut self) {
        self.dismissallmsg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_DismissAllStatPopups {
        static instance: CDOTAUserMsg_DismissAllStatPopups = CDOTAUserMsg_DismissAllStatPopups {
            dismissallmsg: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_SendRoshanSpectatorPhase)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SendRoshanSpectatorPhase {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_SendRoshanSpectatorPhase.phase)
    pub phase: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<DOTA_ROSHAN_PHASE>>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SendRoshanSpectatorPhase.phase_start_time)
    pub phase_start_time: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SendRoshanSpectatorPhase.phase_length)
    pub phase_length: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_SendRoshanSpectatorPhase.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SendRoshanSpectatorPhase {
    fn default() -> &'a CDOTAUserMsg_SendRoshanSpectatorPhase {
        <CDOTAUserMsg_SendRoshanSpectatorPhase as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SendRoshanSpectatorPhase {
    pub fn new() -> CDOTAUserMsg_SendRoshanSpectatorPhase {
        ::std::default::Default::default()
    }

    // optional .DOTA_ROSHAN_PHASE phase = 1;

    pub fn phase(&self) -> DOTA_ROSHAN_PHASE {
        match self.phase {
            Some(e) => e.enum_value_or(DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_ALIVE),
            None => DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_ALIVE,
        }
    }

    pub fn clear_phase(&mut self) {
        self.phase = ::std::option::Option::None;
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: DOTA_ROSHAN_PHASE) {
        self.phase = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 phase_start_time = 2;

    pub fn phase_start_time(&self) -> i32 {
        self.phase_start_time.unwrap_or(0)
    }

    pub fn clear_phase_start_time(&mut self) {
        self.phase_start_time = ::std::option::Option::None;
    }

    pub fn has_phase_start_time(&self) -> bool {
        self.phase_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase_start_time(&mut self, v: i32) {
        self.phase_start_time = ::std::option::Option::Some(v);
    }

    // optional int32 phase_length = 3;

    pub fn phase_length(&self) -> i32 {
        self.phase_length.unwrap_or(0)
    }

    pub fn clear_phase_length(&mut self) {
        self.phase_length = ::std::option::Option::None;
    }

    pub fn has_phase_length(&self) -> bool {
        self.phase_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase_length(&mut self, v: i32) {
        self.phase_length = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_SendRoshanSpectatorPhase {
    const NAME: &'static str = "CDOTAUserMsg_SendRoshanSpectatorPhase";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.phase = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.phase_start_time = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.phase_length = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.phase {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.phase_start_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.phase_length {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.phase {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.phase_start_time {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.phase_length {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SendRoshanSpectatorPhase {
        CDOTAUserMsg_SendRoshanSpectatorPhase::new()
    }

    fn clear(&mut self) {
        self.phase = ::std::option::Option::None;
        self.phase_start_time = ::std::option::Option::None;
        self.phase_length = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SendRoshanSpectatorPhase {
        static instance: CDOTAUserMsg_SendRoshanSpectatorPhase = CDOTAUserMsg_SendRoshanSpectatorPhase {
            phase: ::std::option::Option::None,
            phase_start_time: ::std::option::Option::None,
            phase_length: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_SendRoshanPopup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SendRoshanPopup {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_SendRoshanPopup.reclaimed)
    pub reclaimed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SendRoshanPopup.gametime)
    pub gametime: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_SendRoshanPopup.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SendRoshanPopup {
    fn default() -> &'a CDOTAUserMsg_SendRoshanPopup {
        <CDOTAUserMsg_SendRoshanPopup as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SendRoshanPopup {
    pub fn new() -> CDOTAUserMsg_SendRoshanPopup {
        ::std::default::Default::default()
    }

    // optional bool reclaimed = 1;

    pub fn reclaimed(&self) -> bool {
        self.reclaimed.unwrap_or(false)
    }

    pub fn clear_reclaimed(&mut self) {
        self.reclaimed = ::std::option::Option::None;
    }

    pub fn has_reclaimed(&self) -> bool {
        self.reclaimed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reclaimed(&mut self, v: bool) {
        self.reclaimed = ::std::option::Option::Some(v);
    }

    // optional int32 gametime = 2;

    pub fn gametime(&self) -> i32 {
        self.gametime.unwrap_or(0)
    }

    pub fn clear_gametime(&mut self) {
        self.gametime = ::std::option::Option::None;
    }

    pub fn has_gametime(&self) -> bool {
        self.gametime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gametime(&mut self, v: i32) {
        self.gametime = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_SendRoshanPopup {
    const NAME: &'static str = "CDOTAUserMsg_SendRoshanPopup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reclaimed = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.gametime = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reclaimed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.gametime {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.reclaimed {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.gametime {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SendRoshanPopup {
        CDOTAUserMsg_SendRoshanPopup::new()
    }

    fn clear(&mut self) {
        self.reclaimed = ::std::option::Option::None;
        self.gametime = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SendRoshanPopup {
        static instance: CDOTAUserMsg_SendRoshanPopup = CDOTAUserMsg_SendRoshanPopup {
            reclaimed: ::std::option::Option::None,
            gametime: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_SendFinalGold)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SendFinalGold {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_SendFinalGold.reliable_gold)
    pub reliable_gold: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SendFinalGold.unreliable_gold)
    pub unreliable_gold: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_SendFinalGold.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SendFinalGold {
    fn default() -> &'a CDOTAUserMsg_SendFinalGold {
        <CDOTAUserMsg_SendFinalGold as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SendFinalGold {
    pub fn new() -> CDOTAUserMsg_SendFinalGold {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_SendFinalGold {
    const NAME: &'static str = "CDOTAUserMsg_SendFinalGold";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.reliable_gold)?;
                },
                8 => {
                    self.reliable_gold.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.unreliable_gold)?;
                },
                16 => {
                    self.unreliable_gold.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.reliable_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.unreliable_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.reliable_gold {
            os.write_uint32(1, *v)?;
        };
        for v in &self.unreliable_gold {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SendFinalGold {
        CDOTAUserMsg_SendFinalGold::new()
    }

    fn clear(&mut self) {
        self.reliable_gold.clear();
        self.unreliable_gold.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SendFinalGold {
        static instance: CDOTAUserMsg_SendFinalGold = CDOTAUserMsg_SendFinalGold {
            reliable_gold: ::std::vec::Vec::new(),
            unreliable_gold: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_CustomMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CustomMsg {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_CustomMsg.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CustomMsg.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CustomMsg.value)
    pub value: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_CustomMsg.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CustomMsg {
    fn default() -> &'a CDOTAUserMsg_CustomMsg {
        <CDOTAUserMsg_CustomMsg as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CustomMsg {
    pub fn new() -> CDOTAUserMsg_CustomMsg {
        ::std::default::Default::default()
    }

    // optional string message = 1;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 player_id = 2;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 value = 3;

    pub fn value(&self) -> i32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_CustomMsg {
    const NAME: &'static str = "CDOTAUserMsg_CustomMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.value = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.value {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.value {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CustomMsg {
        CDOTAUserMsg_CustomMsg::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.player_id = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CustomMsg {
        static instance: CDOTAUserMsg_CustomMsg = CDOTAUserMsg_CustomMsg {
            message: ::std::option::Option::None,
            player_id: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_CoachHUDPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CoachHUDPing {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_CoachHUDPing.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CoachHUDPing.hud_ping)
    pub hud_ping: ::steam_vent_proto_common::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_CoachHUDPing>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_CoachHUDPing.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CoachHUDPing {
    fn default() -> &'a CDOTAUserMsg_CoachHUDPing {
        <CDOTAUserMsg_CoachHUDPing as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CoachHUDPing {
    pub fn new() -> CDOTAUserMsg_CoachHUDPing {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_CoachHUDPing {
    const NAME: &'static str = "CDOTAUserMsg_CoachHUDPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.hud_ping)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.hud_ping.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.hud_ping.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CoachHUDPing {
        CDOTAUserMsg_CoachHUDPing::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.hud_ping.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CoachHUDPing {
        static instance: CDOTAUserMsg_CoachHUDPing = CDOTAUserMsg_CoachHUDPing {
            player_id: ::std::option::Option::None,
            hud_ping: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_ClientLoadGridNav)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ClientLoadGridNav {
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_ClientLoadGridNav.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ClientLoadGridNav {
    fn default() -> &'a CDOTAUserMsg_ClientLoadGridNav {
        <CDOTAUserMsg_ClientLoadGridNav as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ClientLoadGridNav {
    pub fn new() -> CDOTAUserMsg_ClientLoadGridNav {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_ClientLoadGridNav {
    const NAME: &'static str = "CDOTAUserMsg_ClientLoadGridNav";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ClientLoadGridNav {
        CDOTAUserMsg_ClientLoadGridNav::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ClientLoadGridNav {
        static instance: CDOTAUserMsg_ClientLoadGridNav = CDOTAUserMsg_ClientLoadGridNav {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_TE_Projectile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TE_Projectile {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_Projectile.source)
    pub source: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_Projectile.target)
    pub target: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_Projectile.move_speed)
    pub move_speed: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_Projectile.source_attachment)
    pub source_attachment: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_Projectile.particle_system_handle)
    pub particle_system_handle: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_Projectile.dodgeable)
    pub dodgeable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_Projectile.is_attack)
    pub is_attack: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_Projectile.expire_time)
    pub expire_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_Projectile.maximpacttime)
    pub maximpacttime: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_Projectile.colorgemcolor)
    pub colorgemcolor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_Projectile.launch_tick)
    pub launch_tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_Projectile.handle)
    pub handle: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_Projectile.target_loc)
    pub target_loc: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_Projectile.particle_cp_data)
    pub particle_cp_data: ::std::vec::Vec<CDOTAUserMsg_ProjectileParticleCPData>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_Projectile.additional_particle_system_handle)
    pub additional_particle_system_handle: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_Projectile.original_move_speed)
    pub original_move_speed: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_Projectile.ability)
    pub ability: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_TE_Projectile.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TE_Projectile {
    fn default() -> &'a CDOTAUserMsg_TE_Projectile {
        <CDOTAUserMsg_TE_Projectile as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TE_Projectile {
    pub fn new() -> CDOTAUserMsg_TE_Projectile {
        ::std::default::Default::default()
    }

    // optional uint32 source = 1;

    pub fn source(&self) -> u32 {
        self.source.unwrap_or(16777215u32)
    }

    pub fn clear_source(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: u32) {
        self.source = ::std::option::Option::Some(v);
    }

    // optional uint32 target = 2;

    pub fn target(&self) -> u32 {
        self.target.unwrap_or(16777215u32)
    }

    pub fn clear_target(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: u32) {
        self.target = ::std::option::Option::Some(v);
    }

    // optional int32 move_speed = 3;

    pub fn move_speed(&self) -> i32 {
        self.move_speed.unwrap_or(0)
    }

    pub fn clear_move_speed(&mut self) {
        self.move_speed = ::std::option::Option::None;
    }

    pub fn has_move_speed(&self) -> bool {
        self.move_speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_move_speed(&mut self, v: i32) {
        self.move_speed = ::std::option::Option::Some(v);
    }

    // optional int32 source_attachment = 4;

    pub fn source_attachment(&self) -> i32 {
        self.source_attachment.unwrap_or(0)
    }

    pub fn clear_source_attachment(&mut self) {
        self.source_attachment = ::std::option::Option::None;
    }

    pub fn has_source_attachment(&self) -> bool {
        self.source_attachment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_attachment(&mut self, v: i32) {
        self.source_attachment = ::std::option::Option::Some(v);
    }

    // optional int64 particle_system_handle = 5;

    pub fn particle_system_handle(&self) -> i64 {
        self.particle_system_handle.unwrap_or(0)
    }

    pub fn clear_particle_system_handle(&mut self) {
        self.particle_system_handle = ::std::option::Option::None;
    }

    pub fn has_particle_system_handle(&self) -> bool {
        self.particle_system_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_system_handle(&mut self, v: i64) {
        self.particle_system_handle = ::std::option::Option::Some(v);
    }

    // optional bool dodgeable = 6;

    pub fn dodgeable(&self) -> bool {
        self.dodgeable.unwrap_or(false)
    }

    pub fn clear_dodgeable(&mut self) {
        self.dodgeable = ::std::option::Option::None;
    }

    pub fn has_dodgeable(&self) -> bool {
        self.dodgeable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dodgeable(&mut self, v: bool) {
        self.dodgeable = ::std::option::Option::Some(v);
    }

    // optional bool is_attack = 7;

    pub fn is_attack(&self) -> bool {
        self.is_attack.unwrap_or(false)
    }

    pub fn clear_is_attack(&mut self) {
        self.is_attack = ::std::option::Option::None;
    }

    pub fn has_is_attack(&self) -> bool {
        self.is_attack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_attack(&mut self, v: bool) {
        self.is_attack = ::std::option::Option::Some(v);
    }

    // optional float expire_time = 9;

    pub fn expire_time(&self) -> f32 {
        self.expire_time.unwrap_or(0.)
    }

    pub fn clear_expire_time(&mut self) {
        self.expire_time = ::std::option::Option::None;
    }

    pub fn has_expire_time(&self) -> bool {
        self.expire_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expire_time(&mut self, v: f32) {
        self.expire_time = ::std::option::Option::Some(v);
    }

    // optional float maximpacttime = 10;

    pub fn maximpacttime(&self) -> f32 {
        self.maximpacttime.unwrap_or(0.)
    }

    pub fn clear_maximpacttime(&mut self) {
        self.maximpacttime = ::std::option::Option::None;
    }

    pub fn has_maximpacttime(&self) -> bool {
        self.maximpacttime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximpacttime(&mut self, v: f32) {
        self.maximpacttime = ::std::option::Option::Some(v);
    }

    // optional fixed32 colorgemcolor = 11;

    pub fn colorgemcolor(&self) -> u32 {
        self.colorgemcolor.unwrap_or(0)
    }

    pub fn clear_colorgemcolor(&mut self) {
        self.colorgemcolor = ::std::option::Option::None;
    }

    pub fn has_colorgemcolor(&self) -> bool {
        self.colorgemcolor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_colorgemcolor(&mut self, v: u32) {
        self.colorgemcolor = ::std::option::Option::Some(v);
    }

    // optional int32 launch_tick = 12;

    pub fn launch_tick(&self) -> i32 {
        self.launch_tick.unwrap_or(0)
    }

    pub fn clear_launch_tick(&mut self) {
        self.launch_tick = ::std::option::Option::None;
    }

    pub fn has_launch_tick(&self) -> bool {
        self.launch_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launch_tick(&mut self, v: i32) {
        self.launch_tick = ::std::option::Option::Some(v);
    }

    // optional int32 handle = 13;

    pub fn handle(&self) -> i32 {
        self.handle.unwrap_or(0)
    }

    pub fn clear_handle(&mut self) {
        self.handle = ::std::option::Option::None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: i32) {
        self.handle = ::std::option::Option::Some(v);
    }

    // optional int64 additional_particle_system_handle = 16;

    pub fn additional_particle_system_handle(&self) -> i64 {
        self.additional_particle_system_handle.unwrap_or(0)
    }

    pub fn clear_additional_particle_system_handle(&mut self) {
        self.additional_particle_system_handle = ::std::option::Option::None;
    }

    pub fn has_additional_particle_system_handle(&self) -> bool {
        self.additional_particle_system_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_particle_system_handle(&mut self, v: i64) {
        self.additional_particle_system_handle = ::std::option::Option::Some(v);
    }

    // optional int32 original_move_speed = 17;

    pub fn original_move_speed(&self) -> i32 {
        self.original_move_speed.unwrap_or(0)
    }

    pub fn clear_original_move_speed(&mut self) {
        self.original_move_speed = ::std::option::Option::None;
    }

    pub fn has_original_move_speed(&self) -> bool {
        self.original_move_speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_move_speed(&mut self, v: i32) {
        self.original_move_speed = ::std::option::Option::Some(v);
    }

    // optional uint32 ability = 18;

    pub fn ability(&self) -> u32 {
        self.ability.unwrap_or(16777215u32)
    }

    pub fn clear_ability(&mut self) {
        self.ability = ::std::option::Option::None;
    }

    pub fn has_ability(&self) -> bool {
        self.ability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability(&mut self, v: u32) {
        self.ability = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_TE_Projectile {
    const NAME: &'static str = "CDOTAUserMsg_TE_Projectile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.move_speed = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.source_attachment = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.particle_system_handle = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.dodgeable = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.is_attack = ::std::option::Option::Some(is.read_bool()?);
                },
                77 => {
                    self.expire_time = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.maximpacttime = ::std::option::Option::Some(is.read_float()?);
                },
                93 => {
                    self.colorgemcolor = ::std::option::Option::Some(is.read_fixed32()?);
                },
                96 => {
                    self.launch_tick = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.handle = ::std::option::Option::Some(is.read_int32()?);
                },
                114 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.target_loc)?;
                },
                122 => {
                    self.particle_cp_data.push(is.read_message()?);
                },
                128 => {
                    self.additional_particle_system_handle = ::std::option::Option::Some(is.read_int64()?);
                },
                136 => {
                    self.original_move_speed = ::std::option::Option::Some(is.read_int32()?);
                },
                144 => {
                    self.ability = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.move_speed {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.source_attachment {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.particle_system_handle {
            my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.dodgeable {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_attack {
            my_size += 1 + 1;
        }
        if let Some(v) = self.expire_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.maximpacttime {
            my_size += 1 + 4;
        }
        if let Some(v) = self.colorgemcolor {
            my_size += 1 + 4;
        }
        if let Some(v) = self.launch_tick {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.handle {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.target_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.particle_cp_data {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.additional_particle_system_handle {
            my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(16, v);
        }
        if let Some(v) = self.original_move_speed {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(17, v);
        }
        if let Some(v) = self.ability {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.source {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.move_speed {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.source_attachment {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.particle_system_handle {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.dodgeable {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.is_attack {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.expire_time {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.maximpacttime {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.colorgemcolor {
            os.write_fixed32(11, v)?;
        }
        if let Some(v) = self.launch_tick {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.handle {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.target_loc.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        for v in &self.particle_cp_data {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        if let Some(v) = self.additional_particle_system_handle {
            os.write_int64(16, v)?;
        }
        if let Some(v) = self.original_move_speed {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.ability {
            os.write_uint32(18, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TE_Projectile {
        CDOTAUserMsg_TE_Projectile::new()
    }

    fn clear(&mut self) {
        self.source = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.move_speed = ::std::option::Option::None;
        self.source_attachment = ::std::option::Option::None;
        self.particle_system_handle = ::std::option::Option::None;
        self.dodgeable = ::std::option::Option::None;
        self.is_attack = ::std::option::Option::None;
        self.expire_time = ::std::option::Option::None;
        self.maximpacttime = ::std::option::Option::None;
        self.colorgemcolor = ::std::option::Option::None;
        self.launch_tick = ::std::option::Option::None;
        self.handle = ::std::option::Option::None;
        self.target_loc.clear();
        self.particle_cp_data.clear();
        self.additional_particle_system_handle = ::std::option::Option::None;
        self.original_move_speed = ::std::option::Option::None;
        self.ability = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TE_Projectile {
        static instance: CDOTAUserMsg_TE_Projectile = CDOTAUserMsg_TE_Projectile {
            source: ::std::option::Option::None,
            target: ::std::option::Option::None,
            move_speed: ::std::option::Option::None,
            source_attachment: ::std::option::Option::None,
            particle_system_handle: ::std::option::Option::None,
            dodgeable: ::std::option::Option::None,
            is_attack: ::std::option::Option::None,
            expire_time: ::std::option::Option::None,
            maximpacttime: ::std::option::Option::None,
            colorgemcolor: ::std::option::Option::None,
            launch_tick: ::std::option::Option::None,
            handle: ::std::option::Option::None,
            target_loc: ::steam_vent_proto_common::protobuf::MessageField::none(),
            particle_cp_data: ::std::vec::Vec::new(),
            additional_particle_system_handle: ::std::option::Option::None,
            original_move_speed: ::std::option::Option::None,
            ability: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_TE_ProjectileLoc)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TE_ProjectileLoc {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_ProjectileLoc.source_loc)
    pub source_loc: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_ProjectileLoc.target)
    pub target: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_ProjectileLoc.move_speed)
    pub move_speed: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_ProjectileLoc.particle_system_handle)
    pub particle_system_handle: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_ProjectileLoc.dodgeable)
    pub dodgeable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_ProjectileLoc.is_attack)
    pub is_attack: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_ProjectileLoc.expire_time)
    pub expire_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_ProjectileLoc.target_loc)
    pub target_loc: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_ProjectileLoc.colorgemcolor)
    pub colorgemcolor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_ProjectileLoc.launch_tick)
    pub launch_tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_ProjectileLoc.handle)
    pub handle: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_ProjectileLoc.source)
    pub source: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_ProjectileLoc.source_attachment)
    pub source_attachment: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_ProjectileLoc.particle_cp_data)
    pub particle_cp_data: ::std::vec::Vec<CDOTAUserMsg_ProjectileParticleCPData>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_ProjectileLoc.additional_particle_system_handle)
    pub additional_particle_system_handle: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_ProjectileLoc.original_move_speed)
    pub original_move_speed: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_TE_ProjectileLoc.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TE_ProjectileLoc {
    fn default() -> &'a CDOTAUserMsg_TE_ProjectileLoc {
        <CDOTAUserMsg_TE_ProjectileLoc as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TE_ProjectileLoc {
    pub fn new() -> CDOTAUserMsg_TE_ProjectileLoc {
        ::std::default::Default::default()
    }

    // optional uint32 target = 2;

    pub fn target(&self) -> u32 {
        self.target.unwrap_or(16777215u32)
    }

    pub fn clear_target(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: u32) {
        self.target = ::std::option::Option::Some(v);
    }

    // optional int32 move_speed = 3;

    pub fn move_speed(&self) -> i32 {
        self.move_speed.unwrap_or(0)
    }

    pub fn clear_move_speed(&mut self) {
        self.move_speed = ::std::option::Option::None;
    }

    pub fn has_move_speed(&self) -> bool {
        self.move_speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_move_speed(&mut self, v: i32) {
        self.move_speed = ::std::option::Option::Some(v);
    }

    // optional int64 particle_system_handle = 4;

    pub fn particle_system_handle(&self) -> i64 {
        self.particle_system_handle.unwrap_or(0)
    }

    pub fn clear_particle_system_handle(&mut self) {
        self.particle_system_handle = ::std::option::Option::None;
    }

    pub fn has_particle_system_handle(&self) -> bool {
        self.particle_system_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_system_handle(&mut self, v: i64) {
        self.particle_system_handle = ::std::option::Option::Some(v);
    }

    // optional bool dodgeable = 5;

    pub fn dodgeable(&self) -> bool {
        self.dodgeable.unwrap_or(false)
    }

    pub fn clear_dodgeable(&mut self) {
        self.dodgeable = ::std::option::Option::None;
    }

    pub fn has_dodgeable(&self) -> bool {
        self.dodgeable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dodgeable(&mut self, v: bool) {
        self.dodgeable = ::std::option::Option::Some(v);
    }

    // optional bool is_attack = 6;

    pub fn is_attack(&self) -> bool {
        self.is_attack.unwrap_or(false)
    }

    pub fn clear_is_attack(&mut self) {
        self.is_attack = ::std::option::Option::None;
    }

    pub fn has_is_attack(&self) -> bool {
        self.is_attack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_attack(&mut self, v: bool) {
        self.is_attack = ::std::option::Option::Some(v);
    }

    // optional float expire_time = 9;

    pub fn expire_time(&self) -> f32 {
        self.expire_time.unwrap_or(0.)
    }

    pub fn clear_expire_time(&mut self) {
        self.expire_time = ::std::option::Option::None;
    }

    pub fn has_expire_time(&self) -> bool {
        self.expire_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expire_time(&mut self, v: f32) {
        self.expire_time = ::std::option::Option::Some(v);
    }

    // optional fixed32 colorgemcolor = 11;

    pub fn colorgemcolor(&self) -> u32 {
        self.colorgemcolor.unwrap_or(0)
    }

    pub fn clear_colorgemcolor(&mut self) {
        self.colorgemcolor = ::std::option::Option::None;
    }

    pub fn has_colorgemcolor(&self) -> bool {
        self.colorgemcolor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_colorgemcolor(&mut self, v: u32) {
        self.colorgemcolor = ::std::option::Option::Some(v);
    }

    // optional int32 launch_tick = 12;

    pub fn launch_tick(&self) -> i32 {
        self.launch_tick.unwrap_or(0)
    }

    pub fn clear_launch_tick(&mut self) {
        self.launch_tick = ::std::option::Option::None;
    }

    pub fn has_launch_tick(&self) -> bool {
        self.launch_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launch_tick(&mut self, v: i32) {
        self.launch_tick = ::std::option::Option::Some(v);
    }

    // optional int32 handle = 13;

    pub fn handle(&self) -> i32 {
        self.handle.unwrap_or(0)
    }

    pub fn clear_handle(&mut self) {
        self.handle = ::std::option::Option::None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: i32) {
        self.handle = ::std::option::Option::Some(v);
    }

    // optional uint32 source = 14;

    pub fn source(&self) -> u32 {
        self.source.unwrap_or(16777215u32)
    }

    pub fn clear_source(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: u32) {
        self.source = ::std::option::Option::Some(v);
    }

    // optional int32 source_attachment = 15;

    pub fn source_attachment(&self) -> i32 {
        self.source_attachment.unwrap_or(0)
    }

    pub fn clear_source_attachment(&mut self) {
        self.source_attachment = ::std::option::Option::None;
    }

    pub fn has_source_attachment(&self) -> bool {
        self.source_attachment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_attachment(&mut self, v: i32) {
        self.source_attachment = ::std::option::Option::Some(v);
    }

    // optional int64 additional_particle_system_handle = 17;

    pub fn additional_particle_system_handle(&self) -> i64 {
        self.additional_particle_system_handle.unwrap_or(0)
    }

    pub fn clear_additional_particle_system_handle(&mut self) {
        self.additional_particle_system_handle = ::std::option::Option::None;
    }

    pub fn has_additional_particle_system_handle(&self) -> bool {
        self.additional_particle_system_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_particle_system_handle(&mut self, v: i64) {
        self.additional_particle_system_handle = ::std::option::Option::Some(v);
    }

    // optional int32 original_move_speed = 18;

    pub fn original_move_speed(&self) -> i32 {
        self.original_move_speed.unwrap_or(0)
    }

    pub fn clear_original_move_speed(&mut self) {
        self.original_move_speed = ::std::option::Option::None;
    }

    pub fn has_original_move_speed(&self) -> bool {
        self.original_move_speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_move_speed(&mut self, v: i32) {
        self.original_move_speed = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_TE_ProjectileLoc {
    const NAME: &'static str = "CDOTAUserMsg_TE_ProjectileLoc";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.source_loc)?;
                },
                16 => {
                    self.target = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.move_speed = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.particle_system_handle = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.dodgeable = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.is_attack = ::std::option::Option::Some(is.read_bool()?);
                },
                77 => {
                    self.expire_time = ::std::option::Option::Some(is.read_float()?);
                },
                82 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.target_loc)?;
                },
                93 => {
                    self.colorgemcolor = ::std::option::Option::Some(is.read_fixed32()?);
                },
                96 => {
                    self.launch_tick = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.handle = ::std::option::Option::Some(is.read_int32()?);
                },
                112 => {
                    self.source = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.source_attachment = ::std::option::Option::Some(is.read_int32()?);
                },
                130 => {
                    self.particle_cp_data.push(is.read_message()?);
                },
                136 => {
                    self.additional_particle_system_handle = ::std::option::Option::Some(is.read_int64()?);
                },
                144 => {
                    self.original_move_speed = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.target {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.move_speed {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.particle_system_handle {
            my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.dodgeable {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_attack {
            my_size += 1 + 1;
        }
        if let Some(v) = self.expire_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.target_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.colorgemcolor {
            my_size += 1 + 4;
        }
        if let Some(v) = self.launch_tick {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.handle {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.source {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.source_attachment {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(15, v);
        }
        for value in &self.particle_cp_data {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.additional_particle_system_handle {
            my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(17, v);
        }
        if let Some(v) = self.original_move_speed {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(18, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.source_loc.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.target {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.move_speed {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.particle_system_handle {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.dodgeable {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.is_attack {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.expire_time {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.target_loc.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.colorgemcolor {
            os.write_fixed32(11, v)?;
        }
        if let Some(v) = self.launch_tick {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.handle {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.source {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.source_attachment {
            os.write_int32(15, v)?;
        }
        for v in &self.particle_cp_data {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        if let Some(v) = self.additional_particle_system_handle {
            os.write_int64(17, v)?;
        }
        if let Some(v) = self.original_move_speed {
            os.write_int32(18, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TE_ProjectileLoc {
        CDOTAUserMsg_TE_ProjectileLoc::new()
    }

    fn clear(&mut self) {
        self.source_loc.clear();
        self.target = ::std::option::Option::None;
        self.move_speed = ::std::option::Option::None;
        self.particle_system_handle = ::std::option::Option::None;
        self.dodgeable = ::std::option::Option::None;
        self.is_attack = ::std::option::Option::None;
        self.expire_time = ::std::option::Option::None;
        self.target_loc.clear();
        self.colorgemcolor = ::std::option::Option::None;
        self.launch_tick = ::std::option::Option::None;
        self.handle = ::std::option::Option::None;
        self.source = ::std::option::Option::None;
        self.source_attachment = ::std::option::Option::None;
        self.particle_cp_data.clear();
        self.additional_particle_system_handle = ::std::option::Option::None;
        self.original_move_speed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TE_ProjectileLoc {
        static instance: CDOTAUserMsg_TE_ProjectileLoc = CDOTAUserMsg_TE_ProjectileLoc {
            source_loc: ::steam_vent_proto_common::protobuf::MessageField::none(),
            target: ::std::option::Option::None,
            move_speed: ::std::option::Option::None,
            particle_system_handle: ::std::option::Option::None,
            dodgeable: ::std::option::Option::None,
            is_attack: ::std::option::Option::None,
            expire_time: ::std::option::Option::None,
            target_loc: ::steam_vent_proto_common::protobuf::MessageField::none(),
            colorgemcolor: ::std::option::Option::None,
            launch_tick: ::std::option::Option::None,
            handle: ::std::option::Option::None,
            source: ::std::option::Option::None,
            source_attachment: ::std::option::Option::None,
            particle_cp_data: ::std::vec::Vec::new(),
            additional_particle_system_handle: ::std::option::Option::None,
            original_move_speed: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_TE_DestroyProjectile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TE_DestroyProjectile {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_DestroyProjectile.handle)
    pub handle: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_TE_DestroyProjectile.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TE_DestroyProjectile {
    fn default() -> &'a CDOTAUserMsg_TE_DestroyProjectile {
        <CDOTAUserMsg_TE_DestroyProjectile as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TE_DestroyProjectile {
    pub fn new() -> CDOTAUserMsg_TE_DestroyProjectile {
        ::std::default::Default::default()
    }

    // optional int32 handle = 1;

    pub fn handle(&self) -> i32 {
        self.handle.unwrap_or(0)
    }

    pub fn clear_handle(&mut self) {
        self.handle = ::std::option::Option::None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: i32) {
        self.handle = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_TE_DestroyProjectile {
    const NAME: &'static str = "CDOTAUserMsg_TE_DestroyProjectile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.handle = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.handle {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.handle {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TE_DestroyProjectile {
        CDOTAUserMsg_TE_DestroyProjectile::new()
    }

    fn clear(&mut self) {
        self.handle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TE_DestroyProjectile {
        static instance: CDOTAUserMsg_TE_DestroyProjectile = CDOTAUserMsg_TE_DestroyProjectile {
            handle: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_TE_DotaBloodImpact)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TE_DotaBloodImpact {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_DotaBloodImpact.entity)
    pub entity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_DotaBloodImpact.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_DotaBloodImpact.xnormal)
    pub xnormal: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_DotaBloodImpact.ynormal)
    pub ynormal: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_TE_DotaBloodImpact.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TE_DotaBloodImpact {
    fn default() -> &'a CDOTAUserMsg_TE_DotaBloodImpact {
        <CDOTAUserMsg_TE_DotaBloodImpact as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TE_DotaBloodImpact {
    pub fn new() -> CDOTAUserMsg_TE_DotaBloodImpact {
        ::std::default::Default::default()
    }

    // optional uint32 entity = 1;

    pub fn entity(&self) -> u32 {
        self.entity.unwrap_or(16777215u32)
    }

    pub fn clear_entity(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: u32) {
        self.entity = ::std::option::Option::Some(v);
    }

    // optional float scale = 2;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional float xnormal = 3;

    pub fn xnormal(&self) -> f32 {
        self.xnormal.unwrap_or(0.)
    }

    pub fn clear_xnormal(&mut self) {
        self.xnormal = ::std::option::Option::None;
    }

    pub fn has_xnormal(&self) -> bool {
        self.xnormal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xnormal(&mut self, v: f32) {
        self.xnormal = ::std::option::Option::Some(v);
    }

    // optional float ynormal = 4;

    pub fn ynormal(&self) -> f32 {
        self.ynormal.unwrap_or(0.)
    }

    pub fn clear_ynormal(&mut self) {
        self.ynormal = ::std::option::Option::None;
    }

    pub fn has_ynormal(&self) -> bool {
        self.ynormal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ynormal(&mut self, v: f32) {
        self.ynormal = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_TE_DotaBloodImpact {
    const NAME: &'static str = "CDOTAUserMsg_TE_DotaBloodImpact";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entity = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.xnormal = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.ynormal = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.xnormal {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ynormal {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.entity {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scale {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.xnormal {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.ynormal {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TE_DotaBloodImpact {
        CDOTAUserMsg_TE_DotaBloodImpact::new()
    }

    fn clear(&mut self) {
        self.entity = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.xnormal = ::std::option::Option::None;
        self.ynormal = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TE_DotaBloodImpact {
        static instance: CDOTAUserMsg_TE_DotaBloodImpact = CDOTAUserMsg_TE_DotaBloodImpact {
            entity: ::std::option::Option::None,
            scale: ::std::option::Option::None,
            xnormal: ::std::option::Option::None,
            ynormal: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_AbilityPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_AbilityPing {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_AbilityPing.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AbilityPing.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AbilityPing.type)
    pub type_: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<DOTA_ABILITY_PING_TYPE>>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AbilityPing.cooldown_seconds)
    pub cooldown_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AbilityPing.level)
    pub level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AbilityPing.passive)
    pub passive: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AbilityPing.mana_needed)
    pub mana_needed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AbilityPing.entity_id)
    pub entity_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AbilityPing.primary_charges)
    pub primary_charges: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AbilityPing.secondary_charges)
    pub secondary_charges: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AbilityPing.ctrl_held)
    pub ctrl_held: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AbilityPing.reclaim_time)
    pub reclaim_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AbilityPing.owner_entity)
    pub owner_entity: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_AbilityPing.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_AbilityPing {
    fn default() -> &'a CDOTAUserMsg_AbilityPing {
        <CDOTAUserMsg_AbilityPing as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_AbilityPing {
    pub fn new() -> CDOTAUserMsg_AbilityPing {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 ability_id = 2;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(-1i32)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional .DOTA_ABILITY_PING_TYPE type = 3;

    pub fn type_(&self) -> DOTA_ABILITY_PING_TYPE {
        match self.type_ {
            Some(e) => e.enum_value_or(DOTA_ABILITY_PING_TYPE::ABILITY_PING_READY),
            None => DOTA_ABILITY_PING_TYPE::ABILITY_PING_READY,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: DOTA_ABILITY_PING_TYPE) {
        self.type_ = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 cooldown_seconds = 4;

    pub fn cooldown_seconds(&self) -> u32 {
        self.cooldown_seconds.unwrap_or(0)
    }

    pub fn clear_cooldown_seconds(&mut self) {
        self.cooldown_seconds = ::std::option::Option::None;
    }

    pub fn has_cooldown_seconds(&self) -> bool {
        self.cooldown_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown_seconds(&mut self, v: u32) {
        self.cooldown_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 level = 5;

    pub fn level(&self) -> u32 {
        self.level.unwrap_or(0)
    }

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }

    // optional bool passive = 6;

    pub fn passive(&self) -> bool {
        self.passive.unwrap_or(false)
    }

    pub fn clear_passive(&mut self) {
        self.passive = ::std::option::Option::None;
    }

    pub fn has_passive(&self) -> bool {
        self.passive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passive(&mut self, v: bool) {
        self.passive = ::std::option::Option::Some(v);
    }

    // optional uint32 mana_needed = 7;

    pub fn mana_needed(&self) -> u32 {
        self.mana_needed.unwrap_or(0)
    }

    pub fn clear_mana_needed(&mut self) {
        self.mana_needed = ::std::option::Option::None;
    }

    pub fn has_mana_needed(&self) -> bool {
        self.mana_needed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mana_needed(&mut self, v: u32) {
        self.mana_needed = ::std::option::Option::Some(v);
    }

    // optional uint32 entity_id = 8;

    pub fn entity_id(&self) -> u32 {
        self.entity_id.unwrap_or(0)
    }

    pub fn clear_entity_id(&mut self) {
        self.entity_id = ::std::option::Option::None;
    }

    pub fn has_entity_id(&self) -> bool {
        self.entity_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_id(&mut self, v: u32) {
        self.entity_id = ::std::option::Option::Some(v);
    }

    // optional int32 primary_charges = 9;

    pub fn primary_charges(&self) -> i32 {
        self.primary_charges.unwrap_or(0)
    }

    pub fn clear_primary_charges(&mut self) {
        self.primary_charges = ::std::option::Option::None;
    }

    pub fn has_primary_charges(&self) -> bool {
        self.primary_charges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_charges(&mut self, v: i32) {
        self.primary_charges = ::std::option::Option::Some(v);
    }

    // optional int32 secondary_charges = 10;

    pub fn secondary_charges(&self) -> i32 {
        self.secondary_charges.unwrap_or(0)
    }

    pub fn clear_secondary_charges(&mut self) {
        self.secondary_charges = ::std::option::Option::None;
    }

    pub fn has_secondary_charges(&self) -> bool {
        self.secondary_charges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondary_charges(&mut self, v: i32) {
        self.secondary_charges = ::std::option::Option::Some(v);
    }

    // optional bool ctrl_held = 12;

    pub fn ctrl_held(&self) -> bool {
        self.ctrl_held.unwrap_or(false)
    }

    pub fn clear_ctrl_held(&mut self) {
        self.ctrl_held = ::std::option::Option::None;
    }

    pub fn has_ctrl_held(&self) -> bool {
        self.ctrl_held.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctrl_held(&mut self, v: bool) {
        self.ctrl_held = ::std::option::Option::Some(v);
    }

    // optional float reclaim_time = 13;

    pub fn reclaim_time(&self) -> f32 {
        self.reclaim_time.unwrap_or(0.)
    }

    pub fn clear_reclaim_time(&mut self) {
        self.reclaim_time = ::std::option::Option::None;
    }

    pub fn has_reclaim_time(&self) -> bool {
        self.reclaim_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reclaim_time(&mut self, v: f32) {
        self.reclaim_time = ::std::option::Option::Some(v);
    }

    // optional int32 owner_entity = 14;

    pub fn owner_entity(&self) -> i32 {
        self.owner_entity.unwrap_or(-1i32)
    }

    pub fn clear_owner_entity(&mut self) {
        self.owner_entity = ::std::option::Option::None;
    }

    pub fn has_owner_entity(&self) -> bool {
        self.owner_entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_entity(&mut self, v: i32) {
        self.owner_entity = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_AbilityPing {
    const NAME: &'static str = "CDOTAUserMsg_AbilityPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.cooldown_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.level = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.passive = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.mana_needed = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.entity_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.primary_charges = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.secondary_charges = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.ctrl_held = ::std::option::Option::Some(is.read_bool()?);
                },
                109 => {
                    self.reclaim_time = ::std::option::Option::Some(is.read_float()?);
                },
                112 => {
                    self.owner_entity = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.cooldown_seconds {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.passive {
            my_size += 1 + 1;
        }
        if let Some(v) = self.mana_needed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.entity_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.primary_charges {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.secondary_charges {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.ctrl_held {
            my_size += 1 + 1;
        }
        if let Some(v) = self.reclaim_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.owner_entity {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(14, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.ability_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.cooldown_seconds {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.passive {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.mana_needed {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.entity_id {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.primary_charges {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.secondary_charges {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.ctrl_held {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.reclaim_time {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.owner_entity {
            os.write_int32(14, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_AbilityPing {
        CDOTAUserMsg_AbilityPing::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.ability_id = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.cooldown_seconds = ::std::option::Option::None;
        self.level = ::std::option::Option::None;
        self.passive = ::std::option::Option::None;
        self.mana_needed = ::std::option::Option::None;
        self.entity_id = ::std::option::Option::None;
        self.primary_charges = ::std::option::Option::None;
        self.secondary_charges = ::std::option::Option::None;
        self.ctrl_held = ::std::option::Option::None;
        self.reclaim_time = ::std::option::Option::None;
        self.owner_entity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_AbilityPing {
        static instance: CDOTAUserMsg_AbilityPing = CDOTAUserMsg_AbilityPing {
            player_id: ::std::option::Option::None,
            ability_id: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            cooldown_seconds: ::std::option::Option::None,
            level: ::std::option::Option::None,
            passive: ::std::option::Option::None,
            mana_needed: ::std::option::Option::None,
            entity_id: ::std::option::Option::None,
            primary_charges: ::std::option::Option::None,
            secondary_charges: ::std::option::Option::None,
            ctrl_held: ::std::option::Option::None,
            reclaim_time: ::std::option::Option::None,
            owner_entity: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_TE_UnitAnimation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TE_UnitAnimation {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_UnitAnimation.entity)
    pub entity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_UnitAnimation.sequence_variant)
    pub sequence_variant: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_UnitAnimation.playbackrate)
    pub playbackrate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_UnitAnimation.castpoint)
    pub castpoint: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_UnitAnimation.type)
    pub type_: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_UnitAnimation.activity)
    pub activity: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_UnitAnimation.lag_compensation_time)
    pub lag_compensation_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_TE_UnitAnimation.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TE_UnitAnimation {
    fn default() -> &'a CDOTAUserMsg_TE_UnitAnimation {
        <CDOTAUserMsg_TE_UnitAnimation as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TE_UnitAnimation {
    pub fn new() -> CDOTAUserMsg_TE_UnitAnimation {
        ::std::default::Default::default()
    }

    // optional uint32 entity = 1;

    pub fn entity(&self) -> u32 {
        self.entity.unwrap_or(16777215u32)
    }

    pub fn clear_entity(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: u32) {
        self.entity = ::std::option::Option::Some(v);
    }

    // optional int32 sequence_variant = 2;

    pub fn sequence_variant(&self) -> i32 {
        self.sequence_variant.unwrap_or(0)
    }

    pub fn clear_sequence_variant(&mut self) {
        self.sequence_variant = ::std::option::Option::None;
    }

    pub fn has_sequence_variant(&self) -> bool {
        self.sequence_variant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_variant(&mut self, v: i32) {
        self.sequence_variant = ::std::option::Option::Some(v);
    }

    // optional float playbackrate = 3;

    pub fn playbackrate(&self) -> f32 {
        self.playbackrate.unwrap_or(0.)
    }

    pub fn clear_playbackrate(&mut self) {
        self.playbackrate = ::std::option::Option::None;
    }

    pub fn has_playbackrate(&self) -> bool {
        self.playbackrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playbackrate(&mut self, v: f32) {
        self.playbackrate = ::std::option::Option::Some(v);
    }

    // optional float castpoint = 4;

    pub fn castpoint(&self) -> f32 {
        self.castpoint.unwrap_or(0.)
    }

    pub fn clear_castpoint(&mut self) {
        self.castpoint = ::std::option::Option::None;
    }

    pub fn has_castpoint(&self) -> bool {
        self.castpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_castpoint(&mut self, v: f32) {
        self.castpoint = ::std::option::Option::Some(v);
    }

    // optional int32 type = 5;

    pub fn type_(&self) -> i32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: i32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional int32 activity = 6;

    pub fn activity(&self) -> i32 {
        self.activity.unwrap_or(0)
    }

    pub fn clear_activity(&mut self) {
        self.activity = ::std::option::Option::None;
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: i32) {
        self.activity = ::std::option::Option::Some(v);
    }

    // optional float lag_compensation_time = 7;

    pub fn lag_compensation_time(&self) -> f32 {
        self.lag_compensation_time.unwrap_or(0.)
    }

    pub fn clear_lag_compensation_time(&mut self) {
        self.lag_compensation_time = ::std::option::Option::None;
    }

    pub fn has_lag_compensation_time(&self) -> bool {
        self.lag_compensation_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lag_compensation_time(&mut self, v: f32) {
        self.lag_compensation_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_TE_UnitAnimation {
    const NAME: &'static str = "CDOTAUserMsg_TE_UnitAnimation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entity = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.sequence_variant = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.playbackrate = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.castpoint = ::std::option::Option::Some(is.read_float()?);
                },
                40 => {
                    self.type_ = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.activity = ::std::option::Option::Some(is.read_int32()?);
                },
                61 => {
                    self.lag_compensation_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.sequence_variant {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.playbackrate {
            my_size += 1 + 4;
        }
        if let Some(v) = self.castpoint {
            my_size += 1 + 4;
        }
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.activity {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.lag_compensation_time {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.entity {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.sequence_variant {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.playbackrate {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.castpoint {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.activity {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.lag_compensation_time {
            os.write_float(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TE_UnitAnimation {
        CDOTAUserMsg_TE_UnitAnimation::new()
    }

    fn clear(&mut self) {
        self.entity = ::std::option::Option::None;
        self.sequence_variant = ::std::option::Option::None;
        self.playbackrate = ::std::option::Option::None;
        self.castpoint = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.activity = ::std::option::Option::None;
        self.lag_compensation_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TE_UnitAnimation {
        static instance: CDOTAUserMsg_TE_UnitAnimation = CDOTAUserMsg_TE_UnitAnimation {
            entity: ::std::option::Option::None,
            sequence_variant: ::std::option::Option::None,
            playbackrate: ::std::option::Option::None,
            castpoint: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            activity: ::std::option::Option::None,
            lag_compensation_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_TE_UnitAnimationEnd)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TE_UnitAnimationEnd {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_UnitAnimationEnd.entity)
    pub entity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TE_UnitAnimationEnd.snap)
    pub snap: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_TE_UnitAnimationEnd.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TE_UnitAnimationEnd {
    fn default() -> &'a CDOTAUserMsg_TE_UnitAnimationEnd {
        <CDOTAUserMsg_TE_UnitAnimationEnd as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TE_UnitAnimationEnd {
    pub fn new() -> CDOTAUserMsg_TE_UnitAnimationEnd {
        ::std::default::Default::default()
    }

    // optional uint32 entity = 1;

    pub fn entity(&self) -> u32 {
        self.entity.unwrap_or(16777215u32)
    }

    pub fn clear_entity(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: u32) {
        self.entity = ::std::option::Option::Some(v);
    }

    // optional bool snap = 2;

    pub fn snap(&self) -> bool {
        self.snap.unwrap_or(false)
    }

    pub fn clear_snap(&mut self) {
        self.snap = ::std::option::Option::None;
    }

    pub fn has_snap(&self) -> bool {
        self.snap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snap(&mut self, v: bool) {
        self.snap = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_TE_UnitAnimationEnd {
    const NAME: &'static str = "CDOTAUserMsg_TE_UnitAnimationEnd";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entity = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.snap = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.snap {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.entity {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.snap {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TE_UnitAnimationEnd {
        CDOTAUserMsg_TE_UnitAnimationEnd::new()
    }

    fn clear(&mut self) {
        self.entity = ::std::option::Option::None;
        self.snap = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TE_UnitAnimationEnd {
        static instance: CDOTAUserMsg_TE_UnitAnimationEnd = CDOTAUserMsg_TE_UnitAnimationEnd {
            entity: ::std::option::Option::None,
            snap: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_ShowGenericPopup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ShowGenericPopup {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_ShowGenericPopup.header)
    pub header: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ShowGenericPopup.body)
    pub body: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ShowGenericPopup.param1)
    pub param1: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ShowGenericPopup.param2)
    pub param2: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ShowGenericPopup.tint_screen)
    pub tint_screen: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ShowGenericPopup.show_no_other_dialogs)
    pub show_no_other_dialogs: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_ShowGenericPopup.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ShowGenericPopup {
    fn default() -> &'a CDOTAUserMsg_ShowGenericPopup {
        <CDOTAUserMsg_ShowGenericPopup as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ShowGenericPopup {
    pub fn new() -> CDOTAUserMsg_ShowGenericPopup {
        ::std::default::Default::default()
    }

    // required string header = 1;

    pub fn header(&self) -> &str {
        match self.header.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_header(&mut self) {
        self.header = ::std::option::Option::None;
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ::std::string::String) {
        self.header = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ::std::string::String {
        if self.header.is_none() {
            self.header = ::std::option::Option::Some(::std::string::String::new());
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ::std::string::String {
        self.header.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string body = 2;

    pub fn body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body = ::std::option::Option::Some(::std::string::String::new());
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string param1 = 3;

    pub fn param1(&self) -> &str {
        match self.param1.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_param1(&mut self) {
        self.param1 = ::std::option::Option::None;
    }

    pub fn has_param1(&self) -> bool {
        self.param1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param1(&mut self, v: ::std::string::String) {
        self.param1 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_param1(&mut self) -> &mut ::std::string::String {
        if self.param1.is_none() {
            self.param1 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.param1.as_mut().unwrap()
    }

    // Take field
    pub fn take_param1(&mut self) -> ::std::string::String {
        self.param1.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string param2 = 4;

    pub fn param2(&self) -> &str {
        match self.param2.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_param2(&mut self) {
        self.param2 = ::std::option::Option::None;
    }

    pub fn has_param2(&self) -> bool {
        self.param2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param2(&mut self, v: ::std::string::String) {
        self.param2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_param2(&mut self) -> &mut ::std::string::String {
        if self.param2.is_none() {
            self.param2 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.param2.as_mut().unwrap()
    }

    // Take field
    pub fn take_param2(&mut self) -> ::std::string::String {
        self.param2.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool tint_screen = 5;

    pub fn tint_screen(&self) -> bool {
        self.tint_screen.unwrap_or(false)
    }

    pub fn clear_tint_screen(&mut self) {
        self.tint_screen = ::std::option::Option::None;
    }

    pub fn has_tint_screen(&self) -> bool {
        self.tint_screen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tint_screen(&mut self, v: bool) {
        self.tint_screen = ::std::option::Option::Some(v);
    }

    // optional bool show_no_other_dialogs = 6;

    pub fn show_no_other_dialogs(&self) -> bool {
        self.show_no_other_dialogs.unwrap_or(false)
    }

    pub fn clear_show_no_other_dialogs(&mut self) {
        self.show_no_other_dialogs = ::std::option::Option::None;
    }

    pub fn has_show_no_other_dialogs(&self) -> bool {
        self.show_no_other_dialogs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_no_other_dialogs(&mut self, v: bool) {
        self.show_no_other_dialogs = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_ShowGenericPopup {
    const NAME: &'static str = "CDOTAUserMsg_ShowGenericPopup";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        if self.body.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.header = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.body = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.param1 = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.param2 = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.tint_screen = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.show_no_other_dialogs = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.body.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.param1.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.param2.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.tint_screen {
            my_size += 1 + 1;
        }
        if let Some(v) = self.show_no_other_dialogs {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.body.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.param1.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.param2.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.tint_screen {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.show_no_other_dialogs {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ShowGenericPopup {
        CDOTAUserMsg_ShowGenericPopup::new()
    }

    fn clear(&mut self) {
        self.header = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.param1 = ::std::option::Option::None;
        self.param2 = ::std::option::Option::None;
        self.tint_screen = ::std::option::Option::None;
        self.show_no_other_dialogs = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ShowGenericPopup {
        static instance: CDOTAUserMsg_ShowGenericPopup = CDOTAUserMsg_ShowGenericPopup {
            header: ::std::option::Option::None,
            body: ::std::option::Option::None,
            param1: ::std::option::Option::None,
            param2: ::std::option::Option::None,
            tint_screen: ::std::option::Option::None,
            show_no_other_dialogs: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_VoteStart)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_VoteStart {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_VoteStart.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_VoteStart.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_VoteStart.choice_count)
    pub choice_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_VoteStart.choices)
    pub choices: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_VoteStart.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_VoteStart {
    fn default() -> &'a CDOTAUserMsg_VoteStart {
        <CDOTAUserMsg_VoteStart as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_VoteStart {
    pub fn new() -> CDOTAUserMsg_VoteStart {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float duration = 2;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional int32 choice_count = 3;

    pub fn choice_count(&self) -> i32 {
        self.choice_count.unwrap_or(0)
    }

    pub fn clear_choice_count(&mut self) {
        self.choice_count = ::std::option::Option::None;
    }

    pub fn has_choice_count(&self) -> bool {
        self.choice_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_choice_count(&mut self, v: i32) {
        self.choice_count = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_VoteStart {
    const NAME: &'static str = "CDOTAUserMsg_VoteStart";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                21 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.choice_count = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.choices.push(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.choice_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        for value in &self.choices {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.choice_count {
            os.write_int32(3, v)?;
        }
        for v in &self.choices {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_VoteStart {
        CDOTAUserMsg_VoteStart::new()
    }

    fn clear(&mut self) {
        self.title = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.choice_count = ::std::option::Option::None;
        self.choices.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_VoteStart {
        static instance: CDOTAUserMsg_VoteStart = CDOTAUserMsg_VoteStart {
            title: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            choice_count: ::std::option::Option::None,
            choices: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_VoteUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_VoteUpdate {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_VoteUpdate.choice_counts)
    pub choice_counts: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_VoteUpdate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_VoteUpdate {
    fn default() -> &'a CDOTAUserMsg_VoteUpdate {
        <CDOTAUserMsg_VoteUpdate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_VoteUpdate {
    pub fn new() -> CDOTAUserMsg_VoteUpdate {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_VoteUpdate {
    const NAME: &'static str = "CDOTAUserMsg_VoteUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.choice_counts)?;
                },
                8 => {
                    self.choice_counts.push(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.choice_counts {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.choice_counts {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_VoteUpdate {
        CDOTAUserMsg_VoteUpdate::new()
    }

    fn clear(&mut self) {
        self.choice_counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_VoteUpdate {
        static instance: CDOTAUserMsg_VoteUpdate = CDOTAUserMsg_VoteUpdate {
            choice_counts: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_VoteEnd)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_VoteEnd {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_VoteEnd.selected_choice)
    pub selected_choice: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_VoteEnd.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_VoteEnd {
    fn default() -> &'a CDOTAUserMsg_VoteEnd {
        <CDOTAUserMsg_VoteEnd as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_VoteEnd {
    pub fn new() -> CDOTAUserMsg_VoteEnd {
        ::std::default::Default::default()
    }

    // optional int32 selected_choice = 1;

    pub fn selected_choice(&self) -> i32 {
        self.selected_choice.unwrap_or(0)
    }

    pub fn clear_selected_choice(&mut self) {
        self.selected_choice = ::std::option::Option::None;
    }

    pub fn has_selected_choice(&self) -> bool {
        self.selected_choice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_choice(&mut self, v: i32) {
        self.selected_choice = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_VoteEnd {
    const NAME: &'static str = "CDOTAUserMsg_VoteEnd";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.selected_choice = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.selected_choice {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.selected_choice {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_VoteEnd {
        CDOTAUserMsg_VoteEnd::new()
    }

    fn clear(&mut self) {
        self.selected_choice = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_VoteEnd {
        static instance: CDOTAUserMsg_VoteEnd = CDOTAUserMsg_VoteEnd {
            selected_choice: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_BoosterStatePlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_BoosterStatePlayer {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_BoosterStatePlayer.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_BoosterStatePlayer.bonus)
    pub bonus: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_BoosterStatePlayer.event_bonus)
    pub event_bonus: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_BoosterStatePlayer.bonus_item_id)
    pub bonus_item_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_BoosterStatePlayer.event_bonus_item_id)
    pub event_bonus_item_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_BoosterStatePlayer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_BoosterStatePlayer {
    fn default() -> &'a CDOTAUserMsg_BoosterStatePlayer {
        <CDOTAUserMsg_BoosterStatePlayer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_BoosterStatePlayer {
    pub fn new() -> CDOTAUserMsg_BoosterStatePlayer {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional float bonus = 2;

    pub fn bonus(&self) -> f32 {
        self.bonus.unwrap_or(0.)
    }

    pub fn clear_bonus(&mut self) {
        self.bonus = ::std::option::Option::None;
    }

    pub fn has_bonus(&self) -> bool {
        self.bonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus(&mut self, v: f32) {
        self.bonus = ::std::option::Option::Some(v);
    }

    // optional float event_bonus = 3;

    pub fn event_bonus(&self) -> f32 {
        self.event_bonus.unwrap_or(0.)
    }

    pub fn clear_event_bonus(&mut self) {
        self.event_bonus = ::std::option::Option::None;
    }

    pub fn has_event_bonus(&self) -> bool {
        self.event_bonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_bonus(&mut self, v: f32) {
        self.event_bonus = ::std::option::Option::Some(v);
    }

    // optional uint32 bonus_item_id = 4;

    pub fn bonus_item_id(&self) -> u32 {
        self.bonus_item_id.unwrap_or(0)
    }

    pub fn clear_bonus_item_id(&mut self) {
        self.bonus_item_id = ::std::option::Option::None;
    }

    pub fn has_bonus_item_id(&self) -> bool {
        self.bonus_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_item_id(&mut self, v: u32) {
        self.bonus_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_bonus_item_id = 5;

    pub fn event_bonus_item_id(&self) -> u32 {
        self.event_bonus_item_id.unwrap_or(0)
    }

    pub fn clear_event_bonus_item_id(&mut self) {
        self.event_bonus_item_id = ::std::option::Option::None;
    }

    pub fn has_event_bonus_item_id(&self) -> bool {
        self.event_bonus_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_bonus_item_id(&mut self, v: u32) {
        self.event_bonus_item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_BoosterStatePlayer {
    const NAME: &'static str = "CDOTAUserMsg_BoosterStatePlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.bonus = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.event_bonus = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.bonus_item_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.event_bonus_item_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.bonus {
            my_size += 1 + 4;
        }
        if let Some(v) = self.event_bonus {
            my_size += 1 + 4;
        }
        if let Some(v) = self.bonus_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.event_bonus_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.bonus {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.event_bonus {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.bonus_item_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.event_bonus_item_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_BoosterStatePlayer {
        CDOTAUserMsg_BoosterStatePlayer::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.bonus = ::std::option::Option::None;
        self.event_bonus = ::std::option::Option::None;
        self.bonus_item_id = ::std::option::Option::None;
        self.event_bonus_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_BoosterStatePlayer {
        static instance: CDOTAUserMsg_BoosterStatePlayer = CDOTAUserMsg_BoosterStatePlayer {
            player_id: ::std::option::Option::None,
            bonus: ::std::option::Option::None,
            event_bonus: ::std::option::Option::None,
            bonus_item_id: ::std::option::Option::None,
            event_bonus_item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_BoosterState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_BoosterState {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_BoosterState.boosted_players)
    pub boosted_players: ::std::vec::Vec<CDOTAUserMsg_BoosterStatePlayer>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_BoosterState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_BoosterState {
    fn default() -> &'a CDOTAUserMsg_BoosterState {
        <CDOTAUserMsg_BoosterState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_BoosterState {
    pub fn new() -> CDOTAUserMsg_BoosterState {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_BoosterState {
    const NAME: &'static str = "CDOTAUserMsg_BoosterState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.boosted_players.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.boosted_players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.boosted_players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_BoosterState {
        CDOTAUserMsg_BoosterState::new()
    }

    fn clear(&mut self) {
        self.boosted_players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_BoosterState {
        static instance: CDOTAUserMsg_BoosterState = CDOTAUserMsg_BoosterState {
            boosted_players: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_PlayerMMR)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_PlayerMMR {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_PlayerMMR.mmr)
    pub mmr: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_PlayerMMR.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_PlayerMMR {
    fn default() -> &'a CDOTAUserMsg_PlayerMMR {
        <CDOTAUserMsg_PlayerMMR as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_PlayerMMR {
    pub fn new() -> CDOTAUserMsg_PlayerMMR {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_PlayerMMR {
    const NAME: &'static str = "CDOTAUserMsg_PlayerMMR";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_sint32_into(&mut self.mmr)?;
                },
                8 => {
                    self.mmr.push(is.read_sint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_sint32_size(1, &self.mmr);
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_repeated_packed_sint32(1, &self.mmr)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_PlayerMMR {
        CDOTAUserMsg_PlayerMMR::new()
    }

    fn clear(&mut self) {
        self.mmr.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_PlayerMMR {
        static instance: CDOTAUserMsg_PlayerMMR = CDOTAUserMsg_PlayerMMR {
            mmr: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_AbilitySteal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_AbilitySteal {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_AbilitySteal.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AbilitySteal.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AbilitySteal.ability_level)
    pub ability_level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_AbilitySteal.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_AbilitySteal {
    fn default() -> &'a CDOTAUserMsg_AbilitySteal {
        <CDOTAUserMsg_AbilitySteal as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_AbilitySteal {
    pub fn new() -> CDOTAUserMsg_AbilitySteal {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 ability_id = 2;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(-1i32)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional uint32 ability_level = 3;

    pub fn ability_level(&self) -> u32 {
        self.ability_level.unwrap_or(0)
    }

    pub fn clear_ability_level(&mut self) {
        self.ability_level = ::std::option::Option::None;
    }

    pub fn has_ability_level(&self) -> bool {
        self.ability_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_level(&mut self, v: u32) {
        self.ability_level = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_AbilitySteal {
    const NAME: &'static str = "CDOTAUserMsg_AbilitySteal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.ability_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.ability_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.ability_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ability_level {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_AbilitySteal {
        CDOTAUserMsg_AbilitySteal::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.ability_id = ::std::option::Option::None;
        self.ability_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_AbilitySteal {
        static instance: CDOTAUserMsg_AbilitySteal = CDOTAUserMsg_AbilitySteal {
            player_id: ::std::option::Option::None,
            ability_id: ::std::option::Option::None,
            ability_level: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_StatsHeroLookup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_StatsHeroLookup {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroLookup.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroLookup.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroLookup.hero_name)
    pub hero_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroLookup.persona)
    pub persona: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_StatsHeroLookup.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_StatsHeroLookup {
    fn default() -> &'a CDOTAUserMsg_StatsHeroLookup {
        <CDOTAUserMsg_StatsHeroLookup as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_StatsHeroLookup {
    pub fn new() -> CDOTAUserMsg_StatsHeroLookup {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 2;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional string hero_name = 3;

    pub fn hero_name(&self) -> &str {
        match self.hero_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hero_name(&mut self) {
        self.hero_name = ::std::option::Option::None;
    }

    pub fn has_hero_name(&self) -> bool {
        self.hero_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_name(&mut self, v: ::std::string::String) {
        self.hero_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hero_name(&mut self) -> &mut ::std::string::String {
        if self.hero_name.is_none() {
            self.hero_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hero_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_hero_name(&mut self) -> ::std::string::String {
        self.hero_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string persona = 4;

    pub fn persona(&self) -> &str {
        match self.persona.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona(&mut self) {
        self.persona = ::std::option::Option::None;
    }

    pub fn has_persona(&self) -> bool {
        self.persona.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona(&mut self, v: ::std::string::String) {
        self.persona = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona(&mut self) -> &mut ::std::string::String {
        if self.persona.is_none() {
            self.persona = ::std::option::Option::Some(::std::string::String::new());
        }
        self.persona.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona(&mut self) -> ::std::string::String {
        self.persona.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_StatsHeroLookup {
    const NAME: &'static str = "CDOTAUserMsg_StatsHeroLookup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.hero_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.persona = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.hero_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.persona.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.hero_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.persona.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_StatsHeroLookup {
        CDOTAUserMsg_StatsHeroLookup::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.hero_name = ::std::option::Option::None;
        self.persona = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_StatsHeroLookup {
        static instance: CDOTAUserMsg_StatsHeroLookup = CDOTAUserMsg_StatsHeroLookup {
            player_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            hero_name: ::std::option::Option::None,
            persona: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_StatsHeroPositionInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_StatsHeroPositionInfo {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroPositionInfo.average_position)
    pub average_position: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroPositionInfo.position_details)
    pub position_details: ::std::vec::Vec<cdotauser_msg_stats_hero_position_info::PositionPair>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_StatsHeroPositionInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_StatsHeroPositionInfo {
    fn default() -> &'a CDOTAUserMsg_StatsHeroPositionInfo {
        <CDOTAUserMsg_StatsHeroPositionInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_StatsHeroPositionInfo {
    pub fn new() -> CDOTAUserMsg_StatsHeroPositionInfo {
        ::std::default::Default::default()
    }

    // optional float average_position = 1;

    pub fn average_position(&self) -> f32 {
        self.average_position.unwrap_or(0.)
    }

    pub fn clear_average_position(&mut self) {
        self.average_position = ::std::option::Option::None;
    }

    pub fn has_average_position(&self) -> bool {
        self.average_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_position(&mut self, v: f32) {
        self.average_position = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_StatsHeroPositionInfo {
    const NAME: &'static str = "CDOTAUserMsg_StatsHeroPositionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.average_position = ::std::option::Option::Some(is.read_float()?);
                },
                18 => {
                    self.position_details.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.average_position {
            my_size += 1 + 4;
        }
        for value in &self.position_details {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.average_position {
            os.write_float(1, v)?;
        }
        for v in &self.position_details {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_StatsHeroPositionInfo {
        CDOTAUserMsg_StatsHeroPositionInfo::new()
    }

    fn clear(&mut self) {
        self.average_position = ::std::option::Option::None;
        self.position_details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_StatsHeroPositionInfo {
        static instance: CDOTAUserMsg_StatsHeroPositionInfo = CDOTAUserMsg_StatsHeroPositionInfo {
            average_position: ::std::option::Option::None,
            position_details: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CDOTAUserMsg_StatsHeroPositionInfo`
pub mod cdotauser_msg_stats_hero_position_info {
    // @@protoc_insertion_point(message:CDOTAUserMsg_StatsHeroPositionInfo.PositionPair)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PositionPair {
        // message fields
        // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroPositionInfo.PositionPair.position_category)
        pub position_category: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::DOTA_POSITION_CATEGORY>>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroPositionInfo.PositionPair.position_count)
        pub position_count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAUserMsg_StatsHeroPositionInfo.PositionPair.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PositionPair {
        fn default() -> &'a PositionPair {
            <PositionPair as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PositionPair {
        pub fn new() -> PositionPair {
            ::std::default::Default::default()
        }

        // optional .DOTA_POSITION_CATEGORY position_category = 1;

        pub fn position_category(&self) -> super::DOTA_POSITION_CATEGORY {
            match self.position_category {
                Some(e) => e.enum_value_or(super::DOTA_POSITION_CATEGORY::DOTA_POSITION_NONE),
                None => super::DOTA_POSITION_CATEGORY::DOTA_POSITION_NONE,
            }
        }

        pub fn clear_position_category(&mut self) {
            self.position_category = ::std::option::Option::None;
        }

        pub fn has_position_category(&self) -> bool {
            self.position_category.is_some()
        }

        // Param is passed by value, moved
        pub fn set_position_category(&mut self, v: super::DOTA_POSITION_CATEGORY) {
            self.position_category = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 position_count = 2;

        pub fn position_count(&self) -> u32 {
            self.position_count.unwrap_or(0)
        }

        pub fn clear_position_count(&mut self) {
            self.position_count = ::std::option::Option::None;
        }

        pub fn has_position_count(&self) -> bool {
            self.position_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_position_count(&mut self, v: u32) {
            self.position_count = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PositionPair {
        const NAME: &'static str = "PositionPair";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.position_category = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.position_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.position_category {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.position_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.position_category {
                os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.position_count {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PositionPair {
            PositionPair::new()
        }

        fn clear(&mut self) {
            self.position_category = ::std::option::Option::None;
            self.position_count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PositionPair {
            static instance: PositionPair = PositionPair {
                position_category: ::std::option::Option::None,
                position_count: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_StatsHeroMinuteDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_StatsHeroMinuteDetails {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroMinuteDetails.last_hits)
    pub last_hits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroMinuteDetails.hero_kills)
    pub hero_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroMinuteDetails.hero_damage)
    pub hero_damage: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroMinuteDetails.tower_damage)
    pub tower_damage: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroMinuteDetails.position_info)
    pub position_info: ::steam_vent_proto_common::protobuf::MessageField<CDOTAUserMsg_StatsHeroPositionInfo>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroMinuteDetails.total_xp)
    pub total_xp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroMinuteDetails.net_worth)
    pub net_worth: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroMinuteDetails.harvested_creep_gold)
    pub harvested_creep_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroMinuteDetails.claimed_farm)
    pub claimed_farm: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroMinuteDetails.wards_placed)
    pub wards_placed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroMinuteDetails.runes_collected)
    pub runes_collected: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroMinuteDetails.tps_used)
    pub tps_used: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroMinuteDetails.mana_spent)
    pub mana_spent: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroMinuteDetails.damage_absorbed)
    pub damage_absorbed: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsHeroMinuteDetails.damage_done)
    pub damage_done: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_StatsHeroMinuteDetails.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_StatsHeroMinuteDetails {
    fn default() -> &'a CDOTAUserMsg_StatsHeroMinuteDetails {
        <CDOTAUserMsg_StatsHeroMinuteDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_StatsHeroMinuteDetails {
    pub fn new() -> CDOTAUserMsg_StatsHeroMinuteDetails {
        ::std::default::Default::default()
    }

    // optional uint32 last_hits = 1;

    pub fn last_hits(&self) -> u32 {
        self.last_hits.unwrap_or(0)
    }

    pub fn clear_last_hits(&mut self) {
        self.last_hits = ::std::option::Option::None;
    }

    pub fn has_last_hits(&self) -> bool {
        self.last_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hits(&mut self, v: u32) {
        self.last_hits = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_kills = 2;

    pub fn hero_kills(&self) -> u32 {
        self.hero_kills.unwrap_or(0)
    }

    pub fn clear_hero_kills(&mut self) {
        self.hero_kills = ::std::option::Option::None;
    }

    pub fn has_hero_kills(&self) -> bool {
        self.hero_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_kills(&mut self, v: u32) {
        self.hero_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_damage = 3;

    pub fn hero_damage(&self) -> u32 {
        self.hero_damage.unwrap_or(0)
    }

    pub fn clear_hero_damage(&mut self) {
        self.hero_damage = ::std::option::Option::None;
    }

    pub fn has_hero_damage(&self) -> bool {
        self.hero_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_damage(&mut self, v: u32) {
        self.hero_damage = ::std::option::Option::Some(v);
    }

    // optional uint32 tower_damage = 4;

    pub fn tower_damage(&self) -> u32 {
        self.tower_damage.unwrap_or(0)
    }

    pub fn clear_tower_damage(&mut self) {
        self.tower_damage = ::std::option::Option::None;
    }

    pub fn has_tower_damage(&self) -> bool {
        self.tower_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tower_damage(&mut self, v: u32) {
        self.tower_damage = ::std::option::Option::Some(v);
    }

    // optional uint32 total_xp = 6;

    pub fn total_xp(&self) -> u32 {
        self.total_xp.unwrap_or(0)
    }

    pub fn clear_total_xp(&mut self) {
        self.total_xp = ::std::option::Option::None;
    }

    pub fn has_total_xp(&self) -> bool {
        self.total_xp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_xp(&mut self, v: u32) {
        self.total_xp = ::std::option::Option::Some(v);
    }

    // optional uint32 net_worth = 7;

    pub fn net_worth(&self) -> u32 {
        self.net_worth.unwrap_or(0)
    }

    pub fn clear_net_worth(&mut self) {
        self.net_worth = ::std::option::Option::None;
    }

    pub fn has_net_worth(&self) -> bool {
        self.net_worth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_worth(&mut self, v: u32) {
        self.net_worth = ::std::option::Option::Some(v);
    }

    // optional uint32 harvested_creep_gold = 8;

    pub fn harvested_creep_gold(&self) -> u32 {
        self.harvested_creep_gold.unwrap_or(0)
    }

    pub fn clear_harvested_creep_gold(&mut self) {
        self.harvested_creep_gold = ::std::option::Option::None;
    }

    pub fn has_harvested_creep_gold(&self) -> bool {
        self.harvested_creep_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_harvested_creep_gold(&mut self, v: u32) {
        self.harvested_creep_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 claimed_farm = 9;

    pub fn claimed_farm(&self) -> u32 {
        self.claimed_farm.unwrap_or(0)
    }

    pub fn clear_claimed_farm(&mut self) {
        self.claimed_farm = ::std::option::Option::None;
    }

    pub fn has_claimed_farm(&self) -> bool {
        self.claimed_farm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claimed_farm(&mut self, v: u32) {
        self.claimed_farm = ::std::option::Option::Some(v);
    }

    // optional uint32 wards_placed = 10;

    pub fn wards_placed(&self) -> u32 {
        self.wards_placed.unwrap_or(0)
    }

    pub fn clear_wards_placed(&mut self) {
        self.wards_placed = ::std::option::Option::None;
    }

    pub fn has_wards_placed(&self) -> bool {
        self.wards_placed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wards_placed(&mut self, v: u32) {
        self.wards_placed = ::std::option::Option::Some(v);
    }

    // optional uint32 runes_collected = 11;

    pub fn runes_collected(&self) -> u32 {
        self.runes_collected.unwrap_or(0)
    }

    pub fn clear_runes_collected(&mut self) {
        self.runes_collected = ::std::option::Option::None;
    }

    pub fn has_runes_collected(&self) -> bool {
        self.runes_collected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runes_collected(&mut self, v: u32) {
        self.runes_collected = ::std::option::Option::Some(v);
    }

    // optional uint32 tps_used = 12;

    pub fn tps_used(&self) -> u32 {
        self.tps_used.unwrap_or(0)
    }

    pub fn clear_tps_used(&mut self) {
        self.tps_used = ::std::option::Option::None;
    }

    pub fn has_tps_used(&self) -> bool {
        self.tps_used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tps_used(&mut self, v: u32) {
        self.tps_used = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_StatsHeroMinuteDetails {
    const NAME: &'static str = "CDOTAUserMsg_StatsHeroMinuteDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.last_hits = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.hero_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.hero_damage = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.tower_damage = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.position_info)?;
                },
                48 => {
                    self.total_xp = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.harvested_creep_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.claimed_farm = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.wards_placed = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.runes_collected = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.tps_used = ::std::option::Option::Some(is.read_uint32()?);
                },
                106 => {
                    is.read_repeated_packed_uint32_into(&mut self.mana_spent)?;
                },
                104 => {
                    self.mana_spent.push(is.read_uint32()?);
                },
                114 => {
                    is.read_repeated_packed_uint32_into(&mut self.damage_absorbed)?;
                },
                112 => {
                    self.damage_absorbed.push(is.read_uint32()?);
                },
                122 => {
                    is.read_repeated_packed_uint32_into(&mut self.damage_done)?;
                },
                120 => {
                    self.damage_done.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.last_hits {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.hero_kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.hero_damage {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.tower_damage {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.position_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.total_xp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.net_worth {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.harvested_creep_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.claimed_farm {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.wards_placed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.runes_collected {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.tps_used {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        for value in &self.mana_spent {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, *value);
        };
        for value in &self.damage_absorbed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, *value);
        };
        for value in &self.damage_done {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.last_hits {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_kills {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.hero_damage {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.tower_damage {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.position_info.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.total_xp {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.net_worth {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.harvested_creep_gold {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.claimed_farm {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.wards_placed {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.runes_collected {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.tps_used {
            os.write_uint32(12, v)?;
        }
        for v in &self.mana_spent {
            os.write_uint32(13, *v)?;
        };
        for v in &self.damage_absorbed {
            os.write_uint32(14, *v)?;
        };
        for v in &self.damage_done {
            os.write_uint32(15, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_StatsHeroMinuteDetails {
        CDOTAUserMsg_StatsHeroMinuteDetails::new()
    }

    fn clear(&mut self) {
        self.last_hits = ::std::option::Option::None;
        self.hero_kills = ::std::option::Option::None;
        self.hero_damage = ::std::option::Option::None;
        self.tower_damage = ::std::option::Option::None;
        self.position_info.clear();
        self.total_xp = ::std::option::Option::None;
        self.net_worth = ::std::option::Option::None;
        self.harvested_creep_gold = ::std::option::Option::None;
        self.claimed_farm = ::std::option::Option::None;
        self.wards_placed = ::std::option::Option::None;
        self.runes_collected = ::std::option::Option::None;
        self.tps_used = ::std::option::Option::None;
        self.mana_spent.clear();
        self.damage_absorbed.clear();
        self.damage_done.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_StatsHeroMinuteDetails {
        static instance: CDOTAUserMsg_StatsHeroMinuteDetails = CDOTAUserMsg_StatsHeroMinuteDetails {
            last_hits: ::std::option::Option::None,
            hero_kills: ::std::option::Option::None,
            hero_damage: ::std::option::Option::None,
            tower_damage: ::std::option::Option::None,
            position_info: ::steam_vent_proto_common::protobuf::MessageField::none(),
            total_xp: ::std::option::Option::None,
            net_worth: ::std::option::Option::None,
            harvested_creep_gold: ::std::option::Option::None,
            claimed_farm: ::std::option::Option::None,
            wards_placed: ::std::option::Option::None,
            runes_collected: ::std::option::Option::None,
            tps_used: ::std::option::Option::None,
            mana_spent: ::std::vec::Vec::new(),
            damage_absorbed: ::std::vec::Vec::new(),
            damage_done: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_StatsTeamMinuteDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_StatsTeamMinuteDetails {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsTeamMinuteDetails.player_stats)
    pub player_stats: ::std::vec::Vec<CDOTAUserMsg_StatsHeroMinuteDetails>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsTeamMinuteDetails.tower_kills)
    pub tower_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsTeamMinuteDetails.barrack_kills)
    pub barrack_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsTeamMinuteDetails.available_lane_creep_gold)
    pub available_lane_creep_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsTeamMinuteDetails.balance_kill_value)
    pub balance_kill_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsTeamMinuteDetails.balance_tower_value)
    pub balance_tower_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsTeamMinuteDetails.balance_barracks_value)
    pub balance_barracks_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsTeamMinuteDetails.balance_gold_value)
    pub balance_gold_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsTeamMinuteDetails.balance_xp_value)
    pub balance_xp_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsTeamMinuteDetails.lane_performance)
    pub lane_performance: ::std::vec::Vec<cdotauser_msg_stats_team_minute_details::LocationPerformance>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_StatsTeamMinuteDetails.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_StatsTeamMinuteDetails {
    fn default() -> &'a CDOTAUserMsg_StatsTeamMinuteDetails {
        <CDOTAUserMsg_StatsTeamMinuteDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_StatsTeamMinuteDetails {
    pub fn new() -> CDOTAUserMsg_StatsTeamMinuteDetails {
        ::std::default::Default::default()
    }

    // optional uint32 tower_kills = 2;

    pub fn tower_kills(&self) -> u32 {
        self.tower_kills.unwrap_or(0)
    }

    pub fn clear_tower_kills(&mut self) {
        self.tower_kills = ::std::option::Option::None;
    }

    pub fn has_tower_kills(&self) -> bool {
        self.tower_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tower_kills(&mut self, v: u32) {
        self.tower_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 barrack_kills = 3;

    pub fn barrack_kills(&self) -> u32 {
        self.barrack_kills.unwrap_or(0)
    }

    pub fn clear_barrack_kills(&mut self) {
        self.barrack_kills = ::std::option::Option::None;
    }

    pub fn has_barrack_kills(&self) -> bool {
        self.barrack_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_barrack_kills(&mut self, v: u32) {
        self.barrack_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 available_lane_creep_gold = 4;

    pub fn available_lane_creep_gold(&self) -> u32 {
        self.available_lane_creep_gold.unwrap_or(0)
    }

    pub fn clear_available_lane_creep_gold(&mut self) {
        self.available_lane_creep_gold = ::std::option::Option::None;
    }

    pub fn has_available_lane_creep_gold(&self) -> bool {
        self.available_lane_creep_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_available_lane_creep_gold(&mut self, v: u32) {
        self.available_lane_creep_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 balance_kill_value = 5;

    pub fn balance_kill_value(&self) -> u32 {
        self.balance_kill_value.unwrap_or(0)
    }

    pub fn clear_balance_kill_value(&mut self) {
        self.balance_kill_value = ::std::option::Option::None;
    }

    pub fn has_balance_kill_value(&self) -> bool {
        self.balance_kill_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_kill_value(&mut self, v: u32) {
        self.balance_kill_value = ::std::option::Option::Some(v);
    }

    // optional uint32 balance_tower_value = 6;

    pub fn balance_tower_value(&self) -> u32 {
        self.balance_tower_value.unwrap_or(0)
    }

    pub fn clear_balance_tower_value(&mut self) {
        self.balance_tower_value = ::std::option::Option::None;
    }

    pub fn has_balance_tower_value(&self) -> bool {
        self.balance_tower_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_tower_value(&mut self, v: u32) {
        self.balance_tower_value = ::std::option::Option::Some(v);
    }

    // optional uint32 balance_barracks_value = 7;

    pub fn balance_barracks_value(&self) -> u32 {
        self.balance_barracks_value.unwrap_or(0)
    }

    pub fn clear_balance_barracks_value(&mut self) {
        self.balance_barracks_value = ::std::option::Option::None;
    }

    pub fn has_balance_barracks_value(&self) -> bool {
        self.balance_barracks_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_barracks_value(&mut self, v: u32) {
        self.balance_barracks_value = ::std::option::Option::Some(v);
    }

    // optional uint32 balance_gold_value = 8;

    pub fn balance_gold_value(&self) -> u32 {
        self.balance_gold_value.unwrap_or(0)
    }

    pub fn clear_balance_gold_value(&mut self) {
        self.balance_gold_value = ::std::option::Option::None;
    }

    pub fn has_balance_gold_value(&self) -> bool {
        self.balance_gold_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_gold_value(&mut self, v: u32) {
        self.balance_gold_value = ::std::option::Option::Some(v);
    }

    // optional uint32 balance_xp_value = 9;

    pub fn balance_xp_value(&self) -> u32 {
        self.balance_xp_value.unwrap_or(0)
    }

    pub fn clear_balance_xp_value(&mut self) {
        self.balance_xp_value = ::std::option::Option::None;
    }

    pub fn has_balance_xp_value(&self) -> bool {
        self.balance_xp_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_xp_value(&mut self, v: u32) {
        self.balance_xp_value = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_StatsTeamMinuteDetails {
    const NAME: &'static str = "CDOTAUserMsg_StatsTeamMinuteDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_stats.push(is.read_message()?);
                },
                16 => {
                    self.tower_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.barrack_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.available_lane_creep_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.balance_kill_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.balance_tower_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.balance_barracks_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.balance_gold_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.balance_xp_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.lane_performance.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_stats {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.tower_kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.barrack_kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.available_lane_creep_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.balance_kill_value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.balance_tower_value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.balance_barracks_value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.balance_gold_value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.balance_xp_value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        for value in &self.lane_performance {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.player_stats {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.tower_kills {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.barrack_kills {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.available_lane_creep_gold {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.balance_kill_value {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.balance_tower_value {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.balance_barracks_value {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.balance_gold_value {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.balance_xp_value {
            os.write_uint32(9, v)?;
        }
        for v in &self.lane_performance {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_StatsTeamMinuteDetails {
        CDOTAUserMsg_StatsTeamMinuteDetails::new()
    }

    fn clear(&mut self) {
        self.player_stats.clear();
        self.tower_kills = ::std::option::Option::None;
        self.barrack_kills = ::std::option::Option::None;
        self.available_lane_creep_gold = ::std::option::Option::None;
        self.balance_kill_value = ::std::option::Option::None;
        self.balance_tower_value = ::std::option::Option::None;
        self.balance_barracks_value = ::std::option::Option::None;
        self.balance_gold_value = ::std::option::Option::None;
        self.balance_xp_value = ::std::option::Option::None;
        self.lane_performance.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_StatsTeamMinuteDetails {
        static instance: CDOTAUserMsg_StatsTeamMinuteDetails = CDOTAUserMsg_StatsTeamMinuteDetails {
            player_stats: ::std::vec::Vec::new(),
            tower_kills: ::std::option::Option::None,
            barrack_kills: ::std::option::Option::None,
            available_lane_creep_gold: ::std::option::Option::None,
            balance_kill_value: ::std::option::Option::None,
            balance_tower_value: ::std::option::Option::None,
            balance_barracks_value: ::std::option::Option::None,
            balance_gold_value: ::std::option::Option::None,
            balance_xp_value: ::std::option::Option::None,
            lane_performance: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CDOTAUserMsg_StatsTeamMinuteDetails`
pub mod cdotauser_msg_stats_team_minute_details {
    // @@protoc_insertion_point(message:CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LocationPerformance {
        // message fields
        // @@protoc_insertion_point(field:CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance.location_category)
        pub location_category: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance.stat_type)
        pub stat_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance.value)
        pub value: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LocationPerformance {
        fn default() -> &'a LocationPerformance {
            <LocationPerformance as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl LocationPerformance {
        pub fn new() -> LocationPerformance {
            ::std::default::Default::default()
        }

        // optional uint32 location_category = 1;

        pub fn location_category(&self) -> u32 {
            self.location_category.unwrap_or(0)
        }

        pub fn clear_location_category(&mut self) {
            self.location_category = ::std::option::Option::None;
        }

        pub fn has_location_category(&self) -> bool {
            self.location_category.is_some()
        }

        // Param is passed by value, moved
        pub fn set_location_category(&mut self, v: u32) {
            self.location_category = ::std::option::Option::Some(v);
        }

        // optional uint32 stat_type = 2;

        pub fn stat_type(&self) -> u32 {
            self.stat_type.unwrap_or(0)
        }

        pub fn clear_stat_type(&mut self) {
            self.stat_type = ::std::option::Option::None;
        }

        pub fn has_stat_type(&self) -> bool {
            self.stat_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_type(&mut self, v: u32) {
            self.stat_type = ::std::option::Option::Some(v);
        }

        // optional uint32 value = 3;

        pub fn value(&self) -> u32 {
            self.value.unwrap_or(0)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: u32) {
            self.value = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for LocationPerformance {
        const NAME: &'static str = "LocationPerformance";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.location_category = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.stat_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.location_category {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.stat_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.value {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.location_category {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.stat_type {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.value {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LocationPerformance {
            LocationPerformance::new()
        }

        fn clear(&mut self) {
            self.location_category = ::std::option::Option::None;
            self.stat_type = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LocationPerformance {
            static instance: LocationPerformance = LocationPerformance {
                location_category: ::std::option::Option::None,
                stat_type: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_StatsPlayerKillShare)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_StatsPlayerKillShare {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsPlayerKillShare.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsPlayerKillShare.kill_share_percent)
    pub kill_share_percent: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsPlayerKillShare.player_loc_x)
    pub player_loc_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsPlayerKillShare.player_loc_y)
    pub player_loc_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsPlayerKillShare.health_percent)
    pub health_percent: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsPlayerKillShare.mana_percent)
    pub mana_percent: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_StatsPlayerKillShare.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_StatsPlayerKillShare {
    fn default() -> &'a CDOTAUserMsg_StatsPlayerKillShare {
        <CDOTAUserMsg_StatsPlayerKillShare as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_StatsPlayerKillShare {
    pub fn new() -> CDOTAUserMsg_StatsPlayerKillShare {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional float kill_share_percent = 2;

    pub fn kill_share_percent(&self) -> f32 {
        self.kill_share_percent.unwrap_or(0.)
    }

    pub fn clear_kill_share_percent(&mut self) {
        self.kill_share_percent = ::std::option::Option::None;
    }

    pub fn has_kill_share_percent(&self) -> bool {
        self.kill_share_percent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kill_share_percent(&mut self, v: f32) {
        self.kill_share_percent = ::std::option::Option::Some(v);
    }

    // optional float player_loc_x = 3;

    pub fn player_loc_x(&self) -> f32 {
        self.player_loc_x.unwrap_or(0.)
    }

    pub fn clear_player_loc_x(&mut self) {
        self.player_loc_x = ::std::option::Option::None;
    }

    pub fn has_player_loc_x(&self) -> bool {
        self.player_loc_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_loc_x(&mut self, v: f32) {
        self.player_loc_x = ::std::option::Option::Some(v);
    }

    // optional float player_loc_y = 4;

    pub fn player_loc_y(&self) -> f32 {
        self.player_loc_y.unwrap_or(0.)
    }

    pub fn clear_player_loc_y(&mut self) {
        self.player_loc_y = ::std::option::Option::None;
    }

    pub fn has_player_loc_y(&self) -> bool {
        self.player_loc_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_loc_y(&mut self, v: f32) {
        self.player_loc_y = ::std::option::Option::Some(v);
    }

    // optional float health_percent = 5;

    pub fn health_percent(&self) -> f32 {
        self.health_percent.unwrap_or(0.)
    }

    pub fn clear_health_percent(&mut self) {
        self.health_percent = ::std::option::Option::None;
    }

    pub fn has_health_percent(&self) -> bool {
        self.health_percent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health_percent(&mut self, v: f32) {
        self.health_percent = ::std::option::Option::Some(v);
    }

    // optional float mana_percent = 6;

    pub fn mana_percent(&self) -> f32 {
        self.mana_percent.unwrap_or(0.)
    }

    pub fn clear_mana_percent(&mut self) {
        self.mana_percent = ::std::option::Option::None;
    }

    pub fn has_mana_percent(&self) -> bool {
        self.mana_percent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mana_percent(&mut self, v: f32) {
        self.mana_percent = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_StatsPlayerKillShare {
    const NAME: &'static str = "CDOTAUserMsg_StatsPlayerKillShare";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.kill_share_percent = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.player_loc_x = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.player_loc_y = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.health_percent = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.mana_percent = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.kill_share_percent {
            my_size += 1 + 4;
        }
        if let Some(v) = self.player_loc_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.player_loc_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.health_percent {
            my_size += 1 + 4;
        }
        if let Some(v) = self.mana_percent {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.kill_share_percent {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.player_loc_x {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.player_loc_y {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.health_percent {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.mana_percent {
            os.write_float(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_StatsPlayerKillShare {
        CDOTAUserMsg_StatsPlayerKillShare::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.kill_share_percent = ::std::option::Option::None;
        self.player_loc_x = ::std::option::Option::None;
        self.player_loc_y = ::std::option::Option::None;
        self.health_percent = ::std::option::Option::None;
        self.mana_percent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_StatsPlayerKillShare {
        static instance: CDOTAUserMsg_StatsPlayerKillShare = CDOTAUserMsg_StatsPlayerKillShare {
            player_id: ::std::option::Option::None,
            kill_share_percent: ::std::option::Option::None,
            player_loc_x: ::std::option::Option::None,
            player_loc_y: ::std::option::Option::None,
            health_percent: ::std::option::Option::None,
            mana_percent: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_StatsKillDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_StatsKillDetails {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsKillDetails.victim_id)
    pub victim_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsKillDetails.kill_shares)
    pub kill_shares: ::std::vec::Vec<CDOTAUserMsg_StatsPlayerKillShare>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsKillDetails.damage_to_kill)
    pub damage_to_kill: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsKillDetails.effective_health)
    pub effective_health: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsKillDetails.death_time)
    pub death_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsKillDetails.killer_id)
    pub killer_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_StatsKillDetails.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_StatsKillDetails {
    fn default() -> &'a CDOTAUserMsg_StatsKillDetails {
        <CDOTAUserMsg_StatsKillDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_StatsKillDetails {
    pub fn new() -> CDOTAUserMsg_StatsKillDetails {
        ::std::default::Default::default()
    }

    // optional int32 victim_id = 1;

    pub fn victim_id(&self) -> i32 {
        self.victim_id.unwrap_or(-1i32)
    }

    pub fn clear_victim_id(&mut self) {
        self.victim_id = ::std::option::Option::None;
    }

    pub fn has_victim_id(&self) -> bool {
        self.victim_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_id(&mut self, v: i32) {
        self.victim_id = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_to_kill = 3;

    pub fn damage_to_kill(&self) -> u32 {
        self.damage_to_kill.unwrap_or(0)
    }

    pub fn clear_damage_to_kill(&mut self) {
        self.damage_to_kill = ::std::option::Option::None;
    }

    pub fn has_damage_to_kill(&self) -> bool {
        self.damage_to_kill.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_to_kill(&mut self, v: u32) {
        self.damage_to_kill = ::std::option::Option::Some(v);
    }

    // optional uint32 effective_health = 4;

    pub fn effective_health(&self) -> u32 {
        self.effective_health.unwrap_or(0)
    }

    pub fn clear_effective_health(&mut self) {
        self.effective_health = ::std::option::Option::None;
    }

    pub fn has_effective_health(&self) -> bool {
        self.effective_health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effective_health(&mut self, v: u32) {
        self.effective_health = ::std::option::Option::Some(v);
    }

    // optional float death_time = 5;

    pub fn death_time(&self) -> f32 {
        self.death_time.unwrap_or(0.)
    }

    pub fn clear_death_time(&mut self) {
        self.death_time = ::std::option::Option::None;
    }

    pub fn has_death_time(&self) -> bool {
        self.death_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_death_time(&mut self, v: f32) {
        self.death_time = ::std::option::Option::Some(v);
    }

    // optional int32 killer_id = 6;

    pub fn killer_id(&self) -> i32 {
        self.killer_id.unwrap_or(-1i32)
    }

    pub fn clear_killer_id(&mut self) {
        self.killer_id = ::std::option::Option::None;
    }

    pub fn has_killer_id(&self) -> bool {
        self.killer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_id(&mut self, v: i32) {
        self.killer_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_StatsKillDetails {
    const NAME: &'static str = "CDOTAUserMsg_StatsKillDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.victim_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.kill_shares.push(is.read_message()?);
                },
                24 => {
                    self.damage_to_kill = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.effective_health = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    self.death_time = ::std::option::Option::Some(is.read_float()?);
                },
                48 => {
                    self.killer_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.victim_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        for value in &self.kill_shares {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.damage_to_kill {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.effective_health {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.death_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.killer_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.victim_id {
            os.write_int32(1, v)?;
        }
        for v in &self.kill_shares {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.damage_to_kill {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.effective_health {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.death_time {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.killer_id {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_StatsKillDetails {
        CDOTAUserMsg_StatsKillDetails::new()
    }

    fn clear(&mut self) {
        self.victim_id = ::std::option::Option::None;
        self.kill_shares.clear();
        self.damage_to_kill = ::std::option::Option::None;
        self.effective_health = ::std::option::Option::None;
        self.death_time = ::std::option::Option::None;
        self.killer_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_StatsKillDetails {
        static instance: CDOTAUserMsg_StatsKillDetails = CDOTAUserMsg_StatsKillDetails {
            victim_id: ::std::option::Option::None,
            kill_shares: ::std::vec::Vec::new(),
            damage_to_kill: ::std::option::Option::None,
            effective_health: ::std::option::Option::None,
            death_time: ::std::option::Option::None,
            killer_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_StatsMatchDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_StatsMatchDetails {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsMatchDetails.hero_lookup)
    pub hero_lookup: ::std::vec::Vec<CDOTAUserMsg_StatsHeroLookup>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsMatchDetails.radiant_stats)
    pub radiant_stats: ::std::vec::Vec<CDOTAUserMsg_StatsTeamMinuteDetails>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsMatchDetails.dire_stats)
    pub dire_stats: ::std::vec::Vec<CDOTAUserMsg_StatsTeamMinuteDetails>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsMatchDetails.radiant_kills)
    pub radiant_kills: ::std::vec::Vec<CDOTAUserMsg_StatsKillDetails>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsMatchDetails.dire_kills)
    pub dire_kills: ::std::vec::Vec<CDOTAUserMsg_StatsKillDetails>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_StatsMatchDetails.fight_details)
    pub fight_details: ::std::vec::Vec<cdotauser_msg_stats_match_details::CDOTAUserMsg_StatsFightDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_StatsMatchDetails.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_StatsMatchDetails {
    fn default() -> &'a CDOTAUserMsg_StatsMatchDetails {
        <CDOTAUserMsg_StatsMatchDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_StatsMatchDetails {
    pub fn new() -> CDOTAUserMsg_StatsMatchDetails {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_StatsMatchDetails {
    const NAME: &'static str = "CDOTAUserMsg_StatsMatchDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hero_lookup.push(is.read_message()?);
                },
                18 => {
                    self.radiant_stats.push(is.read_message()?);
                },
                26 => {
                    self.dire_stats.push(is.read_message()?);
                },
                34 => {
                    self.radiant_kills.push(is.read_message()?);
                },
                42 => {
                    self.dire_kills.push(is.read_message()?);
                },
                50 => {
                    self.fight_details.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.hero_lookup {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.radiant_stats {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.dire_stats {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.radiant_kills {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.dire_kills {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.fight_details {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.hero_lookup {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.radiant_stats {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.dire_stats {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.radiant_kills {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.dire_kills {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.fight_details {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_StatsMatchDetails {
        CDOTAUserMsg_StatsMatchDetails::new()
    }

    fn clear(&mut self) {
        self.hero_lookup.clear();
        self.radiant_stats.clear();
        self.dire_stats.clear();
        self.radiant_kills.clear();
        self.dire_kills.clear();
        self.fight_details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_StatsMatchDetails {
        static instance: CDOTAUserMsg_StatsMatchDetails = CDOTAUserMsg_StatsMatchDetails {
            hero_lookup: ::std::vec::Vec::new(),
            radiant_stats: ::std::vec::Vec::new(),
            dire_stats: ::std::vec::Vec::new(),
            radiant_kills: ::std::vec::Vec::new(),
            dire_kills: ::std::vec::Vec::new(),
            fight_details: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CDOTAUserMsg_StatsMatchDetails`
pub mod cdotauser_msg_stats_match_details {
    // @@protoc_insertion_point(message:CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CDOTAUserMsg_StatsFightTeamDetails {
        // message fields
        // @@protoc_insertion_point(field:CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.participants)
        pub participants: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.deaths)
        pub deaths: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.gold_delta)
        pub gold_delta: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.xp_delta)
        pub xp_delta: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CDOTAUserMsg_StatsFightTeamDetails {
        fn default() -> &'a CDOTAUserMsg_StatsFightTeamDetails {
            <CDOTAUserMsg_StatsFightTeamDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CDOTAUserMsg_StatsFightTeamDetails {
        pub fn new() -> CDOTAUserMsg_StatsFightTeamDetails {
            ::std::default::Default::default()
        }

        // optional uint32 gold_delta = 3;

        pub fn gold_delta(&self) -> u32 {
            self.gold_delta.unwrap_or(0)
        }

        pub fn clear_gold_delta(&mut self) {
            self.gold_delta = ::std::option::Option::None;
        }

        pub fn has_gold_delta(&self) -> bool {
            self.gold_delta.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_delta(&mut self, v: u32) {
            self.gold_delta = ::std::option::Option::Some(v);
        }

        // optional uint32 xp_delta = 4;

        pub fn xp_delta(&self) -> u32 {
            self.xp_delta.unwrap_or(0)
        }

        pub fn clear_xp_delta(&mut self) {
            self.xp_delta = ::std::option::Option::None;
        }

        pub fn has_xp_delta(&self) -> bool {
            self.xp_delta.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xp_delta(&mut self, v: u32) {
            self.xp_delta = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_StatsFightTeamDetails {
        const NAME: &'static str = "CDOTAUserMsg_StatsFightTeamDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_int32_into(&mut self.participants)?;
                    },
                    8 => {
                        self.participants.push(is.read_int32()?);
                    },
                    18 => {
                        is.read_repeated_packed_int32_into(&mut self.deaths)?;
                    },
                    16 => {
                        self.deaths.push(is.read_int32()?);
                    },
                    24 => {
                        self.gold_delta = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.xp_delta = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.participants {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, *value);
            };
            for value in &self.deaths {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, *value);
            };
            if let Some(v) = self.gold_delta {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.xp_delta {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            for v in &self.participants {
                os.write_int32(1, *v)?;
            };
            for v in &self.deaths {
                os.write_int32(2, *v)?;
            };
            if let Some(v) = self.gold_delta {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.xp_delta {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CDOTAUserMsg_StatsFightTeamDetails {
            CDOTAUserMsg_StatsFightTeamDetails::new()
        }

        fn clear(&mut self) {
            self.participants.clear();
            self.deaths.clear();
            self.gold_delta = ::std::option::Option::None;
            self.xp_delta = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CDOTAUserMsg_StatsFightTeamDetails {
            static instance: CDOTAUserMsg_StatsFightTeamDetails = CDOTAUserMsg_StatsFightTeamDetails {
                participants: ::std::vec::Vec::new(),
                deaths: ::std::vec::Vec::new(),
                gold_delta: ::std::option::Option::None,
                xp_delta: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CDOTAUserMsg_StatsFightDetails {
        // message fields
        // @@protoc_insertion_point(field:CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails.start_time)
        pub start_time: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails.end_time)
        pub end_time: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails.radiant_fight_details)
        pub radiant_fight_details: ::steam_vent_proto_common::protobuf::MessageField<CDOTAUserMsg_StatsFightTeamDetails>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails.dire_fight_details)
        pub dire_fight_details: ::steam_vent_proto_common::protobuf::MessageField<CDOTAUserMsg_StatsFightTeamDetails>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CDOTAUserMsg_StatsFightDetails {
        fn default() -> &'a CDOTAUserMsg_StatsFightDetails {
            <CDOTAUserMsg_StatsFightDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CDOTAUserMsg_StatsFightDetails {
        pub fn new() -> CDOTAUserMsg_StatsFightDetails {
            ::std::default::Default::default()
        }

        // optional float start_time = 1;

        pub fn start_time(&self) -> f32 {
            self.start_time.unwrap_or(0.)
        }

        pub fn clear_start_time(&mut self) {
            self.start_time = ::std::option::Option::None;
        }

        pub fn has_start_time(&self) -> bool {
            self.start_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_time(&mut self, v: f32) {
            self.start_time = ::std::option::Option::Some(v);
        }

        // optional float end_time = 2;

        pub fn end_time(&self) -> f32 {
            self.end_time.unwrap_or(0.)
        }

        pub fn clear_end_time(&mut self) {
            self.end_time = ::std::option::Option::None;
        }

        pub fn has_end_time(&self) -> bool {
            self.end_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end_time(&mut self, v: f32) {
            self.end_time = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_StatsFightDetails {
        const NAME: &'static str = "CDOTAUserMsg_StatsFightDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.start_time = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.end_time = ::std::option::Option::Some(is.read_float()?);
                    },
                    26 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.radiant_fight_details)?;
                    },
                    34 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.dire_fight_details)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.start_time {
                my_size += 1 + 4;
            }
            if let Some(v) = self.end_time {
                my_size += 1 + 4;
            }
            if let Some(v) = self.radiant_fight_details.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.dire_fight_details.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.start_time {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.end_time {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.radiant_fight_details.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.dire_fight_details.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CDOTAUserMsg_StatsFightDetails {
            CDOTAUserMsg_StatsFightDetails::new()
        }

        fn clear(&mut self) {
            self.start_time = ::std::option::Option::None;
            self.end_time = ::std::option::Option::None;
            self.radiant_fight_details.clear();
            self.dire_fight_details.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CDOTAUserMsg_StatsFightDetails {
            static instance: CDOTAUserMsg_StatsFightDetails = CDOTAUserMsg_StatsFightDetails {
                start_time: ::std::option::Option::None,
                end_time: ::std::option::Option::None,
                radiant_fight_details: ::steam_vent_proto_common::protobuf::MessageField::none(),
                dire_fight_details: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_MiniTaunt)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_MiniTaunt {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_MiniTaunt.taunting_player_id)
    pub taunting_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_MiniTaunt.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_MiniTaunt {
    fn default() -> &'a CDOTAUserMsg_MiniTaunt {
        <CDOTAUserMsg_MiniTaunt as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_MiniTaunt {
    pub fn new() -> CDOTAUserMsg_MiniTaunt {
        ::std::default::Default::default()
    }

    // optional int32 taunting_player_id = 1;

    pub fn taunting_player_id(&self) -> i32 {
        self.taunting_player_id.unwrap_or(-1i32)
    }

    pub fn clear_taunting_player_id(&mut self) {
        self.taunting_player_id = ::std::option::Option::None;
    }

    pub fn has_taunting_player_id(&self) -> bool {
        self.taunting_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_taunting_player_id(&mut self, v: i32) {
        self.taunting_player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_MiniTaunt {
    const NAME: &'static str = "CDOTAUserMsg_MiniTaunt";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.taunting_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.taunting_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.taunting_player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_MiniTaunt {
        CDOTAUserMsg_MiniTaunt::new()
    }

    fn clear(&mut self) {
        self.taunting_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_MiniTaunt {
        static instance: CDOTAUserMsg_MiniTaunt = CDOTAUserMsg_MiniTaunt {
            taunting_player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_SpeechBubble)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SpeechBubble {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_SpeechBubble.destroy_all)
    pub destroy_all: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_SpeechBubble.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SpeechBubble {
    fn default() -> &'a CDOTAUserMsg_SpeechBubble {
        <CDOTAUserMsg_SpeechBubble as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SpeechBubble {
    pub fn new() -> CDOTAUserMsg_SpeechBubble {
        ::std::default::Default::default()
    }

    // optional bool destroy_all = 1;

    pub fn destroy_all(&self) -> bool {
        self.destroy_all.unwrap_or(false)
    }

    pub fn clear_destroy_all(&mut self) {
        self.destroy_all = ::std::option::Option::None;
    }

    pub fn has_destroy_all(&self) -> bool {
        self.destroy_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destroy_all(&mut self, v: bool) {
        self.destroy_all = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_SpeechBubble {
    const NAME: &'static str = "CDOTAUserMsg_SpeechBubble";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.destroy_all = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.destroy_all {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.destroy_all {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SpeechBubble {
        CDOTAUserMsg_SpeechBubble::new()
    }

    fn clear(&mut self) {
        self.destroy_all = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SpeechBubble {
        static instance: CDOTAUserMsg_SpeechBubble = CDOTAUserMsg_SpeechBubble {
            destroy_all: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_CustomHeaderMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CustomHeaderMessage {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_CustomHeaderMessage.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CustomHeaderMessage.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CustomHeaderMessage.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CustomHeaderMessage.value)
    pub value: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_CustomHeaderMessage.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CustomHeaderMessage {
    fn default() -> &'a CDOTAUserMsg_CustomHeaderMessage {
        <CDOTAUserMsg_CustomHeaderMessage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CustomHeaderMessage {
    pub fn new() -> CDOTAUserMsg_CustomHeaderMessage {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional float duration = 2;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional string message = 3;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 value = 4;

    pub fn value(&self) -> i32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_CustomHeaderMessage {
    const NAME: &'static str = "CDOTAUserMsg_CustomHeaderMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                26 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.value = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.value {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.value {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CustomHeaderMessage {
        CDOTAUserMsg_CustomHeaderMessage::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CustomHeaderMessage {
        static instance: CDOTAUserMsg_CustomHeaderMessage = CDOTAUserMsg_CustomHeaderMessage {
            player_id: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            message: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgHeroAbilityStat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHeroAbilityStat {
    // message fields
    // @@protoc_insertion_point(field:CMsgHeroAbilityStat.stat_type)
    pub stat_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EHeroStatType>>,
    // @@protoc_insertion_point(field:CMsgHeroAbilityStat.int_value)
    pub int_value: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgHeroAbilityStat.float_value)
    pub float_value: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHeroAbilityStat.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHeroAbilityStat {
    fn default() -> &'a CMsgHeroAbilityStat {
        <CMsgHeroAbilityStat as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgHeroAbilityStat {
    pub fn new() -> CMsgHeroAbilityStat {
        ::std::default::Default::default()
    }

    // optional .EHeroStatType stat_type = 1;

    pub fn stat_type(&self) -> EHeroStatType {
        match self.stat_type {
            Some(e) => e.enum_value_or(EHeroStatType::k_EHeroStatType_None),
            None => EHeroStatType::k_EHeroStatType_None,
        }
    }

    pub fn clear_stat_type(&mut self) {
        self.stat_type = ::std::option::Option::None;
    }

    pub fn has_stat_type(&self) -> bool {
        self.stat_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_type(&mut self, v: EHeroStatType) {
        self.stat_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 int_value = 2;

    pub fn int_value(&self) -> i32 {
        self.int_value.unwrap_or(0)
    }

    pub fn clear_int_value(&mut self) {
        self.int_value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        self.int_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: i32) {
        self.int_value = ::std::option::Option::Some(v);
    }

    // optional float float_value = 3;

    pub fn float_value(&self) -> f32 {
        self.float_value.unwrap_or(0.)
    }

    pub fn clear_float_value(&mut self) {
        self.float_value = ::std::option::Option::None;
    }

    pub fn has_float_value(&self) -> bool {
        self.float_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_float_value(&mut self, v: f32) {
        self.float_value = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgHeroAbilityStat {
    const NAME: &'static str = "CMsgHeroAbilityStat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.stat_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.int_value = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.float_value = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stat_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.int_value {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.float_value {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.stat_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.int_value {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.float_value {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHeroAbilityStat {
        CMsgHeroAbilityStat::new()
    }

    fn clear(&mut self) {
        self.stat_type = ::std::option::Option::None;
        self.int_value = ::std::option::Option::None;
        self.float_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHeroAbilityStat {
        static instance: CMsgHeroAbilityStat = CMsgHeroAbilityStat {
            stat_type: ::std::option::Option::None,
            int_value: ::std::option::Option::None,
            float_value: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgCombatAnalyzerPlayerStat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCombatAnalyzerPlayerStat {
    // message fields
    // @@protoc_insertion_point(field:CMsgCombatAnalyzerPlayerStat.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCombatAnalyzerPlayerStat.hero_ability_stats)
    pub hero_ability_stats: ::std::vec::Vec<CMsgHeroAbilityStat>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCombatAnalyzerPlayerStat.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCombatAnalyzerPlayerStat {
    fn default() -> &'a CMsgCombatAnalyzerPlayerStat {
        <CMsgCombatAnalyzerPlayerStat as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgCombatAnalyzerPlayerStat {
    pub fn new() -> CMsgCombatAnalyzerPlayerStat {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgCombatAnalyzerPlayerStat {
    const NAME: &'static str = "CMsgCombatAnalyzerPlayerStat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.hero_ability_stats.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.hero_ability_stats {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.hero_ability_stats {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCombatAnalyzerPlayerStat {
        CMsgCombatAnalyzerPlayerStat::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.hero_ability_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCombatAnalyzerPlayerStat {
        static instance: CMsgCombatAnalyzerPlayerStat = CMsgCombatAnalyzerPlayerStat {
            account_id: ::std::option::Option::None,
            hero_ability_stats: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgCombatAnalyzerStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCombatAnalyzerStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgCombatAnalyzerStats.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgCombatAnalyzerStats.player_stats)
    pub player_stats: ::std::vec::Vec<CMsgCombatAnalyzerPlayerStat>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCombatAnalyzerStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCombatAnalyzerStats {
    fn default() -> &'a CMsgCombatAnalyzerStats {
        <CMsgCombatAnalyzerStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgCombatAnalyzerStats {
    pub fn new() -> CMsgCombatAnalyzerStats {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgCombatAnalyzerStats {
    const NAME: &'static str = "CMsgCombatAnalyzerStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.player_stats.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.player_stats {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.player_stats {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCombatAnalyzerStats {
        CMsgCombatAnalyzerStats::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.player_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCombatAnalyzerStats {
        static instance: CMsgCombatAnalyzerStats = CMsgCombatAnalyzerStats {
            match_id: ::std::option::Option::None,
            player_stats: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_BeastChat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_BeastChat {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_BeastChat.team)
    pub team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_BeastChat.format)
    pub format: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_BeastChat.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_BeastChat.target)
    pub target: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_BeastChat.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_BeastChat {
    fn default() -> &'a CDOTAUserMsg_BeastChat {
        <CDOTAUserMsg_BeastChat as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_BeastChat {
    pub fn new() -> CDOTAUserMsg_BeastChat {
        ::std::default::Default::default()
    }

    // optional uint32 team = 1;

    pub fn team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional string format = 2;

    pub fn format(&self) -> &str {
        match self.format.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: ::std::string::String) {
        self.format = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_format(&mut self) -> &mut ::std::string::String {
        if self.format.is_none() {
            self.format = ::std::option::Option::Some(::std::string::String::new());
        }
        self.format.as_mut().unwrap()
    }

    // Take field
    pub fn take_format(&mut self) -> ::std::string::String {
        self.format.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 3;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string target = 4;

    pub fn target(&self) -> &str {
        match self.target.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_target(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ::std::string::String) {
        self.target = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut ::std::string::String {
        if self.target.is_none() {
            self.target = ::std::option::Option::Some(::std::string::String::new());
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> ::std::string::String {
        self.target.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_BeastChat {
    const NAME: &'static str = "CDOTAUserMsg_BeastChat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.format = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.target = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.format.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.target.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.team {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.format.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.target.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_BeastChat {
        CDOTAUserMsg_BeastChat::new()
    }

    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.format = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_BeastChat {
        static instance: CDOTAUserMsg_BeastChat = CDOTAUserMsg_BeastChat {
            team: ::std::option::Option::None,
            format: ::std::option::Option::None,
            message: ::std::option::Option::None,
            target: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_CustomHudElement_Create)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CustomHudElement_Create {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_CustomHudElement_Create.element_id)
    pub element_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CustomHudElement_Create.layout_filename)
    pub layout_filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CustomHudElement_Create.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_CustomHudElement_Create.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CustomHudElement_Create {
    fn default() -> &'a CDOTAUserMsg_CustomHudElement_Create {
        <CDOTAUserMsg_CustomHudElement_Create as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CustomHudElement_Create {
    pub fn new() -> CDOTAUserMsg_CustomHudElement_Create {
        ::std::default::Default::default()
    }

    // optional string element_id = 1;

    pub fn element_id(&self) -> &str {
        match self.element_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_element_id(&mut self) {
        self.element_id = ::std::option::Option::None;
    }

    pub fn has_element_id(&self) -> bool {
        self.element_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_element_id(&mut self, v: ::std::string::String) {
        self.element_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_element_id(&mut self) -> &mut ::std::string::String {
        if self.element_id.is_none() {
            self.element_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.element_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_element_id(&mut self) -> ::std::string::String {
        self.element_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string layout_filename = 2;

    pub fn layout_filename(&self) -> &str {
        match self.layout_filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_layout_filename(&mut self) {
        self.layout_filename = ::std::option::Option::None;
    }

    pub fn has_layout_filename(&self) -> bool {
        self.layout_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layout_filename(&mut self, v: ::std::string::String) {
        self.layout_filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_layout_filename(&mut self) -> &mut ::std::string::String {
        if self.layout_filename.is_none() {
            self.layout_filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.layout_filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_layout_filename(&mut self) -> ::std::string::String {
        self.layout_filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes data = 3;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_CustomHudElement_Create {
    const NAME: &'static str = "CDOTAUserMsg_CustomHudElement_Create";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.element_id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.layout_filename = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.element_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.layout_filename.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.element_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.layout_filename.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CustomHudElement_Create {
        CDOTAUserMsg_CustomHudElement_Create::new()
    }

    fn clear(&mut self) {
        self.element_id = ::std::option::Option::None;
        self.layout_filename = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CustomHudElement_Create {
        static instance: CDOTAUserMsg_CustomHudElement_Create = CDOTAUserMsg_CustomHudElement_Create {
            element_id: ::std::option::Option::None,
            layout_filename: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_CustomHudElement_Modify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CustomHudElement_Modify {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_CustomHudElement_Modify.element_id)
    pub element_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CustomHudElement_Modify.modify_visible)
    pub modify_visible: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CustomHudElement_Modify.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_CustomHudElement_Modify.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CustomHudElement_Modify {
    fn default() -> &'a CDOTAUserMsg_CustomHudElement_Modify {
        <CDOTAUserMsg_CustomHudElement_Modify as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CustomHudElement_Modify {
    pub fn new() -> CDOTAUserMsg_CustomHudElement_Modify {
        ::std::default::Default::default()
    }

    // optional string element_id = 1;

    pub fn element_id(&self) -> &str {
        match self.element_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_element_id(&mut self) {
        self.element_id = ::std::option::Option::None;
    }

    pub fn has_element_id(&self) -> bool {
        self.element_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_element_id(&mut self, v: ::std::string::String) {
        self.element_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_element_id(&mut self) -> &mut ::std::string::String {
        if self.element_id.is_none() {
            self.element_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.element_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_element_id(&mut self) -> ::std::string::String {
        self.element_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool modify_visible = 2;

    pub fn modify_visible(&self) -> bool {
        self.modify_visible.unwrap_or(false)
    }

    pub fn clear_modify_visible(&mut self) {
        self.modify_visible = ::std::option::Option::None;
    }

    pub fn has_modify_visible(&self) -> bool {
        self.modify_visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modify_visible(&mut self, v: bool) {
        self.modify_visible = ::std::option::Option::Some(v);
    }

    // optional bytes data = 3;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_CustomHudElement_Modify {
    const NAME: &'static str = "CDOTAUserMsg_CustomHudElement_Modify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.element_id = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.modify_visible = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.element_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.modify_visible {
            my_size += 1 + 1;
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.element_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.modify_visible {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CustomHudElement_Modify {
        CDOTAUserMsg_CustomHudElement_Modify::new()
    }

    fn clear(&mut self) {
        self.element_id = ::std::option::Option::None;
        self.modify_visible = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CustomHudElement_Modify {
        static instance: CDOTAUserMsg_CustomHudElement_Modify = CDOTAUserMsg_CustomHudElement_Modify {
            element_id: ::std::option::Option::None,
            modify_visible: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_CustomHudElement_Destroy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CustomHudElement_Destroy {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_CustomHudElement_Destroy.element_id)
    pub element_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_CustomHudElement_Destroy.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CustomHudElement_Destroy {
    fn default() -> &'a CDOTAUserMsg_CustomHudElement_Destroy {
        <CDOTAUserMsg_CustomHudElement_Destroy as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CustomHudElement_Destroy {
    pub fn new() -> CDOTAUserMsg_CustomHudElement_Destroy {
        ::std::default::Default::default()
    }

    // optional string element_id = 1;

    pub fn element_id(&self) -> &str {
        match self.element_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_element_id(&mut self) {
        self.element_id = ::std::option::Option::None;
    }

    pub fn has_element_id(&self) -> bool {
        self.element_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_element_id(&mut self, v: ::std::string::String) {
        self.element_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_element_id(&mut self) -> &mut ::std::string::String {
        if self.element_id.is_none() {
            self.element_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.element_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_element_id(&mut self) -> ::std::string::String {
        self.element_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_CustomHudElement_Destroy {
    const NAME: &'static str = "CDOTAUserMsg_CustomHudElement_Destroy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.element_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.element_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.element_id.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CustomHudElement_Destroy {
        CDOTAUserMsg_CustomHudElement_Destroy::new()
    }

    fn clear(&mut self) {
        self.element_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CustomHudElement_Destroy {
        static instance: CDOTAUserMsg_CustomHudElement_Destroy = CDOTAUserMsg_CustomHudElement_Destroy {
            element_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_CompendiumStatePlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CompendiumStatePlayer {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_CompendiumStatePlayer.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_CompendiumStatePlayer.level)
    pub level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_CompendiumStatePlayer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CompendiumStatePlayer {
    fn default() -> &'a CDOTAUserMsg_CompendiumStatePlayer {
        <CDOTAUserMsg_CompendiumStatePlayer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CompendiumStatePlayer {
    pub fn new() -> CDOTAUserMsg_CompendiumStatePlayer {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 level = 2;

    pub fn level(&self) -> u32 {
        self.level.unwrap_or(0)
    }

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_CompendiumStatePlayer {
    const NAME: &'static str = "CDOTAUserMsg_CompendiumStatePlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CompendiumStatePlayer {
        CDOTAUserMsg_CompendiumStatePlayer::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CompendiumStatePlayer {
        static instance: CDOTAUserMsg_CompendiumStatePlayer = CDOTAUserMsg_CompendiumStatePlayer {
            player_id: ::std::option::Option::None,
            level: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_CompendiumState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_CompendiumState {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_CompendiumState.compendium_players)
    pub compendium_players: ::std::vec::Vec<CDOTAUserMsg_CompendiumStatePlayer>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_CompendiumState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_CompendiumState {
    fn default() -> &'a CDOTAUserMsg_CompendiumState {
        <CDOTAUserMsg_CompendiumState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_CompendiumState {
    pub fn new() -> CDOTAUserMsg_CompendiumState {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_CompendiumState {
    const NAME: &'static str = "CDOTAUserMsg_CompendiumState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.compendium_players.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.compendium_players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.compendium_players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_CompendiumState {
        CDOTAUserMsg_CompendiumState::new()
    }

    fn clear(&mut self) {
        self.compendium_players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_CompendiumState {
        static instance: CDOTAUserMsg_CompendiumState = CDOTAUserMsg_CompendiumState {
            compendium_players: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_ProjectionAbility)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ProjectionAbility {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_ProjectionAbility.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ProjectionAbility.caster_ent_index)
    pub caster_ent_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ProjectionAbility.caster_team)
    pub caster_team: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ProjectionAbility.channel_end)
    pub channel_end: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ProjectionAbility.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ProjectionAbility.track_caster_only)
    pub track_caster_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ProjectionAbility.end_time)
    pub end_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ProjectionAbility.victim_ent_index)
    pub victim_ent_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_ProjectionAbility.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ProjectionAbility {
    fn default() -> &'a CDOTAUserMsg_ProjectionAbility {
        <CDOTAUserMsg_ProjectionAbility as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ProjectionAbility {
    pub fn new() -> CDOTAUserMsg_ProjectionAbility {
        ::std::default::Default::default()
    }

    // optional int32 ability_id = 1;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(-1i32)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional int32 caster_ent_index = 2;

    pub fn caster_ent_index(&self) -> i32 {
        self.caster_ent_index.unwrap_or(-1i32)
    }

    pub fn clear_caster_ent_index(&mut self) {
        self.caster_ent_index = ::std::option::Option::None;
    }

    pub fn has_caster_ent_index(&self) -> bool {
        self.caster_ent_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caster_ent_index(&mut self, v: i32) {
        self.caster_ent_index = ::std::option::Option::Some(v);
    }

    // optional int32 caster_team = 3;

    pub fn caster_team(&self) -> i32 {
        self.caster_team.unwrap_or(0)
    }

    pub fn clear_caster_team(&mut self) {
        self.caster_team = ::std::option::Option::None;
    }

    pub fn has_caster_team(&self) -> bool {
        self.caster_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caster_team(&mut self, v: i32) {
        self.caster_team = ::std::option::Option::Some(v);
    }

    // optional bool channel_end = 4;

    pub fn channel_end(&self) -> bool {
        self.channel_end.unwrap_or(false)
    }

    pub fn clear_channel_end(&mut self) {
        self.channel_end = ::std::option::Option::None;
    }

    pub fn has_channel_end(&self) -> bool {
        self.channel_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_end(&mut self, v: bool) {
        self.channel_end = ::std::option::Option::Some(v);
    }

    // optional bool track_caster_only = 6;

    pub fn track_caster_only(&self) -> bool {
        self.track_caster_only.unwrap_or(false)
    }

    pub fn clear_track_caster_only(&mut self) {
        self.track_caster_only = ::std::option::Option::None;
    }

    pub fn has_track_caster_only(&self) -> bool {
        self.track_caster_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_track_caster_only(&mut self, v: bool) {
        self.track_caster_only = ::std::option::Option::Some(v);
    }

    // optional float end_time = 7;

    pub fn end_time(&self) -> f32 {
        self.end_time.unwrap_or(0.)
    }

    pub fn clear_end_time(&mut self) {
        self.end_time = ::std::option::Option::None;
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: f32) {
        self.end_time = ::std::option::Option::Some(v);
    }

    // optional int32 victim_ent_index = 8;

    pub fn victim_ent_index(&self) -> i32 {
        self.victim_ent_index.unwrap_or(-1i32)
    }

    pub fn clear_victim_ent_index(&mut self) {
        self.victim_ent_index = ::std::option::Option::None;
    }

    pub fn has_victim_ent_index(&self) -> bool {
        self.victim_ent_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_ent_index(&mut self, v: i32) {
        self.victim_ent_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_ProjectionAbility {
    const NAME: &'static str = "CDOTAUserMsg_ProjectionAbility";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.caster_ent_index = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.caster_team = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.channel_end = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                48 => {
                    self.track_caster_only = ::std::option::Option::Some(is.read_bool()?);
                },
                61 => {
                    self.end_time = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.victim_ent_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.caster_ent_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.caster_team {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.channel_end {
            my_size += 1 + 1;
        }
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.track_caster_only {
            my_size += 1 + 1;
        }
        if let Some(v) = self.end_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.victim_ent_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ability_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.caster_ent_index {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.caster_team {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.channel_end {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.track_caster_only {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.end_time {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.victim_ent_index {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ProjectionAbility {
        CDOTAUserMsg_ProjectionAbility::new()
    }

    fn clear(&mut self) {
        self.ability_id = ::std::option::Option::None;
        self.caster_ent_index = ::std::option::Option::None;
        self.caster_team = ::std::option::Option::None;
        self.channel_end = ::std::option::Option::None;
        self.origin.clear();
        self.track_caster_only = ::std::option::Option::None;
        self.end_time = ::std::option::Option::None;
        self.victim_ent_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ProjectionAbility {
        static instance: CDOTAUserMsg_ProjectionAbility = CDOTAUserMsg_ProjectionAbility {
            ability_id: ::std::option::Option::None,
            caster_ent_index: ::std::option::Option::None,
            caster_team: ::std::option::Option::None,
            channel_end: ::std::option::Option::None,
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            track_caster_only: ::std::option::Option::None,
            end_time: ::std::option::Option::None,
            victim_ent_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_ProjectionEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ProjectionEvent {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_ProjectionEvent.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EProjectionEvent>>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ProjectionEvent.team)
    pub team: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_ProjectionEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ProjectionEvent {
    fn default() -> &'a CDOTAUserMsg_ProjectionEvent {
        <CDOTAUserMsg_ProjectionEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ProjectionEvent {
    pub fn new() -> CDOTAUserMsg_ProjectionEvent {
        ::std::default::Default::default()
    }

    // optional .EProjectionEvent event_id = 1;

    pub fn event_id(&self) -> EProjectionEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(EProjectionEvent::ePE_FirstBlood),
            None => EProjectionEvent::ePE_FirstBlood,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: EProjectionEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 team = 2;

    pub fn team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_ProjectionEvent {
    const NAME: &'static str = "CDOTAUserMsg_ProjectionEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.team = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.team {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.team {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ProjectionEvent {
        CDOTAUserMsg_ProjectionEvent::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.team = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ProjectionEvent {
        static instance: CDOTAUserMsg_ProjectionEvent = CDOTAUserMsg_ProjectionEvent {
            event_id: ::std::option::Option::None,
            team: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_XPAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_XPAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_XPAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_XPAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_XPAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_XPAlert {
    fn default() -> &'a CDOTAUserMsg_XPAlert {
        <CDOTAUserMsg_XPAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_XPAlert {
    pub fn new() -> CDOTAUserMsg_XPAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 2;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(-1i32)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_XPAlert {
    const NAME: &'static str = "CDOTAUserMsg_XPAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_XPAlert {
        CDOTAUserMsg_XPAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_XPAlert {
        static instance: CDOTAUserMsg_XPAlert = CDOTAUserMsg_XPAlert {
            player_id: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_TalentTreeAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TalentTreeAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_TalentTreeAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TalentTreeAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TalentTreeAlert.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TalentTreeAlert.slot)
    pub slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TalentTreeAlert.learned)
    pub learned: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_TalentTreeAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TalentTreeAlert {
    fn default() -> &'a CDOTAUserMsg_TalentTreeAlert {
        <CDOTAUserMsg_TalentTreeAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TalentTreeAlert {
    pub fn new() -> CDOTAUserMsg_TalentTreeAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 2;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(-1i32)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 ability_id = 3;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(-1i32)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional int32 slot = 4;

    pub fn slot(&self) -> i32 {
        self.slot.unwrap_or(0)
    }

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = ::std::option::Option::Some(v);
    }

    // optional bool learned = 5;

    pub fn learned(&self) -> bool {
        self.learned.unwrap_or(false)
    }

    pub fn clear_learned(&mut self) {
        self.learned = ::std::option::Option::None;
    }

    pub fn has_learned(&self) -> bool {
        self.learned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_learned(&mut self, v: bool) {
        self.learned = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_TalentTreeAlert {
    const NAME: &'static str = "CDOTAUserMsg_TalentTreeAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.slot = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.learned = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.learned {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ability_id {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.slot {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.learned {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TalentTreeAlert {
        CDOTAUserMsg_TalentTreeAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.ability_id = ::std::option::Option::None;
        self.slot = ::std::option::Option::None;
        self.learned = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TalentTreeAlert {
        static instance: CDOTAUserMsg_TalentTreeAlert = CDOTAUserMsg_TalentTreeAlert {
            player_id: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            ability_id: ::std::option::Option::None,
            slot: ::std::option::Option::None,
            learned: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_UpdateQuestProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_UpdateQuestProgress {
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_UpdateQuestProgress.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_UpdateQuestProgress {
    fn default() -> &'a CDOTAUserMsg_UpdateQuestProgress {
        <CDOTAUserMsg_UpdateQuestProgress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_UpdateQuestProgress {
    pub fn new() -> CDOTAUserMsg_UpdateQuestProgress {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_UpdateQuestProgress {
    const NAME: &'static str = "CDOTAUserMsg_UpdateQuestProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_UpdateQuestProgress {
        CDOTAUserMsg_UpdateQuestProgress::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_UpdateQuestProgress {
        static instance: CDOTAUserMsg_UpdateQuestProgress = CDOTAUserMsg_UpdateQuestProgress {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_QuestStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_QuestStatus {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_QuestStatus.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_QuestStatus.quest_id)
    pub quest_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_QuestStatus.challenge_id)
    pub challenge_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_QuestStatus.progress)
    pub progress: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_QuestStatus.goal)
    pub goal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_QuestStatus.query)
    pub query: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_QuestStatus.fail_gametime)
    pub fail_gametime: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_QuestStatus.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_QuestStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_QuestStatus {
    fn default() -> &'a CDOTAUserMsg_QuestStatus {
        <CDOTAUserMsg_QuestStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_QuestStatus {
    pub fn new() -> CDOTAUserMsg_QuestStatus {
        ::std::default::Default::default()
    }

    // required int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 quest_id = 2;

    pub fn quest_id(&self) -> u32 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u32) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_id = 3;

    pub fn challenge_id(&self) -> u32 {
        self.challenge_id.unwrap_or(0)
    }

    pub fn clear_challenge_id(&mut self) {
        self.challenge_id = ::std::option::Option::None;
    }

    pub fn has_challenge_id(&self) -> bool {
        self.challenge_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_id(&mut self, v: u32) {
        self.challenge_id = ::std::option::Option::Some(v);
    }

    // optional uint32 progress = 4;

    pub fn progress(&self) -> u32 {
        self.progress.unwrap_or(0)
    }

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: u32) {
        self.progress = ::std::option::Option::Some(v);
    }

    // optional uint32 goal = 5;

    pub fn goal(&self) -> u32 {
        self.goal.unwrap_or(0)
    }

    pub fn clear_goal(&mut self) {
        self.goal = ::std::option::Option::None;
    }

    pub fn has_goal(&self) -> bool {
        self.goal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_goal(&mut self, v: u32) {
        self.goal = ::std::option::Option::Some(v);
    }

    // optional uint32 query = 6;

    pub fn query(&self) -> u32 {
        self.query.unwrap_or(0)
    }

    pub fn clear_query(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: u32) {
        self.query = ::std::option::Option::Some(v);
    }

    // optional float fail_gametime = 7;

    pub fn fail_gametime(&self) -> f32 {
        self.fail_gametime.unwrap_or(0.)
    }

    pub fn clear_fail_gametime(&mut self) {
        self.fail_gametime = ::std::option::Option::None;
    }

    pub fn has_fail_gametime(&self) -> bool {
        self.fail_gametime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fail_gametime(&mut self, v: f32) {
        self.fail_gametime = ::std::option::Option::Some(v);
    }

    // optional int32 item_ability_id = 8;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(-1i32)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_QuestStatus {
    const NAME: &'static str = "CDOTAUserMsg_QuestStatus";

    fn is_initialized(&self) -> bool {
        if self.player_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.challenge_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.progress = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.goal = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.query = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.fail_gametime = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.quest_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.challenge_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.progress {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.goal {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.query {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.fail_gametime {
            my_size += 1 + 4;
        }
        if let Some(v) = self.item_ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.quest_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.challenge_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.progress {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.goal {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.query {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.fail_gametime {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.item_ability_id {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_QuestStatus {
        CDOTAUserMsg_QuestStatus::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.quest_id = ::std::option::Option::None;
        self.challenge_id = ::std::option::Option::None;
        self.progress = ::std::option::Option::None;
        self.goal = ::std::option::Option::None;
        self.query = ::std::option::Option::None;
        self.fail_gametime = ::std::option::Option::None;
        self.item_ability_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_QuestStatus {
        static instance: CDOTAUserMsg_QuestStatus = CDOTAUserMsg_QuestStatus {
            player_id: ::std::option::Option::None,
            quest_id: ::std::option::Option::None,
            challenge_id: ::std::option::Option::None,
            progress: ::std::option::Option::None,
            goal: ::std::option::Option::None,
            query: ::std::option::Option::None,
            fail_gametime: ::std::option::Option::None,
            item_ability_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_SuggestHeroPick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SuggestHeroPick {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_SuggestHeroPick.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SuggestHeroPick.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SuggestHeroPick.ban)
    pub ban: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SuggestHeroPick.facet_id)
    pub facet_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_SuggestHeroPick.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SuggestHeroPick {
    fn default() -> &'a CDOTAUserMsg_SuggestHeroPick {
        <CDOTAUserMsg_SuggestHeroPick as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SuggestHeroPick {
    pub fn new() -> CDOTAUserMsg_SuggestHeroPick {
        ::std::default::Default::default()
    }

    // required int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 2;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional bool ban = 3;

    pub fn ban(&self) -> bool {
        self.ban.unwrap_or(false)
    }

    pub fn clear_ban(&mut self) {
        self.ban = ::std::option::Option::None;
    }

    pub fn has_ban(&self) -> bool {
        self.ban.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban(&mut self, v: bool) {
        self.ban = ::std::option::Option::Some(v);
    }

    // optional uint32 facet_id = 4;

    pub fn facet_id(&self) -> u32 {
        self.facet_id.unwrap_or(0)
    }

    pub fn clear_facet_id(&mut self) {
        self.facet_id = ::std::option::Option::None;
    }

    pub fn has_facet_id(&self) -> bool {
        self.facet_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_facet_id(&mut self, v: u32) {
        self.facet_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_SuggestHeroPick {
    const NAME: &'static str = "CDOTAUserMsg_SuggestHeroPick";

    fn is_initialized(&self) -> bool {
        if self.player_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.ban = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.facet_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.ban {
            my_size += 1 + 1;
        }
        if let Some(v) = self.facet_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ban {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.facet_id {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SuggestHeroPick {
        CDOTAUserMsg_SuggestHeroPick::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.ban = ::std::option::Option::None;
        self.facet_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SuggestHeroPick {
        static instance: CDOTAUserMsg_SuggestHeroPick = CDOTAUserMsg_SuggestHeroPick {
            player_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            ban: ::std::option::Option::None,
            facet_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_SuggestHeroRole)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SuggestHeroRole {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_SuggestHeroRole.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SuggestHeroRole.hero_role)
    pub hero_role: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_SuggestHeroRole.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SuggestHeroRole {
    fn default() -> &'a CDOTAUserMsg_SuggestHeroRole {
        <CDOTAUserMsg_SuggestHeroRole as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SuggestHeroRole {
    pub fn new() -> CDOTAUserMsg_SuggestHeroRole {
        ::std::default::Default::default()
    }

    // required int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional string hero_role = 2;

    pub fn hero_role(&self) -> &str {
        match self.hero_role.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hero_role(&mut self) {
        self.hero_role = ::std::option::Option::None;
    }

    pub fn has_hero_role(&self) -> bool {
        self.hero_role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_role(&mut self, v: ::std::string::String) {
        self.hero_role = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hero_role(&mut self) -> &mut ::std::string::String {
        if self.hero_role.is_none() {
            self.hero_role = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hero_role.as_mut().unwrap()
    }

    // Take field
    pub fn take_hero_role(&mut self) -> ::std::string::String {
        self.hero_role.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_SuggestHeroRole {
    const NAME: &'static str = "CDOTAUserMsg_SuggestHeroRole";

    fn is_initialized(&self) -> bool {
        if self.player_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.hero_role = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.hero_role.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.hero_role.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SuggestHeroRole {
        CDOTAUserMsg_SuggestHeroRole::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.hero_role = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SuggestHeroRole {
        static instance: CDOTAUserMsg_SuggestHeroRole = CDOTAUserMsg_SuggestHeroRole {
            player_id: ::std::option::Option::None,
            hero_role: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_KillcamDamageTaken)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_KillcamDamageTaken {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_KillcamDamageTaken.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_KillcamDamageTaken.damage_taken)
    pub damage_taken: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_KillcamDamageTaken.item_type)
    pub item_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_KillcamDamageTaken.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_KillcamDamageTaken.hero_name)
    pub hero_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_KillcamDamageTaken.damage_color)
    pub damage_color: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_KillcamDamageTaken.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_KillcamDamageTaken {
    fn default() -> &'a CDOTAUserMsg_KillcamDamageTaken {
        <CDOTAUserMsg_KillcamDamageTaken as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_KillcamDamageTaken {
    pub fn new() -> CDOTAUserMsg_KillcamDamageTaken {
        ::std::default::Default::default()
    }

    // required int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_taken = 2;

    pub fn damage_taken(&self) -> u32 {
        self.damage_taken.unwrap_or(0)
    }

    pub fn clear_damage_taken(&mut self) {
        self.damage_taken = ::std::option::Option::None;
    }

    pub fn has_damage_taken(&self) -> bool {
        self.damage_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_taken(&mut self, v: u32) {
        self.damage_taken = ::std::option::Option::Some(v);
    }

    // optional uint32 item_type = 3;

    pub fn item_type(&self) -> u32 {
        self.item_type.unwrap_or(0)
    }

    pub fn clear_item_type(&mut self) {
        self.item_type = ::std::option::Option::None;
    }

    pub fn has_item_type(&self) -> bool {
        self.item_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_type(&mut self, v: u32) {
        self.item_type = ::std::option::Option::Some(v);
    }

    // optional int32 item_ability_id = 4;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(-1i32)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    // optional string hero_name = 5;

    pub fn hero_name(&self) -> &str {
        match self.hero_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hero_name(&mut self) {
        self.hero_name = ::std::option::Option::None;
    }

    pub fn has_hero_name(&self) -> bool {
        self.hero_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_name(&mut self, v: ::std::string::String) {
        self.hero_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hero_name(&mut self) -> &mut ::std::string::String {
        if self.hero_name.is_none() {
            self.hero_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hero_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_hero_name(&mut self) -> ::std::string::String {
        self.hero_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string damage_color = 6;

    pub fn damage_color(&self) -> &str {
        match self.damage_color.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_damage_color(&mut self) {
        self.damage_color = ::std::option::Option::None;
    }

    pub fn has_damage_color(&self) -> bool {
        self.damage_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_color(&mut self, v: ::std::string::String) {
        self.damage_color = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_damage_color(&mut self) -> &mut ::std::string::String {
        if self.damage_color.is_none() {
            self.damage_color = ::std::option::Option::Some(::std::string::String::new());
        }
        self.damage_color.as_mut().unwrap()
    }

    // Take field
    pub fn take_damage_color(&mut self) -> ::std::string::String {
        self.damage_color.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_KillcamDamageTaken {
    const NAME: &'static str = "CDOTAUserMsg_KillcamDamageTaken";

    fn is_initialized(&self) -> bool {
        if self.player_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.damage_taken = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.hero_name = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.damage_color = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.damage_taken {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.item_ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.hero_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.damage_color.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.damage_taken {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.item_ability_id {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.hero_name.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.damage_color.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_KillcamDamageTaken {
        CDOTAUserMsg_KillcamDamageTaken::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.damage_taken = ::std::option::Option::None;
        self.item_type = ::std::option::Option::None;
        self.item_ability_id = ::std::option::Option::None;
        self.hero_name = ::std::option::Option::None;
        self.damage_color = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_KillcamDamageTaken {
        static instance: CDOTAUserMsg_KillcamDamageTaken = CDOTAUserMsg_KillcamDamageTaken {
            player_id: ::std::option::Option::None,
            damage_taken: ::std::option::Option::None,
            item_type: ::std::option::Option::None,
            item_ability_id: ::std::option::Option::None,
            hero_name: ::std::option::Option::None,
            damage_color: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_SelectPenaltyGold)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SelectPenaltyGold {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_SelectPenaltyGold.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SelectPenaltyGold.cost)
    pub cost: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_SelectPenaltyGold.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SelectPenaltyGold {
    fn default() -> &'a CDOTAUserMsg_SelectPenaltyGold {
        <CDOTAUserMsg_SelectPenaltyGold as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SelectPenaltyGold {
    pub fn new() -> CDOTAUserMsg_SelectPenaltyGold {
        ::std::default::Default::default()
    }

    // required int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional sint32 cost = 2;

    pub fn cost(&self) -> i32 {
        self.cost.unwrap_or(0)
    }

    pub fn clear_cost(&mut self) {
        self.cost = ::std::option::Option::None;
    }

    pub fn has_cost(&self) -> bool {
        self.cost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cost(&mut self, v: i32) {
        self.cost = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_SelectPenaltyGold {
    const NAME: &'static str = "CDOTAUserMsg_SelectPenaltyGold";

    fn is_initialized(&self) -> bool {
        if self.player_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.cost = ::std::option::Option::Some(is.read_sint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.cost {
            my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.cost {
            os.write_sint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SelectPenaltyGold {
        CDOTAUserMsg_SelectPenaltyGold::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.cost = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SelectPenaltyGold {
        static instance: CDOTAUserMsg_SelectPenaltyGold = CDOTAUserMsg_SelectPenaltyGold {
            player_id: ::std::option::Option::None,
            cost: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_RollDiceResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_RollDiceResult {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_RollDiceResult.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_RollDiceResult.channel_type)
    pub channel_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_RollDiceResult.roll_min)
    pub roll_min: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_RollDiceResult.roll_max)
    pub roll_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_RollDiceResult.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_RollDiceResult.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_RollDiceResult {
    fn default() -> &'a CDOTAUserMsg_RollDiceResult {
        <CDOTAUserMsg_RollDiceResult as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_RollDiceResult {
    pub fn new() -> CDOTAUserMsg_RollDiceResult {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 channel_type = 2;

    pub fn channel_type(&self) -> u32 {
        self.channel_type.unwrap_or(0)
    }

    pub fn clear_channel_type(&mut self) {
        self.channel_type = ::std::option::Option::None;
    }

    pub fn has_channel_type(&self) -> bool {
        self.channel_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_type(&mut self, v: u32) {
        self.channel_type = ::std::option::Option::Some(v);
    }

    // optional uint32 roll_min = 3;

    pub fn roll_min(&self) -> u32 {
        self.roll_min.unwrap_or(0)
    }

    pub fn clear_roll_min(&mut self) {
        self.roll_min = ::std::option::Option::None;
    }

    pub fn has_roll_min(&self) -> bool {
        self.roll_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roll_min(&mut self, v: u32) {
        self.roll_min = ::std::option::Option::Some(v);
    }

    // optional uint32 roll_max = 4;

    pub fn roll_max(&self) -> u32 {
        self.roll_max.unwrap_or(0)
    }

    pub fn clear_roll_max(&mut self) {
        self.roll_max = ::std::option::Option::None;
    }

    pub fn has_roll_max(&self) -> bool {
        self.roll_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roll_max(&mut self, v: u32) {
        self.roll_max = ::std::option::Option::Some(v);
    }

    // optional uint32 result = 5;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_RollDiceResult {
    const NAME: &'static str = "CDOTAUserMsg_RollDiceResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.channel_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.roll_min = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.roll_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.channel_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.roll_min {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.roll_max {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.channel_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.roll_min {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.roll_max {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.result {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_RollDiceResult {
        CDOTAUserMsg_RollDiceResult::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.channel_type = ::std::option::Option::None;
        self.roll_min = ::std::option::Option::None;
        self.roll_max = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_RollDiceResult {
        static instance: CDOTAUserMsg_RollDiceResult = CDOTAUserMsg_RollDiceResult {
            player_id: ::std::option::Option::None,
            channel_type: ::std::option::Option::None,
            roll_min: ::std::option::Option::None,
            roll_max: ::std::option::Option::None,
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_FlipCoinResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_FlipCoinResult {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_FlipCoinResult.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_FlipCoinResult.channel_type)
    pub channel_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_FlipCoinResult.result)
    pub result: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_FlipCoinResult.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_FlipCoinResult {
    fn default() -> &'a CDOTAUserMsg_FlipCoinResult {
        <CDOTAUserMsg_FlipCoinResult as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_FlipCoinResult {
    pub fn new() -> CDOTAUserMsg_FlipCoinResult {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 channel_type = 2;

    pub fn channel_type(&self) -> u32 {
        self.channel_type.unwrap_or(0)
    }

    pub fn clear_channel_type(&mut self) {
        self.channel_type = ::std::option::Option::None;
    }

    pub fn has_channel_type(&self) -> bool {
        self.channel_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_type(&mut self, v: u32) {
        self.channel_type = ::std::option::Option::Some(v);
    }

    // optional bool result = 3;

    pub fn result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_FlipCoinResult {
    const NAME: &'static str = "CDOTAUserMsg_FlipCoinResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.channel_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.result = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.channel_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.result {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.channel_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.result {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_FlipCoinResult {
        CDOTAUserMsg_FlipCoinResult::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.channel_type = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_FlipCoinResult {
        static instance: CDOTAUserMsg_FlipCoinResult = CDOTAUserMsg_FlipCoinResult {
            player_id: ::std::option::Option::None,
            channel_type: ::std::option::Option::None,
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMessage_RequestItemSuggestions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMessage_RequestItemSuggestions {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMessage_RequestItemSuggestions.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMessage_RequestItemSuggestions.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMessage_RequestItemSuggestions {
    fn default() -> &'a CDOTAUserMessage_RequestItemSuggestions {
        <CDOTAUserMessage_RequestItemSuggestions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMessage_RequestItemSuggestions {
    pub fn new() -> CDOTAUserMessage_RequestItemSuggestions {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMessage_RequestItemSuggestions {
    const NAME: &'static str = "CDOTAUserMessage_RequestItemSuggestions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMessage_RequestItemSuggestions {
        CDOTAUserMessage_RequestItemSuggestions::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMessage_RequestItemSuggestions {
        static instance: CDOTAUserMessage_RequestItemSuggestions = CDOTAUserMessage_RequestItemSuggestions {
            player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMessage_TeamCaptainChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMessage_TeamCaptainChanged {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMessage_TeamCaptainChanged.team)
    pub team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMessage_TeamCaptainChanged.captain_player_id)
    pub captain_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMessage_TeamCaptainChanged.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMessage_TeamCaptainChanged {
    fn default() -> &'a CDOTAUserMessage_TeamCaptainChanged {
        <CDOTAUserMessage_TeamCaptainChanged as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMessage_TeamCaptainChanged {
    pub fn new() -> CDOTAUserMessage_TeamCaptainChanged {
        ::std::default::Default::default()
    }

    // optional uint32 team = 1;

    pub fn team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional int32 captain_player_id = 2;

    pub fn captain_player_id(&self) -> i32 {
        self.captain_player_id.unwrap_or(-1i32)
    }

    pub fn clear_captain_player_id(&mut self) {
        self.captain_player_id = ::std::option::Option::None;
    }

    pub fn has_captain_player_id(&self) -> bool {
        self.captain_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_captain_player_id(&mut self, v: i32) {
        self.captain_player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMessage_TeamCaptainChanged {
    const NAME: &'static str = "CDOTAUserMessage_TeamCaptainChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.captain_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.captain_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.team {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.captain_player_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMessage_TeamCaptainChanged {
        CDOTAUserMessage_TeamCaptainChanged::new()
    }

    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.captain_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMessage_TeamCaptainChanged {
        static instance: CDOTAUserMessage_TeamCaptainChanged = CDOTAUserMessage_TeamCaptainChanged {
            team: ::std::option::Option::None,
            captain_player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_ChatWheelCooldown)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ChatWheelCooldown {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_ChatWheelCooldown.message_id)
    pub message_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ChatWheelCooldown.cooldown_remaining)
    pub cooldown_remaining: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_ChatWheelCooldown.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ChatWheelCooldown {
    fn default() -> &'a CDOTAUserMsg_ChatWheelCooldown {
        <CDOTAUserMsg_ChatWheelCooldown as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ChatWheelCooldown {
    pub fn new() -> CDOTAUserMsg_ChatWheelCooldown {
        ::std::default::Default::default()
    }

    // optional uint32 message_id = 1;

    pub fn message_id(&self) -> u32 {
        self.message_id.unwrap_or(4294967295u32)
    }

    pub fn clear_message_id(&mut self) {
        self.message_id = ::std::option::Option::None;
    }

    pub fn has_message_id(&self) -> bool {
        self.message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: u32) {
        self.message_id = ::std::option::Option::Some(v);
    }

    // optional float cooldown_remaining = 2;

    pub fn cooldown_remaining(&self) -> f32 {
        self.cooldown_remaining.unwrap_or(0.)
    }

    pub fn clear_cooldown_remaining(&mut self) {
        self.cooldown_remaining = ::std::option::Option::None;
    }

    pub fn has_cooldown_remaining(&self) -> bool {
        self.cooldown_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown_remaining(&mut self, v: f32) {
        self.cooldown_remaining = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_ChatWheelCooldown {
    const NAME: &'static str = "CDOTAUserMsg_ChatWheelCooldown";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.message_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.cooldown_remaining = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.cooldown_remaining {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.message_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cooldown_remaining {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ChatWheelCooldown {
        CDOTAUserMsg_ChatWheelCooldown::new()
    }

    fn clear(&mut self) {
        self.message_id = ::std::option::Option::None;
        self.cooldown_remaining = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ChatWheelCooldown {
        static instance: CDOTAUserMsg_ChatWheelCooldown = CDOTAUserMsg_ChatWheelCooldown {
            message_id: ::std::option::Option::None,
            cooldown_remaining: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_HeroRelicProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_HeroRelicProgress {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_HeroRelicProgress.hero_relic_type)
    pub hero_relic_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_HeroRelicProgress.value)
    pub value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_HeroRelicProgress.ehandle)
    pub ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_HeroRelicProgress.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_HeroRelicProgress.value_display)
    pub value_display: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_HeroRelicProgress.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_HeroRelicProgress {
    fn default() -> &'a CDOTAUserMsg_HeroRelicProgress {
        <CDOTAUserMsg_HeroRelicProgress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_HeroRelicProgress {
    pub fn new() -> CDOTAUserMsg_HeroRelicProgress {
        ::std::default::Default::default()
    }

    // optional uint32 hero_relic_type = 1;

    pub fn hero_relic_type(&self) -> u32 {
        self.hero_relic_type.unwrap_or(0)
    }

    pub fn clear_hero_relic_type(&mut self) {
        self.hero_relic_type = ::std::option::Option::None;
    }

    pub fn has_hero_relic_type(&self) -> bool {
        self.hero_relic_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_relic_type(&mut self, v: u32) {
        self.hero_relic_type = ::std::option::Option::Some(v);
    }

    // optional uint32 value = 2;

    pub fn value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional uint32 ehandle = 3;

    pub fn ehandle(&self) -> u32 {
        self.ehandle.unwrap_or(16777215u32)
    }

    pub fn clear_ehandle(&mut self) {
        self.ehandle = ::std::option::Option::None;
    }

    pub fn has_ehandle(&self) -> bool {
        self.ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ehandle(&mut self, v: u32) {
        self.ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 4;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional float value_display = 5;

    pub fn value_display(&self) -> f32 {
        self.value_display.unwrap_or(0.)
    }

    pub fn clear_value_display(&mut self) {
        self.value_display = ::std::option::Option::None;
    }

    pub fn has_value_display(&self) -> bool {
        self.value_display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_display(&mut self, v: f32) {
        self.value_display = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_HeroRelicProgress {
    const NAME: &'static str = "CDOTAUserMsg_HeroRelicProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_relic_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.value = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    self.value_display = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_relic_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.ehandle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.value_display {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hero_relic_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ehandle {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.value_display {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_HeroRelicProgress {
        CDOTAUserMsg_HeroRelicProgress::new()
    }

    fn clear(&mut self) {
        self.hero_relic_type = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.ehandle = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.value_display = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_HeroRelicProgress {
        static instance: CDOTAUserMsg_HeroRelicProgress = CDOTAUserMsg_HeroRelicProgress {
            hero_relic_type: ::std::option::Option::None,
            value: ::std::option::Option::None,
            ehandle: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            value_display: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_AbilityDraftRequestAbility)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_AbilityDraftRequestAbility {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_AbilityDraftRequestAbility.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AbilityDraftRequestAbility.requested_ability_id)
    pub requested_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AbilityDraftRequestAbility.ctrl_is_down)
    pub ctrl_is_down: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_AbilityDraftRequestAbility.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_AbilityDraftRequestAbility {
    fn default() -> &'a CDOTAUserMsg_AbilityDraftRequestAbility {
        <CDOTAUserMsg_AbilityDraftRequestAbility as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_AbilityDraftRequestAbility {
    pub fn new() -> CDOTAUserMsg_AbilityDraftRequestAbility {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 requested_ability_id = 2;

    pub fn requested_ability_id(&self) -> i32 {
        self.requested_ability_id.unwrap_or(-1i32)
    }

    pub fn clear_requested_ability_id(&mut self) {
        self.requested_ability_id = ::std::option::Option::None;
    }

    pub fn has_requested_ability_id(&self) -> bool {
        self.requested_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requested_ability_id(&mut self, v: i32) {
        self.requested_ability_id = ::std::option::Option::Some(v);
    }

    // optional bool ctrl_is_down = 3;

    pub fn ctrl_is_down(&self) -> bool {
        self.ctrl_is_down.unwrap_or(false)
    }

    pub fn clear_ctrl_is_down(&mut self) {
        self.ctrl_is_down = ::std::option::Option::None;
    }

    pub fn has_ctrl_is_down(&self) -> bool {
        self.ctrl_is_down.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctrl_is_down(&mut self, v: bool) {
        self.ctrl_is_down = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_AbilityDraftRequestAbility {
    const NAME: &'static str = "CDOTAUserMsg_AbilityDraftRequestAbility";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.requested_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.ctrl_is_down = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.requested_ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.ctrl_is_down {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.requested_ability_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ctrl_is_down {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_AbilityDraftRequestAbility {
        CDOTAUserMsg_AbilityDraftRequestAbility::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.requested_ability_id = ::std::option::Option::None;
        self.ctrl_is_down = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_AbilityDraftRequestAbility {
        static instance: CDOTAUserMsg_AbilityDraftRequestAbility = CDOTAUserMsg_AbilityDraftRequestAbility {
            player_id: ::std::option::Option::None,
            requested_ability_id: ::std::option::Option::None,
            ctrl_is_down: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_DamageReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_DamageReport {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_DamageReport.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_DamageReport.target_hero_id)
    pub target_hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_DamageReport.source_hero_id)
    pub source_hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_DamageReport.damage_amount)
    pub damage_amount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_DamageReport.broadcast)
    pub broadcast: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_DamageReport.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_DamageReport {
    fn default() -> &'a CDOTAUserMsg_DamageReport {
        <CDOTAUserMsg_DamageReport as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_DamageReport {
    pub fn new() -> CDOTAUserMsg_DamageReport {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_hero_id = 2;

    pub fn target_hero_id(&self) -> i32 {
        self.target_hero_id.unwrap_or(0)
    }

    pub fn clear_target_hero_id(&mut self) {
        self.target_hero_id = ::std::option::Option::None;
    }

    pub fn has_target_hero_id(&self) -> bool {
        self.target_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_hero_id(&mut self, v: i32) {
        self.target_hero_id = ::std::option::Option::Some(v);
    }

    // optional int32 source_hero_id = 3;

    pub fn source_hero_id(&self) -> i32 {
        self.source_hero_id.unwrap_or(0)
    }

    pub fn clear_source_hero_id(&mut self) {
        self.source_hero_id = ::std::option::Option::None;
    }

    pub fn has_source_hero_id(&self) -> bool {
        self.source_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_hero_id(&mut self, v: i32) {
        self.source_hero_id = ::std::option::Option::Some(v);
    }

    // optional int32 damage_amount = 4;

    pub fn damage_amount(&self) -> i32 {
        self.damage_amount.unwrap_or(0)
    }

    pub fn clear_damage_amount(&mut self) {
        self.damage_amount = ::std::option::Option::None;
    }

    pub fn has_damage_amount(&self) -> bool {
        self.damage_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_amount(&mut self, v: i32) {
        self.damage_amount = ::std::option::Option::Some(v);
    }

    // optional bool broadcast = 5;

    pub fn broadcast(&self) -> bool {
        self.broadcast.unwrap_or(false)
    }

    pub fn clear_broadcast(&mut self) {
        self.broadcast = ::std::option::Option::None;
    }

    pub fn has_broadcast(&self) -> bool {
        self.broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast(&mut self, v: bool) {
        self.broadcast = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_DamageReport {
    const NAME: &'static str = "CDOTAUserMsg_DamageReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.source_hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.damage_amount = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.broadcast = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.source_hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.damage_amount {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.broadcast {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_hero_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.source_hero_id {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.damage_amount {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.broadcast {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_DamageReport {
        CDOTAUserMsg_DamageReport::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.target_hero_id = ::std::option::Option::None;
        self.source_hero_id = ::std::option::Option::None;
        self.damage_amount = ::std::option::Option::None;
        self.broadcast = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_DamageReport {
        static instance: CDOTAUserMsg_DamageReport = CDOTAUserMsg_DamageReport {
            player_id: ::std::option::Option::None,
            target_hero_id: ::std::option::Option::None,
            source_hero_id: ::std::option::Option::None,
            damage_amount: ::std::option::Option::None,
            broadcast: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_SalutePlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_SalutePlayer {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_SalutePlayer.source_player_id)
    pub source_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SalutePlayer.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SalutePlayer.tip_amount)
    pub tip_amount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SalutePlayer.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SalutePlayer.custom_tip_style)
    pub custom_tip_style: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_SalutePlayer.num_recent_tips)
    pub num_recent_tips: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_SalutePlayer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_SalutePlayer {
    fn default() -> &'a CDOTAUserMsg_SalutePlayer {
        <CDOTAUserMsg_SalutePlayer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_SalutePlayer {
    pub fn new() -> CDOTAUserMsg_SalutePlayer {
        ::std::default::Default::default()
    }

    // optional int32 source_player_id = 1;

    pub fn source_player_id(&self) -> i32 {
        self.source_player_id.unwrap_or(-1i32)
    }

    pub fn clear_source_player_id(&mut self) {
        self.source_player_id = ::std::option::Option::None;
    }

    pub fn has_source_player_id(&self) -> bool {
        self.source_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_player_id(&mut self, v: i32) {
        self.source_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_player_id = 2;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(-1i32)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 tip_amount = 3;

    pub fn tip_amount(&self) -> u32 {
        self.tip_amount.unwrap_or(0)
    }

    pub fn clear_tip_amount(&mut self) {
        self.tip_amount = ::std::option::Option::None;
    }

    pub fn has_tip_amount(&self) -> bool {
        self.tip_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tip_amount(&mut self, v: u32) {
        self.tip_amount = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 4;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional string custom_tip_style = 5;

    pub fn custom_tip_style(&self) -> &str {
        match self.custom_tip_style.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_tip_style(&mut self) {
        self.custom_tip_style = ::std::option::Option::None;
    }

    pub fn has_custom_tip_style(&self) -> bool {
        self.custom_tip_style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_tip_style(&mut self, v: ::std::string::String) {
        self.custom_tip_style = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_tip_style(&mut self) -> &mut ::std::string::String {
        if self.custom_tip_style.is_none() {
            self.custom_tip_style = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_tip_style.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_tip_style(&mut self) -> ::std::string::String {
        self.custom_tip_style.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 num_recent_tips = 6;

    pub fn num_recent_tips(&self) -> u32 {
        self.num_recent_tips.unwrap_or(0)
    }

    pub fn clear_num_recent_tips(&mut self) {
        self.num_recent_tips = ::std::option::Option::None;
    }

    pub fn has_num_recent_tips(&self) -> bool {
        self.num_recent_tips.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_recent_tips(&mut self, v: u32) {
        self.num_recent_tips = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_SalutePlayer {
    const NAME: &'static str = "CDOTAUserMsg_SalutePlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.tip_amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.custom_tip_style = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.num_recent_tips = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.tip_amount {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.custom_tip_style.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.num_recent_tips {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.source_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.tip_amount {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.custom_tip_style.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.num_recent_tips {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_SalutePlayer {
        CDOTAUserMsg_SalutePlayer::new()
    }

    fn clear(&mut self) {
        self.source_player_id = ::std::option::Option::None;
        self.target_player_id = ::std::option::Option::None;
        self.tip_amount = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.custom_tip_style = ::std::option::Option::None;
        self.num_recent_tips = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_SalutePlayer {
        static instance: CDOTAUserMsg_SalutePlayer = CDOTAUserMsg_SalutePlayer {
            source_player_id: ::std::option::Option::None,
            target_player_id: ::std::option::Option::None,
            tip_amount: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            custom_tip_style: ::std::option::Option::None,
            num_recent_tips: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_GiftPlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_GiftPlayer {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_GiftPlayer.source_player_id)
    pub source_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_GiftPlayer.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_GiftPlayer.gift_item_def_index)
    pub gift_item_def_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_GiftPlayer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_GiftPlayer {
    fn default() -> &'a CDOTAUserMsg_GiftPlayer {
        <CDOTAUserMsg_GiftPlayer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_GiftPlayer {
    pub fn new() -> CDOTAUserMsg_GiftPlayer {
        ::std::default::Default::default()
    }

    // optional int32 source_player_id = 1;

    pub fn source_player_id(&self) -> i32 {
        self.source_player_id.unwrap_or(-1i32)
    }

    pub fn clear_source_player_id(&mut self) {
        self.source_player_id = ::std::option::Option::None;
    }

    pub fn has_source_player_id(&self) -> bool {
        self.source_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_player_id(&mut self, v: i32) {
        self.source_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_player_id = 2;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(-1i32)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 gift_item_def_index = 3;

    pub fn gift_item_def_index(&self) -> u32 {
        self.gift_item_def_index.unwrap_or(0)
    }

    pub fn clear_gift_item_def_index(&mut self) {
        self.gift_item_def_index = ::std::option::Option::None;
    }

    pub fn has_gift_item_def_index(&self) -> bool {
        self.gift_item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gift_item_def_index(&mut self, v: u32) {
        self.gift_item_def_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_GiftPlayer {
    const NAME: &'static str = "CDOTAUserMsg_GiftPlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.gift_item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.gift_item_def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.source_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.gift_item_def_index {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_GiftPlayer {
        CDOTAUserMsg_GiftPlayer::new()
    }

    fn clear(&mut self) {
        self.source_player_id = ::std::option::Option::None;
        self.target_player_id = ::std::option::Option::None;
        self.gift_item_def_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_GiftPlayer {
        static instance: CDOTAUserMsg_GiftPlayer = CDOTAUserMsg_GiftPlayer {
            source_player_id: ::std::option::Option::None,
            target_player_id: ::std::option::Option::None,
            gift_item_def_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_TipAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_TipAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_TipAlert.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_TipAlert.tip_text)
    pub tip_text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_TipAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_TipAlert {
    fn default() -> &'a CDOTAUserMsg_TipAlert {
        <CDOTAUserMsg_TipAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_TipAlert {
    pub fn new() -> CDOTAUserMsg_TipAlert {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional string tip_text = 2;

    pub fn tip_text(&self) -> &str {
        match self.tip_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tip_text(&mut self) {
        self.tip_text = ::std::option::Option::None;
    }

    pub fn has_tip_text(&self) -> bool {
        self.tip_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tip_text(&mut self, v: ::std::string::String) {
        self.tip_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tip_text(&mut self) -> &mut ::std::string::String {
        if self.tip_text.is_none() {
            self.tip_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tip_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_tip_text(&mut self) -> ::std::string::String {
        self.tip_text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_TipAlert {
    const NAME: &'static str = "CDOTAUserMsg_TipAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.tip_text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.tip_text.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.tip_text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_TipAlert {
        CDOTAUserMsg_TipAlert::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.tip_text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_TipAlert {
        static instance: CDOTAUserMsg_TipAlert = CDOTAUserMsg_TipAlert {
            player_id: ::std::option::Option::None,
            tip_text: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_ReplaceQueryUnit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ReplaceQueryUnit {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_ReplaceQueryUnit.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ReplaceQueryUnit.source_entindex)
    pub source_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ReplaceQueryUnit.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_ReplaceQueryUnit.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ReplaceQueryUnit {
    fn default() -> &'a CDOTAUserMsg_ReplaceQueryUnit {
        <CDOTAUserMsg_ReplaceQueryUnit as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ReplaceQueryUnit {
    pub fn new() -> CDOTAUserMsg_ReplaceQueryUnit {
        ::std::default::Default::default()
    }

    // required int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 source_entindex = 2;

    pub fn source_entindex(&self) -> i32 {
        self.source_entindex.unwrap_or(-1i32)
    }

    pub fn clear_source_entindex(&mut self) {
        self.source_entindex = ::std::option::Option::None;
    }

    pub fn has_source_entindex(&self) -> bool {
        self.source_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_entindex(&mut self, v: i32) {
        self.source_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 3;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(-1i32)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_ReplaceQueryUnit {
    const NAME: &'static str = "CDOTAUserMsg_ReplaceQueryUnit";

    fn is_initialized(&self) -> bool {
        if self.player_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.source_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.source_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.source_entindex {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ReplaceQueryUnit {
        CDOTAUserMsg_ReplaceQueryUnit::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.source_entindex = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ReplaceQueryUnit {
        static instance: CDOTAUserMsg_ReplaceQueryUnit = CDOTAUserMsg_ReplaceQueryUnit {
            player_id: ::std::option::Option::None,
            source_entindex: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_ESArcanaCombo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ESArcanaCombo {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_ESArcanaCombo.ehandle)
    pub ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ESArcanaCombo.combo_count)
    pub combo_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ESArcanaCombo.arcana_level)
    pub arcana_level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_ESArcanaCombo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ESArcanaCombo {
    fn default() -> &'a CDOTAUserMsg_ESArcanaCombo {
        <CDOTAUserMsg_ESArcanaCombo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ESArcanaCombo {
    pub fn new() -> CDOTAUserMsg_ESArcanaCombo {
        ::std::default::Default::default()
    }

    // optional uint32 ehandle = 1;

    pub fn ehandle(&self) -> u32 {
        self.ehandle.unwrap_or(16777215u32)
    }

    pub fn clear_ehandle(&mut self) {
        self.ehandle = ::std::option::Option::None;
    }

    pub fn has_ehandle(&self) -> bool {
        self.ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ehandle(&mut self, v: u32) {
        self.ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 combo_count = 2;

    pub fn combo_count(&self) -> u32 {
        self.combo_count.unwrap_or(0)
    }

    pub fn clear_combo_count(&mut self) {
        self.combo_count = ::std::option::Option::None;
    }

    pub fn has_combo_count(&self) -> bool {
        self.combo_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_combo_count(&mut self, v: u32) {
        self.combo_count = ::std::option::Option::Some(v);
    }

    // optional uint32 arcana_level = 3;

    pub fn arcana_level(&self) -> u32 {
        self.arcana_level.unwrap_or(0)
    }

    pub fn clear_arcana_level(&mut self) {
        self.arcana_level = ::std::option::Option::None;
    }

    pub fn has_arcana_level(&self) -> bool {
        self.arcana_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arcana_level(&mut self, v: u32) {
        self.arcana_level = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_ESArcanaCombo {
    const NAME: &'static str = "CDOTAUserMsg_ESArcanaCombo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.combo_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.arcana_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ehandle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.combo_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.arcana_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ehandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.combo_count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.arcana_level {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ESArcanaCombo {
        CDOTAUserMsg_ESArcanaCombo::new()
    }

    fn clear(&mut self) {
        self.ehandle = ::std::option::Option::None;
        self.combo_count = ::std::option::Option::None;
        self.arcana_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ESArcanaCombo {
        static instance: CDOTAUserMsg_ESArcanaCombo = CDOTAUserMsg_ESArcanaCombo {
            ehandle: ::std::option::Option::None,
            combo_count: ::std::option::Option::None,
            arcana_level: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_ESArcanaComboSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ESArcanaComboSummary {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_ESArcanaComboSummary.ehandle)
    pub ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ESArcanaComboSummary.combo_count)
    pub combo_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ESArcanaComboSummary.damage_amount)
    pub damage_amount: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_ESArcanaComboSummary.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ESArcanaComboSummary {
    fn default() -> &'a CDOTAUserMsg_ESArcanaComboSummary {
        <CDOTAUserMsg_ESArcanaComboSummary as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ESArcanaComboSummary {
    pub fn new() -> CDOTAUserMsg_ESArcanaComboSummary {
        ::std::default::Default::default()
    }

    // optional uint32 ehandle = 1;

    pub fn ehandle(&self) -> u32 {
        self.ehandle.unwrap_or(16777215u32)
    }

    pub fn clear_ehandle(&mut self) {
        self.ehandle = ::std::option::Option::None;
    }

    pub fn has_ehandle(&self) -> bool {
        self.ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ehandle(&mut self, v: u32) {
        self.ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 combo_count = 2;

    pub fn combo_count(&self) -> u32 {
        self.combo_count.unwrap_or(0)
    }

    pub fn clear_combo_count(&mut self) {
        self.combo_count = ::std::option::Option::None;
    }

    pub fn has_combo_count(&self) -> bool {
        self.combo_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_combo_count(&mut self, v: u32) {
        self.combo_count = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_amount = 3;

    pub fn damage_amount(&self) -> u32 {
        self.damage_amount.unwrap_or(0)
    }

    pub fn clear_damage_amount(&mut self) {
        self.damage_amount = ::std::option::Option::None;
    }

    pub fn has_damage_amount(&self) -> bool {
        self.damage_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_amount(&mut self, v: u32) {
        self.damage_amount = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_ESArcanaComboSummary {
    const NAME: &'static str = "CDOTAUserMsg_ESArcanaComboSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.combo_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.damage_amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ehandle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.combo_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.damage_amount {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ehandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.combo_count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.damage_amount {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ESArcanaComboSummary {
        CDOTAUserMsg_ESArcanaComboSummary::new()
    }

    fn clear(&mut self) {
        self.ehandle = ::std::option::Option::None;
        self.combo_count = ::std::option::Option::None;
        self.damage_amount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ESArcanaComboSummary {
        static instance: CDOTAUserMsg_ESArcanaComboSummary = CDOTAUserMsg_ESArcanaComboSummary {
            ehandle: ::std::option::Option::None,
            combo_count: ::std::option::Option::None,
            damage_amount: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_OMArcanaCombo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_OMArcanaCombo {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_OMArcanaCombo.ehandle)
    pub ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_OMArcanaCombo.multicast_amount)
    pub multicast_amount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_OMArcanaCombo.arcana_level)
    pub arcana_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_OMArcanaCombo.multicast_chance)
    pub multicast_chance: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_OMArcanaCombo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_OMArcanaCombo {
    fn default() -> &'a CDOTAUserMsg_OMArcanaCombo {
        <CDOTAUserMsg_OMArcanaCombo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_OMArcanaCombo {
    pub fn new() -> CDOTAUserMsg_OMArcanaCombo {
        ::std::default::Default::default()
    }

    // optional uint32 ehandle = 1;

    pub fn ehandle(&self) -> u32 {
        self.ehandle.unwrap_or(16777215u32)
    }

    pub fn clear_ehandle(&mut self) {
        self.ehandle = ::std::option::Option::None;
    }

    pub fn has_ehandle(&self) -> bool {
        self.ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ehandle(&mut self, v: u32) {
        self.ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 multicast_amount = 2;

    pub fn multicast_amount(&self) -> u32 {
        self.multicast_amount.unwrap_or(0)
    }

    pub fn clear_multicast_amount(&mut self) {
        self.multicast_amount = ::std::option::Option::None;
    }

    pub fn has_multicast_amount(&self) -> bool {
        self.multicast_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multicast_amount(&mut self, v: u32) {
        self.multicast_amount = ::std::option::Option::Some(v);
    }

    // optional uint32 arcana_level = 3;

    pub fn arcana_level(&self) -> u32 {
        self.arcana_level.unwrap_or(0)
    }

    pub fn clear_arcana_level(&mut self) {
        self.arcana_level = ::std::option::Option::None;
    }

    pub fn has_arcana_level(&self) -> bool {
        self.arcana_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arcana_level(&mut self, v: u32) {
        self.arcana_level = ::std::option::Option::Some(v);
    }

    // optional uint32 multicast_chance = 4;

    pub fn multicast_chance(&self) -> u32 {
        self.multicast_chance.unwrap_or(0)
    }

    pub fn clear_multicast_chance(&mut self) {
        self.multicast_chance = ::std::option::Option::None;
    }

    pub fn has_multicast_chance(&self) -> bool {
        self.multicast_chance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multicast_chance(&mut self, v: u32) {
        self.multicast_chance = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_OMArcanaCombo {
    const NAME: &'static str = "CDOTAUserMsg_OMArcanaCombo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.multicast_amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.arcana_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.multicast_chance = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ehandle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.multicast_amount {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.arcana_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.multicast_chance {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ehandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.multicast_amount {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.arcana_level {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.multicast_chance {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_OMArcanaCombo {
        CDOTAUserMsg_OMArcanaCombo::new()
    }

    fn clear(&mut self) {
        self.ehandle = ::std::option::Option::None;
        self.multicast_amount = ::std::option::Option::None;
        self.arcana_level = ::std::option::Option::None;
        self.multicast_chance = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_OMArcanaCombo {
        static instance: CDOTAUserMsg_OMArcanaCombo = CDOTAUserMsg_OMArcanaCombo {
            ehandle: ::std::option::Option::None,
            multicast_amount: ::std::option::Option::None,
            arcana_level: ::std::option::Option::None,
            multicast_chance: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_HighFiveCompleted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_HighFiveCompleted {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_HighFiveCompleted.player_id_1)
    pub player_id_1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_HighFiveCompleted.player_id_2)
    pub player_id_2: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_HighFiveCompleted.special_high_five)
    pub special_high_five: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_HighFiveCompleted.special_entindex)
    pub special_entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_HighFiveCompleted.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_HighFiveCompleted {
    fn default() -> &'a CDOTAUserMsg_HighFiveCompleted {
        <CDOTAUserMsg_HighFiveCompleted as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_HighFiveCompleted {
    pub fn new() -> CDOTAUserMsg_HighFiveCompleted {
        ::std::default::Default::default()
    }

    // optional int32 player_id_1 = 1;

    pub fn player_id_1(&self) -> i32 {
        self.player_id_1.unwrap_or(-1i32)
    }

    pub fn clear_player_id_1(&mut self) {
        self.player_id_1 = ::std::option::Option::None;
    }

    pub fn has_player_id_1(&self) -> bool {
        self.player_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_1(&mut self, v: i32) {
        self.player_id_1 = ::std::option::Option::Some(v);
    }

    // optional int32 player_id_2 = 2;

    pub fn player_id_2(&self) -> i32 {
        self.player_id_2.unwrap_or(-1i32)
    }

    pub fn clear_player_id_2(&mut self) {
        self.player_id_2 = ::std::option::Option::None;
    }

    pub fn has_player_id_2(&self) -> bool {
        self.player_id_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_2(&mut self, v: i32) {
        self.player_id_2 = ::std::option::Option::Some(v);
    }

    // optional bool special_high_five = 3;

    pub fn special_high_five(&self) -> bool {
        self.special_high_five.unwrap_or(false)
    }

    pub fn clear_special_high_five(&mut self) {
        self.special_high_five = ::std::option::Option::None;
    }

    pub fn has_special_high_five(&self) -> bool {
        self.special_high_five.is_some()
    }

    // Param is passed by value, moved
    pub fn set_special_high_five(&mut self, v: bool) {
        self.special_high_five = ::std::option::Option::Some(v);
    }

    // optional int32 special_entindex = 4;

    pub fn special_entindex(&self) -> i32 {
        self.special_entindex.unwrap_or(-1i32)
    }

    pub fn clear_special_entindex(&mut self) {
        self.special_entindex = ::std::option::Option::None;
    }

    pub fn has_special_entindex(&self) -> bool {
        self.special_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_special_entindex(&mut self, v: i32) {
        self.special_entindex = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_HighFiveCompleted {
    const NAME: &'static str = "CDOTAUserMsg_HighFiveCompleted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id_1 = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_id_2 = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.special_high_five = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.special_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id_1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_id_2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.special_high_five {
            my_size += 1 + 1;
        }
        if let Some(v) = self.special_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id_1 {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_id_2 {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.special_high_five {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.special_entindex {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_HighFiveCompleted {
        CDOTAUserMsg_HighFiveCompleted::new()
    }

    fn clear(&mut self) {
        self.player_id_1 = ::std::option::Option::None;
        self.player_id_2 = ::std::option::Option::None;
        self.special_high_five = ::std::option::Option::None;
        self.special_entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_HighFiveCompleted {
        static instance: CDOTAUserMsg_HighFiveCompleted = CDOTAUserMsg_HighFiveCompleted {
            player_id_1: ::std::option::Option::None,
            player_id_2: ::std::option::Option::None,
            special_high_five: ::std::option::Option::None,
            special_entindex: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_HighFiveLeftHanging)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_HighFiveLeftHanging {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_HighFiveLeftHanging.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_HighFiveLeftHanging.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_HighFiveLeftHanging {
    fn default() -> &'a CDOTAUserMsg_HighFiveLeftHanging {
        <CDOTAUserMsg_HighFiveLeftHanging as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_HighFiveLeftHanging {
    pub fn new() -> CDOTAUserMsg_HighFiveLeftHanging {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_HighFiveLeftHanging {
    const NAME: &'static str = "CDOTAUserMsg_HighFiveLeftHanging";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_HighFiveLeftHanging {
        CDOTAUserMsg_HighFiveLeftHanging::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_HighFiveLeftHanging {
        static instance: CDOTAUserMsg_HighFiveLeftHanging = CDOTAUserMsg_HighFiveLeftHanging {
            player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_ShovelUnearth)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ShovelUnearth {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_ShovelUnearth.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ShovelUnearth.all_chat)
    pub all_chat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ShovelUnearth.locstring)
    pub locstring: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ShovelUnearth.quantity)
    pub quantity: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_ShovelUnearth.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ShovelUnearth {
    fn default() -> &'a CDOTAUserMsg_ShovelUnearth {
        <CDOTAUserMsg_ShovelUnearth as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ShovelUnearth {
    pub fn new() -> CDOTAUserMsg_ShovelUnearth {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional bool all_chat = 2;

    pub fn all_chat(&self) -> bool {
        self.all_chat.unwrap_or(false)
    }

    pub fn clear_all_chat(&mut self) {
        self.all_chat = ::std::option::Option::None;
    }

    pub fn has_all_chat(&self) -> bool {
        self.all_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_all_chat(&mut self, v: bool) {
        self.all_chat = ::std::option::Option::Some(v);
    }

    // optional string locstring = 3;

    pub fn locstring(&self) -> &str {
        match self.locstring.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_locstring(&mut self) {
        self.locstring = ::std::option::Option::None;
    }

    pub fn has_locstring(&self) -> bool {
        self.locstring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locstring(&mut self, v: ::std::string::String) {
        self.locstring = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locstring(&mut self) -> &mut ::std::string::String {
        if self.locstring.is_none() {
            self.locstring = ::std::option::Option::Some(::std::string::String::new());
        }
        self.locstring.as_mut().unwrap()
    }

    // Take field
    pub fn take_locstring(&mut self) -> ::std::string::String {
        self.locstring.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 quantity = 4;

    pub fn quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_ShovelUnearth {
    const NAME: &'static str = "CDOTAUserMsg_ShovelUnearth";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.all_chat = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.locstring = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.all_chat {
            my_size += 1 + 1;
        }
        if let Some(v) = self.locstring.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.quantity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.all_chat {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.locstring.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ShovelUnearth {
        CDOTAUserMsg_ShovelUnearth::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.all_chat = ::std::option::Option::None;
        self.locstring = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ShovelUnearth {
        static instance: CDOTAUserMsg_ShovelUnearth = CDOTAUserMsg_ShovelUnearth {
            player_id: ::std::option::Option::None,
            all_chat: ::std::option::Option::None,
            locstring: ::std::option::Option::None,
            quantity: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_AllStarEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_AllStarEvent {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_AllStarEvent.source_player_id)
    pub source_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AllStarEvent.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AllStarEvent.point_amount)
    pub point_amount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AllStarEvent.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AllStarEvent.player_scores)
    pub player_scores: ::std::vec::Vec<cdotauser_msg_all_star_event::PlayerScore>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_AllStarEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_AllStarEvent {
    fn default() -> &'a CDOTAUserMsg_AllStarEvent {
        <CDOTAUserMsg_AllStarEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_AllStarEvent {
    pub fn new() -> CDOTAUserMsg_AllStarEvent {
        ::std::default::Default::default()
    }

    // optional int32 source_player_id = 1;

    pub fn source_player_id(&self) -> i32 {
        self.source_player_id.unwrap_or(-1i32)
    }

    pub fn clear_source_player_id(&mut self) {
        self.source_player_id = ::std::option::Option::None;
    }

    pub fn has_source_player_id(&self) -> bool {
        self.source_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_player_id(&mut self, v: i32) {
        self.source_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_player_id = 2;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(-1i32)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 point_amount = 3;

    pub fn point_amount(&self) -> u32 {
        self.point_amount.unwrap_or(0)
    }

    pub fn clear_point_amount(&mut self) {
        self.point_amount = ::std::option::Option::None;
    }

    pub fn has_point_amount(&self) -> bool {
        self.point_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_point_amount(&mut self, v: u32) {
        self.point_amount = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 4;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_AllStarEvent {
    const NAME: &'static str = "CDOTAUserMsg_AllStarEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.point_amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.player_scores.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.point_amount {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.player_scores {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.source_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.point_amount {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(4, v)?;
        }
        for v in &self.player_scores {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_AllStarEvent {
        CDOTAUserMsg_AllStarEvent::new()
    }

    fn clear(&mut self) {
        self.source_player_id = ::std::option::Option::None;
        self.target_player_id = ::std::option::Option::None;
        self.point_amount = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.player_scores.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_AllStarEvent {
        static instance: CDOTAUserMsg_AllStarEvent = CDOTAUserMsg_AllStarEvent {
            source_player_id: ::std::option::Option::None,
            target_player_id: ::std::option::Option::None,
            point_amount: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            player_scores: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CDOTAUserMsg_AllStarEvent`
pub mod cdotauser_msg_all_star_event {
    // @@protoc_insertion_point(message:CDOTAUserMsg_AllStarEvent.PlayerScore)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerScore {
        // message fields
        // @@protoc_insertion_point(field:CDOTAUserMsg_AllStarEvent.PlayerScore.player_id)
        pub player_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_AllStarEvent.PlayerScore.score_sans_kda)
        pub score_sans_kda: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAUserMsg_AllStarEvent.PlayerScore.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerScore {
        fn default() -> &'a PlayerScore {
            <PlayerScore as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerScore {
        pub fn new() -> PlayerScore {
            ::std::default::Default::default()
        }

        // optional int32 player_id = 1;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(-1i32)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }

        // optional uint32 score_sans_kda = 2;

        pub fn score_sans_kda(&self) -> u32 {
            self.score_sans_kda.unwrap_or(0)
        }

        pub fn clear_score_sans_kda(&mut self) {
            self.score_sans_kda = ::std::option::Option::None;
        }

        pub fn has_score_sans_kda(&self) -> bool {
            self.score_sans_kda.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score_sans_kda(&mut self, v: u32) {
            self.score_sans_kda = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerScore {
        const NAME: &'static str = "PlayerScore";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.score_sans_kda = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.score_sans_kda {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.player_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.score_sans_kda {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerScore {
            PlayerScore::new()
        }

        fn clear(&mut self) {
            self.player_id = ::std::option::Option::None;
            self.score_sans_kda = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerScore {
            static instance: PlayerScore = PlayerScore {
                player_id: ::std::option::Option::None,
                score_sans_kda: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_QueuedOrderRemoved)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_QueuedOrderRemoved {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_QueuedOrderRemoved.unit_order_sequence)
    pub unit_order_sequence: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_QueuedOrderRemoved.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_QueuedOrderRemoved {
    fn default() -> &'a CDOTAUserMsg_QueuedOrderRemoved {
        <CDOTAUserMsg_QueuedOrderRemoved as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_QueuedOrderRemoved {
    pub fn new() -> CDOTAUserMsg_QueuedOrderRemoved {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_QueuedOrderRemoved {
    const NAME: &'static str = "CDOTAUserMsg_QueuedOrderRemoved";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.unit_order_sequence)?;
                },
                8 => {
                    self.unit_order_sequence.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.unit_order_sequence {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.unit_order_sequence {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_QueuedOrderRemoved {
        CDOTAUserMsg_QueuedOrderRemoved::new()
    }

    fn clear(&mut self) {
        self.unit_order_sequence.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_QueuedOrderRemoved {
        static instance: CDOTAUserMsg_QueuedOrderRemoved = CDOTAUserMsg_QueuedOrderRemoved {
            unit_order_sequence: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_DebugChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_DebugChallenge {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_DebugChallenge.challenge_type)
    pub challenge_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_DebugChallenge.challenge_query_id)
    pub challenge_query_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_DebugChallenge.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_DebugChallenge.instance_id)
    pub instance_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_DebugChallenge.challenge_var_0)
    pub challenge_var_0: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_DebugChallenge.challenge_var_1)
    pub challenge_var_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_DebugChallenge.challenge_max_rank)
    pub challenge_max_rank: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_DebugChallenge.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_DebugChallenge {
    fn default() -> &'a CDOTAUserMsg_DebugChallenge {
        <CDOTAUserMsg_DebugChallenge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_DebugChallenge {
    pub fn new() -> CDOTAUserMsg_DebugChallenge {
        ::std::default::Default::default()
    }

    // required uint32 challenge_type = 1;

    pub fn challenge_type(&self) -> u32 {
        self.challenge_type.unwrap_or(0)
    }

    pub fn clear_challenge_type(&mut self) {
        self.challenge_type = ::std::option::Option::None;
    }

    pub fn has_challenge_type(&self) -> bool {
        self.challenge_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_type(&mut self, v: u32) {
        self.challenge_type = ::std::option::Option::Some(v);
    }

    // required uint32 challenge_query_id = 2;

    pub fn challenge_query_id(&self) -> u32 {
        self.challenge_query_id.unwrap_or(0)
    }

    pub fn clear_challenge_query_id(&mut self) {
        self.challenge_query_id = ::std::option::Option::None;
    }

    pub fn has_challenge_query_id(&self) -> bool {
        self.challenge_query_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_query_id(&mut self, v: u32) {
        self.challenge_query_id = ::std::option::Option::Some(v);
    }

    // required uint32 event_id = 3;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 instance_id = 4;

    pub fn instance_id(&self) -> u32 {
        self.instance_id.unwrap_or(0)
    }

    pub fn clear_instance_id(&mut self) {
        self.instance_id = ::std::option::Option::None;
    }

    pub fn has_instance_id(&self) -> bool {
        self.instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: u32) {
        self.instance_id = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_var_0 = 5;

    pub fn challenge_var_0(&self) -> u32 {
        self.challenge_var_0.unwrap_or(0)
    }

    pub fn clear_challenge_var_0(&mut self) {
        self.challenge_var_0 = ::std::option::Option::None;
    }

    pub fn has_challenge_var_0(&self) -> bool {
        self.challenge_var_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_var_0(&mut self, v: u32) {
        self.challenge_var_0 = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_var_1 = 6;

    pub fn challenge_var_1(&self) -> u32 {
        self.challenge_var_1.unwrap_or(0)
    }

    pub fn clear_challenge_var_1(&mut self) {
        self.challenge_var_1 = ::std::option::Option::None;
    }

    pub fn has_challenge_var_1(&self) -> bool {
        self.challenge_var_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_var_1(&mut self, v: u32) {
        self.challenge_var_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_max_rank = 7;

    pub fn challenge_max_rank(&self) -> u32 {
        self.challenge_max_rank.unwrap_or(0)
    }

    pub fn clear_challenge_max_rank(&mut self) {
        self.challenge_max_rank = ::std::option::Option::None;
    }

    pub fn has_challenge_max_rank(&self) -> bool {
        self.challenge_max_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_max_rank(&mut self, v: u32) {
        self.challenge_max_rank = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_DebugChallenge {
    const NAME: &'static str = "CDOTAUserMsg_DebugChallenge";

    fn is_initialized(&self) -> bool {
        if self.challenge_type.is_none() {
            return false;
        }
        if self.challenge_query_id.is_none() {
            return false;
        }
        if self.event_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.challenge_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.challenge_query_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.instance_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.challenge_var_0 = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.challenge_var_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.challenge_max_rank = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.challenge_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.challenge_query_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.instance_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.challenge_var_0 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.challenge_var_1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.challenge_max_rank {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.challenge_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.challenge_query_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.instance_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.challenge_var_0 {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.challenge_var_1 {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.challenge_max_rank {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_DebugChallenge {
        CDOTAUserMsg_DebugChallenge::new()
    }

    fn clear(&mut self) {
        self.challenge_type = ::std::option::Option::None;
        self.challenge_query_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.instance_id = ::std::option::Option::None;
        self.challenge_var_0 = ::std::option::Option::None;
        self.challenge_var_1 = ::std::option::Option::None;
        self.challenge_max_rank = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_DebugChallenge {
        static instance: CDOTAUserMsg_DebugChallenge = CDOTAUserMsg_DebugChallenge {
            challenge_type: ::std::option::Option::None,
            challenge_query_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            instance_id: ::std::option::Option::None,
            challenge_var_0: ::std::option::Option::None,
            challenge_var_1: ::std::option::Option::None,
            challenge_max_rank: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_FoundNeutralItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_FoundNeutralItem {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_FoundNeutralItem.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_FoundNeutralItem.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_FoundNeutralItem.item_tier)
    pub item_tier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_FoundNeutralItem.tier_item_count)
    pub tier_item_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_FoundNeutralItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_FoundNeutralItem {
    fn default() -> &'a CDOTAUserMsg_FoundNeutralItem {
        <CDOTAUserMsg_FoundNeutralItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_FoundNeutralItem {
    pub fn new() -> CDOTAUserMsg_FoundNeutralItem {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 item_ability_id = 2;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(-1i32)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    // optional uint32 item_tier = 3;

    pub fn item_tier(&self) -> u32 {
        self.item_tier.unwrap_or(0)
    }

    pub fn clear_item_tier(&mut self) {
        self.item_tier = ::std::option::Option::None;
    }

    pub fn has_item_tier(&self) -> bool {
        self.item_tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_tier(&mut self, v: u32) {
        self.item_tier = ::std::option::Option::Some(v);
    }

    // optional uint32 tier_item_count = 4;

    pub fn tier_item_count(&self) -> u32 {
        self.tier_item_count.unwrap_or(0)
    }

    pub fn clear_tier_item_count(&mut self) {
        self.tier_item_count = ::std::option::Option::None;
    }

    pub fn has_tier_item_count(&self) -> bool {
        self.tier_item_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tier_item_count(&mut self, v: u32) {
        self.tier_item_count = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_FoundNeutralItem {
    const NAME: &'static str = "CDOTAUserMsg_FoundNeutralItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.item_tier = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.tier_item_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.item_ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.item_tier {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.tier_item_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.item_ability_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.item_tier {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.tier_item_count {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_FoundNeutralItem {
        CDOTAUserMsg_FoundNeutralItem::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.item_ability_id = ::std::option::Option::None;
        self.item_tier = ::std::option::Option::None;
        self.tier_item_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_FoundNeutralItem {
        static instance: CDOTAUserMsg_FoundNeutralItem = CDOTAUserMsg_FoundNeutralItem {
            player_id: ::std::option::Option::None,
            item_ability_id: ::std::option::Option::None,
            item_tier: ::std::option::Option::None,
            tier_item_count: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_OutpostCaptured)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_OutpostCaptured {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_OutpostCaptured.outpost_entindex)
    pub outpost_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_OutpostCaptured.team_id)
    pub team_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_OutpostCaptured.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_OutpostCaptured {
    fn default() -> &'a CDOTAUserMsg_OutpostCaptured {
        <CDOTAUserMsg_OutpostCaptured as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_OutpostCaptured {
    pub fn new() -> CDOTAUserMsg_OutpostCaptured {
        ::std::default::Default::default()
    }

    // optional int32 outpost_entindex = 1;

    pub fn outpost_entindex(&self) -> i32 {
        self.outpost_entindex.unwrap_or(-1i32)
    }

    pub fn clear_outpost_entindex(&mut self) {
        self.outpost_entindex = ::std::option::Option::None;
    }

    pub fn has_outpost_entindex(&self) -> bool {
        self.outpost_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outpost_entindex(&mut self, v: i32) {
        self.outpost_entindex = ::std::option::Option::Some(v);
    }

    // optional uint32 team_id = 2;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_OutpostCaptured {
    const NAME: &'static str = "CDOTAUserMsg_OutpostCaptured";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.outpost_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.outpost_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.outpost_entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_OutpostCaptured {
        CDOTAUserMsg_OutpostCaptured::new()
    }

    fn clear(&mut self) {
        self.outpost_entindex = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_OutpostCaptured {
        static instance: CDOTAUserMsg_OutpostCaptured = CDOTAUserMsg_OutpostCaptured {
            outpost_entindex: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_OutpostGrantedXP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_OutpostGrantedXP {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_OutpostGrantedXP.team_id)
    pub team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_OutpostGrantedXP.xp_amount)
    pub xp_amount: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_OutpostGrantedXP.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_OutpostGrantedXP {
    fn default() -> &'a CDOTAUserMsg_OutpostGrantedXP {
        <CDOTAUserMsg_OutpostGrantedXP as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_OutpostGrantedXP {
    pub fn new() -> CDOTAUserMsg_OutpostGrantedXP {
        ::std::default::Default::default()
    }

    // optional uint32 team_id = 1;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional uint32 xp_amount = 2;

    pub fn xp_amount(&self) -> u32 {
        self.xp_amount.unwrap_or(0)
    }

    pub fn clear_xp_amount(&mut self) {
        self.xp_amount = ::std::option::Option::None;
    }

    pub fn has_xp_amount(&self) -> bool {
        self.xp_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp_amount(&mut self, v: u32) {
        self.xp_amount = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_OutpostGrantedXP {
    const NAME: &'static str = "CDOTAUserMsg_OutpostGrantedXP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.xp_amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.xp_amount {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.team_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.xp_amount {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_OutpostGrantedXP {
        CDOTAUserMsg_OutpostGrantedXP::new()
    }

    fn clear(&mut self) {
        self.team_id = ::std::option::Option::None;
        self.xp_amount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_OutpostGrantedXP {
        static instance: CDOTAUserMsg_OutpostGrantedXP = CDOTAUserMsg_OutpostGrantedXP {
            team_id: ::std::option::Option::None,
            xp_amount: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_MoveCameraToUnit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_MoveCameraToUnit {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_MoveCameraToUnit.unit_ehandle)
    pub unit_ehandle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_MoveCameraToUnit.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_MoveCameraToUnit {
    fn default() -> &'a CDOTAUserMsg_MoveCameraToUnit {
        <CDOTAUserMsg_MoveCameraToUnit as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_MoveCameraToUnit {
    pub fn new() -> CDOTAUserMsg_MoveCameraToUnit {
        ::std::default::Default::default()
    }

    // optional uint32 unit_ehandle = 1;

    pub fn unit_ehandle(&self) -> u32 {
        self.unit_ehandle.unwrap_or(16777215u32)
    }

    pub fn clear_unit_ehandle(&mut self) {
        self.unit_ehandle = ::std::option::Option::None;
    }

    pub fn has_unit_ehandle(&self) -> bool {
        self.unit_ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_ehandle(&mut self, v: u32) {
        self.unit_ehandle = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_MoveCameraToUnit {
    const NAME: &'static str = "CDOTAUserMsg_MoveCameraToUnit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.unit_ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unit_ehandle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.unit_ehandle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_MoveCameraToUnit {
        CDOTAUserMsg_MoveCameraToUnit::new()
    }

    fn clear(&mut self) {
        self.unit_ehandle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_MoveCameraToUnit {
        static instance: CDOTAUserMsg_MoveCameraToUnit = CDOTAUserMsg_MoveCameraToUnit {
            unit_ehandle: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_PauseMinigameData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_PauseMinigameData {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_PauseMinigameData.data_bits)
    pub data_bits: ::std::vec::Vec<cdotauser_msg_pause_minigame_data::DataBit>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_PauseMinigameData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_PauseMinigameData {
    fn default() -> &'a CDOTAUserMsg_PauseMinigameData {
        <CDOTAUserMsg_PauseMinigameData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_PauseMinigameData {
    pub fn new() -> CDOTAUserMsg_PauseMinigameData {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_PauseMinigameData {
    const NAME: &'static str = "CDOTAUserMsg_PauseMinigameData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data_bits.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.data_bits {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.data_bits {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_PauseMinigameData {
        CDOTAUserMsg_PauseMinigameData::new()
    }

    fn clear(&mut self) {
        self.data_bits.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_PauseMinigameData {
        static instance: CDOTAUserMsg_PauseMinigameData = CDOTAUserMsg_PauseMinigameData {
            data_bits: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CDOTAUserMsg_PauseMinigameData`
pub mod cdotauser_msg_pause_minigame_data {
    // @@protoc_insertion_point(message:CDOTAUserMsg_PauseMinigameData.DataBit)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DataBit {
        // message fields
        // @@protoc_insertion_point(field:CDOTAUserMsg_PauseMinigameData.DataBit.index)
        pub index: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_PauseMinigameData.DataBit.data)
        pub data: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_PauseMinigameData.DataBit.data_extra)
        pub data_extra: ::std::option::Option<i64>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAUserMsg_PauseMinigameData.DataBit.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DataBit {
        fn default() -> &'a DataBit {
            <DataBit as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl DataBit {
        pub fn new() -> DataBit {
            ::std::default::Default::default()
        }

        // optional uint32 index = 1;

        pub fn index(&self) -> u32 {
            self.index.unwrap_or(0)
        }

        pub fn clear_index(&mut self) {
            self.index = ::std::option::Option::None;
        }

        pub fn has_index(&self) -> bool {
            self.index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_index(&mut self, v: u32) {
            self.index = ::std::option::Option::Some(v);
        }

        // optional int32 data = 2;

        pub fn data(&self) -> i32 {
            self.data.unwrap_or(0)
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: i32) {
            self.data = ::std::option::Option::Some(v);
        }

        // optional int64 data_extra = 3;

        pub fn data_extra(&self) -> i64 {
            self.data_extra.unwrap_or(0)
        }

        pub fn clear_data_extra(&mut self) {
            self.data_extra = ::std::option::Option::None;
        }

        pub fn has_data_extra(&self) -> bool {
            self.data_extra.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data_extra(&mut self, v: i64) {
            self.data_extra = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for DataBit {
        const NAME: &'static str = "DataBit";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.data = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.data_extra = ::std::option::Option::Some(is.read_int64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.index {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.data {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.data_extra {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.index {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.data {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.data_extra {
                os.write_int64(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DataBit {
            DataBit::new()
        }

        fn clear(&mut self) {
            self.index = ::std::option::Option::None;
            self.data = ::std::option::Option::None;
            self.data_extra = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DataBit {
            static instance: DataBit = DataBit {
                index: ::std::option::Option::None,
                data: ::std::option::Option::None,
                data_extra: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_VersusScene_PlayerBehavior)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_VersusScene_PlayerBehavior {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_VersusScene_PlayerBehavior.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_VersusScene_PlayerBehavior.behavior)
    pub behavior: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_commonmessages::EDOTAVersusScenePlayerBehavior>>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_VersusScene_PlayerBehavior.play_activity)
    pub play_activity: ::steam_vent_proto_common::protobuf::MessageField<super::dota_commonmessages::VersusScene_PlayActivity>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_VersusScene_PlayerBehavior.chat_wheel)
    pub chat_wheel: ::steam_vent_proto_common::protobuf::MessageField<super::dota_commonmessages::VersusScene_ChatWheel>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_VersusScene_PlayerBehavior.playback_rate)
    pub playback_rate: ::steam_vent_proto_common::protobuf::MessageField<super::dota_commonmessages::VersusScene_PlaybackRate>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_VersusScene_PlayerBehavior.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_VersusScene_PlayerBehavior {
    fn default() -> &'a CDOTAUserMsg_VersusScene_PlayerBehavior {
        <CDOTAUserMsg_VersusScene_PlayerBehavior as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_VersusScene_PlayerBehavior {
    pub fn new() -> CDOTAUserMsg_VersusScene_PlayerBehavior {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional .EDOTAVersusScenePlayerBehavior behavior = 2;

    pub fn behavior(&self) -> super::dota_commonmessages::EDOTAVersusScenePlayerBehavior {
        match self.behavior {
            Some(e) => e.enum_value_or(super::dota_commonmessages::EDOTAVersusScenePlayerBehavior::VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY),
            None => super::dota_commonmessages::EDOTAVersusScenePlayerBehavior::VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY,
        }
    }

    pub fn clear_behavior(&mut self) {
        self.behavior = ::std::option::Option::None;
    }

    pub fn has_behavior(&self) -> bool {
        self.behavior.is_some()
    }

    // Param is passed by value, moved
    pub fn set_behavior(&mut self, v: super::dota_commonmessages::EDOTAVersusScenePlayerBehavior) {
        self.behavior = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_VersusScene_PlayerBehavior {
    const NAME: &'static str = "CDOTAUserMsg_VersusScene_PlayerBehavior";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.behavior = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.play_activity)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.chat_wheel)?;
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.playback_rate)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.behavior {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.play_activity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.chat_wheel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.playback_rate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.behavior {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.play_activity.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.chat_wheel.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.playback_rate.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_VersusScene_PlayerBehavior {
        CDOTAUserMsg_VersusScene_PlayerBehavior::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.behavior = ::std::option::Option::None;
        self.play_activity.clear();
        self.chat_wheel.clear();
        self.playback_rate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_VersusScene_PlayerBehavior {
        static instance: CDOTAUserMsg_VersusScene_PlayerBehavior = CDOTAUserMsg_VersusScene_PlayerBehavior {
            player_id: ::std::option::Option::None,
            behavior: ::std::option::Option::None,
            play_activity: ::steam_vent_proto_common::protobuf::MessageField::none(),
            chat_wheel: ::steam_vent_proto_common::protobuf::MessageField::none(),
            playback_rate: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_QoP_ArcanaSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_QoP_ArcanaSummary {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_QoP_ArcanaSummary.ehandle)
    pub ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_QoP_ArcanaSummary.arcana_level)
    pub arcana_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_QoP_ArcanaSummary.players_hit)
    pub players_hit: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_QoP_ArcanaSummary.players_killed)
    pub players_killed: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_QoP_ArcanaSummary.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_QoP_ArcanaSummary {
    fn default() -> &'a CDOTAUserMsg_QoP_ArcanaSummary {
        <CDOTAUserMsg_QoP_ArcanaSummary as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_QoP_ArcanaSummary {
    pub fn new() -> CDOTAUserMsg_QoP_ArcanaSummary {
        ::std::default::Default::default()
    }

    // optional uint32 ehandle = 1;

    pub fn ehandle(&self) -> u32 {
        self.ehandle.unwrap_or(16777215u32)
    }

    pub fn clear_ehandle(&mut self) {
        self.ehandle = ::std::option::Option::None;
    }

    pub fn has_ehandle(&self) -> bool {
        self.ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ehandle(&mut self, v: u32) {
        self.ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 arcana_level = 2;

    pub fn arcana_level(&self) -> u32 {
        self.arcana_level.unwrap_or(0)
    }

    pub fn clear_arcana_level(&mut self) {
        self.arcana_level = ::std::option::Option::None;
    }

    pub fn has_arcana_level(&self) -> bool {
        self.arcana_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arcana_level(&mut self, v: u32) {
        self.arcana_level = ::std::option::Option::Some(v);
    }

    // optional uint32 players_hit = 3;

    pub fn players_hit(&self) -> u32 {
        self.players_hit.unwrap_or(0)
    }

    pub fn clear_players_hit(&mut self) {
        self.players_hit = ::std::option::Option::None;
    }

    pub fn has_players_hit(&self) -> bool {
        self.players_hit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players_hit(&mut self, v: u32) {
        self.players_hit = ::std::option::Option::Some(v);
    }

    // optional uint32 players_killed = 4;

    pub fn players_killed(&self) -> u32 {
        self.players_killed.unwrap_or(0)
    }

    pub fn clear_players_killed(&mut self) {
        self.players_killed = ::std::option::Option::None;
    }

    pub fn has_players_killed(&self) -> bool {
        self.players_killed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players_killed(&mut self, v: u32) {
        self.players_killed = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_QoP_ArcanaSummary {
    const NAME: &'static str = "CDOTAUserMsg_QoP_ArcanaSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.arcana_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.players_hit = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.players_killed = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ehandle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.arcana_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.players_hit {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.players_killed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ehandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.arcana_level {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.players_hit {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.players_killed {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_QoP_ArcanaSummary {
        CDOTAUserMsg_QoP_ArcanaSummary::new()
    }

    fn clear(&mut self) {
        self.ehandle = ::std::option::Option::None;
        self.arcana_level = ::std::option::Option::None;
        self.players_hit = ::std::option::Option::None;
        self.players_killed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_QoP_ArcanaSummary {
        static instance: CDOTAUserMsg_QoP_ArcanaSummary = CDOTAUserMsg_QoP_ArcanaSummary {
            ehandle: ::std::option::Option::None,
            arcana_level: ::std::option::Option::None,
            players_hit: ::std::option::Option::None,
            players_killed: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_HotPotato_Created)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_HotPotato_Created {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_HotPotato_Created.player_id_1)
    pub player_id_1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_HotPotato_Created.player_id_2)
    pub player_id_2: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_HotPotato_Created.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_HotPotato_Created {
    fn default() -> &'a CDOTAUserMsg_HotPotato_Created {
        <CDOTAUserMsg_HotPotato_Created as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_HotPotato_Created {
    pub fn new() -> CDOTAUserMsg_HotPotato_Created {
        ::std::default::Default::default()
    }

    // optional int32 player_id_1 = 1;

    pub fn player_id_1(&self) -> i32 {
        self.player_id_1.unwrap_or(-1i32)
    }

    pub fn clear_player_id_1(&mut self) {
        self.player_id_1 = ::std::option::Option::None;
    }

    pub fn has_player_id_1(&self) -> bool {
        self.player_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_1(&mut self, v: i32) {
        self.player_id_1 = ::std::option::Option::Some(v);
    }

    // optional int32 player_id_2 = 2;

    pub fn player_id_2(&self) -> i32 {
        self.player_id_2.unwrap_or(-1i32)
    }

    pub fn clear_player_id_2(&mut self) {
        self.player_id_2 = ::std::option::Option::None;
    }

    pub fn has_player_id_2(&self) -> bool {
        self.player_id_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_2(&mut self, v: i32) {
        self.player_id_2 = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_HotPotato_Created {
    const NAME: &'static str = "CDOTAUserMsg_HotPotato_Created";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id_1 = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_id_2 = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id_1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_id_2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id_1 {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_id_2 {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_HotPotato_Created {
        CDOTAUserMsg_HotPotato_Created::new()
    }

    fn clear(&mut self) {
        self.player_id_1 = ::std::option::Option::None;
        self.player_id_2 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_HotPotato_Created {
        static instance: CDOTAUserMsg_HotPotato_Created = CDOTAUserMsg_HotPotato_Created {
            player_id_1: ::std::option::Option::None,
            player_id_2: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_HotPotato_Exploded)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_HotPotato_Exploded {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_HotPotato_Exploded.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_HotPotato_Exploded.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_HotPotato_Exploded {
    fn default() -> &'a CDOTAUserMsg_HotPotato_Exploded {
        <CDOTAUserMsg_HotPotato_Exploded as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_HotPotato_Exploded {
    pub fn new() -> CDOTAUserMsg_HotPotato_Exploded {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_HotPotato_Exploded {
    const NAME: &'static str = "CDOTAUserMsg_HotPotato_Exploded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_HotPotato_Exploded {
        CDOTAUserMsg_HotPotato_Exploded::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_HotPotato_Exploded {
        static instance: CDOTAUserMsg_HotPotato_Exploded = CDOTAUserMsg_HotPotato_Exploded {
            player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_WK_Arcana_Progress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_WK_Arcana_Progress {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_WK_Arcana_Progress.ehandle)
    pub ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_WK_Arcana_Progress.arcana_level)
    pub arcana_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_WK_Arcana_Progress.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_WK_Arcana_Progress.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_WK_Arcana_Progress {
    fn default() -> &'a CDOTAUserMsg_WK_Arcana_Progress {
        <CDOTAUserMsg_WK_Arcana_Progress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_WK_Arcana_Progress {
    pub fn new() -> CDOTAUserMsg_WK_Arcana_Progress {
        ::std::default::Default::default()
    }

    // optional uint32 ehandle = 1;

    pub fn ehandle(&self) -> u32 {
        self.ehandle.unwrap_or(16777215u32)
    }

    pub fn clear_ehandle(&mut self) {
        self.ehandle = ::std::option::Option::None;
    }

    pub fn has_ehandle(&self) -> bool {
        self.ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ehandle(&mut self, v: u32) {
        self.ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 arcana_level = 2;

    pub fn arcana_level(&self) -> u32 {
        self.arcana_level.unwrap_or(0)
    }

    pub fn clear_arcana_level(&mut self) {
        self.arcana_level = ::std::option::Option::None;
    }

    pub fn has_arcana_level(&self) -> bool {
        self.arcana_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arcana_level(&mut self, v: u32) {
        self.arcana_level = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 3;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_WK_Arcana_Progress {
    const NAME: &'static str = "CDOTAUserMsg_WK_Arcana_Progress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.arcana_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ehandle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.arcana_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ehandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.arcana_level {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_WK_Arcana_Progress {
        CDOTAUserMsg_WK_Arcana_Progress::new()
    }

    fn clear(&mut self) {
        self.ehandle = ::std::option::Option::None;
        self.arcana_level = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_WK_Arcana_Progress {
        static instance: CDOTAUserMsg_WK_Arcana_Progress = CDOTAUserMsg_WK_Arcana_Progress {
            ehandle: ::std::option::Option::None,
            arcana_level: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_GuildChallenge_Progress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_GuildChallenge_Progress {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_GuildChallenge_Progress.player_progress)
    pub player_progress: ::std::vec::Vec<cdotauser_msg_guild_challenge_progress::PlayerProgress>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_GuildChallenge_Progress.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_GuildChallenge_Progress.challenge_instance_id)
    pub challenge_instance_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_GuildChallenge_Progress.challenge_parameter)
    pub challenge_parameter: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_GuildChallenge_Progress.challenge_type)
    pub challenge_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cdotauser_msg_guild_challenge_progress::EChallengeType>>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_GuildChallenge_Progress.challenge_progress_at_start)
    pub challenge_progress_at_start: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_GuildChallenge_Progress.complete)
    pub complete: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_GuildChallenge_Progress.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_GuildChallenge_Progress {
    fn default() -> &'a CDOTAUserMsg_GuildChallenge_Progress {
        <CDOTAUserMsg_GuildChallenge_Progress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_GuildChallenge_Progress {
    pub fn new() -> CDOTAUserMsg_GuildChallenge_Progress {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 2;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_instance_id = 3;

    pub fn challenge_instance_id(&self) -> u32 {
        self.challenge_instance_id.unwrap_or(0)
    }

    pub fn clear_challenge_instance_id(&mut self) {
        self.challenge_instance_id = ::std::option::Option::None;
    }

    pub fn has_challenge_instance_id(&self) -> bool {
        self.challenge_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_instance_id(&mut self, v: u32) {
        self.challenge_instance_id = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_parameter = 4;

    pub fn challenge_parameter(&self) -> u32 {
        self.challenge_parameter.unwrap_or(0)
    }

    pub fn clear_challenge_parameter(&mut self) {
        self.challenge_parameter = ::std::option::Option::None;
    }

    pub fn has_challenge_parameter(&self) -> bool {
        self.challenge_parameter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_parameter(&mut self, v: u32) {
        self.challenge_parameter = ::std::option::Option::Some(v);
    }

    // optional .CDOTAUserMsg_GuildChallenge_Progress.EChallengeType challenge_type = 5;

    pub fn challenge_type(&self) -> cdotauser_msg_guild_challenge_progress::EChallengeType {
        match self.challenge_type {
            Some(e) => e.enum_value_or(cdotauser_msg_guild_challenge_progress::EChallengeType::k_EChallengeType_Invalid),
            None => cdotauser_msg_guild_challenge_progress::EChallengeType::k_EChallengeType_Invalid,
        }
    }

    pub fn clear_challenge_type(&mut self) {
        self.challenge_type = ::std::option::Option::None;
    }

    pub fn has_challenge_type(&self) -> bool {
        self.challenge_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_type(&mut self, v: cdotauser_msg_guild_challenge_progress::EChallengeType) {
        self.challenge_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 challenge_progress_at_start = 7;

    pub fn challenge_progress_at_start(&self) -> u32 {
        self.challenge_progress_at_start.unwrap_or(0)
    }

    pub fn clear_challenge_progress_at_start(&mut self) {
        self.challenge_progress_at_start = ::std::option::Option::None;
    }

    pub fn has_challenge_progress_at_start(&self) -> bool {
        self.challenge_progress_at_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_progress_at_start(&mut self, v: u32) {
        self.challenge_progress_at_start = ::std::option::Option::Some(v);
    }

    // optional bool complete = 8;

    pub fn complete(&self) -> bool {
        self.complete.unwrap_or(false)
    }

    pub fn clear_complete(&mut self) {
        self.complete = ::std::option::Option::None;
    }

    pub fn has_complete(&self) -> bool {
        self.complete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_complete(&mut self, v: bool) {
        self.complete = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_GuildChallenge_Progress {
    const NAME: &'static str = "CDOTAUserMsg_GuildChallenge_Progress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_progress.push(is.read_message()?);
                },
                16 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.challenge_instance_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.challenge_parameter = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.challenge_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.challenge_progress_at_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.complete = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_progress {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.challenge_instance_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.challenge_parameter {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.challenge_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.challenge_progress_at_start {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.complete {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.player_progress {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.guild_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.challenge_instance_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.challenge_parameter {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.challenge_type {
            os.write_enum(5, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.challenge_progress_at_start {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.complete {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_GuildChallenge_Progress {
        CDOTAUserMsg_GuildChallenge_Progress::new()
    }

    fn clear(&mut self) {
        self.player_progress.clear();
        self.guild_id = ::std::option::Option::None;
        self.challenge_instance_id = ::std::option::Option::None;
        self.challenge_parameter = ::std::option::Option::None;
        self.challenge_type = ::std::option::Option::None;
        self.challenge_progress_at_start = ::std::option::Option::None;
        self.complete = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_GuildChallenge_Progress {
        static instance: CDOTAUserMsg_GuildChallenge_Progress = CDOTAUserMsg_GuildChallenge_Progress {
            player_progress: ::std::vec::Vec::new(),
            guild_id: ::std::option::Option::None,
            challenge_instance_id: ::std::option::Option::None,
            challenge_parameter: ::std::option::Option::None,
            challenge_type: ::std::option::Option::None,
            challenge_progress_at_start: ::std::option::Option::None,
            complete: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CDOTAUserMsg_GuildChallenge_Progress`
pub mod cdotauser_msg_guild_challenge_progress {
    // @@protoc_insertion_point(message:CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerProgress {
        // message fields
        // @@protoc_insertion_point(field:CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress.player_id)
        pub player_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress.progress)
        pub progress: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CDOTAUserMsg_GuildChallenge_Progress.PlayerProgress.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerProgress {
        fn default() -> &'a PlayerProgress {
            <PlayerProgress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerProgress {
        pub fn new() -> PlayerProgress {
            ::std::default::Default::default()
        }

        // optional int32 player_id = 1;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(-1i32)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }

        // optional uint32 progress = 6;

        pub fn progress(&self) -> u32 {
            self.progress.unwrap_or(0)
        }

        pub fn clear_progress(&mut self) {
            self.progress = ::std::option::Option::None;
        }

        pub fn has_progress(&self) -> bool {
            self.progress.is_some()
        }

        // Param is passed by value, moved
        pub fn set_progress(&mut self, v: u32) {
            self.progress = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerProgress {
        const NAME: &'static str = "PlayerProgress";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.progress = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.progress {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.player_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.progress {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerProgress {
            PlayerProgress::new()
        }

        fn clear(&mut self) {
            self.player_id = ::std::option::Option::None;
            self.progress = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerProgress {
            static instance: PlayerProgress = PlayerProgress {
                player_id: ::std::option::Option::None,
                progress: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CDOTAUserMsg_GuildChallenge_Progress.EChallengeType)
    pub enum EChallengeType {
        // @@protoc_insertion_point(enum_value:CDOTAUserMsg_GuildChallenge_Progress.EChallengeType.k_EChallengeType_Invalid)
        k_EChallengeType_Invalid = 0,
        // @@protoc_insertion_point(enum_value:CDOTAUserMsg_GuildChallenge_Progress.EChallengeType.k_EChallengeType_Cooperative)
        k_EChallengeType_Cooperative = 1,
        // @@protoc_insertion_point(enum_value:CDOTAUserMsg_GuildChallenge_Progress.EChallengeType.k_EChallengeType_Contract)
        k_EChallengeType_Contract = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EChallengeType {
        const NAME: &'static str = "EChallengeType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EChallengeType> {
            match value {
                0 => ::std::option::Option::Some(EChallengeType::k_EChallengeType_Invalid),
                1 => ::std::option::Option::Some(EChallengeType::k_EChallengeType_Cooperative),
                2 => ::std::option::Option::Some(EChallengeType::k_EChallengeType_Contract),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EChallengeType> {
            match str {
                "k_EChallengeType_Invalid" => ::std::option::Option::Some(EChallengeType::k_EChallengeType_Invalid),
                "k_EChallengeType_Cooperative" => ::std::option::Option::Some(EChallengeType::k_EChallengeType_Cooperative),
                "k_EChallengeType_Contract" => ::std::option::Option::Some(EChallengeType::k_EChallengeType_Contract),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EChallengeType] = &[
            EChallengeType::k_EChallengeType_Invalid,
            EChallengeType::k_EChallengeType_Cooperative,
            EChallengeType::k_EChallengeType_Contract,
        ];
    }

    impl ::std::default::Default for EChallengeType {
        fn default() -> Self {
            EChallengeType::k_EChallengeType_Invalid
        }
    }

}

// @@protoc_insertion_point(message:CDOTAUserMsg_WRArcanaProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_WRArcanaProgress {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_WRArcanaProgress.ehandle)
    pub ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_WRArcanaProgress.target_ehandle)
    pub target_ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_WRArcanaProgress.arrows_landed)
    pub arrows_landed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_WRArcanaProgress.damage_dealt)
    pub damage_dealt: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_WRArcanaProgress.target_hp)
    pub target_hp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_WRArcanaProgress.target_max_hp)
    pub target_max_hp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_WRArcanaProgress.arcana_level)
    pub arcana_level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_WRArcanaProgress.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_WRArcanaProgress {
    fn default() -> &'a CDOTAUserMsg_WRArcanaProgress {
        <CDOTAUserMsg_WRArcanaProgress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_WRArcanaProgress {
    pub fn new() -> CDOTAUserMsg_WRArcanaProgress {
        ::std::default::Default::default()
    }

    // optional uint32 ehandle = 1;

    pub fn ehandle(&self) -> u32 {
        self.ehandle.unwrap_or(16777215u32)
    }

    pub fn clear_ehandle(&mut self) {
        self.ehandle = ::std::option::Option::None;
    }

    pub fn has_ehandle(&self) -> bool {
        self.ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ehandle(&mut self, v: u32) {
        self.ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 target_ehandle = 2;

    pub fn target_ehandle(&self) -> u32 {
        self.target_ehandle.unwrap_or(16777215u32)
    }

    pub fn clear_target_ehandle(&mut self) {
        self.target_ehandle = ::std::option::Option::None;
    }

    pub fn has_target_ehandle(&self) -> bool {
        self.target_ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_ehandle(&mut self, v: u32) {
        self.target_ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 arrows_landed = 3;

    pub fn arrows_landed(&self) -> u32 {
        self.arrows_landed.unwrap_or(0)
    }

    pub fn clear_arrows_landed(&mut self) {
        self.arrows_landed = ::std::option::Option::None;
    }

    pub fn has_arrows_landed(&self) -> bool {
        self.arrows_landed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arrows_landed(&mut self, v: u32) {
        self.arrows_landed = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_dealt = 4;

    pub fn damage_dealt(&self) -> u32 {
        self.damage_dealt.unwrap_or(0)
    }

    pub fn clear_damage_dealt(&mut self) {
        self.damage_dealt = ::std::option::Option::None;
    }

    pub fn has_damage_dealt(&self) -> bool {
        self.damage_dealt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_dealt(&mut self, v: u32) {
        self.damage_dealt = ::std::option::Option::Some(v);
    }

    // optional uint32 target_hp = 5;

    pub fn target_hp(&self) -> u32 {
        self.target_hp.unwrap_or(0)
    }

    pub fn clear_target_hp(&mut self) {
        self.target_hp = ::std::option::Option::None;
    }

    pub fn has_target_hp(&self) -> bool {
        self.target_hp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_hp(&mut self, v: u32) {
        self.target_hp = ::std::option::Option::Some(v);
    }

    // optional uint32 target_max_hp = 6;

    pub fn target_max_hp(&self) -> u32 {
        self.target_max_hp.unwrap_or(0)
    }

    pub fn clear_target_max_hp(&mut self) {
        self.target_max_hp = ::std::option::Option::None;
    }

    pub fn has_target_max_hp(&self) -> bool {
        self.target_max_hp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_max_hp(&mut self, v: u32) {
        self.target_max_hp = ::std::option::Option::Some(v);
    }

    // optional uint32 arcana_level = 7;

    pub fn arcana_level(&self) -> u32 {
        self.arcana_level.unwrap_or(0)
    }

    pub fn clear_arcana_level(&mut self) {
        self.arcana_level = ::std::option::Option::None;
    }

    pub fn has_arcana_level(&self) -> bool {
        self.arcana_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arcana_level(&mut self, v: u32) {
        self.arcana_level = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_WRArcanaProgress {
    const NAME: &'static str = "CDOTAUserMsg_WRArcanaProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target_ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.arrows_landed = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.damage_dealt = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.target_hp = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.target_max_hp = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.arcana_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ehandle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_ehandle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.arrows_landed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.damage_dealt {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.target_hp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.target_max_hp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.arcana_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ehandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_ehandle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.arrows_landed {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.damage_dealt {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.target_hp {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.target_max_hp {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.arcana_level {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_WRArcanaProgress {
        CDOTAUserMsg_WRArcanaProgress::new()
    }

    fn clear(&mut self) {
        self.ehandle = ::std::option::Option::None;
        self.target_ehandle = ::std::option::Option::None;
        self.arrows_landed = ::std::option::Option::None;
        self.damage_dealt = ::std::option::Option::None;
        self.target_hp = ::std::option::Option::None;
        self.target_max_hp = ::std::option::Option::None;
        self.arcana_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_WRArcanaProgress {
        static instance: CDOTAUserMsg_WRArcanaProgress = CDOTAUserMsg_WRArcanaProgress {
            ehandle: ::std::option::Option::None,
            target_ehandle: ::std::option::Option::None,
            arrows_landed: ::std::option::Option::None,
            damage_dealt: ::std::option::Option::None,
            target_hp: ::std::option::Option::None,
            target_max_hp: ::std::option::Option::None,
            arcana_level: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_WRArcanaSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_WRArcanaSummary {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_WRArcanaSummary.ehandle)
    pub ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_WRArcanaSummary.target_ehandle)
    pub target_ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_WRArcanaSummary.arrows_landed)
    pub arrows_landed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_WRArcanaSummary.damage_dealt)
    pub damage_dealt: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_WRArcanaSummary.target_hp)
    pub target_hp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_WRArcanaSummary.target_max_hp)
    pub target_max_hp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_WRArcanaSummary.arcana_level)
    pub arcana_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_WRArcanaSummary.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_WRArcanaSummary.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_WRArcanaSummary {
    fn default() -> &'a CDOTAUserMsg_WRArcanaSummary {
        <CDOTAUserMsg_WRArcanaSummary as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_WRArcanaSummary {
    pub fn new() -> CDOTAUserMsg_WRArcanaSummary {
        ::std::default::Default::default()
    }

    // optional uint32 ehandle = 1;

    pub fn ehandle(&self) -> u32 {
        self.ehandle.unwrap_or(16777215u32)
    }

    pub fn clear_ehandle(&mut self) {
        self.ehandle = ::std::option::Option::None;
    }

    pub fn has_ehandle(&self) -> bool {
        self.ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ehandle(&mut self, v: u32) {
        self.ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 target_ehandle = 2;

    pub fn target_ehandle(&self) -> u32 {
        self.target_ehandle.unwrap_or(16777215u32)
    }

    pub fn clear_target_ehandle(&mut self) {
        self.target_ehandle = ::std::option::Option::None;
    }

    pub fn has_target_ehandle(&self) -> bool {
        self.target_ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_ehandle(&mut self, v: u32) {
        self.target_ehandle = ::std::option::Option::Some(v);
    }

    // optional uint32 arrows_landed = 3;

    pub fn arrows_landed(&self) -> u32 {
        self.arrows_landed.unwrap_or(0)
    }

    pub fn clear_arrows_landed(&mut self) {
        self.arrows_landed = ::std::option::Option::None;
    }

    pub fn has_arrows_landed(&self) -> bool {
        self.arrows_landed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arrows_landed(&mut self, v: u32) {
        self.arrows_landed = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_dealt = 4;

    pub fn damage_dealt(&self) -> u32 {
        self.damage_dealt.unwrap_or(0)
    }

    pub fn clear_damage_dealt(&mut self) {
        self.damage_dealt = ::std::option::Option::None;
    }

    pub fn has_damage_dealt(&self) -> bool {
        self.damage_dealt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_dealt(&mut self, v: u32) {
        self.damage_dealt = ::std::option::Option::Some(v);
    }

    // optional uint32 target_hp = 5;

    pub fn target_hp(&self) -> u32 {
        self.target_hp.unwrap_or(0)
    }

    pub fn clear_target_hp(&mut self) {
        self.target_hp = ::std::option::Option::None;
    }

    pub fn has_target_hp(&self) -> bool {
        self.target_hp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_hp(&mut self, v: u32) {
        self.target_hp = ::std::option::Option::Some(v);
    }

    // optional uint32 target_max_hp = 6;

    pub fn target_max_hp(&self) -> u32 {
        self.target_max_hp.unwrap_or(0)
    }

    pub fn clear_target_max_hp(&mut self) {
        self.target_max_hp = ::std::option::Option::None;
    }

    pub fn has_target_max_hp(&self) -> bool {
        self.target_max_hp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_max_hp(&mut self, v: u32) {
        self.target_max_hp = ::std::option::Option::Some(v);
    }

    // optional uint32 arcana_level = 7;

    pub fn arcana_level(&self) -> u32 {
        self.arcana_level.unwrap_or(0)
    }

    pub fn clear_arcana_level(&mut self) {
        self.arcana_level = ::std::option::Option::None;
    }

    pub fn has_arcana_level(&self) -> bool {
        self.arcana_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arcana_level(&mut self, v: u32) {
        self.arcana_level = ::std::option::Option::Some(v);
    }

    // optional bool success = 8;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_WRArcanaSummary {
    const NAME: &'static str = "CDOTAUserMsg_WRArcanaSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target_ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.arrows_landed = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.damage_dealt = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.target_hp = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.target_max_hp = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.arcana_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ehandle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_ehandle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.arrows_landed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.damage_dealt {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.target_hp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.target_max_hp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.arcana_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ehandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_ehandle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.arrows_landed {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.damage_dealt {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.target_hp {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.target_max_hp {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.arcana_level {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.success {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_WRArcanaSummary {
        CDOTAUserMsg_WRArcanaSummary::new()
    }

    fn clear(&mut self) {
        self.ehandle = ::std::option::Option::None;
        self.target_ehandle = ::std::option::Option::None;
        self.arrows_landed = ::std::option::Option::None;
        self.damage_dealt = ::std::option::Option::None;
        self.target_hp = ::std::option::Option::None;
        self.target_max_hp = ::std::option::Option::None;
        self.arcana_level = ::std::option::Option::None;
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_WRArcanaSummary {
        static instance: CDOTAUserMsg_WRArcanaSummary = CDOTAUserMsg_WRArcanaSummary {
            ehandle: ::std::option::Option::None,
            target_ehandle: ::std::option::Option::None,
            arrows_landed: ::std::option::Option::None,
            damage_dealt: ::std::option::Option::None,
            target_hp: ::std::option::Option::None,
            target_max_hp: ::std::option::Option::None,
            arcana_level: ::std::option::Option::None,
            success: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_EmptyItemSlotAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_EmptyItemSlotAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_EmptyItemSlotAlert.source_player_id)
    pub source_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_EmptyItemSlotAlert.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_EmptyItemSlotAlert.slot_index)
    pub slot_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_EmptyItemSlotAlert.cooldown_seconds)
    pub cooldown_seconds: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_EmptyItemSlotAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_EmptyItemSlotAlert {
    fn default() -> &'a CDOTAUserMsg_EmptyItemSlotAlert {
        <CDOTAUserMsg_EmptyItemSlotAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_EmptyItemSlotAlert {
    pub fn new() -> CDOTAUserMsg_EmptyItemSlotAlert {
        ::std::default::Default::default()
    }

    // optional int32 source_player_id = 1;

    pub fn source_player_id(&self) -> i32 {
        self.source_player_id.unwrap_or(-1i32)
    }

    pub fn clear_source_player_id(&mut self) {
        self.source_player_id = ::std::option::Option::None;
    }

    pub fn has_source_player_id(&self) -> bool {
        self.source_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_player_id(&mut self, v: i32) {
        self.source_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_player_id = 2;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(-1i32)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 slot_index = 3;

    pub fn slot_index(&self) -> i32 {
        self.slot_index.unwrap_or(0)
    }

    pub fn clear_slot_index(&mut self) {
        self.slot_index = ::std::option::Option::None;
    }

    pub fn has_slot_index(&self) -> bool {
        self.slot_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_index(&mut self, v: i32) {
        self.slot_index = ::std::option::Option::Some(v);
    }

    // optional int32 cooldown_seconds = 4;

    pub fn cooldown_seconds(&self) -> i32 {
        self.cooldown_seconds.unwrap_or(0)
    }

    pub fn clear_cooldown_seconds(&mut self) {
        self.cooldown_seconds = ::std::option::Option::None;
    }

    pub fn has_cooldown_seconds(&self) -> bool {
        self.cooldown_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown_seconds(&mut self, v: i32) {
        self.cooldown_seconds = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_EmptyItemSlotAlert {
    const NAME: &'static str = "CDOTAUserMsg_EmptyItemSlotAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.slot_index = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.cooldown_seconds = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.slot_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.cooldown_seconds {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.source_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.slot_index {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.cooldown_seconds {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_EmptyItemSlotAlert {
        CDOTAUserMsg_EmptyItemSlotAlert::new()
    }

    fn clear(&mut self) {
        self.source_player_id = ::std::option::Option::None;
        self.target_player_id = ::std::option::Option::None;
        self.slot_index = ::std::option::Option::None;
        self.cooldown_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_EmptyItemSlotAlert {
        static instance: CDOTAUserMsg_EmptyItemSlotAlert = CDOTAUserMsg_EmptyItemSlotAlert {
            source_player_id: ::std::option::Option::None,
            target_player_id: ::std::option::Option::None,
            slot_index: ::std::option::Option::None,
            cooldown_seconds: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_AghsStatusAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_AghsStatusAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_AghsStatusAlert.source_player_id)
    pub source_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AghsStatusAlert.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AghsStatusAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AghsStatusAlert.alert_type)
    pub alert_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AghsStatusAlert.has_scepter)
    pub has_scepter: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_AghsStatusAlert.has_shard)
    pub has_shard: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_AghsStatusAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_AghsStatusAlert {
    fn default() -> &'a CDOTAUserMsg_AghsStatusAlert {
        <CDOTAUserMsg_AghsStatusAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_AghsStatusAlert {
    pub fn new() -> CDOTAUserMsg_AghsStatusAlert {
        ::std::default::Default::default()
    }

    // optional int32 source_player_id = 1;

    pub fn source_player_id(&self) -> i32 {
        self.source_player_id.unwrap_or(-1i32)
    }

    pub fn clear_source_player_id(&mut self) {
        self.source_player_id = ::std::option::Option::None;
    }

    pub fn has_source_player_id(&self) -> bool {
        self.source_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_player_id(&mut self, v: i32) {
        self.source_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_player_id = 2;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(-1i32)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 3;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(-1i32)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional uint32 alert_type = 4;

    pub fn alert_type(&self) -> u32 {
        self.alert_type.unwrap_or(0)
    }

    pub fn clear_alert_type(&mut self) {
        self.alert_type = ::std::option::Option::None;
    }

    pub fn has_alert_type(&self) -> bool {
        self.alert_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alert_type(&mut self, v: u32) {
        self.alert_type = ::std::option::Option::Some(v);
    }

    // optional bool has_scepter = 5;

    pub fn has_scepter(&self) -> bool {
        self.has_scepter.unwrap_or(false)
    }

    pub fn clear_has_scepter(&mut self) {
        self.has_scepter = ::std::option::Option::None;
    }

    pub fn has_has_scepter(&self) -> bool {
        self.has_scepter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_scepter(&mut self, v: bool) {
        self.has_scepter = ::std::option::Option::Some(v);
    }

    // optional bool has_shard = 6;

    pub fn has_shard(&self) -> bool {
        self.has_shard.unwrap_or(false)
    }

    pub fn clear_has_shard(&mut self) {
        self.has_shard = ::std::option::Option::None;
    }

    pub fn has_has_shard(&self) -> bool {
        self.has_shard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_shard(&mut self, v: bool) {
        self.has_shard = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_AghsStatusAlert {
    const NAME: &'static str = "CDOTAUserMsg_AghsStatusAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.alert_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.has_scepter = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.has_shard = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.alert_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.has_scepter {
            my_size += 1 + 1;
        }
        if let Some(v) = self.has_shard {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.source_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.alert_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.has_scepter {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.has_shard {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_AghsStatusAlert {
        CDOTAUserMsg_AghsStatusAlert::new()
    }

    fn clear(&mut self) {
        self.source_player_id = ::std::option::Option::None;
        self.target_player_id = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.alert_type = ::std::option::Option::None;
        self.has_scepter = ::std::option::Option::None;
        self.has_shard = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_AghsStatusAlert {
        static instance: CDOTAUserMsg_AghsStatusAlert = CDOTAUserMsg_AghsStatusAlert {
            source_player_id: ::std::option::Option::None,
            target_player_id: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            alert_type: ::std::option::Option::None,
            has_scepter: ::std::option::Option::None,
            has_shard: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_MutedPlayers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_MutedPlayers {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_MutedPlayers.text_muted_player_ids)
    pub text_muted_player_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_MutedPlayers.voice_muted_player_ids)
    pub voice_muted_player_ids: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_MutedPlayers.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_MutedPlayers {
    fn default() -> &'a CDOTAUserMsg_MutedPlayers {
        <CDOTAUserMsg_MutedPlayers as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_MutedPlayers {
    pub fn new() -> CDOTAUserMsg_MutedPlayers {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_MutedPlayers {
    const NAME: &'static str = "CDOTAUserMsg_MutedPlayers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.text_muted_player_ids)?;
                },
                8 => {
                    self.text_muted_player_ids.push(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.voice_muted_player_ids)?;
                },
                16 => {
                    self.voice_muted_player_ids.push(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.text_muted_player_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, *value);
        };
        for value in &self.voice_muted_player_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.text_muted_player_ids {
            os.write_int32(1, *v)?;
        };
        for v in &self.voice_muted_player_ids {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_MutedPlayers {
        CDOTAUserMsg_MutedPlayers::new()
    }

    fn clear(&mut self) {
        self.text_muted_player_ids.clear();
        self.voice_muted_player_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_MutedPlayers {
        static instance: CDOTAUserMsg_MutedPlayers = CDOTAUserMsg_MutedPlayers {
            text_muted_player_ids: ::std::vec::Vec::new(),
            voice_muted_player_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_ContextualTip)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ContextualTip {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_ContextualTip.tip_id)
    pub tip_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ContextualTip.referenced_abilities)
    pub referenced_abilities: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ContextualTip.referenced_units)
    pub referenced_units: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ContextualTip.panorama_classes)
    pub panorama_classes: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ContextualTip.force_annotation)
    pub force_annotation: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ContextualTip.variant)
    pub variant: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ContextualTip.int_param)
    pub int_param: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ContextualTip.int_param2)
    pub int_param2: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ContextualTip.float_param)
    pub float_param: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ContextualTip.float_param2)
    pub float_param2: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ContextualTip.string_param)
    pub string_param: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ContextualTip.string_param2)
    pub string_param2: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ContextualTip.tip_text_override)
    pub tip_text_override: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ContextualTip.tip_annotation_override)
    pub tip_annotation_override: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ContextualTip.panorama_snippet)
    pub panorama_snippet: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_ContextualTip.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ContextualTip {
    fn default() -> &'a CDOTAUserMsg_ContextualTip {
        <CDOTAUserMsg_ContextualTip as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ContextualTip {
    pub fn new() -> CDOTAUserMsg_ContextualTip {
        ::std::default::Default::default()
    }

    // optional int32 tip_id = 1;

    pub fn tip_id(&self) -> i32 {
        self.tip_id.unwrap_or(0)
    }

    pub fn clear_tip_id(&mut self) {
        self.tip_id = ::std::option::Option::None;
    }

    pub fn has_tip_id(&self) -> bool {
        self.tip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tip_id(&mut self, v: i32) {
        self.tip_id = ::std::option::Option::Some(v);
    }

    // optional bool force_annotation = 5;

    pub fn force_annotation(&self) -> bool {
        self.force_annotation.unwrap_or(false)
    }

    pub fn clear_force_annotation(&mut self) {
        self.force_annotation = ::std::option::Option::None;
    }

    pub fn has_force_annotation(&self) -> bool {
        self.force_annotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_annotation(&mut self, v: bool) {
        self.force_annotation = ::std::option::Option::Some(v);
    }

    // optional int32 variant = 6;

    pub fn variant(&self) -> i32 {
        self.variant.unwrap_or(0)
    }

    pub fn clear_variant(&mut self) {
        self.variant = ::std::option::Option::None;
    }

    pub fn has_variant(&self) -> bool {
        self.variant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_variant(&mut self, v: i32) {
        self.variant = ::std::option::Option::Some(v);
    }

    // optional int32 int_param = 7;

    pub fn int_param(&self) -> i32 {
        self.int_param.unwrap_or(0)
    }

    pub fn clear_int_param(&mut self) {
        self.int_param = ::std::option::Option::None;
    }

    pub fn has_int_param(&self) -> bool {
        self.int_param.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_param(&mut self, v: i32) {
        self.int_param = ::std::option::Option::Some(v);
    }

    // optional int32 int_param2 = 8;

    pub fn int_param2(&self) -> i32 {
        self.int_param2.unwrap_or(0)
    }

    pub fn clear_int_param2(&mut self) {
        self.int_param2 = ::std::option::Option::None;
    }

    pub fn has_int_param2(&self) -> bool {
        self.int_param2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_param2(&mut self, v: i32) {
        self.int_param2 = ::std::option::Option::Some(v);
    }

    // optional float float_param = 9;

    pub fn float_param(&self) -> f32 {
        self.float_param.unwrap_or(0.)
    }

    pub fn clear_float_param(&mut self) {
        self.float_param = ::std::option::Option::None;
    }

    pub fn has_float_param(&self) -> bool {
        self.float_param.is_some()
    }

    // Param is passed by value, moved
    pub fn set_float_param(&mut self, v: f32) {
        self.float_param = ::std::option::Option::Some(v);
    }

    // optional float float_param2 = 10;

    pub fn float_param2(&self) -> f32 {
        self.float_param2.unwrap_or(0.)
    }

    pub fn clear_float_param2(&mut self) {
        self.float_param2 = ::std::option::Option::None;
    }

    pub fn has_float_param2(&self) -> bool {
        self.float_param2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_float_param2(&mut self, v: f32) {
        self.float_param2 = ::std::option::Option::Some(v);
    }

    // optional string string_param = 11;

    pub fn string_param(&self) -> &str {
        match self.string_param.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string_param(&mut self) {
        self.string_param = ::std::option::Option::None;
    }

    pub fn has_string_param(&self) -> bool {
        self.string_param.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_param(&mut self, v: ::std::string::String) {
        self.string_param = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_param(&mut self) -> &mut ::std::string::String {
        if self.string_param.is_none() {
            self.string_param = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string_param.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_param(&mut self) -> ::std::string::String {
        self.string_param.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string string_param2 = 12;

    pub fn string_param2(&self) -> &str {
        match self.string_param2.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string_param2(&mut self) {
        self.string_param2 = ::std::option::Option::None;
    }

    pub fn has_string_param2(&self) -> bool {
        self.string_param2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_param2(&mut self, v: ::std::string::String) {
        self.string_param2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_param2(&mut self) -> &mut ::std::string::String {
        if self.string_param2.is_none() {
            self.string_param2 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string_param2.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_param2(&mut self) -> ::std::string::String {
        self.string_param2.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string tip_text_override = 13;

    pub fn tip_text_override(&self) -> &str {
        match self.tip_text_override.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tip_text_override(&mut self) {
        self.tip_text_override = ::std::option::Option::None;
    }

    pub fn has_tip_text_override(&self) -> bool {
        self.tip_text_override.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tip_text_override(&mut self, v: ::std::string::String) {
        self.tip_text_override = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tip_text_override(&mut self) -> &mut ::std::string::String {
        if self.tip_text_override.is_none() {
            self.tip_text_override = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tip_text_override.as_mut().unwrap()
    }

    // Take field
    pub fn take_tip_text_override(&mut self) -> ::std::string::String {
        self.tip_text_override.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string tip_annotation_override = 14;

    pub fn tip_annotation_override(&self) -> &str {
        match self.tip_annotation_override.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tip_annotation_override(&mut self) {
        self.tip_annotation_override = ::std::option::Option::None;
    }

    pub fn has_tip_annotation_override(&self) -> bool {
        self.tip_annotation_override.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tip_annotation_override(&mut self, v: ::std::string::String) {
        self.tip_annotation_override = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tip_annotation_override(&mut self) -> &mut ::std::string::String {
        if self.tip_annotation_override.is_none() {
            self.tip_annotation_override = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tip_annotation_override.as_mut().unwrap()
    }

    // Take field
    pub fn take_tip_annotation_override(&mut self) -> ::std::string::String {
        self.tip_annotation_override.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string panorama_snippet = 15;

    pub fn panorama_snippet(&self) -> &str {
        match self.panorama_snippet.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_panorama_snippet(&mut self) {
        self.panorama_snippet = ::std::option::Option::None;
    }

    pub fn has_panorama_snippet(&self) -> bool {
        self.panorama_snippet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_panorama_snippet(&mut self, v: ::std::string::String) {
        self.panorama_snippet = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_panorama_snippet(&mut self) -> &mut ::std::string::String {
        if self.panorama_snippet.is_none() {
            self.panorama_snippet = ::std::option::Option::Some(::std::string::String::new());
        }
        self.panorama_snippet.as_mut().unwrap()
    }

    // Take field
    pub fn take_panorama_snippet(&mut self) -> ::std::string::String {
        self.panorama_snippet.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_ContextualTip {
    const NAME: &'static str = "CDOTAUserMsg_ContextualTip";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tip_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.referenced_abilities.push(is.read_string()?);
                },
                26 => {
                    self.referenced_units.push(is.read_string()?);
                },
                34 => {
                    self.panorama_classes.push(is.read_string()?);
                },
                40 => {
                    self.force_annotation = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.variant = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.int_param = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.int_param2 = ::std::option::Option::Some(is.read_int32()?);
                },
                77 => {
                    self.float_param = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.float_param2 = ::std::option::Option::Some(is.read_float()?);
                },
                90 => {
                    self.string_param = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.string_param2 = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.tip_text_override = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.tip_annotation_override = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.panorama_snippet = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tip_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        for value in &self.referenced_abilities {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &value);
        };
        for value in &self.referenced_units {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &value);
        };
        for value in &self.panorama_classes {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.force_annotation {
            my_size += 1 + 1;
        }
        if let Some(v) = self.variant {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.int_param {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.int_param2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.float_param {
            my_size += 1 + 4;
        }
        if let Some(v) = self.float_param2 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.string_param.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.string_param2.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.tip_text_override.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.tip_annotation_override.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.panorama_snippet.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(15, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.tip_id {
            os.write_int32(1, v)?;
        }
        for v in &self.referenced_abilities {
            os.write_string(2, &v)?;
        };
        for v in &self.referenced_units {
            os.write_string(3, &v)?;
        };
        for v in &self.panorama_classes {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.force_annotation {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.variant {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.int_param {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.int_param2 {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.float_param {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.float_param2 {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.string_param.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.string_param2.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.tip_text_override.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.tip_annotation_override.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.panorama_snippet.as_ref() {
            os.write_string(15, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ContextualTip {
        CDOTAUserMsg_ContextualTip::new()
    }

    fn clear(&mut self) {
        self.tip_id = ::std::option::Option::None;
        self.referenced_abilities.clear();
        self.referenced_units.clear();
        self.panorama_classes.clear();
        self.force_annotation = ::std::option::Option::None;
        self.variant = ::std::option::Option::None;
        self.int_param = ::std::option::Option::None;
        self.int_param2 = ::std::option::Option::None;
        self.float_param = ::std::option::Option::None;
        self.float_param2 = ::std::option::Option::None;
        self.string_param = ::std::option::Option::None;
        self.string_param2 = ::std::option::Option::None;
        self.tip_text_override = ::std::option::Option::None;
        self.tip_annotation_override = ::std::option::Option::None;
        self.panorama_snippet = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ContextualTip {
        static instance: CDOTAUserMsg_ContextualTip = CDOTAUserMsg_ContextualTip {
            tip_id: ::std::option::Option::None,
            referenced_abilities: ::std::vec::Vec::new(),
            referenced_units: ::std::vec::Vec::new(),
            panorama_classes: ::std::vec::Vec::new(),
            force_annotation: ::std::option::Option::None,
            variant: ::std::option::Option::None,
            int_param: ::std::option::Option::None,
            int_param2: ::std::option::Option::None,
            float_param: ::std::option::Option::None,
            float_param2: ::std::option::Option::None,
            string_param: ::std::option::Option::None,
            string_param2: ::std::option::Option::None,
            tip_text_override: ::std::option::Option::None,
            tip_annotation_override: ::std::option::Option::None,
            panorama_snippet: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_ChatMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_ChatMessage {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_ChatMessage.source_player_id)
    pub source_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ChatMessage.channel_type)
    pub channel_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_ChatMessage.message_text)
    pub message_text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_ChatMessage.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_ChatMessage {
    fn default() -> &'a CDOTAUserMsg_ChatMessage {
        <CDOTAUserMsg_ChatMessage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_ChatMessage {
    pub fn new() -> CDOTAUserMsg_ChatMessage {
        ::std::default::Default::default()
    }

    // optional int32 source_player_id = 1;

    pub fn source_player_id(&self) -> i32 {
        self.source_player_id.unwrap_or(-1i32)
    }

    pub fn clear_source_player_id(&mut self) {
        self.source_player_id = ::std::option::Option::None;
    }

    pub fn has_source_player_id(&self) -> bool {
        self.source_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_player_id(&mut self, v: i32) {
        self.source_player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 channel_type = 2;

    pub fn channel_type(&self) -> u32 {
        self.channel_type.unwrap_or(0)
    }

    pub fn clear_channel_type(&mut self) {
        self.channel_type = ::std::option::Option::None;
    }

    pub fn has_channel_type(&self) -> bool {
        self.channel_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_type(&mut self, v: u32) {
        self.channel_type = ::std::option::Option::Some(v);
    }

    // optional string message_text = 3;

    pub fn message_text(&self) -> &str {
        match self.message_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message_text(&mut self) {
        self.message_text = ::std::option::Option::None;
    }

    pub fn has_message_text(&self) -> bool {
        self.message_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_text(&mut self, v: ::std::string::String) {
        self.message_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_text(&mut self) -> &mut ::std::string::String {
        if self.message_text.is_none() {
            self.message_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_text(&mut self) -> ::std::string::String {
        self.message_text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_ChatMessage {
    const NAME: &'static str = "CDOTAUserMsg_ChatMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.channel_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.message_text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.channel_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.message_text.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.source_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.channel_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.message_text.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_ChatMessage {
        CDOTAUserMsg_ChatMessage::new()
    }

    fn clear(&mut self) {
        self.source_player_id = ::std::option::Option::None;
        self.channel_type = ::std::option::Option::None;
        self.message_text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_ChatMessage {
        static instance: CDOTAUserMsg_ChatMessage = CDOTAUserMsg_ChatMessage {
            source_player_id: ::std::option::Option::None,
            channel_type: ::std::option::Option::None,
            message_text: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_RockPaperScissorsStarted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_RockPaperScissorsStarted {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_RockPaperScissorsStarted.player_id_source)
    pub player_id_source: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_RockPaperScissorsStarted.player_id_target)
    pub player_id_target: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_RockPaperScissorsStarted.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_RockPaperScissorsStarted {
    fn default() -> &'a CDOTAUserMsg_RockPaperScissorsStarted {
        <CDOTAUserMsg_RockPaperScissorsStarted as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_RockPaperScissorsStarted {
    pub fn new() -> CDOTAUserMsg_RockPaperScissorsStarted {
        ::std::default::Default::default()
    }

    // optional int32 player_id_source = 1;

    pub fn player_id_source(&self) -> i32 {
        self.player_id_source.unwrap_or(-1i32)
    }

    pub fn clear_player_id_source(&mut self) {
        self.player_id_source = ::std::option::Option::None;
    }

    pub fn has_player_id_source(&self) -> bool {
        self.player_id_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_source(&mut self, v: i32) {
        self.player_id_source = ::std::option::Option::Some(v);
    }

    // optional int32 player_id_target = 2;

    pub fn player_id_target(&self) -> i32 {
        self.player_id_target.unwrap_or(-1i32)
    }

    pub fn clear_player_id_target(&mut self) {
        self.player_id_target = ::std::option::Option::None;
    }

    pub fn has_player_id_target(&self) -> bool {
        self.player_id_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_target(&mut self, v: i32) {
        self.player_id_target = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_RockPaperScissorsStarted {
    const NAME: &'static str = "CDOTAUserMsg_RockPaperScissorsStarted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id_source = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_id_target = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id_source {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_id_target {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id_source {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_id_target {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_RockPaperScissorsStarted {
        CDOTAUserMsg_RockPaperScissorsStarted::new()
    }

    fn clear(&mut self) {
        self.player_id_source = ::std::option::Option::None;
        self.player_id_target = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_RockPaperScissorsStarted {
        static instance: CDOTAUserMsg_RockPaperScissorsStarted = CDOTAUserMsg_RockPaperScissorsStarted {
            player_id_source: ::std::option::Option::None,
            player_id_target: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_RockPaperScissorsFinished)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_RockPaperScissorsFinished {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_RockPaperScissorsFinished.player_id_1)
    pub player_id_1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_RockPaperScissorsFinished.player_id_2)
    pub player_id_2: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_RockPaperScissorsFinished.player_1_choice)
    pub player_1_choice: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_RockPaperScissorsFinished.player_2_choice)
    pub player_2_choice: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_RockPaperScissorsFinished.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_RockPaperScissorsFinished {
    fn default() -> &'a CDOTAUserMsg_RockPaperScissorsFinished {
        <CDOTAUserMsg_RockPaperScissorsFinished as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_RockPaperScissorsFinished {
    pub fn new() -> CDOTAUserMsg_RockPaperScissorsFinished {
        ::std::default::Default::default()
    }

    // optional int32 player_id_1 = 1;

    pub fn player_id_1(&self) -> i32 {
        self.player_id_1.unwrap_or(-1i32)
    }

    pub fn clear_player_id_1(&mut self) {
        self.player_id_1 = ::std::option::Option::None;
    }

    pub fn has_player_id_1(&self) -> bool {
        self.player_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_1(&mut self, v: i32) {
        self.player_id_1 = ::std::option::Option::Some(v);
    }

    // optional int32 player_id_2 = 2;

    pub fn player_id_2(&self) -> i32 {
        self.player_id_2.unwrap_or(-1i32)
    }

    pub fn clear_player_id_2(&mut self) {
        self.player_id_2 = ::std::option::Option::None;
    }

    pub fn has_player_id_2(&self) -> bool {
        self.player_id_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_2(&mut self, v: i32) {
        self.player_id_2 = ::std::option::Option::Some(v);
    }

    // optional int32 player_1_choice = 3;

    pub fn player_1_choice(&self) -> i32 {
        self.player_1_choice.unwrap_or(0)
    }

    pub fn clear_player_1_choice(&mut self) {
        self.player_1_choice = ::std::option::Option::None;
    }

    pub fn has_player_1_choice(&self) -> bool {
        self.player_1_choice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_1_choice(&mut self, v: i32) {
        self.player_1_choice = ::std::option::Option::Some(v);
    }

    // optional int32 player_2_choice = 4;

    pub fn player_2_choice(&self) -> i32 {
        self.player_2_choice.unwrap_or(0)
    }

    pub fn clear_player_2_choice(&mut self) {
        self.player_2_choice = ::std::option::Option::None;
    }

    pub fn has_player_2_choice(&self) -> bool {
        self.player_2_choice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_2_choice(&mut self, v: i32) {
        self.player_2_choice = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_RockPaperScissorsFinished {
    const NAME: &'static str = "CDOTAUserMsg_RockPaperScissorsFinished";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id_1 = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_id_2 = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.player_1_choice = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.player_2_choice = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id_1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_id_2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.player_1_choice {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.player_2_choice {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id_1 {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_id_2 {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.player_1_choice {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.player_2_choice {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_RockPaperScissorsFinished {
        CDOTAUserMsg_RockPaperScissorsFinished::new()
    }

    fn clear(&mut self) {
        self.player_id_1 = ::std::option::Option::None;
        self.player_id_2 = ::std::option::Option::None;
        self.player_1_choice = ::std::option::Option::None;
        self.player_2_choice = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_RockPaperScissorsFinished {
        static instance: CDOTAUserMsg_RockPaperScissorsFinished = CDOTAUserMsg_RockPaperScissorsFinished {
            player_id_1: ::std::option::Option::None,
            player_id_2: ::std::option::Option::None,
            player_1_choice: ::std::option::Option::None,
            player_2_choice: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_DuelOpponentKilled)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_DuelOpponentKilled {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_DuelOpponentKilled.player_id_winner)
    pub player_id_winner: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_DuelOpponentKilled.player_id_loser)
    pub player_id_loser: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_DuelOpponentKilled.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_DuelOpponentKilled {
    fn default() -> &'a CDOTAUserMsg_DuelOpponentKilled {
        <CDOTAUserMsg_DuelOpponentKilled as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_DuelOpponentKilled {
    pub fn new() -> CDOTAUserMsg_DuelOpponentKilled {
        ::std::default::Default::default()
    }

    // optional int32 player_id_winner = 1;

    pub fn player_id_winner(&self) -> i32 {
        self.player_id_winner.unwrap_or(0)
    }

    pub fn clear_player_id_winner(&mut self) {
        self.player_id_winner = ::std::option::Option::None;
    }

    pub fn has_player_id_winner(&self) -> bool {
        self.player_id_winner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_winner(&mut self, v: i32) {
        self.player_id_winner = ::std::option::Option::Some(v);
    }

    // optional int32 player_id_loser = 2;

    pub fn player_id_loser(&self) -> i32 {
        self.player_id_loser.unwrap_or(0)
    }

    pub fn clear_player_id_loser(&mut self) {
        self.player_id_loser = ::std::option::Option::None;
    }

    pub fn has_player_id_loser(&self) -> bool {
        self.player_id_loser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_loser(&mut self, v: i32) {
        self.player_id_loser = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_DuelOpponentKilled {
    const NAME: &'static str = "CDOTAUserMsg_DuelOpponentKilled";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id_winner = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_id_loser = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id_winner {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_id_loser {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id_winner {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_id_loser {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_DuelOpponentKilled {
        CDOTAUserMsg_DuelOpponentKilled::new()
    }

    fn clear(&mut self) {
        self.player_id_winner = ::std::option::Option::None;
        self.player_id_loser = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_DuelOpponentKilled {
        static instance: CDOTAUserMsg_DuelOpponentKilled = CDOTAUserMsg_DuelOpponentKilled {
            player_id_winner: ::std::option::Option::None,
            player_id_loser: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_DuelAccepted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_DuelAccepted {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_DuelAccepted.player_id_1)
    pub player_id_1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_DuelAccepted.player_id_2)
    pub player_id_2: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_DuelAccepted.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_DuelAccepted {
    fn default() -> &'a CDOTAUserMsg_DuelAccepted {
        <CDOTAUserMsg_DuelAccepted as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_DuelAccepted {
    pub fn new() -> CDOTAUserMsg_DuelAccepted {
        ::std::default::Default::default()
    }

    // optional int32 player_id_1 = 1;

    pub fn player_id_1(&self) -> i32 {
        self.player_id_1.unwrap_or(0)
    }

    pub fn clear_player_id_1(&mut self) {
        self.player_id_1 = ::std::option::Option::None;
    }

    pub fn has_player_id_1(&self) -> bool {
        self.player_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_1(&mut self, v: i32) {
        self.player_id_1 = ::std::option::Option::Some(v);
    }

    // optional int32 player_id_2 = 2;

    pub fn player_id_2(&self) -> i32 {
        self.player_id_2.unwrap_or(0)
    }

    pub fn clear_player_id_2(&mut self) {
        self.player_id_2 = ::std::option::Option::None;
    }

    pub fn has_player_id_2(&self) -> bool {
        self.player_id_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_2(&mut self, v: i32) {
        self.player_id_2 = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_DuelAccepted {
    const NAME: &'static str = "CDOTAUserMsg_DuelAccepted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id_1 = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_id_2 = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id_1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_id_2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id_1 {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_id_2 {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_DuelAccepted {
        CDOTAUserMsg_DuelAccepted::new()
    }

    fn clear(&mut self) {
        self.player_id_1 = ::std::option::Option::None;
        self.player_id_2 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_DuelAccepted {
        static instance: CDOTAUserMsg_DuelAccepted = CDOTAUserMsg_DuelAccepted {
            player_id_1: ::std::option::Option::None,
            player_id_2: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_DuelRequested)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_DuelRequested {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_DuelRequested.player_id_requestor)
    pub player_id_requestor: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_DuelRequested.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_DuelRequested {
    fn default() -> &'a CDOTAUserMsg_DuelRequested {
        <CDOTAUserMsg_DuelRequested as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_DuelRequested {
    pub fn new() -> CDOTAUserMsg_DuelRequested {
        ::std::default::Default::default()
    }

    // optional int32 player_id_requestor = 1;

    pub fn player_id_requestor(&self) -> i32 {
        self.player_id_requestor.unwrap_or(-1i32)
    }

    pub fn clear_player_id_requestor(&mut self) {
        self.player_id_requestor = ::std::option::Option::None;
    }

    pub fn has_player_id_requestor(&self) -> bool {
        self.player_id_requestor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_requestor(&mut self, v: i32) {
        self.player_id_requestor = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_DuelRequested {
    const NAME: &'static str = "CDOTAUserMsg_DuelRequested";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id_requestor = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id_requestor {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id_requestor {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_DuelRequested {
        CDOTAUserMsg_DuelRequested::new()
    }

    fn clear(&mut self) {
        self.player_id_requestor = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_DuelRequested {
        static instance: CDOTAUserMsg_DuelRequested = CDOTAUserMsg_DuelRequested {
            player_id_requestor: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled.player_id_killer)
    pub player_id_killer: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled.player_id_target)
    pub player_id_target: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled.points)
    pub points: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled.points_total)
    pub points_total: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled.last_hit)
    pub last_hit: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
    fn default() -> &'a CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
        <CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
    pub fn new() -> CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
        ::std::default::Default::default()
    }

    // required int32 player_id_killer = 1;

    pub fn player_id_killer(&self) -> i32 {
        self.player_id_killer.unwrap_or(-1i32)
    }

    pub fn clear_player_id_killer(&mut self) {
        self.player_id_killer = ::std::option::Option::None;
    }

    pub fn has_player_id_killer(&self) -> bool {
        self.player_id_killer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_killer(&mut self, v: i32) {
        self.player_id_killer = ::std::option::Option::Some(v);
    }

    // required int32 player_id_target = 2;

    pub fn player_id_target(&self) -> i32 {
        self.player_id_target.unwrap_or(-1i32)
    }

    pub fn clear_player_id_target(&mut self) {
        self.player_id_target = ::std::option::Option::None;
    }

    pub fn has_player_id_target(&self) -> bool {
        self.player_id_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_target(&mut self, v: i32) {
        self.player_id_target = ::std::option::Option::Some(v);
    }

    // required int32 points = 3;

    pub fn points(&self) -> i32 {
        self.points.unwrap_or(0)
    }

    pub fn clear_points(&mut self) {
        self.points = ::std::option::Option::None;
    }

    pub fn has_points(&self) -> bool {
        self.points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: i32) {
        self.points = ::std::option::Option::Some(v);
    }

    // required int32 points_total = 4;

    pub fn points_total(&self) -> i32 {
        self.points_total.unwrap_or(0)
    }

    pub fn clear_points_total(&mut self) {
        self.points_total = ::std::option::Option::None;
    }

    pub fn has_points_total(&self) -> bool {
        self.points_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_total(&mut self, v: i32) {
        self.points_total = ::std::option::Option::Some(v);
    }

    // required bool last_hit = 5;

    pub fn last_hit(&self) -> bool {
        self.last_hit.unwrap_or(false)
    }

    pub fn clear_last_hit(&mut self) {
        self.last_hit = ::std::option::Option::None;
    }

    pub fn has_last_hit(&self) -> bool {
        self.last_hit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hit(&mut self, v: bool) {
        self.last_hit = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
    const NAME: &'static str = "CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled";

    fn is_initialized(&self) -> bool {
        if self.player_id_killer.is_none() {
            return false;
        }
        if self.player_id_target.is_none() {
            return false;
        }
        if self.points.is_none() {
            return false;
        }
        if self.points_total.is_none() {
            return false;
        }
        if self.last_hit.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id_killer = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_id_target = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.points = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.points_total = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.last_hit = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id_killer {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_id_target {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.points {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.points_total {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.last_hit {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id_killer {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_id_target {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.points {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.points_total {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.last_hit {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
        CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled::new()
    }

    fn clear(&mut self) {
        self.player_id_killer = ::std::option::Option::None;
        self.player_id_target = ::std::option::Option::None;
        self.points = ::std::option::Option::None;
        self.points_total = ::std::option::Option::None;
        self.last_hit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
        static instance: CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled = CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
            player_id_killer: ::std::option::Option::None,
            player_id_target: ::std::option::Option::None,
            points: ::std::option::Option::None,
            points_total: ::std::option::Option::None,
            last_hit: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_PlayerDraftSuggestPick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_PlayerDraftSuggestPick {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_PlayerDraftSuggestPick.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_PlayerDraftSuggestPick.suggestion_player_id)
    pub suggestion_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_PlayerDraftSuggestPick.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_PlayerDraftSuggestPick {
    fn default() -> &'a CDOTAUserMsg_PlayerDraftSuggestPick {
        <CDOTAUserMsg_PlayerDraftSuggestPick as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_PlayerDraftSuggestPick {
    pub fn new() -> CDOTAUserMsg_PlayerDraftSuggestPick {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 suggestion_player_id = 2;

    pub fn suggestion_player_id(&self) -> i32 {
        self.suggestion_player_id.unwrap_or(-1i32)
    }

    pub fn clear_suggestion_player_id(&mut self) {
        self.suggestion_player_id = ::std::option::Option::None;
    }

    pub fn has_suggestion_player_id(&self) -> bool {
        self.suggestion_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suggestion_player_id(&mut self, v: i32) {
        self.suggestion_player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_PlayerDraftSuggestPick {
    const NAME: &'static str = "CDOTAUserMsg_PlayerDraftSuggestPick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.suggestion_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.suggestion_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.suggestion_player_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_PlayerDraftSuggestPick {
        CDOTAUserMsg_PlayerDraftSuggestPick::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.suggestion_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_PlayerDraftSuggestPick {
        static instance: CDOTAUserMsg_PlayerDraftSuggestPick = CDOTAUserMsg_PlayerDraftSuggestPick {
            player_id: ::std::option::Option::None,
            suggestion_player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_PlayerDraftPick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_PlayerDraftPick {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_PlayerDraftPick.player_id_captain)
    pub player_id_captain: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_PlayerDraftPick.player_id_target)
    pub player_id_target: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_PlayerDraftPick.team)
    pub team: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_PlayerDraftPick.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_PlayerDraftPick {
    fn default() -> &'a CDOTAUserMsg_PlayerDraftPick {
        <CDOTAUserMsg_PlayerDraftPick as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_PlayerDraftPick {
    pub fn new() -> CDOTAUserMsg_PlayerDraftPick {
        ::std::default::Default::default()
    }

    // optional int32 player_id_captain = 1;

    pub fn player_id_captain(&self) -> i32 {
        self.player_id_captain.unwrap_or(-1i32)
    }

    pub fn clear_player_id_captain(&mut self) {
        self.player_id_captain = ::std::option::Option::None;
    }

    pub fn has_player_id_captain(&self) -> bool {
        self.player_id_captain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_captain(&mut self, v: i32) {
        self.player_id_captain = ::std::option::Option::Some(v);
    }

    // optional int32 player_id_target = 2;

    pub fn player_id_target(&self) -> i32 {
        self.player_id_target.unwrap_or(-1i32)
    }

    pub fn clear_player_id_target(&mut self) {
        self.player_id_target = ::std::option::Option::None;
    }

    pub fn has_player_id_target(&self) -> bool {
        self.player_id_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id_target(&mut self, v: i32) {
        self.player_id_target = ::std::option::Option::Some(v);
    }

    // optional int32 team = 3;

    pub fn team(&self) -> i32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: i32) {
        self.team = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_PlayerDraftPick {
    const NAME: &'static str = "CDOTAUserMsg_PlayerDraftPick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id_captain = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_id_target = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.team = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id_captain {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_id_target {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.team {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id_captain {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_id_target {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.team {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_PlayerDraftPick {
        CDOTAUserMsg_PlayerDraftPick::new()
    }

    fn clear(&mut self) {
        self.player_id_captain = ::std::option::Option::None;
        self.player_id_target = ::std::option::Option::None;
        self.team = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_PlayerDraftPick {
        static instance: CDOTAUserMsg_PlayerDraftPick = CDOTAUserMsg_PlayerDraftPick {
            player_id_captain: ::std::option::Option::None,
            player_id_target: ::std::option::Option::None,
            team: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_FacetPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_FacetPing {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_FacetPing.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_FacetPing.facet_strhash)
    pub facet_strhash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_FacetPing.entity_id)
    pub entity_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_FacetPing.all_chat)
    pub all_chat: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_FacetPing.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_FacetPing {
    fn default() -> &'a CDOTAUserMsg_FacetPing {
        <CDOTAUserMsg_FacetPing as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_FacetPing {
    pub fn new() -> CDOTAUserMsg_FacetPing {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 facet_strhash = 2;

    pub fn facet_strhash(&self) -> u32 {
        self.facet_strhash.unwrap_or(0)
    }

    pub fn clear_facet_strhash(&mut self) {
        self.facet_strhash = ::std::option::Option::None;
    }

    pub fn has_facet_strhash(&self) -> bool {
        self.facet_strhash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_facet_strhash(&mut self, v: u32) {
        self.facet_strhash = ::std::option::Option::Some(v);
    }

    // optional uint32 entity_id = 3;

    pub fn entity_id(&self) -> u32 {
        self.entity_id.unwrap_or(0)
    }

    pub fn clear_entity_id(&mut self) {
        self.entity_id = ::std::option::Option::None;
    }

    pub fn has_entity_id(&self) -> bool {
        self.entity_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_id(&mut self, v: u32) {
        self.entity_id = ::std::option::Option::Some(v);
    }

    // optional bool all_chat = 4;

    pub fn all_chat(&self) -> bool {
        self.all_chat.unwrap_or(false)
    }

    pub fn clear_all_chat(&mut self) {
        self.all_chat = ::std::option::Option::None;
    }

    pub fn has_all_chat(&self) -> bool {
        self.all_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_all_chat(&mut self, v: bool) {
        self.all_chat = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_FacetPing {
    const NAME: &'static str = "CDOTAUserMsg_FacetPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.facet_strhash = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.entity_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.all_chat = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.facet_strhash {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.entity_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.all_chat {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.facet_strhash {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.entity_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.all_chat {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_FacetPing {
        CDOTAUserMsg_FacetPing::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.facet_strhash = ::std::option::Option::None;
        self.entity_id = ::std::option::Option::None;
        self.all_chat = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_FacetPing {
        static instance: CDOTAUserMsg_FacetPing = CDOTAUserMsg_FacetPing {
            player_id: ::std::option::Option::None,
            facet_strhash: ::std::option::Option::None,
            entity_id: ::std::option::Option::None,
            all_chat: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAUserMsg_InnatePing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAUserMsg_InnatePing {
    // message fields
    // @@protoc_insertion_point(field:CDOTAUserMsg_InnatePing.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_InnatePing.entity_id)
    pub entity_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAUserMsg_InnatePing.all_chat)
    pub all_chat: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAUserMsg_InnatePing.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAUserMsg_InnatePing {
    fn default() -> &'a CDOTAUserMsg_InnatePing {
        <CDOTAUserMsg_InnatePing as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAUserMsg_InnatePing {
    pub fn new() -> CDOTAUserMsg_InnatePing {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 entity_id = 2;

    pub fn entity_id(&self) -> u32 {
        self.entity_id.unwrap_or(0)
    }

    pub fn clear_entity_id(&mut self) {
        self.entity_id = ::std::option::Option::None;
    }

    pub fn has_entity_id(&self) -> bool {
        self.entity_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_id(&mut self, v: u32) {
        self.entity_id = ::std::option::Option::Some(v);
    }

    // optional bool all_chat = 3;

    pub fn all_chat(&self) -> bool {
        self.all_chat.unwrap_or(false)
    }

    pub fn clear_all_chat(&mut self) {
        self.all_chat = ::std::option::Option::None;
    }

    pub fn has_all_chat(&self) -> bool {
        self.all_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_all_chat(&mut self, v: bool) {
        self.all_chat = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAUserMsg_InnatePing {
    const NAME: &'static str = "CDOTAUserMsg_InnatePing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.entity_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.all_chat = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.entity_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.all_chat {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.entity_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.all_chat {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAUserMsg_InnatePing {
        CDOTAUserMsg_InnatePing::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.entity_id = ::std::option::Option::None;
        self.all_chat = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAUserMsg_InnatePing {
        static instance: CDOTAUserMsg_InnatePing = CDOTAUserMsg_InnatePing {
            player_id: ::std::option::Option::None,
            entity_id: ::std::option::Option::None,
            all_chat: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EDotaUserMessages)
pub enum EDotaUserMessages {
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_AddUnitToSelection)
    DOTA_UM_AddUnitToSelection = 464,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_AIDebugLine)
    DOTA_UM_AIDebugLine = 465,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_ChatEvent)
    DOTA_UM_ChatEvent = 466,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_CombatHeroPositions)
    DOTA_UM_CombatHeroPositions = 467,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_CombatLogData)
    DOTA_UM_CombatLogData = 468,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_CombatLogBulkData)
    DOTA_UM_CombatLogBulkData = 470,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_CreateLinearProjectile)
    DOTA_UM_CreateLinearProjectile = 471,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_DestroyLinearProjectile)
    DOTA_UM_DestroyLinearProjectile = 472,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_DodgeTrackingProjectiles)
    DOTA_UM_DodgeTrackingProjectiles = 473,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_GlobalLightColor)
    DOTA_UM_GlobalLightColor = 474,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_GlobalLightDirection)
    DOTA_UM_GlobalLightDirection = 475,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_InvalidCommand)
    DOTA_UM_InvalidCommand = 476,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_LocationPing)
    DOTA_UM_LocationPing = 477,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_MapLine)
    DOTA_UM_MapLine = 478,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_MiniKillCamInfo)
    DOTA_UM_MiniKillCamInfo = 479,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_MinimapDebugPoint)
    DOTA_UM_MinimapDebugPoint = 480,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_MinimapEvent)
    DOTA_UM_MinimapEvent = 481,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_NevermoreRequiem)
    DOTA_UM_NevermoreRequiem = 482,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_OverheadEvent)
    DOTA_UM_OverheadEvent = 483,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_SetNextAutobuyItem)
    DOTA_UM_SetNextAutobuyItem = 484,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_SharedCooldown)
    DOTA_UM_SharedCooldown = 485,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_SpectatorPlayerClick)
    DOTA_UM_SpectatorPlayerClick = 486,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_TutorialTipInfo)
    DOTA_UM_TutorialTipInfo = 487,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_UnitEvent)
    DOTA_UM_UnitEvent = 488,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_ParticleManager)
    DOTA_UM_ParticleManager = 489,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_BotChat)
    DOTA_UM_BotChat = 490,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_HudError)
    DOTA_UM_HudError = 491,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_ItemPurchased)
    DOTA_UM_ItemPurchased = 492,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_Ping)
    DOTA_UM_Ping = 493,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_ItemFound)
    DOTA_UM_ItemFound = 494,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_CharacterSpeakConcept)
    DOTA_UM_CharacterSpeakConcept = 495,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_SwapVerify)
    DOTA_UM_SwapVerify = 496,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_WorldLine)
    DOTA_UM_WorldLine = 497,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_TournamentDrop)
    DOTA_UM_TournamentDrop = 498,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_ItemAlert)
    DOTA_UM_ItemAlert = 499,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_HalloweenDrops)
    DOTA_UM_HalloweenDrops = 500,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_ChatWheel)
    DOTA_UM_ChatWheel = 501,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_ReceivedXmasGift)
    DOTA_UM_ReceivedXmasGift = 502,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_UpdateSharedContent)
    DOTA_UM_UpdateSharedContent = 503,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_TutorialRequestExp)
    DOTA_UM_TutorialRequestExp = 504,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_TutorialPingMinimap)
    DOTA_UM_TutorialPingMinimap = 505,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_GamerulesStateChanged)
    DOTA_UM_GamerulesStateChanged = 506,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_ShowSurvey)
    DOTA_UM_ShowSurvey = 507,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_TutorialFade)
    DOTA_UM_TutorialFade = 508,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_AddQuestLogEntry)
    DOTA_UM_AddQuestLogEntry = 509,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_SendStatPopup)
    DOTA_UM_SendStatPopup = 510,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_TutorialFinish)
    DOTA_UM_TutorialFinish = 511,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_SendRoshanPopup)
    DOTA_UM_SendRoshanPopup = 512,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_SendGenericToolTip)
    DOTA_UM_SendGenericToolTip = 513,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_SendFinalGold)
    DOTA_UM_SendFinalGold = 514,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_CustomMsg)
    DOTA_UM_CustomMsg = 515,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_CoachHUDPing)
    DOTA_UM_CoachHUDPing = 516,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_ClientLoadGridNav)
    DOTA_UM_ClientLoadGridNav = 517,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_TE_Projectile)
    DOTA_UM_TE_Projectile = 518,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_TE_ProjectileLoc)
    DOTA_UM_TE_ProjectileLoc = 519,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_TE_DotaBloodImpact)
    DOTA_UM_TE_DotaBloodImpact = 520,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_TE_UnitAnimation)
    DOTA_UM_TE_UnitAnimation = 521,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_TE_UnitAnimationEnd)
    DOTA_UM_TE_UnitAnimationEnd = 522,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_AbilityPing)
    DOTA_UM_AbilityPing = 523,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_ShowGenericPopup)
    DOTA_UM_ShowGenericPopup = 524,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_VoteStart)
    DOTA_UM_VoteStart = 525,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_VoteUpdate)
    DOTA_UM_VoteUpdate = 526,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_VoteEnd)
    DOTA_UM_VoteEnd = 527,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_BoosterState)
    DOTA_UM_BoosterState = 528,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_WillPurchaseAlert)
    DOTA_UM_WillPurchaseAlert = 529,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_TutorialMinimapPosition)
    DOTA_UM_TutorialMinimapPosition = 530,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_PlayerMMR)
    DOTA_UM_PlayerMMR = 531,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_AbilitySteal)
    DOTA_UM_AbilitySteal = 532,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_CourierKilledAlert)
    DOTA_UM_CourierKilledAlert = 533,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_EnemyItemAlert)
    DOTA_UM_EnemyItemAlert = 534,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_StatsMatchDetails)
    DOTA_UM_StatsMatchDetails = 535,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_MiniTaunt)
    DOTA_UM_MiniTaunt = 536,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_BuyBackStateAlert)
    DOTA_UM_BuyBackStateAlert = 537,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_SpeechBubble)
    DOTA_UM_SpeechBubble = 538,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_CustomHeaderMessage)
    DOTA_UM_CustomHeaderMessage = 539,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_QuickBuyAlert)
    DOTA_UM_QuickBuyAlert = 540,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_StatsHeroDetails)
    DOTA_UM_StatsHeroDetails = 541,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_PredictionResult)
    DOTA_UM_PredictionResult = 542,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_ModifierAlert)
    DOTA_UM_ModifierAlert = 543,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_HPManaAlert)
    DOTA_UM_HPManaAlert = 544,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_GlyphAlert)
    DOTA_UM_GlyphAlert = 545,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_BeastChat)
    DOTA_UM_BeastChat = 546,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_SpectatorPlayerUnitOrders)
    DOTA_UM_SpectatorPlayerUnitOrders = 547,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_CustomHudElement_Create)
    DOTA_UM_CustomHudElement_Create = 548,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_CustomHudElement_Modify)
    DOTA_UM_CustomHudElement_Modify = 549,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_CustomHudElement_Destroy)
    DOTA_UM_CustomHudElement_Destroy = 550,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_CompendiumState)
    DOTA_UM_CompendiumState = 551,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_ProjectionAbility)
    DOTA_UM_ProjectionAbility = 552,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_ProjectionEvent)
    DOTA_UM_ProjectionEvent = 553,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_CombatLogDataHLTV)
    DOTA_UM_CombatLogDataHLTV = 554,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_XPAlert)
    DOTA_UM_XPAlert = 555,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_UpdateQuestProgress)
    DOTA_UM_UpdateQuestProgress = 556,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_MatchMetadata)
    DOTA_UM_MatchMetadata = 557,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_MatchDetails)
    DOTA_UM_MatchDetails = 558,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_QuestStatus)
    DOTA_UM_QuestStatus = 559,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_SuggestHeroPick)
    DOTA_UM_SuggestHeroPick = 560,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_SuggestHeroRole)
    DOTA_UM_SuggestHeroRole = 561,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_KillcamDamageTaken)
    DOTA_UM_KillcamDamageTaken = 562,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_SelectPenaltyGold)
    DOTA_UM_SelectPenaltyGold = 563,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_RollDiceResult)
    DOTA_UM_RollDiceResult = 564,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_FlipCoinResult)
    DOTA_UM_FlipCoinResult = 565,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_RequestItemSuggestions)
    DOTA_UM_RequestItemSuggestions = 566,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_TeamCaptainChanged)
    DOTA_UM_TeamCaptainChanged = 567,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_SendRoshanSpectatorPhase)
    DOTA_UM_SendRoshanSpectatorPhase = 568,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_ChatWheelCooldown)
    DOTA_UM_ChatWheelCooldown = 569,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_DismissAllStatPopups)
    DOTA_UM_DismissAllStatPopups = 570,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_TE_DestroyProjectile)
    DOTA_UM_TE_DestroyProjectile = 571,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_HeroRelicProgress)
    DOTA_UM_HeroRelicProgress = 572,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_AbilityDraftRequestAbility)
    DOTA_UM_AbilityDraftRequestAbility = 573,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_ItemSold)
    DOTA_UM_ItemSold = 574,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_DamageReport)
    DOTA_UM_DamageReport = 575,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_SalutePlayer)
    DOTA_UM_SalutePlayer = 576,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_TipAlert)
    DOTA_UM_TipAlert = 577,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_ReplaceQueryUnit)
    DOTA_UM_ReplaceQueryUnit = 578,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_EmptyTeleportAlert)
    DOTA_UM_EmptyTeleportAlert = 579,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_MarsArenaOfBloodAttack)
    DOTA_UM_MarsArenaOfBloodAttack = 580,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_ESArcanaCombo)
    DOTA_UM_ESArcanaCombo = 581,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_ESArcanaComboSummary)
    DOTA_UM_ESArcanaComboSummary = 582,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_HighFiveLeftHanging)
    DOTA_UM_HighFiveLeftHanging = 583,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_HighFiveCompleted)
    DOTA_UM_HighFiveCompleted = 584,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_ShovelUnearth)
    DOTA_UM_ShovelUnearth = 585,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_EM_InvokerSpellCast)
    DOTA_EM_InvokerSpellCast = 586,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_RadarAlert)
    DOTA_UM_RadarAlert = 587,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_AllStarEvent)
    DOTA_UM_AllStarEvent = 588,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_TalentTreeAlert)
    DOTA_UM_TalentTreeAlert = 589,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_QueuedOrderRemoved)
    DOTA_UM_QueuedOrderRemoved = 590,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_DebugChallenge)
    DOTA_UM_DebugChallenge = 591,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_OMArcanaCombo)
    DOTA_UM_OMArcanaCombo = 592,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_FoundNeutralItem)
    DOTA_UM_FoundNeutralItem = 593,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_OutpostCaptured)
    DOTA_UM_OutpostCaptured = 594,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_OutpostGrantedXP)
    DOTA_UM_OutpostGrantedXP = 595,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_MoveCameraToUnit)
    DOTA_UM_MoveCameraToUnit = 596,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_PauseMinigameData)
    DOTA_UM_PauseMinigameData = 597,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_VersusScene_PlayerBehavior)
    DOTA_UM_VersusScene_PlayerBehavior = 598,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_QoP_ArcanaSummary)
    DOTA_UM_QoP_ArcanaSummary = 600,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_HotPotato_Created)
    DOTA_UM_HotPotato_Created = 601,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_HotPotato_Exploded)
    DOTA_UM_HotPotato_Exploded = 602,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_WK_Arcana_Progress)
    DOTA_UM_WK_Arcana_Progress = 603,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_GuildChallenge_Progress)
    DOTA_UM_GuildChallenge_Progress = 604,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_WRArcanaProgress)
    DOTA_UM_WRArcanaProgress = 605,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_WRArcanaSummary)
    DOTA_UM_WRArcanaSummary = 606,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_EmptyItemSlotAlert)
    DOTA_UM_EmptyItemSlotAlert = 607,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_AghsStatusAlert)
    DOTA_UM_AghsStatusAlert = 608,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_PingConfirmation)
    DOTA_UM_PingConfirmation = 609,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_MutedPlayers)
    DOTA_UM_MutedPlayers = 610,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_ContextualTip)
    DOTA_UM_ContextualTip = 611,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_ChatMessage)
    DOTA_UM_ChatMessage = 612,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_NeutralCampAlert)
    DOTA_UM_NeutralCampAlert = 613,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_RockPaperScissorsStarted)
    DOTA_UM_RockPaperScissorsStarted = 614,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_RockPaperScissorsFinished)
    DOTA_UM_RockPaperScissorsFinished = 615,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_DuelOpponentKilled)
    DOTA_UM_DuelOpponentKilled = 616,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_DuelAccepted)
    DOTA_UM_DuelAccepted = 617,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_DuelRequested)
    DOTA_UM_DuelRequested = 618,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_MuertaReleaseEvent_AssignedTargetKilled)
    DOTA_UM_MuertaReleaseEvent_AssignedTargetKilled = 619,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_PlayerDraftSuggestPick)
    DOTA_UM_PlayerDraftSuggestPick = 620,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_PlayerDraftPick)
    DOTA_UM_PlayerDraftPick = 621,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_UpdateLinearProjectileCPData)
    DOTA_UM_UpdateLinearProjectileCPData = 622,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_GiftPlayer)
    DOTA_UM_GiftPlayer = 623,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_FacetPing)
    DOTA_UM_FacetPing = 624,
    // @@protoc_insertion_point(enum_value:EDotaUserMessages.DOTA_UM_InnatePing)
    DOTA_UM_InnatePing = 625,
}

impl ::steam_vent_proto_common::protobuf::Enum for EDotaUserMessages {
    const NAME: &'static str = "EDotaUserMessages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDotaUserMessages> {
        match value {
            464 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AddUnitToSelection),
            465 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AIDebugLine),
            466 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ChatEvent),
            467 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CombatHeroPositions),
            468 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CombatLogData),
            470 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CombatLogBulkData),
            471 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CreateLinearProjectile),
            472 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DestroyLinearProjectile),
            473 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DodgeTrackingProjectiles),
            474 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GlobalLightColor),
            475 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GlobalLightDirection),
            476 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_InvalidCommand),
            477 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_LocationPing),
            478 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MapLine),
            479 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MiniKillCamInfo),
            480 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MinimapDebugPoint),
            481 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MinimapEvent),
            482 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_NevermoreRequiem),
            483 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_OverheadEvent),
            484 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SetNextAutobuyItem),
            485 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SharedCooldown),
            486 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SpectatorPlayerClick),
            487 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialTipInfo),
            488 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_UnitEvent),
            489 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ParticleManager),
            490 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_BotChat),
            491 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HudError),
            492 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ItemPurchased),
            493 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_Ping),
            494 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ItemFound),
            495 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CharacterSpeakConcept),
            496 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SwapVerify),
            497 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WorldLine),
            498 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TournamentDrop),
            499 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ItemAlert),
            500 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HalloweenDrops),
            501 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ChatWheel),
            502 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ReceivedXmasGift),
            503 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_UpdateSharedContent),
            504 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialRequestExp),
            505 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialPingMinimap),
            506 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GamerulesStateChanged),
            507 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ShowSurvey),
            508 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialFade),
            509 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AddQuestLogEntry),
            510 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendStatPopup),
            511 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialFinish),
            512 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendRoshanPopup),
            513 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendGenericToolTip),
            514 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendFinalGold),
            515 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomMsg),
            516 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CoachHUDPing),
            517 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ClientLoadGridNav),
            518 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_Projectile),
            519 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_ProjectileLoc),
            520 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_DotaBloodImpact),
            521 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_UnitAnimation),
            522 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_UnitAnimationEnd),
            523 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AbilityPing),
            524 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ShowGenericPopup),
            525 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_VoteStart),
            526 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_VoteUpdate),
            527 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_VoteEnd),
            528 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_BoosterState),
            529 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WillPurchaseAlert),
            530 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialMinimapPosition),
            531 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PlayerMMR),
            532 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AbilitySteal),
            533 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CourierKilledAlert),
            534 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_EnemyItemAlert),
            535 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_StatsMatchDetails),
            536 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MiniTaunt),
            537 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_BuyBackStateAlert),
            538 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SpeechBubble),
            539 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomHeaderMessage),
            540 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_QuickBuyAlert),
            541 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_StatsHeroDetails),
            542 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PredictionResult),
            543 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ModifierAlert),
            544 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HPManaAlert),
            545 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GlyphAlert),
            546 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_BeastChat),
            547 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SpectatorPlayerUnitOrders),
            548 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomHudElement_Create),
            549 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomHudElement_Modify),
            550 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomHudElement_Destroy),
            551 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CompendiumState),
            552 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ProjectionAbility),
            553 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ProjectionEvent),
            554 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CombatLogDataHLTV),
            555 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_XPAlert),
            556 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_UpdateQuestProgress),
            557 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MatchMetadata),
            558 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MatchDetails),
            559 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_QuestStatus),
            560 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SuggestHeroPick),
            561 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SuggestHeroRole),
            562 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_KillcamDamageTaken),
            563 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SelectPenaltyGold),
            564 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RollDiceResult),
            565 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_FlipCoinResult),
            566 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RequestItemSuggestions),
            567 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TeamCaptainChanged),
            568 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendRoshanSpectatorPhase),
            569 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ChatWheelCooldown),
            570 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DismissAllStatPopups),
            571 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_DestroyProjectile),
            572 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HeroRelicProgress),
            573 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AbilityDraftRequestAbility),
            574 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ItemSold),
            575 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DamageReport),
            576 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SalutePlayer),
            577 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TipAlert),
            578 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ReplaceQueryUnit),
            579 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_EmptyTeleportAlert),
            580 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MarsArenaOfBloodAttack),
            581 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ESArcanaCombo),
            582 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ESArcanaComboSummary),
            583 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HighFiveLeftHanging),
            584 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HighFiveCompleted),
            585 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ShovelUnearth),
            586 => ::std::option::Option::Some(EDotaUserMessages::DOTA_EM_InvokerSpellCast),
            587 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RadarAlert),
            588 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AllStarEvent),
            589 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TalentTreeAlert),
            590 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_QueuedOrderRemoved),
            591 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DebugChallenge),
            592 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_OMArcanaCombo),
            593 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_FoundNeutralItem),
            594 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_OutpostCaptured),
            595 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_OutpostGrantedXP),
            596 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MoveCameraToUnit),
            597 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PauseMinigameData),
            598 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_VersusScene_PlayerBehavior),
            600 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_QoP_ArcanaSummary),
            601 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HotPotato_Created),
            602 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HotPotato_Exploded),
            603 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WK_Arcana_Progress),
            604 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GuildChallenge_Progress),
            605 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WRArcanaProgress),
            606 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WRArcanaSummary),
            607 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_EmptyItemSlotAlert),
            608 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AghsStatusAlert),
            609 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PingConfirmation),
            610 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MutedPlayers),
            611 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ContextualTip),
            612 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ChatMessage),
            613 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_NeutralCampAlert),
            614 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RockPaperScissorsStarted),
            615 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RockPaperScissorsFinished),
            616 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DuelOpponentKilled),
            617 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DuelAccepted),
            618 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DuelRequested),
            619 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MuertaReleaseEvent_AssignedTargetKilled),
            620 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PlayerDraftSuggestPick),
            621 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PlayerDraftPick),
            622 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_UpdateLinearProjectileCPData),
            623 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GiftPlayer),
            624 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_FacetPing),
            625 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_InnatePing),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDotaUserMessages> {
        match str {
            "DOTA_UM_AddUnitToSelection" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AddUnitToSelection),
            "DOTA_UM_AIDebugLine" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AIDebugLine),
            "DOTA_UM_ChatEvent" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ChatEvent),
            "DOTA_UM_CombatHeroPositions" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CombatHeroPositions),
            "DOTA_UM_CombatLogData" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CombatLogData),
            "DOTA_UM_CombatLogBulkData" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CombatLogBulkData),
            "DOTA_UM_CreateLinearProjectile" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CreateLinearProjectile),
            "DOTA_UM_DestroyLinearProjectile" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DestroyLinearProjectile),
            "DOTA_UM_DodgeTrackingProjectiles" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DodgeTrackingProjectiles),
            "DOTA_UM_GlobalLightColor" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GlobalLightColor),
            "DOTA_UM_GlobalLightDirection" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GlobalLightDirection),
            "DOTA_UM_InvalidCommand" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_InvalidCommand),
            "DOTA_UM_LocationPing" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_LocationPing),
            "DOTA_UM_MapLine" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MapLine),
            "DOTA_UM_MiniKillCamInfo" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MiniKillCamInfo),
            "DOTA_UM_MinimapDebugPoint" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MinimapDebugPoint),
            "DOTA_UM_MinimapEvent" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MinimapEvent),
            "DOTA_UM_NevermoreRequiem" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_NevermoreRequiem),
            "DOTA_UM_OverheadEvent" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_OverheadEvent),
            "DOTA_UM_SetNextAutobuyItem" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SetNextAutobuyItem),
            "DOTA_UM_SharedCooldown" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SharedCooldown),
            "DOTA_UM_SpectatorPlayerClick" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SpectatorPlayerClick),
            "DOTA_UM_TutorialTipInfo" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialTipInfo),
            "DOTA_UM_UnitEvent" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_UnitEvent),
            "DOTA_UM_ParticleManager" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ParticleManager),
            "DOTA_UM_BotChat" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_BotChat),
            "DOTA_UM_HudError" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HudError),
            "DOTA_UM_ItemPurchased" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ItemPurchased),
            "DOTA_UM_Ping" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_Ping),
            "DOTA_UM_ItemFound" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ItemFound),
            "DOTA_UM_CharacterSpeakConcept" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CharacterSpeakConcept),
            "DOTA_UM_SwapVerify" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SwapVerify),
            "DOTA_UM_WorldLine" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WorldLine),
            "DOTA_UM_TournamentDrop" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TournamentDrop),
            "DOTA_UM_ItemAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ItemAlert),
            "DOTA_UM_HalloweenDrops" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HalloweenDrops),
            "DOTA_UM_ChatWheel" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ChatWheel),
            "DOTA_UM_ReceivedXmasGift" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ReceivedXmasGift),
            "DOTA_UM_UpdateSharedContent" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_UpdateSharedContent),
            "DOTA_UM_TutorialRequestExp" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialRequestExp),
            "DOTA_UM_TutorialPingMinimap" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialPingMinimap),
            "DOTA_UM_GamerulesStateChanged" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GamerulesStateChanged),
            "DOTA_UM_ShowSurvey" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ShowSurvey),
            "DOTA_UM_TutorialFade" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialFade),
            "DOTA_UM_AddQuestLogEntry" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AddQuestLogEntry),
            "DOTA_UM_SendStatPopup" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendStatPopup),
            "DOTA_UM_TutorialFinish" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialFinish),
            "DOTA_UM_SendRoshanPopup" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendRoshanPopup),
            "DOTA_UM_SendGenericToolTip" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendGenericToolTip),
            "DOTA_UM_SendFinalGold" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendFinalGold),
            "DOTA_UM_CustomMsg" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomMsg),
            "DOTA_UM_CoachHUDPing" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CoachHUDPing),
            "DOTA_UM_ClientLoadGridNav" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ClientLoadGridNav),
            "DOTA_UM_TE_Projectile" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_Projectile),
            "DOTA_UM_TE_ProjectileLoc" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_ProjectileLoc),
            "DOTA_UM_TE_DotaBloodImpact" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_DotaBloodImpact),
            "DOTA_UM_TE_UnitAnimation" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_UnitAnimation),
            "DOTA_UM_TE_UnitAnimationEnd" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_UnitAnimationEnd),
            "DOTA_UM_AbilityPing" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AbilityPing),
            "DOTA_UM_ShowGenericPopup" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ShowGenericPopup),
            "DOTA_UM_VoteStart" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_VoteStart),
            "DOTA_UM_VoteUpdate" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_VoteUpdate),
            "DOTA_UM_VoteEnd" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_VoteEnd),
            "DOTA_UM_BoosterState" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_BoosterState),
            "DOTA_UM_WillPurchaseAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WillPurchaseAlert),
            "DOTA_UM_TutorialMinimapPosition" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialMinimapPosition),
            "DOTA_UM_PlayerMMR" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PlayerMMR),
            "DOTA_UM_AbilitySteal" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AbilitySteal),
            "DOTA_UM_CourierKilledAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CourierKilledAlert),
            "DOTA_UM_EnemyItemAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_EnemyItemAlert),
            "DOTA_UM_StatsMatchDetails" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_StatsMatchDetails),
            "DOTA_UM_MiniTaunt" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MiniTaunt),
            "DOTA_UM_BuyBackStateAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_BuyBackStateAlert),
            "DOTA_UM_SpeechBubble" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SpeechBubble),
            "DOTA_UM_CustomHeaderMessage" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomHeaderMessage),
            "DOTA_UM_QuickBuyAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_QuickBuyAlert),
            "DOTA_UM_StatsHeroDetails" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_StatsHeroDetails),
            "DOTA_UM_PredictionResult" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PredictionResult),
            "DOTA_UM_ModifierAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ModifierAlert),
            "DOTA_UM_HPManaAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HPManaAlert),
            "DOTA_UM_GlyphAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GlyphAlert),
            "DOTA_UM_BeastChat" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_BeastChat),
            "DOTA_UM_SpectatorPlayerUnitOrders" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SpectatorPlayerUnitOrders),
            "DOTA_UM_CustomHudElement_Create" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomHudElement_Create),
            "DOTA_UM_CustomHudElement_Modify" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomHudElement_Modify),
            "DOTA_UM_CustomHudElement_Destroy" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomHudElement_Destroy),
            "DOTA_UM_CompendiumState" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CompendiumState),
            "DOTA_UM_ProjectionAbility" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ProjectionAbility),
            "DOTA_UM_ProjectionEvent" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ProjectionEvent),
            "DOTA_UM_CombatLogDataHLTV" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CombatLogDataHLTV),
            "DOTA_UM_XPAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_XPAlert),
            "DOTA_UM_UpdateQuestProgress" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_UpdateQuestProgress),
            "DOTA_UM_MatchMetadata" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MatchMetadata),
            "DOTA_UM_MatchDetails" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MatchDetails),
            "DOTA_UM_QuestStatus" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_QuestStatus),
            "DOTA_UM_SuggestHeroPick" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SuggestHeroPick),
            "DOTA_UM_SuggestHeroRole" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SuggestHeroRole),
            "DOTA_UM_KillcamDamageTaken" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_KillcamDamageTaken),
            "DOTA_UM_SelectPenaltyGold" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SelectPenaltyGold),
            "DOTA_UM_RollDiceResult" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RollDiceResult),
            "DOTA_UM_FlipCoinResult" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_FlipCoinResult),
            "DOTA_UM_RequestItemSuggestions" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RequestItemSuggestions),
            "DOTA_UM_TeamCaptainChanged" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TeamCaptainChanged),
            "DOTA_UM_SendRoshanSpectatorPhase" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendRoshanSpectatorPhase),
            "DOTA_UM_ChatWheelCooldown" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ChatWheelCooldown),
            "DOTA_UM_DismissAllStatPopups" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DismissAllStatPopups),
            "DOTA_UM_TE_DestroyProjectile" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_DestroyProjectile),
            "DOTA_UM_HeroRelicProgress" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HeroRelicProgress),
            "DOTA_UM_AbilityDraftRequestAbility" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AbilityDraftRequestAbility),
            "DOTA_UM_ItemSold" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ItemSold),
            "DOTA_UM_DamageReport" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DamageReport),
            "DOTA_UM_SalutePlayer" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SalutePlayer),
            "DOTA_UM_TipAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TipAlert),
            "DOTA_UM_ReplaceQueryUnit" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ReplaceQueryUnit),
            "DOTA_UM_EmptyTeleportAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_EmptyTeleportAlert),
            "DOTA_UM_MarsArenaOfBloodAttack" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MarsArenaOfBloodAttack),
            "DOTA_UM_ESArcanaCombo" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ESArcanaCombo),
            "DOTA_UM_ESArcanaComboSummary" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ESArcanaComboSummary),
            "DOTA_UM_HighFiveLeftHanging" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HighFiveLeftHanging),
            "DOTA_UM_HighFiveCompleted" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HighFiveCompleted),
            "DOTA_UM_ShovelUnearth" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ShovelUnearth),
            "DOTA_EM_InvokerSpellCast" => ::std::option::Option::Some(EDotaUserMessages::DOTA_EM_InvokerSpellCast),
            "DOTA_UM_RadarAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RadarAlert),
            "DOTA_UM_AllStarEvent" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AllStarEvent),
            "DOTA_UM_TalentTreeAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TalentTreeAlert),
            "DOTA_UM_QueuedOrderRemoved" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_QueuedOrderRemoved),
            "DOTA_UM_DebugChallenge" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DebugChallenge),
            "DOTA_UM_OMArcanaCombo" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_OMArcanaCombo),
            "DOTA_UM_FoundNeutralItem" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_FoundNeutralItem),
            "DOTA_UM_OutpostCaptured" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_OutpostCaptured),
            "DOTA_UM_OutpostGrantedXP" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_OutpostGrantedXP),
            "DOTA_UM_MoveCameraToUnit" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MoveCameraToUnit),
            "DOTA_UM_PauseMinigameData" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PauseMinigameData),
            "DOTA_UM_VersusScene_PlayerBehavior" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_VersusScene_PlayerBehavior),
            "DOTA_UM_QoP_ArcanaSummary" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_QoP_ArcanaSummary),
            "DOTA_UM_HotPotato_Created" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HotPotato_Created),
            "DOTA_UM_HotPotato_Exploded" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HotPotato_Exploded),
            "DOTA_UM_WK_Arcana_Progress" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WK_Arcana_Progress),
            "DOTA_UM_GuildChallenge_Progress" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GuildChallenge_Progress),
            "DOTA_UM_WRArcanaProgress" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WRArcanaProgress),
            "DOTA_UM_WRArcanaSummary" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WRArcanaSummary),
            "DOTA_UM_EmptyItemSlotAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_EmptyItemSlotAlert),
            "DOTA_UM_AghsStatusAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AghsStatusAlert),
            "DOTA_UM_PingConfirmation" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PingConfirmation),
            "DOTA_UM_MutedPlayers" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MutedPlayers),
            "DOTA_UM_ContextualTip" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ContextualTip),
            "DOTA_UM_ChatMessage" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ChatMessage),
            "DOTA_UM_NeutralCampAlert" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_NeutralCampAlert),
            "DOTA_UM_RockPaperScissorsStarted" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RockPaperScissorsStarted),
            "DOTA_UM_RockPaperScissorsFinished" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RockPaperScissorsFinished),
            "DOTA_UM_DuelOpponentKilled" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DuelOpponentKilled),
            "DOTA_UM_DuelAccepted" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DuelAccepted),
            "DOTA_UM_DuelRequested" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DuelRequested),
            "DOTA_UM_MuertaReleaseEvent_AssignedTargetKilled" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MuertaReleaseEvent_AssignedTargetKilled),
            "DOTA_UM_PlayerDraftSuggestPick" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PlayerDraftSuggestPick),
            "DOTA_UM_PlayerDraftPick" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PlayerDraftPick),
            "DOTA_UM_UpdateLinearProjectileCPData" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_UpdateLinearProjectileCPData),
            "DOTA_UM_GiftPlayer" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GiftPlayer),
            "DOTA_UM_FacetPing" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_FacetPing),
            "DOTA_UM_InnatePing" => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_InnatePing),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDotaUserMessages] = &[
        EDotaUserMessages::DOTA_UM_AddUnitToSelection,
        EDotaUserMessages::DOTA_UM_AIDebugLine,
        EDotaUserMessages::DOTA_UM_ChatEvent,
        EDotaUserMessages::DOTA_UM_CombatHeroPositions,
        EDotaUserMessages::DOTA_UM_CombatLogData,
        EDotaUserMessages::DOTA_UM_CombatLogBulkData,
        EDotaUserMessages::DOTA_UM_CreateLinearProjectile,
        EDotaUserMessages::DOTA_UM_DestroyLinearProjectile,
        EDotaUserMessages::DOTA_UM_DodgeTrackingProjectiles,
        EDotaUserMessages::DOTA_UM_GlobalLightColor,
        EDotaUserMessages::DOTA_UM_GlobalLightDirection,
        EDotaUserMessages::DOTA_UM_InvalidCommand,
        EDotaUserMessages::DOTA_UM_LocationPing,
        EDotaUserMessages::DOTA_UM_MapLine,
        EDotaUserMessages::DOTA_UM_MiniKillCamInfo,
        EDotaUserMessages::DOTA_UM_MinimapDebugPoint,
        EDotaUserMessages::DOTA_UM_MinimapEvent,
        EDotaUserMessages::DOTA_UM_NevermoreRequiem,
        EDotaUserMessages::DOTA_UM_OverheadEvent,
        EDotaUserMessages::DOTA_UM_SetNextAutobuyItem,
        EDotaUserMessages::DOTA_UM_SharedCooldown,
        EDotaUserMessages::DOTA_UM_SpectatorPlayerClick,
        EDotaUserMessages::DOTA_UM_TutorialTipInfo,
        EDotaUserMessages::DOTA_UM_UnitEvent,
        EDotaUserMessages::DOTA_UM_ParticleManager,
        EDotaUserMessages::DOTA_UM_BotChat,
        EDotaUserMessages::DOTA_UM_HudError,
        EDotaUserMessages::DOTA_UM_ItemPurchased,
        EDotaUserMessages::DOTA_UM_Ping,
        EDotaUserMessages::DOTA_UM_ItemFound,
        EDotaUserMessages::DOTA_UM_CharacterSpeakConcept,
        EDotaUserMessages::DOTA_UM_SwapVerify,
        EDotaUserMessages::DOTA_UM_WorldLine,
        EDotaUserMessages::DOTA_UM_TournamentDrop,
        EDotaUserMessages::DOTA_UM_ItemAlert,
        EDotaUserMessages::DOTA_UM_HalloweenDrops,
        EDotaUserMessages::DOTA_UM_ChatWheel,
        EDotaUserMessages::DOTA_UM_ReceivedXmasGift,
        EDotaUserMessages::DOTA_UM_UpdateSharedContent,
        EDotaUserMessages::DOTA_UM_TutorialRequestExp,
        EDotaUserMessages::DOTA_UM_TutorialPingMinimap,
        EDotaUserMessages::DOTA_UM_GamerulesStateChanged,
        EDotaUserMessages::DOTA_UM_ShowSurvey,
        EDotaUserMessages::DOTA_UM_TutorialFade,
        EDotaUserMessages::DOTA_UM_AddQuestLogEntry,
        EDotaUserMessages::DOTA_UM_SendStatPopup,
        EDotaUserMessages::DOTA_UM_TutorialFinish,
        EDotaUserMessages::DOTA_UM_SendRoshanPopup,
        EDotaUserMessages::DOTA_UM_SendGenericToolTip,
        EDotaUserMessages::DOTA_UM_SendFinalGold,
        EDotaUserMessages::DOTA_UM_CustomMsg,
        EDotaUserMessages::DOTA_UM_CoachHUDPing,
        EDotaUserMessages::DOTA_UM_ClientLoadGridNav,
        EDotaUserMessages::DOTA_UM_TE_Projectile,
        EDotaUserMessages::DOTA_UM_TE_ProjectileLoc,
        EDotaUserMessages::DOTA_UM_TE_DotaBloodImpact,
        EDotaUserMessages::DOTA_UM_TE_UnitAnimation,
        EDotaUserMessages::DOTA_UM_TE_UnitAnimationEnd,
        EDotaUserMessages::DOTA_UM_AbilityPing,
        EDotaUserMessages::DOTA_UM_ShowGenericPopup,
        EDotaUserMessages::DOTA_UM_VoteStart,
        EDotaUserMessages::DOTA_UM_VoteUpdate,
        EDotaUserMessages::DOTA_UM_VoteEnd,
        EDotaUserMessages::DOTA_UM_BoosterState,
        EDotaUserMessages::DOTA_UM_WillPurchaseAlert,
        EDotaUserMessages::DOTA_UM_TutorialMinimapPosition,
        EDotaUserMessages::DOTA_UM_PlayerMMR,
        EDotaUserMessages::DOTA_UM_AbilitySteal,
        EDotaUserMessages::DOTA_UM_CourierKilledAlert,
        EDotaUserMessages::DOTA_UM_EnemyItemAlert,
        EDotaUserMessages::DOTA_UM_StatsMatchDetails,
        EDotaUserMessages::DOTA_UM_MiniTaunt,
        EDotaUserMessages::DOTA_UM_BuyBackStateAlert,
        EDotaUserMessages::DOTA_UM_SpeechBubble,
        EDotaUserMessages::DOTA_UM_CustomHeaderMessage,
        EDotaUserMessages::DOTA_UM_QuickBuyAlert,
        EDotaUserMessages::DOTA_UM_StatsHeroDetails,
        EDotaUserMessages::DOTA_UM_PredictionResult,
        EDotaUserMessages::DOTA_UM_ModifierAlert,
        EDotaUserMessages::DOTA_UM_HPManaAlert,
        EDotaUserMessages::DOTA_UM_GlyphAlert,
        EDotaUserMessages::DOTA_UM_BeastChat,
        EDotaUserMessages::DOTA_UM_SpectatorPlayerUnitOrders,
        EDotaUserMessages::DOTA_UM_CustomHudElement_Create,
        EDotaUserMessages::DOTA_UM_CustomHudElement_Modify,
        EDotaUserMessages::DOTA_UM_CustomHudElement_Destroy,
        EDotaUserMessages::DOTA_UM_CompendiumState,
        EDotaUserMessages::DOTA_UM_ProjectionAbility,
        EDotaUserMessages::DOTA_UM_ProjectionEvent,
        EDotaUserMessages::DOTA_UM_CombatLogDataHLTV,
        EDotaUserMessages::DOTA_UM_XPAlert,
        EDotaUserMessages::DOTA_UM_UpdateQuestProgress,
        EDotaUserMessages::DOTA_UM_MatchMetadata,
        EDotaUserMessages::DOTA_UM_MatchDetails,
        EDotaUserMessages::DOTA_UM_QuestStatus,
        EDotaUserMessages::DOTA_UM_SuggestHeroPick,
        EDotaUserMessages::DOTA_UM_SuggestHeroRole,
        EDotaUserMessages::DOTA_UM_KillcamDamageTaken,
        EDotaUserMessages::DOTA_UM_SelectPenaltyGold,
        EDotaUserMessages::DOTA_UM_RollDiceResult,
        EDotaUserMessages::DOTA_UM_FlipCoinResult,
        EDotaUserMessages::DOTA_UM_RequestItemSuggestions,
        EDotaUserMessages::DOTA_UM_TeamCaptainChanged,
        EDotaUserMessages::DOTA_UM_SendRoshanSpectatorPhase,
        EDotaUserMessages::DOTA_UM_ChatWheelCooldown,
        EDotaUserMessages::DOTA_UM_DismissAllStatPopups,
        EDotaUserMessages::DOTA_UM_TE_DestroyProjectile,
        EDotaUserMessages::DOTA_UM_HeroRelicProgress,
        EDotaUserMessages::DOTA_UM_AbilityDraftRequestAbility,
        EDotaUserMessages::DOTA_UM_ItemSold,
        EDotaUserMessages::DOTA_UM_DamageReport,
        EDotaUserMessages::DOTA_UM_SalutePlayer,
        EDotaUserMessages::DOTA_UM_TipAlert,
        EDotaUserMessages::DOTA_UM_ReplaceQueryUnit,
        EDotaUserMessages::DOTA_UM_EmptyTeleportAlert,
        EDotaUserMessages::DOTA_UM_MarsArenaOfBloodAttack,
        EDotaUserMessages::DOTA_UM_ESArcanaCombo,
        EDotaUserMessages::DOTA_UM_ESArcanaComboSummary,
        EDotaUserMessages::DOTA_UM_HighFiveLeftHanging,
        EDotaUserMessages::DOTA_UM_HighFiveCompleted,
        EDotaUserMessages::DOTA_UM_ShovelUnearth,
        EDotaUserMessages::DOTA_EM_InvokerSpellCast,
        EDotaUserMessages::DOTA_UM_RadarAlert,
        EDotaUserMessages::DOTA_UM_AllStarEvent,
        EDotaUserMessages::DOTA_UM_TalentTreeAlert,
        EDotaUserMessages::DOTA_UM_QueuedOrderRemoved,
        EDotaUserMessages::DOTA_UM_DebugChallenge,
        EDotaUserMessages::DOTA_UM_OMArcanaCombo,
        EDotaUserMessages::DOTA_UM_FoundNeutralItem,
        EDotaUserMessages::DOTA_UM_OutpostCaptured,
        EDotaUserMessages::DOTA_UM_OutpostGrantedXP,
        EDotaUserMessages::DOTA_UM_MoveCameraToUnit,
        EDotaUserMessages::DOTA_UM_PauseMinigameData,
        EDotaUserMessages::DOTA_UM_VersusScene_PlayerBehavior,
        EDotaUserMessages::DOTA_UM_QoP_ArcanaSummary,
        EDotaUserMessages::DOTA_UM_HotPotato_Created,
        EDotaUserMessages::DOTA_UM_HotPotato_Exploded,
        EDotaUserMessages::DOTA_UM_WK_Arcana_Progress,
        EDotaUserMessages::DOTA_UM_GuildChallenge_Progress,
        EDotaUserMessages::DOTA_UM_WRArcanaProgress,
        EDotaUserMessages::DOTA_UM_WRArcanaSummary,
        EDotaUserMessages::DOTA_UM_EmptyItemSlotAlert,
        EDotaUserMessages::DOTA_UM_AghsStatusAlert,
        EDotaUserMessages::DOTA_UM_PingConfirmation,
        EDotaUserMessages::DOTA_UM_MutedPlayers,
        EDotaUserMessages::DOTA_UM_ContextualTip,
        EDotaUserMessages::DOTA_UM_ChatMessage,
        EDotaUserMessages::DOTA_UM_NeutralCampAlert,
        EDotaUserMessages::DOTA_UM_RockPaperScissorsStarted,
        EDotaUserMessages::DOTA_UM_RockPaperScissorsFinished,
        EDotaUserMessages::DOTA_UM_DuelOpponentKilled,
        EDotaUserMessages::DOTA_UM_DuelAccepted,
        EDotaUserMessages::DOTA_UM_DuelRequested,
        EDotaUserMessages::DOTA_UM_MuertaReleaseEvent_AssignedTargetKilled,
        EDotaUserMessages::DOTA_UM_PlayerDraftSuggestPick,
        EDotaUserMessages::DOTA_UM_PlayerDraftPick,
        EDotaUserMessages::DOTA_UM_UpdateLinearProjectileCPData,
        EDotaUserMessages::DOTA_UM_GiftPlayer,
        EDotaUserMessages::DOTA_UM_FacetPing,
        EDotaUserMessages::DOTA_UM_InnatePing,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EDotaUserMessages {
    fn default() -> Self {
        EDotaUserMessages::DOTA_UM_AddUnitToSelection
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTA_CHAT_MESSAGE)
pub enum DOTA_CHAT_MESSAGE {
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_INVALID)
    CHAT_MESSAGE_INVALID = -1,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HERO_KILL)
    CHAT_MESSAGE_HERO_KILL = 0,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HERO_DENY)
    CHAT_MESSAGE_HERO_DENY = 1,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_BARRACKS_KILL)
    CHAT_MESSAGE_BARRACKS_KILL = 2,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_TOWER_KILL)
    CHAT_MESSAGE_TOWER_KILL = 3,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_TOWER_DENY)
    CHAT_MESSAGE_TOWER_DENY = 4,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_FIRSTBLOOD)
    CHAT_MESSAGE_FIRSTBLOOD = 5,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_STREAK_KILL)
    CHAT_MESSAGE_STREAK_KILL = 6,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_BUYBACK)
    CHAT_MESSAGE_BUYBACK = 7,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_AEGIS)
    CHAT_MESSAGE_AEGIS = 8,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ROSHAN_KILL)
    CHAT_MESSAGE_ROSHAN_KILL = 9,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_COURIER_LOST)
    CHAT_MESSAGE_COURIER_LOST = 10,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_COURIER_RESPAWNED)
    CHAT_MESSAGE_COURIER_RESPAWNED = 11,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_GLYPH_USED)
    CHAT_MESSAGE_GLYPH_USED = 12,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ITEM_PURCHASE)
    CHAT_MESSAGE_ITEM_PURCHASE = 13,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_CONNECT)
    CHAT_MESSAGE_CONNECT = 14,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_DISCONNECT)
    CHAT_MESSAGE_DISCONNECT = 15,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT)
    CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT = 16,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_DISCONNECT_TIME_REMAINING)
    CHAT_MESSAGE_DISCONNECT_TIME_REMAINING = 17,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL)
    CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL = 18,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_RECONNECT)
    CHAT_MESSAGE_RECONNECT = 19,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_PLAYER_LEFT)
    CHAT_MESSAGE_PLAYER_LEFT = 20,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_SAFE_TO_LEAVE)
    CHAT_MESSAGE_SAFE_TO_LEAVE = 21,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_RUNE_PICKUP)
    CHAT_MESSAGE_RUNE_PICKUP = 22,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_RUNE_BOTTLE)
    CHAT_MESSAGE_RUNE_BOTTLE = 23,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_RUNE_DENY)
    CHAT_MESSAGE_RUNE_DENY = 114,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_INTHEBAG)
    CHAT_MESSAGE_INTHEBAG = 24,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_SECRETSHOP)
    CHAT_MESSAGE_SECRETSHOP = 25,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ITEM_AUTOPURCHASED)
    CHAT_MESSAGE_ITEM_AUTOPURCHASED = 26,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ITEMS_COMBINED)
    CHAT_MESSAGE_ITEMS_COMBINED = 27,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_SUPER_CREEPS)
    CHAT_MESSAGE_SUPER_CREEPS = 28,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_CANT_USE_ACTION_ITEM)
    CHAT_MESSAGE_CANT_USE_ACTION_ITEM = 29,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_CANTPAUSE)
    CHAT_MESSAGE_CANTPAUSE = 31,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_NOPAUSESLEFT)
    CHAT_MESSAGE_NOPAUSESLEFT = 32,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_CANTPAUSEYET)
    CHAT_MESSAGE_CANTPAUSEYET = 33,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_PAUSED)
    CHAT_MESSAGE_PAUSED = 34,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_UNPAUSE_COUNTDOWN)
    CHAT_MESSAGE_UNPAUSE_COUNTDOWN = 35,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_UNPAUSED)
    CHAT_MESSAGE_UNPAUSED = 36,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_AUTO_UNPAUSED)
    CHAT_MESSAGE_AUTO_UNPAUSED = 37,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_YOUPAUSED)
    CHAT_MESSAGE_YOUPAUSED = 38,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_CANTUNPAUSETEAM)
    CHAT_MESSAGE_CANTUNPAUSETEAM = 39,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_VOICE_TEXT_BANNED)
    CHAT_MESSAGE_VOICE_TEXT_BANNED = 41,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME)
    CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME = 42,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_REPORT_REMINDER)
    CHAT_MESSAGE_REPORT_REMINDER = 43,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ECON_ITEM)
    CHAT_MESSAGE_ECON_ITEM = 44,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_TAUNT)
    CHAT_MESSAGE_TAUNT = 45,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_RANDOM)
    CHAT_MESSAGE_RANDOM = 46,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_RD_TURN)
    CHAT_MESSAGE_RD_TURN = 47,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_DROP_RATE_BONUS)
    CHAT_MESSAGE_DROP_RATE_BONUS = 49,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_NO_BATTLE_POINTS)
    CHAT_MESSAGE_NO_BATTLE_POINTS = 50,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_DENIED_AEGIS)
    CHAT_MESSAGE_DENIED_AEGIS = 51,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_INFORMATIONAL)
    CHAT_MESSAGE_INFORMATIONAL = 52,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_AEGIS_STOLEN)
    CHAT_MESSAGE_AEGIS_STOLEN = 53,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ROSHAN_CANDY)
    CHAT_MESSAGE_ROSHAN_CANDY = 54,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ITEM_GIFTED)
    CHAT_MESSAGE_ITEM_GIFTED = 55,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL)
    CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL = 56,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED)
    CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED = 57,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED)
    CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED = 58,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HOLDOUT_WALL_FINISHED)
    CHAT_MESSAGE_HOLDOUT_WALL_FINISHED = 59,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO)
    CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO = 62,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION)
    CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION = 63,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_DISCONNECT_LIMITED_HERO)
    CHAT_MESSAGE_DISCONNECT_LIMITED_HERO = 64,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION)
    CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION = 65,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS)
    CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS = 66,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE)
    CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE = 67,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_PLAYER_LEFT_AFK)
    CHAT_MESSAGE_PLAYER_LEFT_AFK = 73,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG)
    CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG = 74,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_PLAYER_ABANDONED)
    CHAT_MESSAGE_PLAYER_ABANDONED = 75,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_PLAYER_ABANDONED_AFK)
    CHAT_MESSAGE_PLAYER_ABANDONED_AFK = 76,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG)
    CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG = 77,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_WILL_NOT_BE_SCORED)
    CHAT_MESSAGE_WILL_NOT_BE_SCORED = 78,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED)
    CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED = 79,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK)
    CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK = 80,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED)
    CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED = 81,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON)
    CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON = 82,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS)
    CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS = 83,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY)
    CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY = 84,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_COMPENDIUM_LEVEL)
    CHAT_MESSAGE_COMPENDIUM_LEVEL = 85,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_VICTORY_PREDICTION_STREAK)
    CHAT_MESSAGE_VICTORY_PREDICTION_STREAK = 86,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ASSASSIN_ANNOUNCE)
    CHAT_MESSAGE_ASSASSIN_ANNOUNCE = 87,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ASSASSIN_SUCCESS)
    CHAT_MESSAGE_ASSASSIN_SUCCESS = 88,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ASSASSIN_DENIED)
    CHAT_MESSAGE_ASSASSIN_DENIED = 89,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM)
    CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM = 90,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_EFFIGY_KILL)
    CHAT_MESSAGE_EFFIGY_KILL = 91,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW)
    CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW = 92,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_YEAR_BEAST_KILLED)
    CHAT_MESSAGE_YEAR_BEAST_KILLED = 93,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_PAUSE_COUNTDOWN)
    CHAT_MESSAGE_PAUSE_COUNTDOWN = 94,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_COINS_WAGERED)
    CHAT_MESSAGE_COINS_WAGERED = 95,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HERO_NOMINATED_BAN)
    CHAT_MESSAGE_HERO_NOMINATED_BAN = 96,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HERO_BANNED)
    CHAT_MESSAGE_HERO_BANNED = 97,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HERO_BAN_COUNT)
    CHAT_MESSAGE_HERO_BAN_COUNT = 98,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_RIVER_PAINTED)
    CHAT_MESSAGE_RIVER_PAINTED = 99,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_SCAN_USED)
    CHAT_MESSAGE_SCAN_USED = 100,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_SHRINE_KILLED)
    CHAT_MESSAGE_SHRINE_KILLED = 101,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_WAGER_TOKEN_SPENT)
    CHAT_MESSAGE_WAGER_TOKEN_SPENT = 102,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_RANK_WAGER)
    CHAT_MESSAGE_RANK_WAGER = 103,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_NEW_PLAYER_REMINDER)
    CHAT_MESSAGE_NEW_PLAYER_REMINDER = 104,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_OBSERVER_WARD_KILLED)
    CHAT_MESSAGE_OBSERVER_WARD_KILLED = 105,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_SENTRY_WARD_KILLED)
    CHAT_MESSAGE_SENTRY_WARD_KILLED = 106,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH)
    CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH = 107,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HERO_CHOICE_INVALID)
    CHAT_MESSAGE_HERO_CHOICE_INVALID = 108,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_BOUNTY)
    CHAT_MESSAGE_BOUNTY = 109,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ABILITY_DRAFT_START)
    CHAT_MESSAGE_ABILITY_DRAFT_START = 110,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HERO_FOUND_CANDY)
    CHAT_MESSAGE_HERO_FOUND_CANDY = 111,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_ABILITY_DRAFT_RANDOMED)
    CHAT_MESSAGE_ABILITY_DRAFT_RANDOMED = 112,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_PRIVATE_COACH_CONNECTED)
    CHAT_MESSAGE_PRIVATE_COACH_CONNECTED = 113,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_CANT_PAUSE_TOO_EARLY)
    CHAT_MESSAGE_CANT_PAUSE_TOO_EARLY = 115,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_HERO_KILL_WITH_PENGUIN)
    CHAT_MESSAGE_HERO_KILL_WITH_PENGUIN = 116,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_MINIBOSS_KILL)
    CHAT_MESSAGE_MINIBOSS_KILL = 117,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_PLAYER_IN_GAME_BAN_TEXT)
    CHAT_MESSAGE_PLAYER_IN_GAME_BAN_TEXT = 118,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_MESSAGE.CHAT_MESSAGE_BANNER_PLANTED)
    CHAT_MESSAGE_BANNER_PLANTED = 119,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTA_CHAT_MESSAGE {
    const NAME: &'static str = "DOTA_CHAT_MESSAGE";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_CHAT_MESSAGE> {
        match value {
            -1 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INVALID),
            0 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL),
            1 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_DENY),
            2 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BARRACKS_KILL),
            3 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TOWER_KILL),
            4 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TOWER_DENY),
            5 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_FIRSTBLOOD),
            6 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_STREAK_KILL),
            7 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BUYBACK),
            8 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AEGIS),
            9 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ROSHAN_KILL),
            10 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COURIER_LOST),
            11 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COURIER_RESPAWNED),
            12 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_GLYPH_USED),
            13 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_PURCHASE),
            14 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CONNECT),
            15 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT),
            16 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT),
            17 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_TIME_REMAINING),
            18 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL),
            19 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RECONNECT),
            20 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT),
            21 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SAFE_TO_LEAVE),
            22 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_PICKUP),
            23 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_BOTTLE),
            114 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_DENY),
            24 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INTHEBAG),
            25 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SECRETSHOP),
            26 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_AUTOPURCHASED),
            27 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEMS_COMBINED),
            28 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SUPER_CREEPS),
            29 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANT_USE_ACTION_ITEM),
            31 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTPAUSE),
            32 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NOPAUSESLEFT),
            33 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTPAUSEYET),
            34 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PAUSED),
            35 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_UNPAUSE_COUNTDOWN),
            36 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_UNPAUSED),
            37 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AUTO_UNPAUSED),
            38 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_YOUPAUSED),
            39 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTUNPAUSETEAM),
            41 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VOICE_TEXT_BANNED),
            42 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME),
            43 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_REPORT_REMINDER),
            44 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ECON_ITEM),
            45 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TAUNT),
            46 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANDOM),
            47 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RD_TURN),
            49 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DROP_RATE_BONUS),
            50 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NO_BATTLE_POINTS),
            51 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DENIED_AEGIS),
            52 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INFORMATIONAL),
            53 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AEGIS_STOLEN),
            54 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ROSHAN_CANDY),
            55 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_GIFTED),
            56 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL),
            57 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED),
            58 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED),
            59 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_WALL_FINISHED),
            62 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO),
            63 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION),
            64 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_LIMITED_HERO),
            65 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION),
            66 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS),
            67 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE),
            73 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_AFK),
            74 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG),
            75 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED),
            76 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED_AFK),
            77 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG),
            78 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED),
            79 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED),
            80 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK),
            81 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED),
            82 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON),
            83 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS),
            84 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY),
            85 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COMPENDIUM_LEVEL),
            86 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VICTORY_PREDICTION_STREAK),
            87 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_ANNOUNCE),
            88 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_SUCCESS),
            89 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_DENIED),
            90 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM),
            91 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_EFFIGY_KILL),
            92 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW),
            93 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_YEAR_BEAST_KILLED),
            94 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PAUSE_COUNTDOWN),
            95 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COINS_WAGERED),
            96 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_NOMINATED_BAN),
            97 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_BANNED),
            98 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_BAN_COUNT),
            99 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RIVER_PAINTED),
            100 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SCAN_USED),
            101 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SHRINE_KILLED),
            102 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WAGER_TOKEN_SPENT),
            103 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANK_WAGER),
            104 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NEW_PLAYER_REMINDER),
            105 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_OBSERVER_WARD_KILLED),
            106 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SENTRY_WARD_KILLED),
            107 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH),
            108 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_CHOICE_INVALID),
            109 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BOUNTY),
            110 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABILITY_DRAFT_START),
            111 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_FOUND_CANDY),
            112 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABILITY_DRAFT_RANDOMED),
            113 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PRIVATE_COACH_CONNECTED),
            115 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANT_PAUSE_TOO_EARLY),
            116 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL_WITH_PENGUIN),
            117 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_MINIBOSS_KILL),
            118 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_IN_GAME_BAN_TEXT),
            119 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BANNER_PLANTED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_CHAT_MESSAGE> {
        match str {
            "CHAT_MESSAGE_INVALID" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INVALID),
            "CHAT_MESSAGE_HERO_KILL" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL),
            "CHAT_MESSAGE_HERO_DENY" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_DENY),
            "CHAT_MESSAGE_BARRACKS_KILL" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BARRACKS_KILL),
            "CHAT_MESSAGE_TOWER_KILL" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TOWER_KILL),
            "CHAT_MESSAGE_TOWER_DENY" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TOWER_DENY),
            "CHAT_MESSAGE_FIRSTBLOOD" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_FIRSTBLOOD),
            "CHAT_MESSAGE_STREAK_KILL" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_STREAK_KILL),
            "CHAT_MESSAGE_BUYBACK" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BUYBACK),
            "CHAT_MESSAGE_AEGIS" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AEGIS),
            "CHAT_MESSAGE_ROSHAN_KILL" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ROSHAN_KILL),
            "CHAT_MESSAGE_COURIER_LOST" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COURIER_LOST),
            "CHAT_MESSAGE_COURIER_RESPAWNED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COURIER_RESPAWNED),
            "CHAT_MESSAGE_GLYPH_USED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_GLYPH_USED),
            "CHAT_MESSAGE_ITEM_PURCHASE" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_PURCHASE),
            "CHAT_MESSAGE_CONNECT" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CONNECT),
            "CHAT_MESSAGE_DISCONNECT" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT),
            "CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT),
            "CHAT_MESSAGE_DISCONNECT_TIME_REMAINING" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_TIME_REMAINING),
            "CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL),
            "CHAT_MESSAGE_RECONNECT" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RECONNECT),
            "CHAT_MESSAGE_PLAYER_LEFT" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT),
            "CHAT_MESSAGE_SAFE_TO_LEAVE" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SAFE_TO_LEAVE),
            "CHAT_MESSAGE_RUNE_PICKUP" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_PICKUP),
            "CHAT_MESSAGE_RUNE_BOTTLE" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_BOTTLE),
            "CHAT_MESSAGE_RUNE_DENY" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_DENY),
            "CHAT_MESSAGE_INTHEBAG" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INTHEBAG),
            "CHAT_MESSAGE_SECRETSHOP" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SECRETSHOP),
            "CHAT_MESSAGE_ITEM_AUTOPURCHASED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_AUTOPURCHASED),
            "CHAT_MESSAGE_ITEMS_COMBINED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEMS_COMBINED),
            "CHAT_MESSAGE_SUPER_CREEPS" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SUPER_CREEPS),
            "CHAT_MESSAGE_CANT_USE_ACTION_ITEM" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANT_USE_ACTION_ITEM),
            "CHAT_MESSAGE_CANTPAUSE" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTPAUSE),
            "CHAT_MESSAGE_NOPAUSESLEFT" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NOPAUSESLEFT),
            "CHAT_MESSAGE_CANTPAUSEYET" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTPAUSEYET),
            "CHAT_MESSAGE_PAUSED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PAUSED),
            "CHAT_MESSAGE_UNPAUSE_COUNTDOWN" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_UNPAUSE_COUNTDOWN),
            "CHAT_MESSAGE_UNPAUSED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_UNPAUSED),
            "CHAT_MESSAGE_AUTO_UNPAUSED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AUTO_UNPAUSED),
            "CHAT_MESSAGE_YOUPAUSED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_YOUPAUSED),
            "CHAT_MESSAGE_CANTUNPAUSETEAM" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTUNPAUSETEAM),
            "CHAT_MESSAGE_VOICE_TEXT_BANNED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VOICE_TEXT_BANNED),
            "CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME),
            "CHAT_MESSAGE_REPORT_REMINDER" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_REPORT_REMINDER),
            "CHAT_MESSAGE_ECON_ITEM" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ECON_ITEM),
            "CHAT_MESSAGE_TAUNT" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TAUNT),
            "CHAT_MESSAGE_RANDOM" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANDOM),
            "CHAT_MESSAGE_RD_TURN" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RD_TURN),
            "CHAT_MESSAGE_DROP_RATE_BONUS" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DROP_RATE_BONUS),
            "CHAT_MESSAGE_NO_BATTLE_POINTS" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NO_BATTLE_POINTS),
            "CHAT_MESSAGE_DENIED_AEGIS" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DENIED_AEGIS),
            "CHAT_MESSAGE_INFORMATIONAL" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INFORMATIONAL),
            "CHAT_MESSAGE_AEGIS_STOLEN" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AEGIS_STOLEN),
            "CHAT_MESSAGE_ROSHAN_CANDY" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ROSHAN_CANDY),
            "CHAT_MESSAGE_ITEM_GIFTED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_GIFTED),
            "CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL),
            "CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED),
            "CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED),
            "CHAT_MESSAGE_HOLDOUT_WALL_FINISHED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_WALL_FINISHED),
            "CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO),
            "CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION),
            "CHAT_MESSAGE_DISCONNECT_LIMITED_HERO" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_LIMITED_HERO),
            "CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION),
            "CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS),
            "CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE),
            "CHAT_MESSAGE_PLAYER_LEFT_AFK" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_AFK),
            "CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG),
            "CHAT_MESSAGE_PLAYER_ABANDONED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED),
            "CHAT_MESSAGE_PLAYER_ABANDONED_AFK" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED_AFK),
            "CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG),
            "CHAT_MESSAGE_WILL_NOT_BE_SCORED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED),
            "CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED),
            "CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK),
            "CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED),
            "CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON),
            "CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS),
            "CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY),
            "CHAT_MESSAGE_COMPENDIUM_LEVEL" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COMPENDIUM_LEVEL),
            "CHAT_MESSAGE_VICTORY_PREDICTION_STREAK" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VICTORY_PREDICTION_STREAK),
            "CHAT_MESSAGE_ASSASSIN_ANNOUNCE" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_ANNOUNCE),
            "CHAT_MESSAGE_ASSASSIN_SUCCESS" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_SUCCESS),
            "CHAT_MESSAGE_ASSASSIN_DENIED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_DENIED),
            "CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM),
            "CHAT_MESSAGE_EFFIGY_KILL" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_EFFIGY_KILL),
            "CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW),
            "CHAT_MESSAGE_YEAR_BEAST_KILLED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_YEAR_BEAST_KILLED),
            "CHAT_MESSAGE_PAUSE_COUNTDOWN" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PAUSE_COUNTDOWN),
            "CHAT_MESSAGE_COINS_WAGERED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COINS_WAGERED),
            "CHAT_MESSAGE_HERO_NOMINATED_BAN" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_NOMINATED_BAN),
            "CHAT_MESSAGE_HERO_BANNED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_BANNED),
            "CHAT_MESSAGE_HERO_BAN_COUNT" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_BAN_COUNT),
            "CHAT_MESSAGE_RIVER_PAINTED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RIVER_PAINTED),
            "CHAT_MESSAGE_SCAN_USED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SCAN_USED),
            "CHAT_MESSAGE_SHRINE_KILLED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SHRINE_KILLED),
            "CHAT_MESSAGE_WAGER_TOKEN_SPENT" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WAGER_TOKEN_SPENT),
            "CHAT_MESSAGE_RANK_WAGER" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANK_WAGER),
            "CHAT_MESSAGE_NEW_PLAYER_REMINDER" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NEW_PLAYER_REMINDER),
            "CHAT_MESSAGE_OBSERVER_WARD_KILLED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_OBSERVER_WARD_KILLED),
            "CHAT_MESSAGE_SENTRY_WARD_KILLED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SENTRY_WARD_KILLED),
            "CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH),
            "CHAT_MESSAGE_HERO_CHOICE_INVALID" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_CHOICE_INVALID),
            "CHAT_MESSAGE_BOUNTY" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BOUNTY),
            "CHAT_MESSAGE_ABILITY_DRAFT_START" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABILITY_DRAFT_START),
            "CHAT_MESSAGE_HERO_FOUND_CANDY" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_FOUND_CANDY),
            "CHAT_MESSAGE_ABILITY_DRAFT_RANDOMED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABILITY_DRAFT_RANDOMED),
            "CHAT_MESSAGE_PRIVATE_COACH_CONNECTED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PRIVATE_COACH_CONNECTED),
            "CHAT_MESSAGE_CANT_PAUSE_TOO_EARLY" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANT_PAUSE_TOO_EARLY),
            "CHAT_MESSAGE_HERO_KILL_WITH_PENGUIN" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL_WITH_PENGUIN),
            "CHAT_MESSAGE_MINIBOSS_KILL" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_MINIBOSS_KILL),
            "CHAT_MESSAGE_PLAYER_IN_GAME_BAN_TEXT" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_IN_GAME_BAN_TEXT),
            "CHAT_MESSAGE_BANNER_PLANTED" => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BANNER_PLANTED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_CHAT_MESSAGE] = &[
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INVALID,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_DENY,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BARRACKS_KILL,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TOWER_KILL,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TOWER_DENY,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_FIRSTBLOOD,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_STREAK_KILL,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BUYBACK,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AEGIS,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ROSHAN_KILL,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COURIER_LOST,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COURIER_RESPAWNED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_GLYPH_USED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_PURCHASE,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CONNECT,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_TIME_REMAINING,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RECONNECT,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SAFE_TO_LEAVE,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_PICKUP,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_BOTTLE,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_DENY,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INTHEBAG,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SECRETSHOP,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_AUTOPURCHASED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEMS_COMBINED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SUPER_CREEPS,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANT_USE_ACTION_ITEM,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTPAUSE,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NOPAUSESLEFT,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTPAUSEYET,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PAUSED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_UNPAUSE_COUNTDOWN,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_UNPAUSED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AUTO_UNPAUSED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_YOUPAUSED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTUNPAUSETEAM,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VOICE_TEXT_BANNED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_REPORT_REMINDER,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ECON_ITEM,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TAUNT,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANDOM,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RD_TURN,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DROP_RATE_BONUS,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NO_BATTLE_POINTS,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DENIED_AEGIS,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INFORMATIONAL,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AEGIS_STOLEN,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ROSHAN_CANDY,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_GIFTED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_WALL_FINISHED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_LIMITED_HERO,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_AFK,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED_AFK,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COMPENDIUM_LEVEL,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VICTORY_PREDICTION_STREAK,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_ANNOUNCE,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_SUCCESS,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_DENIED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_EFFIGY_KILL,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_YEAR_BEAST_KILLED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PAUSE_COUNTDOWN,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COINS_WAGERED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_NOMINATED_BAN,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_BANNED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_BAN_COUNT,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RIVER_PAINTED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SCAN_USED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SHRINE_KILLED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WAGER_TOKEN_SPENT,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANK_WAGER,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NEW_PLAYER_REMINDER,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_OBSERVER_WARD_KILLED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SENTRY_WARD_KILLED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_CHOICE_INVALID,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BOUNTY,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABILITY_DRAFT_START,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_FOUND_CANDY,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABILITY_DRAFT_RANDOMED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PRIVATE_COACH_CONNECTED,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANT_PAUSE_TOO_EARLY,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL_WITH_PENGUIN,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_MINIBOSS_KILL,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_IN_GAME_BAN_TEXT,
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BANNER_PLANTED,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DOTA_CHAT_MESSAGE {
    fn default() -> Self {
        DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INVALID
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTA_NO_BATTLE_POINTS_REASONS)
pub enum DOTA_NO_BATTLE_POINTS_REASONS {
    // @@protoc_insertion_point(enum_value:DOTA_NO_BATTLE_POINTS_REASONS.NO_BATTLE_POINTS_WRONG_LOBBY_TYPE)
    NO_BATTLE_POINTS_WRONG_LOBBY_TYPE = 1,
    // @@protoc_insertion_point(enum_value:DOTA_NO_BATTLE_POINTS_REASONS.NO_BATTLE_POINTS_PRACTICE_BOTS)
    NO_BATTLE_POINTS_PRACTICE_BOTS = 2,
    // @@protoc_insertion_point(enum_value:DOTA_NO_BATTLE_POINTS_REASONS.NO_BATTLE_POINTS_CHEATS_ENABLED)
    NO_BATTLE_POINTS_CHEATS_ENABLED = 3,
    // @@protoc_insertion_point(enum_value:DOTA_NO_BATTLE_POINTS_REASONS.NO_BATTLE_POINTS_LOW_PRIORITY)
    NO_BATTLE_POINTS_LOW_PRIORITY = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTA_NO_BATTLE_POINTS_REASONS {
    const NAME: &'static str = "DOTA_NO_BATTLE_POINTS_REASONS";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_NO_BATTLE_POINTS_REASONS> {
        match value {
            1 => ::std::option::Option::Some(DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_WRONG_LOBBY_TYPE),
            2 => ::std::option::Option::Some(DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_PRACTICE_BOTS),
            3 => ::std::option::Option::Some(DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_CHEATS_ENABLED),
            4 => ::std::option::Option::Some(DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_LOW_PRIORITY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_NO_BATTLE_POINTS_REASONS> {
        match str {
            "NO_BATTLE_POINTS_WRONG_LOBBY_TYPE" => ::std::option::Option::Some(DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_WRONG_LOBBY_TYPE),
            "NO_BATTLE_POINTS_PRACTICE_BOTS" => ::std::option::Option::Some(DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_PRACTICE_BOTS),
            "NO_BATTLE_POINTS_CHEATS_ENABLED" => ::std::option::Option::Some(DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_CHEATS_ENABLED),
            "NO_BATTLE_POINTS_LOW_PRIORITY" => ::std::option::Option::Some(DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_LOW_PRIORITY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_NO_BATTLE_POINTS_REASONS] = &[
        DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_WRONG_LOBBY_TYPE,
        DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_PRACTICE_BOTS,
        DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_CHEATS_ENABLED,
        DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_LOW_PRIORITY,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DOTA_NO_BATTLE_POINTS_REASONS {
    fn default() -> Self {
        DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_WRONG_LOBBY_TYPE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTA_CHAT_INFORMATIONAL)
pub enum DOTA_CHAT_INFORMATIONAL {
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_INFORMATIONAL.INFO_COOP_BATTLE_POINTS_RULES)
    INFO_COOP_BATTLE_POINTS_RULES = 1,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_INFORMATIONAL.INFO_FROSTIVUS_ABANDON_REMINDER)
    INFO_FROSTIVUS_ABANDON_REMINDER = 2,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_INFORMATIONAL.INFO_RANKED_REMINDER)
    INFO_RANKED_REMINDER = 3,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_INFORMATIONAL.INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER)
    INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER = 4,
    // @@protoc_insertion_point(enum_value:DOTA_CHAT_INFORMATIONAL.INFO_CUSTOM_GAME_PENALTY_REMINDER)
    INFO_CUSTOM_GAME_PENALTY_REMINDER = 5,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTA_CHAT_INFORMATIONAL {
    const NAME: &'static str = "DOTA_CHAT_INFORMATIONAL";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_CHAT_INFORMATIONAL> {
        match value {
            1 => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_COOP_BATTLE_POINTS_RULES),
            2 => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_FROSTIVUS_ABANDON_REMINDER),
            3 => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_RANKED_REMINDER),
            4 => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER),
            5 => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_CUSTOM_GAME_PENALTY_REMINDER),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_CHAT_INFORMATIONAL> {
        match str {
            "INFO_COOP_BATTLE_POINTS_RULES" => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_COOP_BATTLE_POINTS_RULES),
            "INFO_FROSTIVUS_ABANDON_REMINDER" => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_FROSTIVUS_ABANDON_REMINDER),
            "INFO_RANKED_REMINDER" => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_RANKED_REMINDER),
            "INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER" => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER),
            "INFO_CUSTOM_GAME_PENALTY_REMINDER" => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_CUSTOM_GAME_PENALTY_REMINDER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_CHAT_INFORMATIONAL] = &[
        DOTA_CHAT_INFORMATIONAL::INFO_COOP_BATTLE_POINTS_RULES,
        DOTA_CHAT_INFORMATIONAL::INFO_FROSTIVUS_ABANDON_REMINDER,
        DOTA_CHAT_INFORMATIONAL::INFO_RANKED_REMINDER,
        DOTA_CHAT_INFORMATIONAL::INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER,
        DOTA_CHAT_INFORMATIONAL::INFO_CUSTOM_GAME_PENALTY_REMINDER,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DOTA_CHAT_INFORMATIONAL {
    fn default() -> Self {
        DOTA_CHAT_INFORMATIONAL::INFO_COOP_BATTLE_POINTS_RULES
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTA_ABILITY_PING_TYPE)
pub enum DOTA_ABILITY_PING_TYPE {
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_PING_TYPE.ABILITY_PING_READY)
    ABILITY_PING_READY = 1,
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_PING_TYPE.ABILITY_PING_MANA)
    ABILITY_PING_MANA = 2,
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_PING_TYPE.ABILITY_PING_COOLDOWN)
    ABILITY_PING_COOLDOWN = 3,
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_PING_TYPE.ABILITY_PING_ENEMY)
    ABILITY_PING_ENEMY = 4,
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_PING_TYPE.ABILITY_PING_UNLEARNED)
    ABILITY_PING_UNLEARNED = 5,
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_PING_TYPE.ABILITY_PING_INBACKPACK)
    ABILITY_PING_INBACKPACK = 6,
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_PING_TYPE.ABILITY_PING_INSTASH)
    ABILITY_PING_INSTASH = 7,
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_PING_TYPE.ABILITY_PING_ONCOURIER)
    ABILITY_PING_ONCOURIER = 8,
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_PING_TYPE.ABILITY_PING_ALLY)
    ABILITY_PING_ALLY = 9,
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_PING_TYPE.ABILITY_PING_LEARN_READY)
    ABILITY_PING_LEARN_READY = 10,
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_PING_TYPE.ABILITY_PING_WILL_LEARN)
    ABILITY_PING_WILL_LEARN = 11,
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_PING_TYPE.ABILITY_PING_FUTURE_LEARN)
    ABILITY_PING_FUTURE_LEARN = 12,
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_PING_TYPE.ABILITY_PING_NEUTRAL_OFFER)
    ABILITY_PING_NEUTRAL_OFFER = 13,
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_PING_TYPE.ABILITY_PING_NEUTRAL_REQUEST)
    ABILITY_PING_NEUTRAL_REQUEST = 14,
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_PING_TYPE.ABILITY_PING_NEUTRAL_EQUIP)
    ABILITY_PING_NEUTRAL_EQUIP = 15,
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_PING_TYPE.ABILITY_PING_INCOURIERBACKPACK)
    ABILITY_PING_INCOURIERBACKPACK = 16,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTA_ABILITY_PING_TYPE {
    const NAME: &'static str = "DOTA_ABILITY_PING_TYPE";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_ABILITY_PING_TYPE> {
        match value {
            1 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_READY),
            2 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_MANA),
            3 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_COOLDOWN),
            4 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_ENEMY),
            5 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_UNLEARNED),
            6 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_INBACKPACK),
            7 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_INSTASH),
            8 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_ONCOURIER),
            9 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_ALLY),
            10 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_LEARN_READY),
            11 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_WILL_LEARN),
            12 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_FUTURE_LEARN),
            13 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_NEUTRAL_OFFER),
            14 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_NEUTRAL_REQUEST),
            15 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_NEUTRAL_EQUIP),
            16 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_INCOURIERBACKPACK),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_ABILITY_PING_TYPE> {
        match str {
            "ABILITY_PING_READY" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_READY),
            "ABILITY_PING_MANA" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_MANA),
            "ABILITY_PING_COOLDOWN" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_COOLDOWN),
            "ABILITY_PING_ENEMY" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_ENEMY),
            "ABILITY_PING_UNLEARNED" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_UNLEARNED),
            "ABILITY_PING_INBACKPACK" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_INBACKPACK),
            "ABILITY_PING_INSTASH" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_INSTASH),
            "ABILITY_PING_ONCOURIER" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_ONCOURIER),
            "ABILITY_PING_ALLY" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_ALLY),
            "ABILITY_PING_LEARN_READY" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_LEARN_READY),
            "ABILITY_PING_WILL_LEARN" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_WILL_LEARN),
            "ABILITY_PING_FUTURE_LEARN" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_FUTURE_LEARN),
            "ABILITY_PING_NEUTRAL_OFFER" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_NEUTRAL_OFFER),
            "ABILITY_PING_NEUTRAL_REQUEST" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_NEUTRAL_REQUEST),
            "ABILITY_PING_NEUTRAL_EQUIP" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_NEUTRAL_EQUIP),
            "ABILITY_PING_INCOURIERBACKPACK" => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_INCOURIERBACKPACK),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_ABILITY_PING_TYPE] = &[
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_READY,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_MANA,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_COOLDOWN,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_ENEMY,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_UNLEARNED,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_INBACKPACK,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_INSTASH,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_ONCOURIER,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_ALLY,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_LEARN_READY,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_WILL_LEARN,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_FUTURE_LEARN,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_NEUTRAL_OFFER,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_NEUTRAL_REQUEST,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_NEUTRAL_EQUIP,
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_INCOURIERBACKPACK,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DOTA_ABILITY_PING_TYPE {
    fn default() -> Self {
        DOTA_ABILITY_PING_TYPE::ABILITY_PING_READY
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTA_REPLAY_STATE_EVENT)
pub enum DOTA_REPLAY_STATE_EVENT {
    // @@protoc_insertion_point(enum_value:DOTA_REPLAY_STATE_EVENT.DOTA_REPLAY_STATE_EVENT_GAME_START)
    DOTA_REPLAY_STATE_EVENT_GAME_START = 1,
    // @@protoc_insertion_point(enum_value:DOTA_REPLAY_STATE_EVENT.DOTA_REPLAY_STATE_EVENT_STARTING_HORN)
    DOTA_REPLAY_STATE_EVENT_STARTING_HORN = 2,
    // @@protoc_insertion_point(enum_value:DOTA_REPLAY_STATE_EVENT.DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD)
    DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD = 3,
    // @@protoc_insertion_point(enum_value:DOTA_REPLAY_STATE_EVENT.DOTA_REPLAY_STATE_EVENT_SHOWCASE)
    DOTA_REPLAY_STATE_EVENT_SHOWCASE = 4,
    // @@protoc_insertion_point(enum_value:DOTA_REPLAY_STATE_EVENT.DOTA_REPLAY_STATE_EVENT_POST_GAME)
    DOTA_REPLAY_STATE_EVENT_POST_GAME = 5,
    // @@protoc_insertion_point(enum_value:DOTA_REPLAY_STATE_EVENT.DOTA_REPLAY_STATE_EVENT_WAIT_FOR_MAP)
    DOTA_REPLAY_STATE_EVENT_WAIT_FOR_MAP = 6,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTA_REPLAY_STATE_EVENT {
    const NAME: &'static str = "DOTA_REPLAY_STATE_EVENT";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_REPLAY_STATE_EVENT> {
        match value {
            1 => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_GAME_START),
            2 => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_STARTING_HORN),
            3 => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD),
            4 => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_SHOWCASE),
            5 => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_POST_GAME),
            6 => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_WAIT_FOR_MAP),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_REPLAY_STATE_EVENT> {
        match str {
            "DOTA_REPLAY_STATE_EVENT_GAME_START" => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_GAME_START),
            "DOTA_REPLAY_STATE_EVENT_STARTING_HORN" => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_STARTING_HORN),
            "DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD" => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD),
            "DOTA_REPLAY_STATE_EVENT_SHOWCASE" => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_SHOWCASE),
            "DOTA_REPLAY_STATE_EVENT_POST_GAME" => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_POST_GAME),
            "DOTA_REPLAY_STATE_EVENT_WAIT_FOR_MAP" => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_WAIT_FOR_MAP),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_REPLAY_STATE_EVENT] = &[
        DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_GAME_START,
        DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_STARTING_HORN,
        DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD,
        DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_SHOWCASE,
        DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_POST_GAME,
        DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_WAIT_FOR_MAP,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DOTA_REPLAY_STATE_EVENT {
    fn default() -> Self {
        DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_GAME_START
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EDotaEntityMessages)
pub enum EDotaEntityMessages {
    // @@protoc_insertion_point(enum_value:EDotaEntityMessages.DOTA_UNIT_SPEECH)
    DOTA_UNIT_SPEECH = 0,
    // @@protoc_insertion_point(enum_value:EDotaEntityMessages.DOTA_UNIT_SPEECH_MUTE)
    DOTA_UNIT_SPEECH_MUTE = 1,
    // @@protoc_insertion_point(enum_value:EDotaEntityMessages.DOTA_UNIT_ADD_GESTURE)
    DOTA_UNIT_ADD_GESTURE = 2,
    // @@protoc_insertion_point(enum_value:EDotaEntityMessages.DOTA_UNIT_REMOVE_GESTURE)
    DOTA_UNIT_REMOVE_GESTURE = 3,
    // @@protoc_insertion_point(enum_value:EDotaEntityMessages.DOTA_UNIT_REMOVE_ALL_GESTURES)
    DOTA_UNIT_REMOVE_ALL_GESTURES = 4,
    // @@protoc_insertion_point(enum_value:EDotaEntityMessages.DOTA_UNIT_FADE_GESTURE)
    DOTA_UNIT_FADE_GESTURE = 6,
    // @@protoc_insertion_point(enum_value:EDotaEntityMessages.DOTA_UNIT_SPEECH_CLIENTSIDE_RULES)
    DOTA_UNIT_SPEECH_CLIENTSIDE_RULES = 7,
}

impl ::steam_vent_proto_common::protobuf::Enum for EDotaEntityMessages {
    const NAME: &'static str = "EDotaEntityMessages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDotaEntityMessages> {
        match value {
            0 => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_SPEECH),
            1 => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_SPEECH_MUTE),
            2 => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_ADD_GESTURE),
            3 => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_REMOVE_GESTURE),
            4 => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_REMOVE_ALL_GESTURES),
            6 => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_FADE_GESTURE),
            7 => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_SPEECH_CLIENTSIDE_RULES),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDotaEntityMessages> {
        match str {
            "DOTA_UNIT_SPEECH" => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_SPEECH),
            "DOTA_UNIT_SPEECH_MUTE" => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_SPEECH_MUTE),
            "DOTA_UNIT_ADD_GESTURE" => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_ADD_GESTURE),
            "DOTA_UNIT_REMOVE_GESTURE" => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_REMOVE_GESTURE),
            "DOTA_UNIT_REMOVE_ALL_GESTURES" => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_REMOVE_ALL_GESTURES),
            "DOTA_UNIT_FADE_GESTURE" => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_FADE_GESTURE),
            "DOTA_UNIT_SPEECH_CLIENTSIDE_RULES" => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_SPEECH_CLIENTSIDE_RULES),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDotaEntityMessages] = &[
        EDotaEntityMessages::DOTA_UNIT_SPEECH,
        EDotaEntityMessages::DOTA_UNIT_SPEECH_MUTE,
        EDotaEntityMessages::DOTA_UNIT_ADD_GESTURE,
        EDotaEntityMessages::DOTA_UNIT_REMOVE_GESTURE,
        EDotaEntityMessages::DOTA_UNIT_REMOVE_ALL_GESTURES,
        EDotaEntityMessages::DOTA_UNIT_FADE_GESTURE,
        EDotaEntityMessages::DOTA_UNIT_SPEECH_CLIENTSIDE_RULES,
    ];
}

impl ::std::default::Default for EDotaEntityMessages {
    fn default() -> Self {
        EDotaEntityMessages::DOTA_UNIT_SPEECH
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTA_OVERHEAD_ALERT)
pub enum DOTA_OVERHEAD_ALERT {
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_GOLD)
    OVERHEAD_ALERT_GOLD = 0,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_DENY)
    OVERHEAD_ALERT_DENY = 1,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_CRITICAL)
    OVERHEAD_ALERT_CRITICAL = 2,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_XP)
    OVERHEAD_ALERT_XP = 3,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_BONUS_SPELL_DAMAGE)
    OVERHEAD_ALERT_BONUS_SPELL_DAMAGE = 4,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_MISS)
    OVERHEAD_ALERT_MISS = 5,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_DAMAGE)
    OVERHEAD_ALERT_DAMAGE = 6,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_EVADE)
    OVERHEAD_ALERT_EVADE = 7,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_BLOCK)
    OVERHEAD_ALERT_BLOCK = 8,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_BONUS_POISON_DAMAGE)
    OVERHEAD_ALERT_BONUS_POISON_DAMAGE = 9,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_HEAL)
    OVERHEAD_ALERT_HEAL = 10,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_MANA_ADD)
    OVERHEAD_ALERT_MANA_ADD = 11,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_MANA_LOSS)
    OVERHEAD_ALERT_MANA_LOSS = 12,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_LAST_HIT_EARLY)
    OVERHEAD_ALERT_LAST_HIT_EARLY = 13,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_LAST_HIT_CLOSE)
    OVERHEAD_ALERT_LAST_HIT_CLOSE = 14,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_LAST_HIT_MISS)
    OVERHEAD_ALERT_LAST_HIT_MISS = 15,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_MAGICAL_BLOCK)
    OVERHEAD_ALERT_MAGICAL_BLOCK = 16,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_INCOMING_DAMAGE)
    OVERHEAD_ALERT_INCOMING_DAMAGE = 17,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_OUTGOING_DAMAGE)
    OVERHEAD_ALERT_OUTGOING_DAMAGE = 18,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_DISABLE_RESIST)
    OVERHEAD_ALERT_DISABLE_RESIST = 19,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_DEATH)
    OVERHEAD_ALERT_DEATH = 20,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_BLOCKED)
    OVERHEAD_ALERT_BLOCKED = 21,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_ITEM_RECEIVED)
    OVERHEAD_ALERT_ITEM_RECEIVED = 22,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_SHARD)
    OVERHEAD_ALERT_SHARD = 23,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_DEADLY_BLOW)
    OVERHEAD_ALERT_DEADLY_BLOW = 24,
    // @@protoc_insertion_point(enum_value:DOTA_OVERHEAD_ALERT.OVERHEAD_ALERT_FORCE_MISS)
    OVERHEAD_ALERT_FORCE_MISS = 25,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTA_OVERHEAD_ALERT {
    const NAME: &'static str = "DOTA_OVERHEAD_ALERT";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_OVERHEAD_ALERT> {
        match value {
            0 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_GOLD),
            1 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DENY),
            2 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_CRITICAL),
            3 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_XP),
            4 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BONUS_SPELL_DAMAGE),
            5 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MISS),
            6 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DAMAGE),
            7 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_EVADE),
            8 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BLOCK),
            9 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BONUS_POISON_DAMAGE),
            10 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_HEAL),
            11 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MANA_ADD),
            12 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MANA_LOSS),
            13 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_EARLY),
            14 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_CLOSE),
            15 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_MISS),
            16 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MAGICAL_BLOCK),
            17 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_INCOMING_DAMAGE),
            18 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_OUTGOING_DAMAGE),
            19 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DISABLE_RESIST),
            20 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DEATH),
            21 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BLOCKED),
            22 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_ITEM_RECEIVED),
            23 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_SHARD),
            24 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DEADLY_BLOW),
            25 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_FORCE_MISS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_OVERHEAD_ALERT> {
        match str {
            "OVERHEAD_ALERT_GOLD" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_GOLD),
            "OVERHEAD_ALERT_DENY" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DENY),
            "OVERHEAD_ALERT_CRITICAL" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_CRITICAL),
            "OVERHEAD_ALERT_XP" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_XP),
            "OVERHEAD_ALERT_BONUS_SPELL_DAMAGE" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BONUS_SPELL_DAMAGE),
            "OVERHEAD_ALERT_MISS" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MISS),
            "OVERHEAD_ALERT_DAMAGE" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DAMAGE),
            "OVERHEAD_ALERT_EVADE" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_EVADE),
            "OVERHEAD_ALERT_BLOCK" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BLOCK),
            "OVERHEAD_ALERT_BONUS_POISON_DAMAGE" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BONUS_POISON_DAMAGE),
            "OVERHEAD_ALERT_HEAL" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_HEAL),
            "OVERHEAD_ALERT_MANA_ADD" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MANA_ADD),
            "OVERHEAD_ALERT_MANA_LOSS" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MANA_LOSS),
            "OVERHEAD_ALERT_LAST_HIT_EARLY" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_EARLY),
            "OVERHEAD_ALERT_LAST_HIT_CLOSE" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_CLOSE),
            "OVERHEAD_ALERT_LAST_HIT_MISS" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_MISS),
            "OVERHEAD_ALERT_MAGICAL_BLOCK" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MAGICAL_BLOCK),
            "OVERHEAD_ALERT_INCOMING_DAMAGE" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_INCOMING_DAMAGE),
            "OVERHEAD_ALERT_OUTGOING_DAMAGE" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_OUTGOING_DAMAGE),
            "OVERHEAD_ALERT_DISABLE_RESIST" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DISABLE_RESIST),
            "OVERHEAD_ALERT_DEATH" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DEATH),
            "OVERHEAD_ALERT_BLOCKED" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BLOCKED),
            "OVERHEAD_ALERT_ITEM_RECEIVED" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_ITEM_RECEIVED),
            "OVERHEAD_ALERT_SHARD" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_SHARD),
            "OVERHEAD_ALERT_DEADLY_BLOW" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DEADLY_BLOW),
            "OVERHEAD_ALERT_FORCE_MISS" => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_FORCE_MISS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_OVERHEAD_ALERT] = &[
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_GOLD,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DENY,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_CRITICAL,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_XP,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BONUS_SPELL_DAMAGE,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MISS,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DAMAGE,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_EVADE,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BLOCK,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BONUS_POISON_DAMAGE,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_HEAL,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MANA_ADD,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MANA_LOSS,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_EARLY,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_CLOSE,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_MISS,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MAGICAL_BLOCK,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_INCOMING_DAMAGE,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_OUTGOING_DAMAGE,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DISABLE_RESIST,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DEATH,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BLOCKED,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_ITEM_RECEIVED,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_SHARD,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DEADLY_BLOW,
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_FORCE_MISS,
    ];
}

impl ::std::default::Default for DOTA_OVERHEAD_ALERT {
    fn default() -> Self {
        DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_GOLD
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTA_ROSHAN_PHASE)
pub enum DOTA_ROSHAN_PHASE {
    // @@protoc_insertion_point(enum_value:DOTA_ROSHAN_PHASE.k_SRSP_ROSHAN_ALIVE)
    k_SRSP_ROSHAN_ALIVE = 0,
    // @@protoc_insertion_point(enum_value:DOTA_ROSHAN_PHASE.k_SRSP_ROSHAN_BASE_TIMER)
    k_SRSP_ROSHAN_BASE_TIMER = 1,
    // @@protoc_insertion_point(enum_value:DOTA_ROSHAN_PHASE.k_SRSP_ROSHAN_VISIBLE_TIMER)
    k_SRSP_ROSHAN_VISIBLE_TIMER = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTA_ROSHAN_PHASE {
    const NAME: &'static str = "DOTA_ROSHAN_PHASE";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_ROSHAN_PHASE> {
        match value {
            0 => ::std::option::Option::Some(DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_ALIVE),
            1 => ::std::option::Option::Some(DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_BASE_TIMER),
            2 => ::std::option::Option::Some(DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_VISIBLE_TIMER),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_ROSHAN_PHASE> {
        match str {
            "k_SRSP_ROSHAN_ALIVE" => ::std::option::Option::Some(DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_ALIVE),
            "k_SRSP_ROSHAN_BASE_TIMER" => ::std::option::Option::Some(DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_BASE_TIMER),
            "k_SRSP_ROSHAN_VISIBLE_TIMER" => ::std::option::Option::Some(DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_VISIBLE_TIMER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_ROSHAN_PHASE] = &[
        DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_ALIVE,
        DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_BASE_TIMER,
        DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_VISIBLE_TIMER,
    ];
}

impl ::std::default::Default for DOTA_ROSHAN_PHASE {
    fn default() -> Self {
        DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_ALIVE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTA_POSITION_CATEGORY)
pub enum DOTA_POSITION_CATEGORY {
    // @@protoc_insertion_point(enum_value:DOTA_POSITION_CATEGORY.DOTA_POSITION_NONE)
    DOTA_POSITION_NONE = 0,
    // @@protoc_insertion_point(enum_value:DOTA_POSITION_CATEGORY.DOTA_POSITION_BOTTOM_LANE)
    DOTA_POSITION_BOTTOM_LANE = 1,
    // @@protoc_insertion_point(enum_value:DOTA_POSITION_CATEGORY.DOTA_POSITION_MID_LANE)
    DOTA_POSITION_MID_LANE = 2,
    // @@protoc_insertion_point(enum_value:DOTA_POSITION_CATEGORY.DOTA_POSITION_TOP_LANE)
    DOTA_POSITION_TOP_LANE = 3,
    // @@protoc_insertion_point(enum_value:DOTA_POSITION_CATEGORY.DOTA_POSITION_RADIANT_JUNGLE)
    DOTA_POSITION_RADIANT_JUNGLE = 4,
    // @@protoc_insertion_point(enum_value:DOTA_POSITION_CATEGORY.DOTA_POSITION_DIRE_JUNGLE)
    DOTA_POSITION_DIRE_JUNGLE = 5,
    // @@protoc_insertion_point(enum_value:DOTA_POSITION_CATEGORY.DOTA_POSITION_RADIANT_ANCIENTS)
    DOTA_POSITION_RADIANT_ANCIENTS = 6,
    // @@protoc_insertion_point(enum_value:DOTA_POSITION_CATEGORY.DOTA_POSITION_DIRE_ANCIENTS)
    DOTA_POSITION_DIRE_ANCIENTS = 7,
    // @@protoc_insertion_point(enum_value:DOTA_POSITION_CATEGORY.DOTA_POSITION_RADIANT_SECRET_SHOP)
    DOTA_POSITION_RADIANT_SECRET_SHOP = 8,
    // @@protoc_insertion_point(enum_value:DOTA_POSITION_CATEGORY.DOTA_POSITION_DIRE_SECRET_SHOP)
    DOTA_POSITION_DIRE_SECRET_SHOP = 9,
    // @@protoc_insertion_point(enum_value:DOTA_POSITION_CATEGORY.DOTA_POSITION_RIVER)
    DOTA_POSITION_RIVER = 10,
    // @@protoc_insertion_point(enum_value:DOTA_POSITION_CATEGORY.DOTA_POSITION_ROSHAN_PIT)
    DOTA_POSITION_ROSHAN_PIT = 11,
    // @@protoc_insertion_point(enum_value:DOTA_POSITION_CATEGORY.DOTA_POSITION_RADIANT_BASE)
    DOTA_POSITION_RADIANT_BASE = 12,
    // @@protoc_insertion_point(enum_value:DOTA_POSITION_CATEGORY.DOTA_POSITION_DIRE_BASE)
    DOTA_POSITION_DIRE_BASE = 13,
    // @@protoc_insertion_point(enum_value:DOTA_POSITION_CATEGORY.DOTA_POSITION_FOUNTAIN)
    DOTA_POSITION_FOUNTAIN = 14,
    // @@protoc_insertion_point(enum_value:DOTA_POSITION_CATEGORY.DOTA_POSITION_OTHER)
    DOTA_POSITION_OTHER = 15,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTA_POSITION_CATEGORY {
    const NAME: &'static str = "DOTA_POSITION_CATEGORY";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_POSITION_CATEGORY> {
        match value {
            0 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_NONE),
            1 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_BOTTOM_LANE),
            2 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_MID_LANE),
            3 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_TOP_LANE),
            4 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_JUNGLE),
            5 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_JUNGLE),
            6 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_ANCIENTS),
            7 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_ANCIENTS),
            8 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_SECRET_SHOP),
            9 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_SECRET_SHOP),
            10 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RIVER),
            11 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_ROSHAN_PIT),
            12 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_BASE),
            13 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_BASE),
            14 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_FOUNTAIN),
            15 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_POSITION_CATEGORY> {
        match str {
            "DOTA_POSITION_NONE" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_NONE),
            "DOTA_POSITION_BOTTOM_LANE" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_BOTTOM_LANE),
            "DOTA_POSITION_MID_LANE" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_MID_LANE),
            "DOTA_POSITION_TOP_LANE" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_TOP_LANE),
            "DOTA_POSITION_RADIANT_JUNGLE" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_JUNGLE),
            "DOTA_POSITION_DIRE_JUNGLE" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_JUNGLE),
            "DOTA_POSITION_RADIANT_ANCIENTS" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_ANCIENTS),
            "DOTA_POSITION_DIRE_ANCIENTS" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_ANCIENTS),
            "DOTA_POSITION_RADIANT_SECRET_SHOP" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_SECRET_SHOP),
            "DOTA_POSITION_DIRE_SECRET_SHOP" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_SECRET_SHOP),
            "DOTA_POSITION_RIVER" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RIVER),
            "DOTA_POSITION_ROSHAN_PIT" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_ROSHAN_PIT),
            "DOTA_POSITION_RADIANT_BASE" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_BASE),
            "DOTA_POSITION_DIRE_BASE" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_BASE),
            "DOTA_POSITION_FOUNTAIN" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_FOUNTAIN),
            "DOTA_POSITION_OTHER" => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_OTHER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_POSITION_CATEGORY] = &[
        DOTA_POSITION_CATEGORY::DOTA_POSITION_NONE,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_BOTTOM_LANE,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_MID_LANE,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_TOP_LANE,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_JUNGLE,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_JUNGLE,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_ANCIENTS,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_ANCIENTS,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_SECRET_SHOP,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_SECRET_SHOP,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_RIVER,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_ROSHAN_PIT,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_BASE,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_BASE,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_FOUNTAIN,
        DOTA_POSITION_CATEGORY::DOTA_POSITION_OTHER,
    ];
}

impl ::std::default::Default for DOTA_POSITION_CATEGORY {
    fn default() -> Self {
        DOTA_POSITION_CATEGORY::DOTA_POSITION_NONE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTA_ABILITY_TARGET_TYPE)
pub enum DOTA_ABILITY_TARGET_TYPE {
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_TARGET_TYPE.DOTA_ABILITY_TARGET_NONE)
    DOTA_ABILITY_TARGET_NONE = 0,
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_TARGET_TYPE.DOTA_ABILITY_TARGET_SELF)
    DOTA_ABILITY_TARGET_SELF = 1,
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_TARGET_TYPE.DOTA_ABILITY_TARGET_ALLY_HERO)
    DOTA_ABILITY_TARGET_ALLY_HERO = 2,
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_TARGET_TYPE.DOTA_ABILITY_TARGET_ALLY_CREEP)
    DOTA_ABILITY_TARGET_ALLY_CREEP = 3,
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_TARGET_TYPE.DOTA_ABILITY_TARGET_ENEMY_HERO)
    DOTA_ABILITY_TARGET_ENEMY_HERO = 4,
    // @@protoc_insertion_point(enum_value:DOTA_ABILITY_TARGET_TYPE.DOTA_ABILITY_TARGET_ENEMY_CREEP)
    DOTA_ABILITY_TARGET_ENEMY_CREEP = 5,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTA_ABILITY_TARGET_TYPE {
    const NAME: &'static str = "DOTA_ABILITY_TARGET_TYPE";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_ABILITY_TARGET_TYPE> {
        match value {
            0 => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_NONE),
            1 => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_SELF),
            2 => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ALLY_HERO),
            3 => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ALLY_CREEP),
            4 => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ENEMY_HERO),
            5 => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ENEMY_CREEP),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_ABILITY_TARGET_TYPE> {
        match str {
            "DOTA_ABILITY_TARGET_NONE" => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_NONE),
            "DOTA_ABILITY_TARGET_SELF" => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_SELF),
            "DOTA_ABILITY_TARGET_ALLY_HERO" => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ALLY_HERO),
            "DOTA_ABILITY_TARGET_ALLY_CREEP" => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ALLY_CREEP),
            "DOTA_ABILITY_TARGET_ENEMY_HERO" => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ENEMY_HERO),
            "DOTA_ABILITY_TARGET_ENEMY_CREEP" => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ENEMY_CREEP),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_ABILITY_TARGET_TYPE] = &[
        DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_NONE,
        DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_SELF,
        DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ALLY_HERO,
        DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ALLY_CREEP,
        DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ENEMY_HERO,
        DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ENEMY_CREEP,
    ];
}

impl ::std::default::Default for DOTA_ABILITY_TARGET_TYPE {
    fn default() -> Self {
        DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_NONE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EHeroStatType)
pub enum EHeroStatType {
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_None)
    k_EHeroStatType_None = 0,
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_AxeTotalDamage)
    k_EHeroStatType_AxeTotalDamage = 2000,
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_BattleHungerDamage)
    k_EHeroStatType_BattleHungerDamage = 2001,
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_CounterHelixDamage)
    k_EHeroStatType_CounterHelixDamage = 2002,
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_CullingBladeDamage)
    k_EHeroStatType_CullingBladeDamage = 2003,
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_BerserkersCallCastCount)
    k_EHeroStatType_BerserkersCallCastCount = 2004,
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_BerserkersCallHeroesHitAverage)
    k_EHeroStatType_BerserkersCallHeroesHitAverage = 2005,
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_BerserkersCallOtherUnitsHit)
    k_EHeroStatType_BerserkersCallOtherUnitsHit = 2006,
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_BerserkersCallHeroAttacksTaken)
    k_EHeroStatType_BerserkersCallHeroAttacksTaken = 2007,
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_BerserkersCallOtherAttacksTaken)
    k_EHeroStatType_BerserkersCallOtherAttacksTaken = 2008,
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_BattleHungerCastCount)
    k_EHeroStatType_BattleHungerCastCount = 2009,
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_BattleHungerPotentialDuration)
    k_EHeroStatType_BattleHungerPotentialDuration = 2010,
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_BattleHungerAverageDuration)
    k_EHeroStatType_BattleHungerAverageDuration = 2011,
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_CounterHelixProcCount)
    k_EHeroStatType_CounterHelixProcCount = 2012,
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_CounterHelixHeroProcCount)
    k_EHeroStatType_CounterHelixHeroProcCount = 2013,
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_CounterHelixHeroesHitAverage)
    k_EHeroStatType_CounterHelixHeroesHitAverage = 2014,
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_CounterHelixOtherUnitsHitCount)
    k_EHeroStatType_CounterHelixOtherUnitsHitCount = 2015,
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_CullingBladeCastCount)
    k_EHeroStatType_CullingBladeCastCount = 2016,
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_CullingBladeKillCount)
    k_EHeroStatType_CullingBladeKillCount = 2017,
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_CullingBladeAverageHealthCulled)
    k_EHeroStatType_CullingBladeAverageHealthCulled = 2018,
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_CullingBladeAverageDamageAvailable)
    k_EHeroStatType_CullingBladeAverageDamageAvailable = 2019,
    // @@protoc_insertion_point(enum_value:EHeroStatType.k_EHeroStatType_CullingBladeHeroBuffAverage)
    k_EHeroStatType_CullingBladeHeroBuffAverage = 2020,
}

impl ::steam_vent_proto_common::protobuf::Enum for EHeroStatType {
    const NAME: &'static str = "EHeroStatType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EHeroStatType> {
        match value {
            0 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_None),
            2000 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_AxeTotalDamage),
            2001 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BattleHungerDamage),
            2002 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixDamage),
            2003 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeDamage),
            2004 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallCastCount),
            2005 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallHeroesHitAverage),
            2006 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallOtherUnitsHit),
            2007 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallHeroAttacksTaken),
            2008 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallOtherAttacksTaken),
            2009 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BattleHungerCastCount),
            2010 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BattleHungerPotentialDuration),
            2011 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BattleHungerAverageDuration),
            2012 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixProcCount),
            2013 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixHeroProcCount),
            2014 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixHeroesHitAverage),
            2015 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixOtherUnitsHitCount),
            2016 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeCastCount),
            2017 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeKillCount),
            2018 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeAverageHealthCulled),
            2019 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeAverageDamageAvailable),
            2020 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeHeroBuffAverage),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EHeroStatType> {
        match str {
            "k_EHeroStatType_None" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_None),
            "k_EHeroStatType_AxeTotalDamage" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_AxeTotalDamage),
            "k_EHeroStatType_BattleHungerDamage" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BattleHungerDamage),
            "k_EHeroStatType_CounterHelixDamage" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixDamage),
            "k_EHeroStatType_CullingBladeDamage" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeDamage),
            "k_EHeroStatType_BerserkersCallCastCount" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallCastCount),
            "k_EHeroStatType_BerserkersCallHeroesHitAverage" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallHeroesHitAverage),
            "k_EHeroStatType_BerserkersCallOtherUnitsHit" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallOtherUnitsHit),
            "k_EHeroStatType_BerserkersCallHeroAttacksTaken" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallHeroAttacksTaken),
            "k_EHeroStatType_BerserkersCallOtherAttacksTaken" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallOtherAttacksTaken),
            "k_EHeroStatType_BattleHungerCastCount" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BattleHungerCastCount),
            "k_EHeroStatType_BattleHungerPotentialDuration" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BattleHungerPotentialDuration),
            "k_EHeroStatType_BattleHungerAverageDuration" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BattleHungerAverageDuration),
            "k_EHeroStatType_CounterHelixProcCount" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixProcCount),
            "k_EHeroStatType_CounterHelixHeroProcCount" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixHeroProcCount),
            "k_EHeroStatType_CounterHelixHeroesHitAverage" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixHeroesHitAverage),
            "k_EHeroStatType_CounterHelixOtherUnitsHitCount" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixOtherUnitsHitCount),
            "k_EHeroStatType_CullingBladeCastCount" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeCastCount),
            "k_EHeroStatType_CullingBladeKillCount" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeKillCount),
            "k_EHeroStatType_CullingBladeAverageHealthCulled" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeAverageHealthCulled),
            "k_EHeroStatType_CullingBladeAverageDamageAvailable" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeAverageDamageAvailable),
            "k_EHeroStatType_CullingBladeHeroBuffAverage" => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeHeroBuffAverage),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EHeroStatType] = &[
        EHeroStatType::k_EHeroStatType_None,
        EHeroStatType::k_EHeroStatType_AxeTotalDamage,
        EHeroStatType::k_EHeroStatType_BattleHungerDamage,
        EHeroStatType::k_EHeroStatType_CounterHelixDamage,
        EHeroStatType::k_EHeroStatType_CullingBladeDamage,
        EHeroStatType::k_EHeroStatType_BerserkersCallCastCount,
        EHeroStatType::k_EHeroStatType_BerserkersCallHeroesHitAverage,
        EHeroStatType::k_EHeroStatType_BerserkersCallOtherUnitsHit,
        EHeroStatType::k_EHeroStatType_BerserkersCallHeroAttacksTaken,
        EHeroStatType::k_EHeroStatType_BerserkersCallOtherAttacksTaken,
        EHeroStatType::k_EHeroStatType_BattleHungerCastCount,
        EHeroStatType::k_EHeroStatType_BattleHungerPotentialDuration,
        EHeroStatType::k_EHeroStatType_BattleHungerAverageDuration,
        EHeroStatType::k_EHeroStatType_CounterHelixProcCount,
        EHeroStatType::k_EHeroStatType_CounterHelixHeroProcCount,
        EHeroStatType::k_EHeroStatType_CounterHelixHeroesHitAverage,
        EHeroStatType::k_EHeroStatType_CounterHelixOtherUnitsHitCount,
        EHeroStatType::k_EHeroStatType_CullingBladeCastCount,
        EHeroStatType::k_EHeroStatType_CullingBladeKillCount,
        EHeroStatType::k_EHeroStatType_CullingBladeAverageHealthCulled,
        EHeroStatType::k_EHeroStatType_CullingBladeAverageDamageAvailable,
        EHeroStatType::k_EHeroStatType_CullingBladeHeroBuffAverage,
    ];
}

impl ::std::default::Default for EHeroStatType {
    fn default() -> Self {
        EHeroStatType::k_EHeroStatType_None
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPlayerVoiceListenState)
pub enum EPlayerVoiceListenState {
    // @@protoc_insertion_point(enum_value:EPlayerVoiceListenState.kPVLS_None)
    kPVLS_None = 0,
    // @@protoc_insertion_point(enum_value:EPlayerVoiceListenState.kPVLS_DeniedChatBanned)
    kPVLS_DeniedChatBanned = 1,
    // @@protoc_insertion_point(enum_value:EPlayerVoiceListenState.kPVLS_DeniedPartner)
    kPVLS_DeniedPartner = 2,
    // @@protoc_insertion_point(enum_value:EPlayerVoiceListenState.kPVLS_DeniedHLTVTalkerNotSpectator)
    kPVLS_DeniedHLTVTalkerNotSpectator = 3,
    // @@protoc_insertion_point(enum_value:EPlayerVoiceListenState.kPVLS_DeniedHLTVNoTalkerPlayerID)
    kPVLS_DeniedHLTVNoTalkerPlayerID = 4,
    // @@protoc_insertion_point(enum_value:EPlayerVoiceListenState.kPVLS_DeniedHLTVTalkerNotBroadcaster)
    kPVLS_DeniedHLTVTalkerNotBroadcaster = 5,
    // @@protoc_insertion_point(enum_value:EPlayerVoiceListenState.kPVLS_DeniedTeamSpectator)
    kPVLS_DeniedTeamSpectator = 6,
    // @@protoc_insertion_point(enum_value:EPlayerVoiceListenState.kPVLS_DeniedStudent)
    kPVLS_DeniedStudent = 8,
    // @@protoc_insertion_point(enum_value:EPlayerVoiceListenState.kPVLS_DeniedPrivateCoach)
    kPVLS_DeniedPrivateCoach = 9,
    // @@protoc_insertion_point(enum_value:EPlayerVoiceListenState.kPVLS_Denied)
    kPVLS_Denied = 64,
    // @@protoc_insertion_point(enum_value:EPlayerVoiceListenState.kPVLS_AllowHLTVTalkerIsBroadcaster)
    kPVLS_AllowHLTVTalkerIsBroadcaster = 65,
    // @@protoc_insertion_point(enum_value:EPlayerVoiceListenState.kPVLS_AllowCoBroadcaster)
    kPVLS_AllowCoBroadcaster = 66,
    // @@protoc_insertion_point(enum_value:EPlayerVoiceListenState.kPVLS_AllowAllChat)
    kPVLS_AllowAllChat = 67,
    // @@protoc_insertion_point(enum_value:EPlayerVoiceListenState.kPVLS_AllowStudentToCoach)
    kPVLS_AllowStudentToCoach = 68,
    // @@protoc_insertion_point(enum_value:EPlayerVoiceListenState.kPVLS_AllowFellowStudent)
    kPVLS_AllowFellowStudent = 69,
    // @@protoc_insertion_point(enum_value:EPlayerVoiceListenState.kPVLS_AllowTalkerIsCoach)
    kPVLS_AllowTalkerIsCoach = 70,
    // @@protoc_insertion_point(enum_value:EPlayerVoiceListenState.kPVLS_AllowCoachHearTeam)
    kPVLS_AllowCoachHearTeam = 71,
    // @@protoc_insertion_point(enum_value:EPlayerVoiceListenState.kPVLS_AllowSameTeam)
    kPVLS_AllowSameTeam = 72,
    // @@protoc_insertion_point(enum_value:EPlayerVoiceListenState.kPVLS_AllowShowcase)
    kPVLS_AllowShowcase = 73,
    // @@protoc_insertion_point(enum_value:EPlayerVoiceListenState.kPVLS_AllowPrivateCoach)
    kPVLS_AllowPrivateCoach = 74,
}

impl ::steam_vent_proto_common::protobuf::Enum for EPlayerVoiceListenState {
    const NAME: &'static str = "EPlayerVoiceListenState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPlayerVoiceListenState> {
        match value {
            0 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_None),
            1 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedChatBanned),
            2 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedPartner),
            3 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedHLTVTalkerNotSpectator),
            4 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedHLTVNoTalkerPlayerID),
            5 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedHLTVTalkerNotBroadcaster),
            6 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedTeamSpectator),
            8 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedStudent),
            9 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedPrivateCoach),
            64 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_Denied),
            65 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowHLTVTalkerIsBroadcaster),
            66 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowCoBroadcaster),
            67 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowAllChat),
            68 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowStudentToCoach),
            69 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowFellowStudent),
            70 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowTalkerIsCoach),
            71 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowCoachHearTeam),
            72 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowSameTeam),
            73 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowShowcase),
            74 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowPrivateCoach),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPlayerVoiceListenState> {
        match str {
            "kPVLS_None" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_None),
            "kPVLS_DeniedChatBanned" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedChatBanned),
            "kPVLS_DeniedPartner" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedPartner),
            "kPVLS_DeniedHLTVTalkerNotSpectator" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedHLTVTalkerNotSpectator),
            "kPVLS_DeniedHLTVNoTalkerPlayerID" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedHLTVNoTalkerPlayerID),
            "kPVLS_DeniedHLTVTalkerNotBroadcaster" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedHLTVTalkerNotBroadcaster),
            "kPVLS_DeniedTeamSpectator" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedTeamSpectator),
            "kPVLS_DeniedStudent" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedStudent),
            "kPVLS_DeniedPrivateCoach" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedPrivateCoach),
            "kPVLS_Denied" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_Denied),
            "kPVLS_AllowHLTVTalkerIsBroadcaster" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowHLTVTalkerIsBroadcaster),
            "kPVLS_AllowCoBroadcaster" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowCoBroadcaster),
            "kPVLS_AllowAllChat" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowAllChat),
            "kPVLS_AllowStudentToCoach" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowStudentToCoach),
            "kPVLS_AllowFellowStudent" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowFellowStudent),
            "kPVLS_AllowTalkerIsCoach" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowTalkerIsCoach),
            "kPVLS_AllowCoachHearTeam" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowCoachHearTeam),
            "kPVLS_AllowSameTeam" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowSameTeam),
            "kPVLS_AllowShowcase" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowShowcase),
            "kPVLS_AllowPrivateCoach" => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowPrivateCoach),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPlayerVoiceListenState] = &[
        EPlayerVoiceListenState::kPVLS_None,
        EPlayerVoiceListenState::kPVLS_DeniedChatBanned,
        EPlayerVoiceListenState::kPVLS_DeniedPartner,
        EPlayerVoiceListenState::kPVLS_DeniedHLTVTalkerNotSpectator,
        EPlayerVoiceListenState::kPVLS_DeniedHLTVNoTalkerPlayerID,
        EPlayerVoiceListenState::kPVLS_DeniedHLTVTalkerNotBroadcaster,
        EPlayerVoiceListenState::kPVLS_DeniedTeamSpectator,
        EPlayerVoiceListenState::kPVLS_DeniedStudent,
        EPlayerVoiceListenState::kPVLS_DeniedPrivateCoach,
        EPlayerVoiceListenState::kPVLS_Denied,
        EPlayerVoiceListenState::kPVLS_AllowHLTVTalkerIsBroadcaster,
        EPlayerVoiceListenState::kPVLS_AllowCoBroadcaster,
        EPlayerVoiceListenState::kPVLS_AllowAllChat,
        EPlayerVoiceListenState::kPVLS_AllowStudentToCoach,
        EPlayerVoiceListenState::kPVLS_AllowFellowStudent,
        EPlayerVoiceListenState::kPVLS_AllowTalkerIsCoach,
        EPlayerVoiceListenState::kPVLS_AllowCoachHearTeam,
        EPlayerVoiceListenState::kPVLS_AllowSameTeam,
        EPlayerVoiceListenState::kPVLS_AllowShowcase,
        EPlayerVoiceListenState::kPVLS_AllowPrivateCoach,
    ];
}

impl ::std::default::Default for EPlayerVoiceListenState {
    fn default() -> Self {
        EPlayerVoiceListenState::kPVLS_None
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EProjectionEvent)
pub enum EProjectionEvent {
    // @@protoc_insertion_point(enum_value:EProjectionEvent.ePE_FirstBlood)
    ePE_FirstBlood = 0,
    // @@protoc_insertion_point(enum_value:EProjectionEvent.ePE_Killstreak_godlike)
    ePE_Killstreak_godlike = 1,
}

impl ::steam_vent_proto_common::protobuf::Enum for EProjectionEvent {
    const NAME: &'static str = "EProjectionEvent";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EProjectionEvent> {
        match value {
            0 => ::std::option::Option::Some(EProjectionEvent::ePE_FirstBlood),
            1 => ::std::option::Option::Some(EProjectionEvent::ePE_Killstreak_godlike),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EProjectionEvent> {
        match str {
            "ePE_FirstBlood" => ::std::option::Option::Some(EProjectionEvent::ePE_FirstBlood),
            "ePE_Killstreak_godlike" => ::std::option::Option::Some(EProjectionEvent::ePE_Killstreak_godlike),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EProjectionEvent] = &[
        EProjectionEvent::ePE_FirstBlood,
        EProjectionEvent::ePE_Killstreak_godlike,
    ];
}

impl ::std::default::Default for EProjectionEvent {
    fn default() -> Self {
        EProjectionEvent::ePE_FirstBlood
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::networkbasetypes::*;
#[allow(unused_imports)]
use crate::dota_shared_enums::*;
#[allow(unused_imports)]
use crate::dota_commonmessages::*;
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_AIDebugLine {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_Ping {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_SwapVerify {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_ChatEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_BotChat {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_CombatHeroPositions {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_CombatLogBulkData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_ProjectileParticleCPData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CDOTAUserMsg_UpdateLinearProjectileCPData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_MiniKillCamInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_GlobalLightColor {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_GlobalLightDirection {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_LocationPing {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_PingConfirmation {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_ItemAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_EnemyItemAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_ModifierAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_HPManaAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_NeutralCampAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_GlyphAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_RadarAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_WillPurchaseAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_EmptyTeleportAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_MarsArenaOfBloodAttack {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAEntityMsg_InvokerSpellCast {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_BuyBackStateAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_QuickBuyAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_CourierKilledAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_MinimapEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_MapLine {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_MinimapDebugPoint {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_CreateLinearProjectile {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_DestroyLinearProjectile {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_DodgeTrackingProjectiles {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_SpectatorPlayerClick {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_SpectatorPlayerUnitOrders {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_NevermoreRequiem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_InvalidCommand {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_HudError {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_SharedCooldown {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_SetNextAutobuyItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_HalloweenDrops {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAResponseQuerySerialized {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTASpeechMatchOnClient {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_UnitEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_ItemPurchased {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_ItemSold {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_ItemFound {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_OverheadEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_TutorialTipInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_TutorialFinish {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_TutorialMinimapPosition {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_SendGenericToolTip {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_WorldLine {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_ChatWheel {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_ReceivedXmasGift {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_ShowSurvey {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_UpdateSharedContent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_TutorialRequestExp {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_TutorialFade {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_TutorialPingMinimap {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_GamerulesStateChanged {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_AddQuestLogEntry {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_SendStatPopup {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_DismissAllStatPopups {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_SendRoshanSpectatorPhase {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_SendRoshanPopup {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_SendFinalGold {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_CustomMsg {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_CoachHUDPing {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_ClientLoadGridNav {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_TE_Projectile {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_TE_ProjectileLoc {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_TE_DestroyProjectile {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_TE_DotaBloodImpact {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_AbilityPing {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_TE_UnitAnimation {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_TE_UnitAnimationEnd {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_ShowGenericPopup {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_VoteStart {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_VoteUpdate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_VoteEnd {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_BoosterStatePlayer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_BoosterState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_PlayerMMR {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_AbilitySteal {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_StatsHeroLookup {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_StatsHeroPositionInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_StatsHeroMinuteDetails {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_StatsTeamMinuteDetails {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_StatsPlayerKillShare {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_StatsKillDetails {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_StatsMatchDetails {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_MiniTaunt {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_SpeechBubble {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_CustomHeaderMessage {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgHeroAbilityStat {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgCombatAnalyzerPlayerStat {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgCombatAnalyzerStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_BeastChat {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_CustomHudElement_Create {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_CustomHudElement_Modify {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_CustomHudElement_Destroy {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_CompendiumStatePlayer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_CompendiumState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_ProjectionAbility {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_ProjectionEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_XPAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_TalentTreeAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_UpdateQuestProgress {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_QuestStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_SuggestHeroPick {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_SuggestHeroRole {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_KillcamDamageTaken {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_SelectPenaltyGold {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_RollDiceResult {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_FlipCoinResult {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMessage_RequestItemSuggestions {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMessage_TeamCaptainChanged {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_ChatWheelCooldown {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_HeroRelicProgress {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_AbilityDraftRequestAbility {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_DamageReport {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_SalutePlayer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_GiftPlayer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_TipAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_ReplaceQueryUnit {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_ESArcanaCombo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_ESArcanaComboSummary {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_OMArcanaCombo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_HighFiveCompleted {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_HighFiveLeftHanging {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_ShovelUnearth {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_AllStarEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_QueuedOrderRemoved {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_DebugChallenge {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_FoundNeutralItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_OutpostCaptured {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_OutpostGrantedXP {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_MoveCameraToUnit {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_PauseMinigameData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_VersusScene_PlayerBehavior {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_QoP_ArcanaSummary {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_HotPotato_Created {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_HotPotato_Exploded {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_WK_Arcana_Progress {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_GuildChallenge_Progress {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_WRArcanaProgress {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_WRArcanaSummary {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_EmptyItemSlotAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_AghsStatusAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_MutedPlayers {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_ContextualTip {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_ChatMessage {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_RockPaperScissorsStarted {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_RockPaperScissorsFinished {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_DuelOpponentKilled {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_DuelAccepted {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_DuelRequested {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_PlayerDraftSuggestPick {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_PlayerDraftPick {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_FacetPing {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAUserMsg_InnatePing {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::MsgKindEnum for EDotaUserMessages {}
impl ::steam_vent_proto_common::MsgKindEnum for EDotaEntityMessages {}
