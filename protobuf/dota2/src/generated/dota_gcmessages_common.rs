// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_common.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CSODOTAGameAccountClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAGameAccountClient {
    // message fields
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.wins)
    pub wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.losses)
    pub losses: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.xp)
    pub xp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.level)
    pub level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.initial_skill)
    pub initial_skill: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.leaver_count)
    pub leaver_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.secondary_leaver_count)
    pub secondary_leaver_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.low_priority_until_date)
    pub low_priority_until_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.prevent_text_chat_until_date)
    pub prevent_text_chat_until_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.prevent_voice_until_date)
    pub prevent_voice_until_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.prevent_public_text_chat_until_date)
    pub prevent_public_text_chat_until_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.prevent_new_player_chat_until_date)
    pub prevent_new_player_chat_until_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.last_abandoned_game_date)
    pub last_abandoned_game_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.last_secondary_abandoned_game_date)
    pub last_secondary_abandoned_game_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.leaver_penalty_count)
    pub leaver_penalty_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.completed_game_streak)
    pub completed_game_streak: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.account_disabled_until_date)
    pub account_disabled_until_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.account_disabled_count)
    pub account_disabled_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.match_disabled_until_date)
    pub match_disabled_until_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.match_disabled_count)
    pub match_disabled_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.shutdownlawterminatetimestamp)
    pub shutdownlawterminatetimestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.low_priority_games_remaining)
    pub low_priority_games_remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.recruitment_level)
    pub recruitment_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.has_new_notifications)
    pub has_new_notifications: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.is_league_admin)
    pub is_league_admin: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.casual_games_played)
    pub casual_games_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.solo_competitive_games_played)
    pub solo_competitive_games_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.party_competitive_games_played)
    pub party_competitive_games_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.casual_1v1_games_played)
    pub casual_1v1_games_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.curr_all_hero_challenge_id)
    pub curr_all_hero_challenge_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.play_time_points)
    pub play_time_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.account_flags)
    pub account_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.play_time_level)
    pub play_time_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.player_behavior_seq_num_last_report)
    pub player_behavior_seq_num_last_report: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.player_behavior_score_last_report)
    pub player_behavior_score_last_report: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.player_behavior_report_old_data)
    pub player_behavior_report_old_data: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.tourney_skill_level)
    pub tourney_skill_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.tourney_recent_participation_date)
    pub tourney_recent_participation_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.anchored_phone_number_id)
    pub anchored_phone_number_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.ranked_matchmaking_ban_until_date)
    pub ranked_matchmaking_ban_until_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.recent_game_time_1)
    pub recent_game_time_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.recent_game_time_2)
    pub recent_game_time_2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.recent_game_time_3)
    pub recent_game_time_3: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.favorite_team_packed)
    pub favorite_team_packed: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.recent_report_time)
    pub recent_report_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.custom_game_disabled_until_date)
    pub custom_game_disabled_until_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.recent_win_time_1)
    pub recent_win_time_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.recent_win_time_2)
    pub recent_win_time_2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.recent_win_time_3)
    pub recent_win_time_3: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.coach_rating)
    pub coach_rating: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.queue_points)
    pub queue_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.role_handicaps)
    pub role_handicaps: ::std::vec::Vec<csodotagame_account_client::RoleHandicap>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.event_mode_recent_time)
    pub event_mode_recent_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.mmr_recalibration_time)
    pub mmr_recalibration_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountClient.banned_hero_ids)
    pub banned_hero_ids: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSODOTAGameAccountClient.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAGameAccountClient {
    fn default() -> &'a CSODOTAGameAccountClient {
        <CSODOTAGameAccountClient as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSODOTAGameAccountClient {
    pub fn new() -> CSODOTAGameAccountClient {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 wins = 3;

    pub fn wins(&self) -> u32 {
        self.wins.unwrap_or(0)
    }

    pub fn clear_wins(&mut self) {
        self.wins = ::std::option::Option::None;
    }

    pub fn has_wins(&self) -> bool {
        self.wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wins(&mut self, v: u32) {
        self.wins = ::std::option::Option::Some(v);
    }

    // optional uint32 losses = 4;

    pub fn losses(&self) -> u32 {
        self.losses.unwrap_or(0)
    }

    pub fn clear_losses(&mut self) {
        self.losses = ::std::option::Option::None;
    }

    pub fn has_losses(&self) -> bool {
        self.losses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_losses(&mut self, v: u32) {
        self.losses = ::std::option::Option::Some(v);
    }

    // optional uint32 xp = 12;

    pub fn xp(&self) -> u32 {
        self.xp.unwrap_or(0)
    }

    pub fn clear_xp(&mut self) {
        self.xp = ::std::option::Option::None;
    }

    pub fn has_xp(&self) -> bool {
        self.xp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp(&mut self, v: u32) {
        self.xp = ::std::option::Option::Some(v);
    }

    // optional uint32 level = 13;

    pub fn level(&self) -> u32 {
        self.level.unwrap_or(0)
    }

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_skill = 14;

    pub fn initial_skill(&self) -> u32 {
        self.initial_skill.unwrap_or(0)
    }

    pub fn clear_initial_skill(&mut self) {
        self.initial_skill = ::std::option::Option::None;
    }

    pub fn has_initial_skill(&self) -> bool {
        self.initial_skill.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_skill(&mut self, v: u32) {
        self.initial_skill = ::std::option::Option::Some(v);
    }

    // optional uint32 leaver_count = 15;

    pub fn leaver_count(&self) -> u32 {
        self.leaver_count.unwrap_or(0)
    }

    pub fn clear_leaver_count(&mut self) {
        self.leaver_count = ::std::option::Option::None;
    }

    pub fn has_leaver_count(&self) -> bool {
        self.leaver_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaver_count(&mut self, v: u32) {
        self.leaver_count = ::std::option::Option::Some(v);
    }

    // optional uint32 secondary_leaver_count = 58;

    pub fn secondary_leaver_count(&self) -> u32 {
        self.secondary_leaver_count.unwrap_or(0)
    }

    pub fn clear_secondary_leaver_count(&mut self) {
        self.secondary_leaver_count = ::std::option::Option::None;
    }

    pub fn has_secondary_leaver_count(&self) -> bool {
        self.secondary_leaver_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondary_leaver_count(&mut self, v: u32) {
        self.secondary_leaver_count = ::std::option::Option::Some(v);
    }

    // optional uint32 low_priority_until_date = 18;

    pub fn low_priority_until_date(&self) -> u32 {
        self.low_priority_until_date.unwrap_or(0)
    }

    pub fn clear_low_priority_until_date(&mut self) {
        self.low_priority_until_date = ::std::option::Option::None;
    }

    pub fn has_low_priority_until_date(&self) -> bool {
        self.low_priority_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority_until_date(&mut self, v: u32) {
        self.low_priority_until_date = ::std::option::Option::Some(v);
    }

    // optional uint32 prevent_text_chat_until_date = 20;

    pub fn prevent_text_chat_until_date(&self) -> u32 {
        self.prevent_text_chat_until_date.unwrap_or(0)
    }

    pub fn clear_prevent_text_chat_until_date(&mut self) {
        self.prevent_text_chat_until_date = ::std::option::Option::None;
    }

    pub fn has_prevent_text_chat_until_date(&self) -> bool {
        self.prevent_text_chat_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevent_text_chat_until_date(&mut self, v: u32) {
        self.prevent_text_chat_until_date = ::std::option::Option::Some(v);
    }

    // optional uint32 prevent_voice_until_date = 21;

    pub fn prevent_voice_until_date(&self) -> u32 {
        self.prevent_voice_until_date.unwrap_or(0)
    }

    pub fn clear_prevent_voice_until_date(&mut self) {
        self.prevent_voice_until_date = ::std::option::Option::None;
    }

    pub fn has_prevent_voice_until_date(&self) -> bool {
        self.prevent_voice_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevent_voice_until_date(&mut self, v: u32) {
        self.prevent_voice_until_date = ::std::option::Option::Some(v);
    }

    // optional uint32 prevent_public_text_chat_until_date = 86;

    pub fn prevent_public_text_chat_until_date(&self) -> u32 {
        self.prevent_public_text_chat_until_date.unwrap_or(0)
    }

    pub fn clear_prevent_public_text_chat_until_date(&mut self) {
        self.prevent_public_text_chat_until_date = ::std::option::Option::None;
    }

    pub fn has_prevent_public_text_chat_until_date(&self) -> bool {
        self.prevent_public_text_chat_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevent_public_text_chat_until_date(&mut self, v: u32) {
        self.prevent_public_text_chat_until_date = ::std::option::Option::Some(v);
    }

    // optional uint32 prevent_new_player_chat_until_date = 122;

    pub fn prevent_new_player_chat_until_date(&self) -> u32 {
        self.prevent_new_player_chat_until_date.unwrap_or(0)
    }

    pub fn clear_prevent_new_player_chat_until_date(&mut self) {
        self.prevent_new_player_chat_until_date = ::std::option::Option::None;
    }

    pub fn has_prevent_new_player_chat_until_date(&self) -> bool {
        self.prevent_new_player_chat_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevent_new_player_chat_until_date(&mut self, v: u32) {
        self.prevent_new_player_chat_until_date = ::std::option::Option::Some(v);
    }

    // optional uint32 last_abandoned_game_date = 22;

    pub fn last_abandoned_game_date(&self) -> u32 {
        self.last_abandoned_game_date.unwrap_or(0)
    }

    pub fn clear_last_abandoned_game_date(&mut self) {
        self.last_abandoned_game_date = ::std::option::Option::None;
    }

    pub fn has_last_abandoned_game_date(&self) -> bool {
        self.last_abandoned_game_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_abandoned_game_date(&mut self, v: u32) {
        self.last_abandoned_game_date = ::std::option::Option::Some(v);
    }

    // optional uint32 last_secondary_abandoned_game_date = 59;

    pub fn last_secondary_abandoned_game_date(&self) -> u32 {
        self.last_secondary_abandoned_game_date.unwrap_or(0)
    }

    pub fn clear_last_secondary_abandoned_game_date(&mut self) {
        self.last_secondary_abandoned_game_date = ::std::option::Option::None;
    }

    pub fn has_last_secondary_abandoned_game_date(&self) -> bool {
        self.last_secondary_abandoned_game_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_secondary_abandoned_game_date(&mut self, v: u32) {
        self.last_secondary_abandoned_game_date = ::std::option::Option::Some(v);
    }

    // optional uint32 leaver_penalty_count = 23;

    pub fn leaver_penalty_count(&self) -> u32 {
        self.leaver_penalty_count.unwrap_or(0)
    }

    pub fn clear_leaver_penalty_count(&mut self) {
        self.leaver_penalty_count = ::std::option::Option::None;
    }

    pub fn has_leaver_penalty_count(&self) -> bool {
        self.leaver_penalty_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaver_penalty_count(&mut self, v: u32) {
        self.leaver_penalty_count = ::std::option::Option::Some(v);
    }

    // optional uint32 completed_game_streak = 24;

    pub fn completed_game_streak(&self) -> u32 {
        self.completed_game_streak.unwrap_or(0)
    }

    pub fn clear_completed_game_streak(&mut self) {
        self.completed_game_streak = ::std::option::Option::None;
    }

    pub fn has_completed_game_streak(&self) -> bool {
        self.completed_game_streak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed_game_streak(&mut self, v: u32) {
        self.completed_game_streak = ::std::option::Option::Some(v);
    }

    // optional uint32 account_disabled_until_date = 38;

    pub fn account_disabled_until_date(&self) -> u32 {
        self.account_disabled_until_date.unwrap_or(0)
    }

    pub fn clear_account_disabled_until_date(&mut self) {
        self.account_disabled_until_date = ::std::option::Option::None;
    }

    pub fn has_account_disabled_until_date(&self) -> bool {
        self.account_disabled_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_disabled_until_date(&mut self, v: u32) {
        self.account_disabled_until_date = ::std::option::Option::Some(v);
    }

    // optional uint32 account_disabled_count = 39;

    pub fn account_disabled_count(&self) -> u32 {
        self.account_disabled_count.unwrap_or(0)
    }

    pub fn clear_account_disabled_count(&mut self) {
        self.account_disabled_count = ::std::option::Option::None;
    }

    pub fn has_account_disabled_count(&self) -> bool {
        self.account_disabled_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_disabled_count(&mut self, v: u32) {
        self.account_disabled_count = ::std::option::Option::Some(v);
    }

    // optional uint32 match_disabled_until_date = 41;

    pub fn match_disabled_until_date(&self) -> u32 {
        self.match_disabled_until_date.unwrap_or(0)
    }

    pub fn clear_match_disabled_until_date(&mut self) {
        self.match_disabled_until_date = ::std::option::Option::None;
    }

    pub fn has_match_disabled_until_date(&self) -> bool {
        self.match_disabled_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_disabled_until_date(&mut self, v: u32) {
        self.match_disabled_until_date = ::std::option::Option::Some(v);
    }

    // optional uint32 match_disabled_count = 42;

    pub fn match_disabled_count(&self) -> u32 {
        self.match_disabled_count.unwrap_or(0)
    }

    pub fn clear_match_disabled_count(&mut self) {
        self.match_disabled_count = ::std::option::Option::None;
    }

    pub fn has_match_disabled_count(&self) -> bool {
        self.match_disabled_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_disabled_count(&mut self, v: u32) {
        self.match_disabled_count = ::std::option::Option::Some(v);
    }

    // optional uint32 shutdownlawterminatetimestamp = 47;

    pub fn shutdownlawterminatetimestamp(&self) -> u32 {
        self.shutdownlawterminatetimestamp.unwrap_or(0)
    }

    pub fn clear_shutdownlawterminatetimestamp(&mut self) {
        self.shutdownlawterminatetimestamp = ::std::option::Option::None;
    }

    pub fn has_shutdownlawterminatetimestamp(&self) -> bool {
        self.shutdownlawterminatetimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shutdownlawterminatetimestamp(&mut self, v: u32) {
        self.shutdownlawterminatetimestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 low_priority_games_remaining = 48;

    pub fn low_priority_games_remaining(&self) -> u32 {
        self.low_priority_games_remaining.unwrap_or(0)
    }

    pub fn clear_low_priority_games_remaining(&mut self) {
        self.low_priority_games_remaining = ::std::option::Option::None;
    }

    pub fn has_low_priority_games_remaining(&self) -> bool {
        self.low_priority_games_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority_games_remaining(&mut self, v: u32) {
        self.low_priority_games_remaining = ::std::option::Option::Some(v);
    }

    // optional uint32 recruitment_level = 55;

    pub fn recruitment_level(&self) -> u32 {
        self.recruitment_level.unwrap_or(0)
    }

    pub fn clear_recruitment_level(&mut self) {
        self.recruitment_level = ::std::option::Option::None;
    }

    pub fn has_recruitment_level(&self) -> bool {
        self.recruitment_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recruitment_level(&mut self, v: u32) {
        self.recruitment_level = ::std::option::Option::Some(v);
    }

    // optional bool has_new_notifications = 56;

    pub fn has_new_notifications(&self) -> bool {
        self.has_new_notifications.unwrap_or(false)
    }

    pub fn clear_has_new_notifications(&mut self) {
        self.has_new_notifications = ::std::option::Option::None;
    }

    pub fn has_has_new_notifications(&self) -> bool {
        self.has_new_notifications.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_new_notifications(&mut self, v: bool) {
        self.has_new_notifications = ::std::option::Option::Some(v);
    }

    // optional bool is_league_admin = 57;

    pub fn is_league_admin(&self) -> bool {
        self.is_league_admin.unwrap_or(false)
    }

    pub fn clear_is_league_admin(&mut self) {
        self.is_league_admin = ::std::option::Option::None;
    }

    pub fn has_is_league_admin(&self) -> bool {
        self.is_league_admin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_league_admin(&mut self, v: bool) {
        self.is_league_admin = ::std::option::Option::Some(v);
    }

    // optional uint32 casual_games_played = 60;

    pub fn casual_games_played(&self) -> u32 {
        self.casual_games_played.unwrap_or(0)
    }

    pub fn clear_casual_games_played(&mut self) {
        self.casual_games_played = ::std::option::Option::None;
    }

    pub fn has_casual_games_played(&self) -> bool {
        self.casual_games_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_casual_games_played(&mut self, v: u32) {
        self.casual_games_played = ::std::option::Option::Some(v);
    }

    // optional uint32 solo_competitive_games_played = 61;

    pub fn solo_competitive_games_played(&self) -> u32 {
        self.solo_competitive_games_played.unwrap_or(0)
    }

    pub fn clear_solo_competitive_games_played(&mut self) {
        self.solo_competitive_games_played = ::std::option::Option::None;
    }

    pub fn has_solo_competitive_games_played(&self) -> bool {
        self.solo_competitive_games_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solo_competitive_games_played(&mut self, v: u32) {
        self.solo_competitive_games_played = ::std::option::Option::Some(v);
    }

    // optional uint32 party_competitive_games_played = 62;

    pub fn party_competitive_games_played(&self) -> u32 {
        self.party_competitive_games_played.unwrap_or(0)
    }

    pub fn clear_party_competitive_games_played(&mut self) {
        self.party_competitive_games_played = ::std::option::Option::None;
    }

    pub fn has_party_competitive_games_played(&self) -> bool {
        self.party_competitive_games_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_competitive_games_played(&mut self, v: u32) {
        self.party_competitive_games_played = ::std::option::Option::Some(v);
    }

    // optional uint32 casual_1v1_games_played = 65;

    pub fn casual_1v1_games_played(&self) -> u32 {
        self.casual_1v1_games_played.unwrap_or(0)
    }

    pub fn clear_casual_1v1_games_played(&mut self) {
        self.casual_1v1_games_played = ::std::option::Option::None;
    }

    pub fn has_casual_1v1_games_played(&self) -> bool {
        self.casual_1v1_games_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_casual_1v1_games_played(&mut self, v: u32) {
        self.casual_1v1_games_played = ::std::option::Option::Some(v);
    }

    // optional int32 curr_all_hero_challenge_id = 67;

    pub fn curr_all_hero_challenge_id(&self) -> i32 {
        self.curr_all_hero_challenge_id.unwrap_or(0)
    }

    pub fn clear_curr_all_hero_challenge_id(&mut self) {
        self.curr_all_hero_challenge_id = ::std::option::Option::None;
    }

    pub fn has_curr_all_hero_challenge_id(&self) -> bool {
        self.curr_all_hero_challenge_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_curr_all_hero_challenge_id(&mut self, v: i32) {
        self.curr_all_hero_challenge_id = ::std::option::Option::Some(v);
    }

    // optional uint32 play_time_points = 68;

    pub fn play_time_points(&self) -> u32 {
        self.play_time_points.unwrap_or(0)
    }

    pub fn clear_play_time_points(&mut self) {
        self.play_time_points = ::std::option::Option::None;
    }

    pub fn has_play_time_points(&self) -> bool {
        self.play_time_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_play_time_points(&mut self, v: u32) {
        self.play_time_points = ::std::option::Option::Some(v);
    }

    // optional uint32 account_flags = 69;

    pub fn account_flags(&self) -> u32 {
        self.account_flags.unwrap_or(0)
    }

    pub fn clear_account_flags(&mut self) {
        self.account_flags = ::std::option::Option::None;
    }

    pub fn has_account_flags(&self) -> bool {
        self.account_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_flags(&mut self, v: u32) {
        self.account_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 play_time_level = 70;

    pub fn play_time_level(&self) -> u32 {
        self.play_time_level.unwrap_or(0)
    }

    pub fn clear_play_time_level(&mut self) {
        self.play_time_level = ::std::option::Option::None;
    }

    pub fn has_play_time_level(&self) -> bool {
        self.play_time_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_play_time_level(&mut self, v: u32) {
        self.play_time_level = ::std::option::Option::Some(v);
    }

    // optional uint32 player_behavior_seq_num_last_report = 71;

    pub fn player_behavior_seq_num_last_report(&self) -> u32 {
        self.player_behavior_seq_num_last_report.unwrap_or(0)
    }

    pub fn clear_player_behavior_seq_num_last_report(&mut self) {
        self.player_behavior_seq_num_last_report = ::std::option::Option::None;
    }

    pub fn has_player_behavior_seq_num_last_report(&self) -> bool {
        self.player_behavior_seq_num_last_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_behavior_seq_num_last_report(&mut self, v: u32) {
        self.player_behavior_seq_num_last_report = ::std::option::Option::Some(v);
    }

    // optional uint32 player_behavior_score_last_report = 72;

    pub fn player_behavior_score_last_report(&self) -> u32 {
        self.player_behavior_score_last_report.unwrap_or(0)
    }

    pub fn clear_player_behavior_score_last_report(&mut self) {
        self.player_behavior_score_last_report = ::std::option::Option::None;
    }

    pub fn has_player_behavior_score_last_report(&self) -> bool {
        self.player_behavior_score_last_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_behavior_score_last_report(&mut self, v: u32) {
        self.player_behavior_score_last_report = ::std::option::Option::Some(v);
    }

    // optional bool player_behavior_report_old_data = 73;

    pub fn player_behavior_report_old_data(&self) -> bool {
        self.player_behavior_report_old_data.unwrap_or(false)
    }

    pub fn clear_player_behavior_report_old_data(&mut self) {
        self.player_behavior_report_old_data = ::std::option::Option::None;
    }

    pub fn has_player_behavior_report_old_data(&self) -> bool {
        self.player_behavior_report_old_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_behavior_report_old_data(&mut self, v: bool) {
        self.player_behavior_report_old_data = ::std::option::Option::Some(v);
    }

    // optional uint32 tourney_skill_level = 74;

    pub fn tourney_skill_level(&self) -> u32 {
        self.tourney_skill_level.unwrap_or(0)
    }

    pub fn clear_tourney_skill_level(&mut self) {
        self.tourney_skill_level = ::std::option::Option::None;
    }

    pub fn has_tourney_skill_level(&self) -> bool {
        self.tourney_skill_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tourney_skill_level(&mut self, v: u32) {
        self.tourney_skill_level = ::std::option::Option::Some(v);
    }

    // optional uint32 tourney_recent_participation_date = 85;

    pub fn tourney_recent_participation_date(&self) -> u32 {
        self.tourney_recent_participation_date.unwrap_or(0)
    }

    pub fn clear_tourney_recent_participation_date(&mut self) {
        self.tourney_recent_participation_date = ::std::option::Option::None;
    }

    pub fn has_tourney_recent_participation_date(&self) -> bool {
        self.tourney_recent_participation_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tourney_recent_participation_date(&mut self, v: u32) {
        self.tourney_recent_participation_date = ::std::option::Option::Some(v);
    }

    // optional uint64 anchored_phone_number_id = 88;

    pub fn anchored_phone_number_id(&self) -> u64 {
        self.anchored_phone_number_id.unwrap_or(0)
    }

    pub fn clear_anchored_phone_number_id(&mut self) {
        self.anchored_phone_number_id = ::std::option::Option::None;
    }

    pub fn has_anchored_phone_number_id(&self) -> bool {
        self.anchored_phone_number_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_anchored_phone_number_id(&mut self, v: u64) {
        self.anchored_phone_number_id = ::std::option::Option::Some(v);
    }

    // optional uint32 ranked_matchmaking_ban_until_date = 89;

    pub fn ranked_matchmaking_ban_until_date(&self) -> u32 {
        self.ranked_matchmaking_ban_until_date.unwrap_or(0)
    }

    pub fn clear_ranked_matchmaking_ban_until_date(&mut self) {
        self.ranked_matchmaking_ban_until_date = ::std::option::Option::None;
    }

    pub fn has_ranked_matchmaking_ban_until_date(&self) -> bool {
        self.ranked_matchmaking_ban_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranked_matchmaking_ban_until_date(&mut self, v: u32) {
        self.ranked_matchmaking_ban_until_date = ::std::option::Option::Some(v);
    }

    // optional uint32 recent_game_time_1 = 90;

    pub fn recent_game_time_1(&self) -> u32 {
        self.recent_game_time_1.unwrap_or(0)
    }

    pub fn clear_recent_game_time_1(&mut self) {
        self.recent_game_time_1 = ::std::option::Option::None;
    }

    pub fn has_recent_game_time_1(&self) -> bool {
        self.recent_game_time_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_game_time_1(&mut self, v: u32) {
        self.recent_game_time_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 recent_game_time_2 = 91;

    pub fn recent_game_time_2(&self) -> u32 {
        self.recent_game_time_2.unwrap_or(0)
    }

    pub fn clear_recent_game_time_2(&mut self) {
        self.recent_game_time_2 = ::std::option::Option::None;
    }

    pub fn has_recent_game_time_2(&self) -> bool {
        self.recent_game_time_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_game_time_2(&mut self, v: u32) {
        self.recent_game_time_2 = ::std::option::Option::Some(v);
    }

    // optional uint32 recent_game_time_3 = 92;

    pub fn recent_game_time_3(&self) -> u32 {
        self.recent_game_time_3.unwrap_or(0)
    }

    pub fn clear_recent_game_time_3(&mut self) {
        self.recent_game_time_3 = ::std::option::Option::None;
    }

    pub fn has_recent_game_time_3(&self) -> bool {
        self.recent_game_time_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_game_time_3(&mut self, v: u32) {
        self.recent_game_time_3 = ::std::option::Option::Some(v);
    }

    // optional uint64 favorite_team_packed = 103;

    pub fn favorite_team_packed(&self) -> u64 {
        self.favorite_team_packed.unwrap_or(0)
    }

    pub fn clear_favorite_team_packed(&mut self) {
        self.favorite_team_packed = ::std::option::Option::None;
    }

    pub fn has_favorite_team_packed(&self) -> bool {
        self.favorite_team_packed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite_team_packed(&mut self, v: u64) {
        self.favorite_team_packed = ::std::option::Option::Some(v);
    }

    // optional uint32 recent_report_time = 104;

    pub fn recent_report_time(&self) -> u32 {
        self.recent_report_time.unwrap_or(0)
    }

    pub fn clear_recent_report_time(&mut self) {
        self.recent_report_time = ::std::option::Option::None;
    }

    pub fn has_recent_report_time(&self) -> bool {
        self.recent_report_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_report_time(&mut self, v: u32) {
        self.recent_report_time = ::std::option::Option::Some(v);
    }

    // optional uint32 custom_game_disabled_until_date = 105;

    pub fn custom_game_disabled_until_date(&self) -> u32 {
        self.custom_game_disabled_until_date.unwrap_or(0)
    }

    pub fn clear_custom_game_disabled_until_date(&mut self) {
        self.custom_game_disabled_until_date = ::std::option::Option::None;
    }

    pub fn has_custom_game_disabled_until_date(&self) -> bool {
        self.custom_game_disabled_until_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_disabled_until_date(&mut self, v: u32) {
        self.custom_game_disabled_until_date = ::std::option::Option::Some(v);
    }

    // optional uint32 recent_win_time_1 = 106;

    pub fn recent_win_time_1(&self) -> u32 {
        self.recent_win_time_1.unwrap_or(0)
    }

    pub fn clear_recent_win_time_1(&mut self) {
        self.recent_win_time_1 = ::std::option::Option::None;
    }

    pub fn has_recent_win_time_1(&self) -> bool {
        self.recent_win_time_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_win_time_1(&mut self, v: u32) {
        self.recent_win_time_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 recent_win_time_2 = 107;

    pub fn recent_win_time_2(&self) -> u32 {
        self.recent_win_time_2.unwrap_or(0)
    }

    pub fn clear_recent_win_time_2(&mut self) {
        self.recent_win_time_2 = ::std::option::Option::None;
    }

    pub fn has_recent_win_time_2(&self) -> bool {
        self.recent_win_time_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_win_time_2(&mut self, v: u32) {
        self.recent_win_time_2 = ::std::option::Option::Some(v);
    }

    // optional uint32 recent_win_time_3 = 108;

    pub fn recent_win_time_3(&self) -> u32 {
        self.recent_win_time_3.unwrap_or(0)
    }

    pub fn clear_recent_win_time_3(&mut self) {
        self.recent_win_time_3 = ::std::option::Option::None;
    }

    pub fn has_recent_win_time_3(&self) -> bool {
        self.recent_win_time_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_win_time_3(&mut self, v: u32) {
        self.recent_win_time_3 = ::std::option::Option::Some(v);
    }

    // optional uint32 coach_rating = 109;

    pub fn coach_rating(&self) -> u32 {
        self.coach_rating.unwrap_or(0)
    }

    pub fn clear_coach_rating(&mut self) {
        self.coach_rating = ::std::option::Option::None;
    }

    pub fn has_coach_rating(&self) -> bool {
        self.coach_rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coach_rating(&mut self, v: u32) {
        self.coach_rating = ::std::option::Option::Some(v);
    }

    // optional uint32 queue_points = 114;

    pub fn queue_points(&self) -> u32 {
        self.queue_points.unwrap_or(0)
    }

    pub fn clear_queue_points(&mut self) {
        self.queue_points = ::std::option::Option::None;
    }

    pub fn has_queue_points(&self) -> bool {
        self.queue_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_points(&mut self, v: u32) {
        self.queue_points = ::std::option::Option::Some(v);
    }

    // optional uint32 event_mode_recent_time = 120;

    pub fn event_mode_recent_time(&self) -> u32 {
        self.event_mode_recent_time.unwrap_or(0)
    }

    pub fn clear_event_mode_recent_time(&mut self) {
        self.event_mode_recent_time = ::std::option::Option::None;
    }

    pub fn has_event_mode_recent_time(&self) -> bool {
        self.event_mode_recent_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_mode_recent_time(&mut self, v: u32) {
        self.event_mode_recent_time = ::std::option::Option::Some(v);
    }

    // optional uint32 mmr_recalibration_time = 121;

    pub fn mmr_recalibration_time(&self) -> u32 {
        self.mmr_recalibration_time.unwrap_or(0)
    }

    pub fn clear_mmr_recalibration_time(&mut self) {
        self.mmr_recalibration_time = ::std::option::Option::None;
    }

    pub fn has_mmr_recalibration_time(&self) -> bool {
        self.mmr_recalibration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mmr_recalibration_time(&mut self, v: u32) {
        self.mmr_recalibration_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSODOTAGameAccountClient {
    const NAME: &'static str = "CSODOTAGameAccountClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.losses = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.xp = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.level = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.initial_skill = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.leaver_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                464 => {
                    self.secondary_leaver_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.low_priority_until_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.prevent_text_chat_until_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.prevent_voice_until_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                688 => {
                    self.prevent_public_text_chat_until_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                976 => {
                    self.prevent_new_player_chat_until_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.last_abandoned_game_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                472 => {
                    self.last_secondary_abandoned_game_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.leaver_penalty_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.completed_game_streak = ::std::option::Option::Some(is.read_uint32()?);
                },
                304 => {
                    self.account_disabled_until_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                312 => {
                    self.account_disabled_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                328 => {
                    self.match_disabled_until_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                336 => {
                    self.match_disabled_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                376 => {
                    self.shutdownlawterminatetimestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                384 => {
                    self.low_priority_games_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                440 => {
                    self.recruitment_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                448 => {
                    self.has_new_notifications = ::std::option::Option::Some(is.read_bool()?);
                },
                456 => {
                    self.is_league_admin = ::std::option::Option::Some(is.read_bool()?);
                },
                480 => {
                    self.casual_games_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                488 => {
                    self.solo_competitive_games_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                496 => {
                    self.party_competitive_games_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                520 => {
                    self.casual_1v1_games_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                536 => {
                    self.curr_all_hero_challenge_id = ::std::option::Option::Some(is.read_int32()?);
                },
                544 => {
                    self.play_time_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                552 => {
                    self.account_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                560 => {
                    self.play_time_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                568 => {
                    self.player_behavior_seq_num_last_report = ::std::option::Option::Some(is.read_uint32()?);
                },
                576 => {
                    self.player_behavior_score_last_report = ::std::option::Option::Some(is.read_uint32()?);
                },
                584 => {
                    self.player_behavior_report_old_data = ::std::option::Option::Some(is.read_bool()?);
                },
                592 => {
                    self.tourney_skill_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                680 => {
                    self.tourney_recent_participation_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                704 => {
                    self.anchored_phone_number_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                712 => {
                    self.ranked_matchmaking_ban_until_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                720 => {
                    self.recent_game_time_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                728 => {
                    self.recent_game_time_2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                736 => {
                    self.recent_game_time_3 = ::std::option::Option::Some(is.read_uint32()?);
                },
                824 => {
                    self.favorite_team_packed = ::std::option::Option::Some(is.read_uint64()?);
                },
                832 => {
                    self.recent_report_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                840 => {
                    self.custom_game_disabled_until_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                848 => {
                    self.recent_win_time_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                856 => {
                    self.recent_win_time_2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                864 => {
                    self.recent_win_time_3 = ::std::option::Option::Some(is.read_uint32()?);
                },
                872 => {
                    self.coach_rating = ::std::option::Option::Some(is.read_uint32()?);
                },
                912 => {
                    self.queue_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                922 => {
                    self.role_handicaps.push(is.read_message()?);
                },
                960 => {
                    self.event_mode_recent_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                968 => {
                    self.mmr_recalibration_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                986 => {
                    is.read_repeated_packed_int32_into(&mut self.banned_hero_ids)?;
                },
                984 => {
                    self.banned_hero_ids.push(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.wins {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.losses {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.xp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.initial_skill {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.leaver_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.secondary_leaver_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(58, v);
        }
        if let Some(v) = self.low_priority_until_date {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.prevent_text_chat_until_date {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.prevent_voice_until_date {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.prevent_public_text_chat_until_date {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(86, v);
        }
        if let Some(v) = self.prevent_new_player_chat_until_date {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(122, v);
        }
        if let Some(v) = self.last_abandoned_game_date {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.last_secondary_abandoned_game_date {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(59, v);
        }
        if let Some(v) = self.leaver_penalty_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.completed_game_streak {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.account_disabled_until_date {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(38, v);
        }
        if let Some(v) = self.account_disabled_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(39, v);
        }
        if let Some(v) = self.match_disabled_until_date {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(41, v);
        }
        if let Some(v) = self.match_disabled_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(42, v);
        }
        if let Some(v) = self.shutdownlawterminatetimestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(47, v);
        }
        if let Some(v) = self.low_priority_games_remaining {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(48, v);
        }
        if let Some(v) = self.recruitment_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(55, v);
        }
        if let Some(v) = self.has_new_notifications {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_league_admin {
            my_size += 2 + 1;
        }
        if let Some(v) = self.casual_games_played {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(60, v);
        }
        if let Some(v) = self.solo_competitive_games_played {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(61, v);
        }
        if let Some(v) = self.party_competitive_games_played {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(62, v);
        }
        if let Some(v) = self.casual_1v1_games_played {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(65, v);
        }
        if let Some(v) = self.curr_all_hero_challenge_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(67, v);
        }
        if let Some(v) = self.play_time_points {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(68, v);
        }
        if let Some(v) = self.account_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(69, v);
        }
        if let Some(v) = self.play_time_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(70, v);
        }
        if let Some(v) = self.player_behavior_seq_num_last_report {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(71, v);
        }
        if let Some(v) = self.player_behavior_score_last_report {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(72, v);
        }
        if let Some(v) = self.player_behavior_report_old_data {
            my_size += 2 + 1;
        }
        if let Some(v) = self.tourney_skill_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(74, v);
        }
        if let Some(v) = self.tourney_recent_participation_date {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(85, v);
        }
        if let Some(v) = self.anchored_phone_number_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(88, v);
        }
        if let Some(v) = self.ranked_matchmaking_ban_until_date {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(89, v);
        }
        if let Some(v) = self.recent_game_time_1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(90, v);
        }
        if let Some(v) = self.recent_game_time_2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(91, v);
        }
        if let Some(v) = self.recent_game_time_3 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(92, v);
        }
        if let Some(v) = self.favorite_team_packed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(103, v);
        }
        if let Some(v) = self.recent_report_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(104, v);
        }
        if let Some(v) = self.custom_game_disabled_until_date {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(105, v);
        }
        if let Some(v) = self.recent_win_time_1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(106, v);
        }
        if let Some(v) = self.recent_win_time_2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(107, v);
        }
        if let Some(v) = self.recent_win_time_3 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(108, v);
        }
        if let Some(v) = self.coach_rating {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(109, v);
        }
        if let Some(v) = self.queue_points {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(114, v);
        }
        for value in &self.role_handicaps {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.event_mode_recent_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(120, v);
        }
        if let Some(v) = self.mmr_recalibration_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(121, v);
        }
        for value in &self.banned_hero_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(123, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.wins {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.losses {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.xp {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.initial_skill {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.leaver_count {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.secondary_leaver_count {
            os.write_uint32(58, v)?;
        }
        if let Some(v) = self.low_priority_until_date {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.prevent_text_chat_until_date {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.prevent_voice_until_date {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.prevent_public_text_chat_until_date {
            os.write_uint32(86, v)?;
        }
        if let Some(v) = self.prevent_new_player_chat_until_date {
            os.write_uint32(122, v)?;
        }
        if let Some(v) = self.last_abandoned_game_date {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.last_secondary_abandoned_game_date {
            os.write_uint32(59, v)?;
        }
        if let Some(v) = self.leaver_penalty_count {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.completed_game_streak {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.account_disabled_until_date {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.account_disabled_count {
            os.write_uint32(39, v)?;
        }
        if let Some(v) = self.match_disabled_until_date {
            os.write_uint32(41, v)?;
        }
        if let Some(v) = self.match_disabled_count {
            os.write_uint32(42, v)?;
        }
        if let Some(v) = self.shutdownlawterminatetimestamp {
            os.write_uint32(47, v)?;
        }
        if let Some(v) = self.low_priority_games_remaining {
            os.write_uint32(48, v)?;
        }
        if let Some(v) = self.recruitment_level {
            os.write_uint32(55, v)?;
        }
        if let Some(v) = self.has_new_notifications {
            os.write_bool(56, v)?;
        }
        if let Some(v) = self.is_league_admin {
            os.write_bool(57, v)?;
        }
        if let Some(v) = self.casual_games_played {
            os.write_uint32(60, v)?;
        }
        if let Some(v) = self.solo_competitive_games_played {
            os.write_uint32(61, v)?;
        }
        if let Some(v) = self.party_competitive_games_played {
            os.write_uint32(62, v)?;
        }
        if let Some(v) = self.casual_1v1_games_played {
            os.write_uint32(65, v)?;
        }
        if let Some(v) = self.curr_all_hero_challenge_id {
            os.write_int32(67, v)?;
        }
        if let Some(v) = self.play_time_points {
            os.write_uint32(68, v)?;
        }
        if let Some(v) = self.account_flags {
            os.write_uint32(69, v)?;
        }
        if let Some(v) = self.play_time_level {
            os.write_uint32(70, v)?;
        }
        if let Some(v) = self.player_behavior_seq_num_last_report {
            os.write_uint32(71, v)?;
        }
        if let Some(v) = self.player_behavior_score_last_report {
            os.write_uint32(72, v)?;
        }
        if let Some(v) = self.player_behavior_report_old_data {
            os.write_bool(73, v)?;
        }
        if let Some(v) = self.tourney_skill_level {
            os.write_uint32(74, v)?;
        }
        if let Some(v) = self.tourney_recent_participation_date {
            os.write_uint32(85, v)?;
        }
        if let Some(v) = self.anchored_phone_number_id {
            os.write_uint64(88, v)?;
        }
        if let Some(v) = self.ranked_matchmaking_ban_until_date {
            os.write_uint32(89, v)?;
        }
        if let Some(v) = self.recent_game_time_1 {
            os.write_uint32(90, v)?;
        }
        if let Some(v) = self.recent_game_time_2 {
            os.write_uint32(91, v)?;
        }
        if let Some(v) = self.recent_game_time_3 {
            os.write_uint32(92, v)?;
        }
        if let Some(v) = self.favorite_team_packed {
            os.write_uint64(103, v)?;
        }
        if let Some(v) = self.recent_report_time {
            os.write_uint32(104, v)?;
        }
        if let Some(v) = self.custom_game_disabled_until_date {
            os.write_uint32(105, v)?;
        }
        if let Some(v) = self.recent_win_time_1 {
            os.write_uint32(106, v)?;
        }
        if let Some(v) = self.recent_win_time_2 {
            os.write_uint32(107, v)?;
        }
        if let Some(v) = self.recent_win_time_3 {
            os.write_uint32(108, v)?;
        }
        if let Some(v) = self.coach_rating {
            os.write_uint32(109, v)?;
        }
        if let Some(v) = self.queue_points {
            os.write_uint32(114, v)?;
        }
        for v in &self.role_handicaps {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(115, v, os)?;
        };
        if let Some(v) = self.event_mode_recent_time {
            os.write_uint32(120, v)?;
        }
        if let Some(v) = self.mmr_recalibration_time {
            os.write_uint32(121, v)?;
        }
        for v in &self.banned_hero_ids {
            os.write_int32(123, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAGameAccountClient {
        CSODOTAGameAccountClient::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.wins = ::std::option::Option::None;
        self.losses = ::std::option::Option::None;
        self.xp = ::std::option::Option::None;
        self.level = ::std::option::Option::None;
        self.initial_skill = ::std::option::Option::None;
        self.leaver_count = ::std::option::Option::None;
        self.secondary_leaver_count = ::std::option::Option::None;
        self.low_priority_until_date = ::std::option::Option::None;
        self.prevent_text_chat_until_date = ::std::option::Option::None;
        self.prevent_voice_until_date = ::std::option::Option::None;
        self.prevent_public_text_chat_until_date = ::std::option::Option::None;
        self.prevent_new_player_chat_until_date = ::std::option::Option::None;
        self.last_abandoned_game_date = ::std::option::Option::None;
        self.last_secondary_abandoned_game_date = ::std::option::Option::None;
        self.leaver_penalty_count = ::std::option::Option::None;
        self.completed_game_streak = ::std::option::Option::None;
        self.account_disabled_until_date = ::std::option::Option::None;
        self.account_disabled_count = ::std::option::Option::None;
        self.match_disabled_until_date = ::std::option::Option::None;
        self.match_disabled_count = ::std::option::Option::None;
        self.shutdownlawterminatetimestamp = ::std::option::Option::None;
        self.low_priority_games_remaining = ::std::option::Option::None;
        self.recruitment_level = ::std::option::Option::None;
        self.has_new_notifications = ::std::option::Option::None;
        self.is_league_admin = ::std::option::Option::None;
        self.casual_games_played = ::std::option::Option::None;
        self.solo_competitive_games_played = ::std::option::Option::None;
        self.party_competitive_games_played = ::std::option::Option::None;
        self.casual_1v1_games_played = ::std::option::Option::None;
        self.curr_all_hero_challenge_id = ::std::option::Option::None;
        self.play_time_points = ::std::option::Option::None;
        self.account_flags = ::std::option::Option::None;
        self.play_time_level = ::std::option::Option::None;
        self.player_behavior_seq_num_last_report = ::std::option::Option::None;
        self.player_behavior_score_last_report = ::std::option::Option::None;
        self.player_behavior_report_old_data = ::std::option::Option::None;
        self.tourney_skill_level = ::std::option::Option::None;
        self.tourney_recent_participation_date = ::std::option::Option::None;
        self.anchored_phone_number_id = ::std::option::Option::None;
        self.ranked_matchmaking_ban_until_date = ::std::option::Option::None;
        self.recent_game_time_1 = ::std::option::Option::None;
        self.recent_game_time_2 = ::std::option::Option::None;
        self.recent_game_time_3 = ::std::option::Option::None;
        self.favorite_team_packed = ::std::option::Option::None;
        self.recent_report_time = ::std::option::Option::None;
        self.custom_game_disabled_until_date = ::std::option::Option::None;
        self.recent_win_time_1 = ::std::option::Option::None;
        self.recent_win_time_2 = ::std::option::Option::None;
        self.recent_win_time_3 = ::std::option::Option::None;
        self.coach_rating = ::std::option::Option::None;
        self.queue_points = ::std::option::Option::None;
        self.role_handicaps.clear();
        self.event_mode_recent_time = ::std::option::Option::None;
        self.mmr_recalibration_time = ::std::option::Option::None;
        self.banned_hero_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAGameAccountClient {
        static instance: CSODOTAGameAccountClient = CSODOTAGameAccountClient {
            account_id: ::std::option::Option::None,
            wins: ::std::option::Option::None,
            losses: ::std::option::Option::None,
            xp: ::std::option::Option::None,
            level: ::std::option::Option::None,
            initial_skill: ::std::option::Option::None,
            leaver_count: ::std::option::Option::None,
            secondary_leaver_count: ::std::option::Option::None,
            low_priority_until_date: ::std::option::Option::None,
            prevent_text_chat_until_date: ::std::option::Option::None,
            prevent_voice_until_date: ::std::option::Option::None,
            prevent_public_text_chat_until_date: ::std::option::Option::None,
            prevent_new_player_chat_until_date: ::std::option::Option::None,
            last_abandoned_game_date: ::std::option::Option::None,
            last_secondary_abandoned_game_date: ::std::option::Option::None,
            leaver_penalty_count: ::std::option::Option::None,
            completed_game_streak: ::std::option::Option::None,
            account_disabled_until_date: ::std::option::Option::None,
            account_disabled_count: ::std::option::Option::None,
            match_disabled_until_date: ::std::option::Option::None,
            match_disabled_count: ::std::option::Option::None,
            shutdownlawterminatetimestamp: ::std::option::Option::None,
            low_priority_games_remaining: ::std::option::Option::None,
            recruitment_level: ::std::option::Option::None,
            has_new_notifications: ::std::option::Option::None,
            is_league_admin: ::std::option::Option::None,
            casual_games_played: ::std::option::Option::None,
            solo_competitive_games_played: ::std::option::Option::None,
            party_competitive_games_played: ::std::option::Option::None,
            casual_1v1_games_played: ::std::option::Option::None,
            curr_all_hero_challenge_id: ::std::option::Option::None,
            play_time_points: ::std::option::Option::None,
            account_flags: ::std::option::Option::None,
            play_time_level: ::std::option::Option::None,
            player_behavior_seq_num_last_report: ::std::option::Option::None,
            player_behavior_score_last_report: ::std::option::Option::None,
            player_behavior_report_old_data: ::std::option::Option::None,
            tourney_skill_level: ::std::option::Option::None,
            tourney_recent_participation_date: ::std::option::Option::None,
            anchored_phone_number_id: ::std::option::Option::None,
            ranked_matchmaking_ban_until_date: ::std::option::Option::None,
            recent_game_time_1: ::std::option::Option::None,
            recent_game_time_2: ::std::option::Option::None,
            recent_game_time_3: ::std::option::Option::None,
            favorite_team_packed: ::std::option::Option::None,
            recent_report_time: ::std::option::Option::None,
            custom_game_disabled_until_date: ::std::option::Option::None,
            recent_win_time_1: ::std::option::Option::None,
            recent_win_time_2: ::std::option::Option::None,
            recent_win_time_3: ::std::option::Option::None,
            coach_rating: ::std::option::Option::None,
            queue_points: ::std::option::Option::None,
            role_handicaps: ::std::vec::Vec::new(),
            event_mode_recent_time: ::std::option::Option::None,
            mmr_recalibration_time: ::std::option::Option::None,
            banned_hero_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CSODOTAGameAccountClient`
pub mod csodotagame_account_client {
    // @@protoc_insertion_point(message:CSODOTAGameAccountClient.RoleHandicap)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RoleHandicap {
        // message fields
        // @@protoc_insertion_point(field:CSODOTAGameAccountClient.RoleHandicap.role)
        pub role: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSODOTAGameAccountClient.RoleHandicap.handicap)
        pub handicap: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CSODOTAGameAccountClient.RoleHandicap.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RoleHandicap {
        fn default() -> &'a RoleHandicap {
            <RoleHandicap as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl RoleHandicap {
        pub fn new() -> RoleHandicap {
            ::std::default::Default::default()
        }

        // optional uint32 role = 1;

        pub fn role(&self) -> u32 {
            self.role.unwrap_or(0)
        }

        pub fn clear_role(&mut self) {
            self.role = ::std::option::Option::None;
        }

        pub fn has_role(&self) -> bool {
            self.role.is_some()
        }

        // Param is passed by value, moved
        pub fn set_role(&mut self, v: u32) {
            self.role = ::std::option::Option::Some(v);
        }

        // optional float handicap = 2;

        pub fn handicap(&self) -> f32 {
            self.handicap.unwrap_or(0.)
        }

        pub fn clear_handicap(&mut self) {
            self.handicap = ::std::option::Option::None;
        }

        pub fn has_handicap(&self) -> bool {
            self.handicap.is_some()
        }

        // Param is passed by value, moved
        pub fn set_handicap(&mut self, v: f32) {
            self.handicap = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for RoleHandicap {
        const NAME: &'static str = "RoleHandicap";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.role = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    21 => {
                        self.handicap = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.role {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.handicap {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.role {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.handicap {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RoleHandicap {
            RoleHandicap::new()
        }

        fn clear(&mut self) {
            self.role = ::std::option::Option::None;
            self.handicap = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RoleHandicap {
            static instance: RoleHandicap = RoleHandicap {
                role: ::std::option::Option::None,
                handicap: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CSODOTAGameAccountPlus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAGameAccountPlus {
    // message fields
    // @@protoc_insertion_point(field:CSODOTAGameAccountPlus.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountPlus.original_start_date)
    pub original_start_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountPlus.plus_flags)
    pub plus_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountPlus.plus_status)
    pub plus_status: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountPlus.prepaid_time_start)
    pub prepaid_time_start: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountPlus.prepaid_time_balance)
    pub prepaid_time_balance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountPlus.next_payment_date)
    pub next_payment_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameAccountPlus.steam_agreement_id)
    pub steam_agreement_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSODOTAGameAccountPlus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAGameAccountPlus {
    fn default() -> &'a CSODOTAGameAccountPlus {
        <CSODOTAGameAccountPlus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSODOTAGameAccountPlus {
    pub fn new() -> CSODOTAGameAccountPlus {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 original_start_date = 2;

    pub fn original_start_date(&self) -> u32 {
        self.original_start_date.unwrap_or(0)
    }

    pub fn clear_original_start_date(&mut self) {
        self.original_start_date = ::std::option::Option::None;
    }

    pub fn has_original_start_date(&self) -> bool {
        self.original_start_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_start_date(&mut self, v: u32) {
        self.original_start_date = ::std::option::Option::Some(v);
    }

    // optional uint32 plus_flags = 3;

    pub fn plus_flags(&self) -> u32 {
        self.plus_flags.unwrap_or(0)
    }

    pub fn clear_plus_flags(&mut self) {
        self.plus_flags = ::std::option::Option::None;
    }

    pub fn has_plus_flags(&self) -> bool {
        self.plus_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plus_flags(&mut self, v: u32) {
        self.plus_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 plus_status = 4;

    pub fn plus_status(&self) -> u32 {
        self.plus_status.unwrap_or(0)
    }

    pub fn clear_plus_status(&mut self) {
        self.plus_status = ::std::option::Option::None;
    }

    pub fn has_plus_status(&self) -> bool {
        self.plus_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plus_status(&mut self, v: u32) {
        self.plus_status = ::std::option::Option::Some(v);
    }

    // optional uint32 prepaid_time_start = 5;

    pub fn prepaid_time_start(&self) -> u32 {
        self.prepaid_time_start.unwrap_or(0)
    }

    pub fn clear_prepaid_time_start(&mut self) {
        self.prepaid_time_start = ::std::option::Option::None;
    }

    pub fn has_prepaid_time_start(&self) -> bool {
        self.prepaid_time_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prepaid_time_start(&mut self, v: u32) {
        self.prepaid_time_start = ::std::option::Option::Some(v);
    }

    // optional uint32 prepaid_time_balance = 6;

    pub fn prepaid_time_balance(&self) -> u32 {
        self.prepaid_time_balance.unwrap_or(0)
    }

    pub fn clear_prepaid_time_balance(&mut self) {
        self.prepaid_time_balance = ::std::option::Option::None;
    }

    pub fn has_prepaid_time_balance(&self) -> bool {
        self.prepaid_time_balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prepaid_time_balance(&mut self, v: u32) {
        self.prepaid_time_balance = ::std::option::Option::Some(v);
    }

    // optional fixed32 next_payment_date = 7;

    pub fn next_payment_date(&self) -> u32 {
        self.next_payment_date.unwrap_or(0)
    }

    pub fn clear_next_payment_date(&mut self) {
        self.next_payment_date = ::std::option::Option::None;
    }

    pub fn has_next_payment_date(&self) -> bool {
        self.next_payment_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_payment_date(&mut self, v: u32) {
        self.next_payment_date = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_agreement_id = 8;

    pub fn steam_agreement_id(&self) -> u64 {
        self.steam_agreement_id.unwrap_or(0)
    }

    pub fn clear_steam_agreement_id(&mut self) {
        self.steam_agreement_id = ::std::option::Option::None;
    }

    pub fn has_steam_agreement_id(&self) -> bool {
        self.steam_agreement_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_agreement_id(&mut self, v: u64) {
        self.steam_agreement_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSODOTAGameAccountPlus {
    const NAME: &'static str = "CSODOTAGameAccountPlus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.original_start_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.plus_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.plus_status = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.prepaid_time_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.prepaid_time_balance = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.next_payment_date = ::std::option::Option::Some(is.read_fixed32()?);
                },
                65 => {
                    self.steam_agreement_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.original_start_date {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.plus_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.plus_status {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.prepaid_time_start {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.prepaid_time_balance {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.next_payment_date {
            my_size += 1 + 4;
        }
        if let Some(v) = self.steam_agreement_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.original_start_date {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.plus_flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.plus_status {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.prepaid_time_start {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.prepaid_time_balance {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.next_payment_date {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.steam_agreement_id {
            os.write_fixed64(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAGameAccountPlus {
        CSODOTAGameAccountPlus::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.original_start_date = ::std::option::Option::None;
        self.plus_flags = ::std::option::Option::None;
        self.plus_status = ::std::option::Option::None;
        self.prepaid_time_start = ::std::option::Option::None;
        self.prepaid_time_balance = ::std::option::Option::None;
        self.next_payment_date = ::std::option::Option::None;
        self.steam_agreement_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAGameAccountPlus {
        static instance: CSODOTAGameAccountPlus = CSODOTAGameAccountPlus {
            account_id: ::std::option::Option::None,
            original_start_date: ::std::option::Option::None,
            plus_flags: ::std::option::Option::None,
            plus_status: ::std::option::Option::None,
            prepaid_time_start: ::std::option::Option::None,
            prepaid_time_balance: ::std::option::Option::None,
            next_payment_date: ::std::option::Option::None,
            steam_agreement_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSODOTAChatWheel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAChatWheel {
    // message fields
    // @@protoc_insertion_point(field:CSODOTAChatWheel.message_id)
    pub message_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSODOTAChatWheel.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAChatWheel {
    fn default() -> &'a CSODOTAChatWheel {
        <CSODOTAChatWheel as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSODOTAChatWheel {
    pub fn new() -> CSODOTAChatWheel {
        ::std::default::Default::default()
    }

    // optional uint32 message_id = 1;

    pub fn message_id(&self) -> u32 {
        self.message_id.unwrap_or(4294967295u32)
    }

    pub fn clear_message_id(&mut self) {
        self.message_id = ::std::option::Option::None;
    }

    pub fn has_message_id(&self) -> bool {
        self.message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: u32) {
        self.message_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSODOTAChatWheel {
    const NAME: &'static str = "CSODOTAChatWheel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.message_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.message_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAChatWheel {
        CSODOTAChatWheel::new()
    }

    fn clear(&mut self) {
        self.message_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAChatWheel {
        static instance: CSODOTAChatWheel = CSODOTAChatWheel {
            message_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLobbyFeaturedGamemodeProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyFeaturedGamemodeProgress {
    // message fields
    // @@protoc_insertion_point(field:CMsgLobbyFeaturedGamemodeProgress.accounts)
    pub accounts: ::std::vec::Vec<cmsg_lobby_featured_gamemode_progress::AccountProgress>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLobbyFeaturedGamemodeProgress.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyFeaturedGamemodeProgress {
    fn default() -> &'a CMsgLobbyFeaturedGamemodeProgress {
        <CMsgLobbyFeaturedGamemodeProgress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyFeaturedGamemodeProgress {
    pub fn new() -> CMsgLobbyFeaturedGamemodeProgress {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLobbyFeaturedGamemodeProgress {
    const NAME: &'static str = "CMsgLobbyFeaturedGamemodeProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.accounts.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.accounts {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.accounts {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyFeaturedGamemodeProgress {
        CMsgLobbyFeaturedGamemodeProgress::new()
    }

    fn clear(&mut self) {
        self.accounts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyFeaturedGamemodeProgress {
        static instance: CMsgLobbyFeaturedGamemodeProgress = CMsgLobbyFeaturedGamemodeProgress {
            accounts: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgLobbyFeaturedGamemodeProgress`
pub mod cmsg_lobby_featured_gamemode_progress {
    // @@protoc_insertion_point(message:CMsgLobbyFeaturedGamemodeProgress.AccountProgress)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AccountProgress {
        // message fields
        // @@protoc_insertion_point(field:CMsgLobbyFeaturedGamemodeProgress.AccountProgress.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgLobbyFeaturedGamemodeProgress.AccountProgress.current_value)
        pub current_value: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgLobbyFeaturedGamemodeProgress.AccountProgress.max_value)
        pub max_value: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgLobbyFeaturedGamemodeProgress.AccountProgress.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AccountProgress {
        fn default() -> &'a AccountProgress {
            <AccountProgress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl AccountProgress {
        pub fn new() -> AccountProgress {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 current_value = 2;

        pub fn current_value(&self) -> u32 {
            self.current_value.unwrap_or(0)
        }

        pub fn clear_current_value(&mut self) {
            self.current_value = ::std::option::Option::None;
        }

        pub fn has_current_value(&self) -> bool {
            self.current_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_current_value(&mut self, v: u32) {
            self.current_value = ::std::option::Option::Some(v);
        }

        // optional uint32 max_value = 3;

        pub fn max_value(&self) -> u32 {
            self.max_value.unwrap_or(0)
        }

        pub fn clear_max_value(&mut self) {
            self.max_value = ::std::option::Option::None;
        }

        pub fn has_max_value(&self) -> bool {
            self.max_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max_value(&mut self, v: u32) {
            self.max_value = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for AccountProgress {
        const NAME: &'static str = "AccountProgress";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.current_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.max_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.current_value {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.max_value {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.current_value {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.max_value {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AccountProgress {
            AccountProgress::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.current_value = ::std::option::Option::None;
            self.max_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AccountProgress {
            static instance: AccountProgress = AccountProgress {
                account_id: ::std::option::Option::None,
                current_value: ::std::option::Option::None,
                max_value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgBattleCupVictory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBattleCupVictory {
    // message fields
    // @@protoc_insertion_point(field:CMsgBattleCupVictory.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleCupVictory.win_date)
    pub win_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleCupVictory.valid_until)
    pub valid_until: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleCupVictory.skill_level)
    pub skill_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleCupVictory.tournament_id)
    pub tournament_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleCupVictory.division_id)
    pub division_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleCupVictory.team_id)
    pub team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleCupVictory.streak)
    pub streak: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleCupVictory.trophy_id)
    pub trophy_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBattleCupVictory.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBattleCupVictory {
    fn default() -> &'a CMsgBattleCupVictory {
        <CMsgBattleCupVictory as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgBattleCupVictory {
    pub fn new() -> CMsgBattleCupVictory {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 win_date = 2;

    pub fn win_date(&self) -> u32 {
        self.win_date.unwrap_or(0)
    }

    pub fn clear_win_date(&mut self) {
        self.win_date = ::std::option::Option::None;
    }

    pub fn has_win_date(&self) -> bool {
        self.win_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_win_date(&mut self, v: u32) {
        self.win_date = ::std::option::Option::Some(v);
    }

    // optional uint32 valid_until = 3;

    pub fn valid_until(&self) -> u32 {
        self.valid_until.unwrap_or(0)
    }

    pub fn clear_valid_until(&mut self) {
        self.valid_until = ::std::option::Option::None;
    }

    pub fn has_valid_until(&self) -> bool {
        self.valid_until.is_some()
    }

    // Param is passed by value, moved
    pub fn set_valid_until(&mut self, v: u32) {
        self.valid_until = ::std::option::Option::Some(v);
    }

    // optional uint32 skill_level = 4;

    pub fn skill_level(&self) -> u32 {
        self.skill_level.unwrap_or(0)
    }

    pub fn clear_skill_level(&mut self) {
        self.skill_level = ::std::option::Option::None;
    }

    pub fn has_skill_level(&self) -> bool {
        self.skill_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skill_level(&mut self, v: u32) {
        self.skill_level = ::std::option::Option::Some(v);
    }

    // optional uint32 tournament_id = 5;

    pub fn tournament_id(&self) -> u32 {
        self.tournament_id.unwrap_or(0)
    }

    pub fn clear_tournament_id(&mut self) {
        self.tournament_id = ::std::option::Option::None;
    }

    pub fn has_tournament_id(&self) -> bool {
        self.tournament_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_id(&mut self, v: u32) {
        self.tournament_id = ::std::option::Option::Some(v);
    }

    // optional uint32 division_id = 6;

    pub fn division_id(&self) -> u32 {
        self.division_id.unwrap_or(0)
    }

    pub fn clear_division_id(&mut self) {
        self.division_id = ::std::option::Option::None;
    }

    pub fn has_division_id(&self) -> bool {
        self.division_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_division_id(&mut self, v: u32) {
        self.division_id = ::std::option::Option::Some(v);
    }

    // optional uint32 team_id = 7;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional uint32 streak = 8;

    pub fn streak(&self) -> u32 {
        self.streak.unwrap_or(0)
    }

    pub fn clear_streak(&mut self) {
        self.streak = ::std::option::Option::None;
    }

    pub fn has_streak(&self) -> bool {
        self.streak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_streak(&mut self, v: u32) {
        self.streak = ::std::option::Option::Some(v);
    }

    // optional uint32 trophy_id = 9;

    pub fn trophy_id(&self) -> u32 {
        self.trophy_id.unwrap_or(0)
    }

    pub fn clear_trophy_id(&mut self) {
        self.trophy_id = ::std::option::Option::None;
    }

    pub fn has_trophy_id(&self) -> bool {
        self.trophy_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trophy_id(&mut self, v: u32) {
        self.trophy_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgBattleCupVictory {
    const NAME: &'static str = "CMsgBattleCupVictory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.win_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.valid_until = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.skill_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.tournament_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.division_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.streak = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.trophy_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.win_date {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.valid_until {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.skill_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.tournament_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.division_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.streak {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.trophy_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.win_date {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.valid_until {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.skill_level {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tournament_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.division_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.streak {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.trophy_id {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBattleCupVictory {
        CMsgBattleCupVictory::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.win_date = ::std::option::Option::None;
        self.valid_until = ::std::option::Option::None;
        self.skill_level = ::std::option::Option::None;
        self.tournament_id = ::std::option::Option::None;
        self.division_id = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.streak = ::std::option::Option::None;
        self.trophy_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBattleCupVictory {
        static instance: CMsgBattleCupVictory = CMsgBattleCupVictory {
            account_id: ::std::option::Option::None,
            win_date: ::std::option::Option::None,
            valid_until: ::std::option::Option::None,
            skill_level: ::std::option::Option::None,
            tournament_id: ::std::option::Option::None,
            division_id: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            streak: ::std::option::Option::None,
            trophy_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLobbyBattleCupVictoryList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyBattleCupVictoryList {
    // message fields
    // @@protoc_insertion_point(field:CMsgLobbyBattleCupVictoryList.winners)
    pub winners: ::std::vec::Vec<CMsgBattleCupVictory>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLobbyBattleCupVictoryList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyBattleCupVictoryList {
    fn default() -> &'a CMsgLobbyBattleCupVictoryList {
        <CMsgLobbyBattleCupVictoryList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyBattleCupVictoryList {
    pub fn new() -> CMsgLobbyBattleCupVictoryList {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLobbyBattleCupVictoryList {
    const NAME: &'static str = "CMsgLobbyBattleCupVictoryList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.winners.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.winners {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.winners {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyBattleCupVictoryList {
        CMsgLobbyBattleCupVictoryList::new()
    }

    fn clear(&mut self) {
        self.winners.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyBattleCupVictoryList {
        static instance: CMsgLobbyBattleCupVictoryList = CMsgLobbyBattleCupVictoryList {
            winners: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTABroadcastNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTABroadcastNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTABroadcastNotification.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTABroadcastNotification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTABroadcastNotification {
    fn default() -> &'a CMsgDOTABroadcastNotification {
        <CMsgDOTABroadcastNotification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTABroadcastNotification {
    pub fn new() -> CMsgDOTABroadcastNotification {
        ::std::default::Default::default()
    }

    // optional string message = 1;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTABroadcastNotification {
    const NAME: &'static str = "CMsgDOTABroadcastNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTABroadcastNotification {
        CMsgDOTABroadcastNotification::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTABroadcastNotification {
        static instance: CMsgDOTABroadcastNotification = CMsgDOTABroadcastNotification {
            message: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CProtoItemHeroStatue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProtoItemHeroStatue {
    // message fields
    // @@protoc_insertion_point(field:CProtoItemHeroStatue.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CProtoItemHeroStatue.status_effect_index)
    pub status_effect_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CProtoItemHeroStatue.sequence_name)
    pub sequence_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CProtoItemHeroStatue.cycle)
    pub cycle: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CProtoItemHeroStatue.wearable)
    pub wearable: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CProtoItemHeroStatue.inscription)
    pub inscription: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CProtoItemHeroStatue.style)
    pub style: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CProtoItemHeroStatue.tournament_drop)
    pub tournament_drop: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CProtoItemHeroStatue.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProtoItemHeroStatue {
    fn default() -> &'a CProtoItemHeroStatue {
        <CProtoItemHeroStatue as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CProtoItemHeroStatue {
    pub fn new() -> CProtoItemHeroStatue {
        ::std::default::Default::default()
    }

    // optional int32 hero_id = 1;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 status_effect_index = 2;

    pub fn status_effect_index(&self) -> u32 {
        self.status_effect_index.unwrap_or(0)
    }

    pub fn clear_status_effect_index(&mut self) {
        self.status_effect_index = ::std::option::Option::None;
    }

    pub fn has_status_effect_index(&self) -> bool {
        self.status_effect_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_effect_index(&mut self, v: u32) {
        self.status_effect_index = ::std::option::Option::Some(v);
    }

    // optional string sequence_name = 3;

    pub fn sequence_name(&self) -> &str {
        match self.sequence_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sequence_name(&mut self) {
        self.sequence_name = ::std::option::Option::None;
    }

    pub fn has_sequence_name(&self) -> bool {
        self.sequence_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_name(&mut self, v: ::std::string::String) {
        self.sequence_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sequence_name(&mut self) -> &mut ::std::string::String {
        if self.sequence_name.is_none() {
            self.sequence_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sequence_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_sequence_name(&mut self) -> ::std::string::String {
        self.sequence_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float cycle = 4;

    pub fn cycle(&self) -> f32 {
        self.cycle.unwrap_or(0.)
    }

    pub fn clear_cycle(&mut self) {
        self.cycle = ::std::option::Option::None;
    }

    pub fn has_cycle(&self) -> bool {
        self.cycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cycle(&mut self, v: f32) {
        self.cycle = ::std::option::Option::Some(v);
    }

    // optional string inscription = 6;

    pub fn inscription(&self) -> &str {
        match self.inscription.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_inscription(&mut self) {
        self.inscription = ::std::option::Option::None;
    }

    pub fn has_inscription(&self) -> bool {
        self.inscription.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inscription(&mut self, v: ::std::string::String) {
        self.inscription = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inscription(&mut self) -> &mut ::std::string::String {
        if self.inscription.is_none() {
            self.inscription = ::std::option::Option::Some(::std::string::String::new());
        }
        self.inscription.as_mut().unwrap()
    }

    // Take field
    pub fn take_inscription(&mut self) -> ::std::string::String {
        self.inscription.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool tournament_drop = 8;

    pub fn tournament_drop(&self) -> bool {
        self.tournament_drop.unwrap_or(false)
    }

    pub fn clear_tournament_drop(&mut self) {
        self.tournament_drop = ::std::option::Option::None;
    }

    pub fn has_tournament_drop(&self) -> bool {
        self.tournament_drop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_drop(&mut self, v: bool) {
        self.tournament_drop = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CProtoItemHeroStatue {
    const NAME: &'static str = "CProtoItemHeroStatue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.status_effect_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.sequence_name = ::std::option::Option::Some(is.read_string()?);
                },
                37 => {
                    self.cycle = ::std::option::Option::Some(is.read_float()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.wearable)?;
                },
                40 => {
                    self.wearable.push(is.read_uint32()?);
                },
                50 => {
                    self.inscription = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    is.read_repeated_packed_uint32_into(&mut self.style)?;
                },
                56 => {
                    self.style.push(is.read_uint32()?);
                },
                64 => {
                    self.tournament_drop = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.status_effect_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.sequence_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.cycle {
            my_size += 1 + 4;
        }
        for value in &self.wearable {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, *value);
        };
        if let Some(v) = self.inscription.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
        }
        for value in &self.style {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, *value);
        };
        if let Some(v) = self.tournament_drop {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hero_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.status_effect_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.sequence_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.cycle {
            os.write_float(4, v)?;
        }
        for v in &self.wearable {
            os.write_uint32(5, *v)?;
        };
        if let Some(v) = self.inscription.as_ref() {
            os.write_string(6, v)?;
        }
        for v in &self.style {
            os.write_uint32(7, *v)?;
        };
        if let Some(v) = self.tournament_drop {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProtoItemHeroStatue {
        CProtoItemHeroStatue::new()
    }

    fn clear(&mut self) {
        self.hero_id = ::std::option::Option::None;
        self.status_effect_index = ::std::option::Option::None;
        self.sequence_name = ::std::option::Option::None;
        self.cycle = ::std::option::Option::None;
        self.wearable.clear();
        self.inscription = ::std::option::Option::None;
        self.style.clear();
        self.tournament_drop = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProtoItemHeroStatue {
        static instance: CProtoItemHeroStatue = CProtoItemHeroStatue {
            hero_id: ::std::option::Option::None,
            status_effect_index: ::std::option::Option::None,
            sequence_name: ::std::option::Option::None,
            cycle: ::std::option::Option::None,
            wearable: ::std::vec::Vec::new(),
            inscription: ::std::option::Option::None,
            style: ::std::vec::Vec::new(),
            tournament_drop: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMatchPlayerAbilityUpgrade)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMatchPlayerAbilityUpgrade {
    // message fields
    // @@protoc_insertion_point(field:CMatchPlayerAbilityUpgrade.ability)
    pub ability: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMatchPlayerAbilityUpgrade.time)
    pub time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMatchPlayerAbilityUpgrade.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMatchPlayerAbilityUpgrade {
    fn default() -> &'a CMatchPlayerAbilityUpgrade {
        <CMatchPlayerAbilityUpgrade as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMatchPlayerAbilityUpgrade {
    pub fn new() -> CMatchPlayerAbilityUpgrade {
        ::std::default::Default::default()
    }

    // optional int32 ability = 1;

    pub fn ability(&self) -> i32 {
        self.ability.unwrap_or(-1i32)
    }

    pub fn clear_ability(&mut self) {
        self.ability = ::std::option::Option::None;
    }

    pub fn has_ability(&self) -> bool {
        self.ability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability(&mut self, v: i32) {
        self.ability = ::std::option::Option::Some(v);
    }

    // optional uint32 time = 2;

    pub fn time(&self) -> u32 {
        self.time.unwrap_or(0)
    }

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: u32) {
        self.time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMatchPlayerAbilityUpgrade {
    const NAME: &'static str = "CMatchPlayerAbilityUpgrade";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ability = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ability {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ability {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.time {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMatchPlayerAbilityUpgrade {
        CMatchPlayerAbilityUpgrade::new()
    }

    fn clear(&mut self) {
        self.ability = ::std::option::Option::None;
        self.time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMatchPlayerAbilityUpgrade {
        static instance: CMatchPlayerAbilityUpgrade = CMatchPlayerAbilityUpgrade {
            ability: ::std::option::Option::None,
            time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMatchPlayerTimedCustomStat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMatchPlayerTimedCustomStat {
    // message fields
    // @@protoc_insertion_point(field:CMatchPlayerTimedCustomStat.stat)
    pub stat: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EDOTAMatchPlayerTimeCustomStat>>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedCustomStat.value)
    pub value: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMatchPlayerTimedCustomStat.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMatchPlayerTimedCustomStat {
    fn default() -> &'a CMatchPlayerTimedCustomStat {
        <CMatchPlayerTimedCustomStat as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMatchPlayerTimedCustomStat {
    pub fn new() -> CMatchPlayerTimedCustomStat {
        ::std::default::Default::default()
    }

    // optional .EDOTAMatchPlayerTimeCustomStat stat = 2;

    pub fn stat(&self) -> EDOTAMatchPlayerTimeCustomStat {
        match self.stat {
            Some(e) => e.enum_value_or(EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers),
            None => EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers,
        }
    }

    pub fn clear_stat(&mut self) {
        self.stat = ::std::option::Option::None;
    }

    pub fn has_stat(&self) -> bool {
        self.stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat(&mut self, v: EDOTAMatchPlayerTimeCustomStat) {
        self.stat = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional float value = 3;

    pub fn value(&self) -> f32 {
        self.value.unwrap_or(0.)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMatchPlayerTimedCustomStat {
    const NAME: &'static str = "CMatchPlayerTimedCustomStat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.stat = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                29 => {
                    self.value = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stat {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.value {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.stat {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.value {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMatchPlayerTimedCustomStat {
        CMatchPlayerTimedCustomStat::new()
    }

    fn clear(&mut self) {
        self.stat = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMatchPlayerTimedCustomStat {
        static instance: CMatchPlayerTimedCustomStat = CMatchPlayerTimedCustomStat {
            stat: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMatchPlayerTimedStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMatchPlayerTimedStats {
    // message fields
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.time)
    pub time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.kills)
    pub kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.deaths)
    pub deaths: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.assists)
    pub assists: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.net_worth)
    pub net_worth: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.xp)
    pub xp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.last_hits)
    pub last_hits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.denies)
    pub denies: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.bounty_rune_gold)
    pub bounty_rune_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.range_creep_upgrade_gold)
    pub range_creep_upgrade_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.observer_wards_dewarded)
    pub observer_wards_dewarded: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.reliable_gold_earned)
    pub reliable_gold_earned: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.gold_loss_prevented)
    pub gold_loss_prevented: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.hero_kill_gold)
    pub hero_kill_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.creep_kill_gold)
    pub creep_kill_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.building_gold)
    pub building_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.other_gold)
    pub other_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.comeback_gold)
    pub comeback_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.experimental_gold)
    pub experimental_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.experimental2_gold)
    pub experimental2_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.creep_deny_gold)
    pub creep_deny_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.tp_scrolls_purchased_1)
    pub tp_scrolls_purchased_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.tp_scrolls_purchased_2)
    pub tp_scrolls_purchased_2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.tp_scrolls_purchased_3)
    pub tp_scrolls_purchased_3: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.tp_scrolls_purchased_4)
    pub tp_scrolls_purchased_4: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.tp_scrolls_purchased_5)
    pub tp_scrolls_purchased_5: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.neutral_gold)
    pub neutral_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.courier_gold)
    pub courier_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.roshan_gold)
    pub roshan_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.income_gold)
    pub income_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.item_value)
    pub item_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.support_gold_spent)
    pub support_gold_spent: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.camps_stacked)
    pub camps_stacked: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.wards_placed)
    pub wards_placed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.triple_kills)
    pub triple_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.rampages)
    pub rampages: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStats.custom_stats)
    pub custom_stats: ::std::vec::Vec<CMatchPlayerTimedCustomStat>,
    // special fields
    // @@protoc_insertion_point(special_field:CMatchPlayerTimedStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMatchPlayerTimedStats {
    fn default() -> &'a CMatchPlayerTimedStats {
        <CMatchPlayerTimedStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMatchPlayerTimedStats {
    pub fn new() -> CMatchPlayerTimedStats {
        ::std::default::Default::default()
    }

    // optional uint32 time = 1;

    pub fn time(&self) -> u32 {
        self.time.unwrap_or(0)
    }

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: u32) {
        self.time = ::std::option::Option::Some(v);
    }

    // optional uint32 kills = 2;

    pub fn kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional uint32 deaths = 3;

    pub fn deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 assists = 4;

    pub fn assists(&self) -> u32 {
        self.assists.unwrap_or(0)
    }

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: u32) {
        self.assists = ::std::option::Option::Some(v);
    }

    // optional uint32 net_worth = 5;

    pub fn net_worth(&self) -> u32 {
        self.net_worth.unwrap_or(0)
    }

    pub fn clear_net_worth(&mut self) {
        self.net_worth = ::std::option::Option::None;
    }

    pub fn has_net_worth(&self) -> bool {
        self.net_worth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_worth(&mut self, v: u32) {
        self.net_worth = ::std::option::Option::Some(v);
    }

    // optional uint32 xp = 6;

    pub fn xp(&self) -> u32 {
        self.xp.unwrap_or(0)
    }

    pub fn clear_xp(&mut self) {
        self.xp = ::std::option::Option::None;
    }

    pub fn has_xp(&self) -> bool {
        self.xp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp(&mut self, v: u32) {
        self.xp = ::std::option::Option::Some(v);
    }

    // optional uint32 last_hits = 7;

    pub fn last_hits(&self) -> u32 {
        self.last_hits.unwrap_or(0)
    }

    pub fn clear_last_hits(&mut self) {
        self.last_hits = ::std::option::Option::None;
    }

    pub fn has_last_hits(&self) -> bool {
        self.last_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hits(&mut self, v: u32) {
        self.last_hits = ::std::option::Option::Some(v);
    }

    // optional uint32 denies = 8;

    pub fn denies(&self) -> u32 {
        self.denies.unwrap_or(0)
    }

    pub fn clear_denies(&mut self) {
        self.denies = ::std::option::Option::None;
    }

    pub fn has_denies(&self) -> bool {
        self.denies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denies(&mut self, v: u32) {
        self.denies = ::std::option::Option::Some(v);
    }

    // optional uint32 bounty_rune_gold = 9;

    pub fn bounty_rune_gold(&self) -> u32 {
        self.bounty_rune_gold.unwrap_or(0)
    }

    pub fn clear_bounty_rune_gold(&mut self) {
        self.bounty_rune_gold = ::std::option::Option::None;
    }

    pub fn has_bounty_rune_gold(&self) -> bool {
        self.bounty_rune_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bounty_rune_gold(&mut self, v: u32) {
        self.bounty_rune_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 range_creep_upgrade_gold = 10;

    pub fn range_creep_upgrade_gold(&self) -> u32 {
        self.range_creep_upgrade_gold.unwrap_or(0)
    }

    pub fn clear_range_creep_upgrade_gold(&mut self) {
        self.range_creep_upgrade_gold = ::std::option::Option::None;
    }

    pub fn has_range_creep_upgrade_gold(&self) -> bool {
        self.range_creep_upgrade_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range_creep_upgrade_gold(&mut self, v: u32) {
        self.range_creep_upgrade_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 observer_wards_dewarded = 11;

    pub fn observer_wards_dewarded(&self) -> u32 {
        self.observer_wards_dewarded.unwrap_or(0)
    }

    pub fn clear_observer_wards_dewarded(&mut self) {
        self.observer_wards_dewarded = ::std::option::Option::None;
    }

    pub fn has_observer_wards_dewarded(&self) -> bool {
        self.observer_wards_dewarded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observer_wards_dewarded(&mut self, v: u32) {
        self.observer_wards_dewarded = ::std::option::Option::Some(v);
    }

    // optional uint32 reliable_gold_earned = 12;

    pub fn reliable_gold_earned(&self) -> u32 {
        self.reliable_gold_earned.unwrap_or(0)
    }

    pub fn clear_reliable_gold_earned(&mut self) {
        self.reliable_gold_earned = ::std::option::Option::None;
    }

    pub fn has_reliable_gold_earned(&self) -> bool {
        self.reliable_gold_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable_gold_earned(&mut self, v: u32) {
        self.reliable_gold_earned = ::std::option::Option::Some(v);
    }

    // optional uint32 gold_loss_prevented = 13;

    pub fn gold_loss_prevented(&self) -> u32 {
        self.gold_loss_prevented.unwrap_or(0)
    }

    pub fn clear_gold_loss_prevented(&mut self) {
        self.gold_loss_prevented = ::std::option::Option::None;
    }

    pub fn has_gold_loss_prevented(&self) -> bool {
        self.gold_loss_prevented.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_loss_prevented(&mut self, v: u32) {
        self.gold_loss_prevented = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_kill_gold = 14;

    pub fn hero_kill_gold(&self) -> u32 {
        self.hero_kill_gold.unwrap_or(0)
    }

    pub fn clear_hero_kill_gold(&mut self) {
        self.hero_kill_gold = ::std::option::Option::None;
    }

    pub fn has_hero_kill_gold(&self) -> bool {
        self.hero_kill_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_kill_gold(&mut self, v: u32) {
        self.hero_kill_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 creep_kill_gold = 15;

    pub fn creep_kill_gold(&self) -> u32 {
        self.creep_kill_gold.unwrap_or(0)
    }

    pub fn clear_creep_kill_gold(&mut self) {
        self.creep_kill_gold = ::std::option::Option::None;
    }

    pub fn has_creep_kill_gold(&self) -> bool {
        self.creep_kill_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creep_kill_gold(&mut self, v: u32) {
        self.creep_kill_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 building_gold = 16;

    pub fn building_gold(&self) -> u32 {
        self.building_gold.unwrap_or(0)
    }

    pub fn clear_building_gold(&mut self) {
        self.building_gold = ::std::option::Option::None;
    }

    pub fn has_building_gold(&self) -> bool {
        self.building_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_building_gold(&mut self, v: u32) {
        self.building_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 other_gold = 17;

    pub fn other_gold(&self) -> u32 {
        self.other_gold.unwrap_or(0)
    }

    pub fn clear_other_gold(&mut self) {
        self.other_gold = ::std::option::Option::None;
    }

    pub fn has_other_gold(&self) -> bool {
        self.other_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_gold(&mut self, v: u32) {
        self.other_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 comeback_gold = 18;

    pub fn comeback_gold(&self) -> u32 {
        self.comeback_gold.unwrap_or(0)
    }

    pub fn clear_comeback_gold(&mut self) {
        self.comeback_gold = ::std::option::Option::None;
    }

    pub fn has_comeback_gold(&self) -> bool {
        self.comeback_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comeback_gold(&mut self, v: u32) {
        self.comeback_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 experimental_gold = 19;

    pub fn experimental_gold(&self) -> u32 {
        self.experimental_gold.unwrap_or(0)
    }

    pub fn clear_experimental_gold(&mut self) {
        self.experimental_gold = ::std::option::Option::None;
    }

    pub fn has_experimental_gold(&self) -> bool {
        self.experimental_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experimental_gold(&mut self, v: u32) {
        self.experimental_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 experimental2_gold = 20;

    pub fn experimental2_gold(&self) -> u32 {
        self.experimental2_gold.unwrap_or(0)
    }

    pub fn clear_experimental2_gold(&mut self) {
        self.experimental2_gold = ::std::option::Option::None;
    }

    pub fn has_experimental2_gold(&self) -> bool {
        self.experimental2_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experimental2_gold(&mut self, v: u32) {
        self.experimental2_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 creep_deny_gold = 21;

    pub fn creep_deny_gold(&self) -> u32 {
        self.creep_deny_gold.unwrap_or(0)
    }

    pub fn clear_creep_deny_gold(&mut self) {
        self.creep_deny_gold = ::std::option::Option::None;
    }

    pub fn has_creep_deny_gold(&self) -> bool {
        self.creep_deny_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creep_deny_gold(&mut self, v: u32) {
        self.creep_deny_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 tp_scrolls_purchased_1 = 22;

    pub fn tp_scrolls_purchased_1(&self) -> u32 {
        self.tp_scrolls_purchased_1.unwrap_or(0)
    }

    pub fn clear_tp_scrolls_purchased_1(&mut self) {
        self.tp_scrolls_purchased_1 = ::std::option::Option::None;
    }

    pub fn has_tp_scrolls_purchased_1(&self) -> bool {
        self.tp_scrolls_purchased_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tp_scrolls_purchased_1(&mut self, v: u32) {
        self.tp_scrolls_purchased_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 tp_scrolls_purchased_2 = 23;

    pub fn tp_scrolls_purchased_2(&self) -> u32 {
        self.tp_scrolls_purchased_2.unwrap_or(0)
    }

    pub fn clear_tp_scrolls_purchased_2(&mut self) {
        self.tp_scrolls_purchased_2 = ::std::option::Option::None;
    }

    pub fn has_tp_scrolls_purchased_2(&self) -> bool {
        self.tp_scrolls_purchased_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tp_scrolls_purchased_2(&mut self, v: u32) {
        self.tp_scrolls_purchased_2 = ::std::option::Option::Some(v);
    }

    // optional uint32 tp_scrolls_purchased_3 = 24;

    pub fn tp_scrolls_purchased_3(&self) -> u32 {
        self.tp_scrolls_purchased_3.unwrap_or(0)
    }

    pub fn clear_tp_scrolls_purchased_3(&mut self) {
        self.tp_scrolls_purchased_3 = ::std::option::Option::None;
    }

    pub fn has_tp_scrolls_purchased_3(&self) -> bool {
        self.tp_scrolls_purchased_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tp_scrolls_purchased_3(&mut self, v: u32) {
        self.tp_scrolls_purchased_3 = ::std::option::Option::Some(v);
    }

    // optional uint32 tp_scrolls_purchased_4 = 25;

    pub fn tp_scrolls_purchased_4(&self) -> u32 {
        self.tp_scrolls_purchased_4.unwrap_or(0)
    }

    pub fn clear_tp_scrolls_purchased_4(&mut self) {
        self.tp_scrolls_purchased_4 = ::std::option::Option::None;
    }

    pub fn has_tp_scrolls_purchased_4(&self) -> bool {
        self.tp_scrolls_purchased_4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tp_scrolls_purchased_4(&mut self, v: u32) {
        self.tp_scrolls_purchased_4 = ::std::option::Option::Some(v);
    }

    // optional uint32 tp_scrolls_purchased_5 = 26;

    pub fn tp_scrolls_purchased_5(&self) -> u32 {
        self.tp_scrolls_purchased_5.unwrap_or(0)
    }

    pub fn clear_tp_scrolls_purchased_5(&mut self) {
        self.tp_scrolls_purchased_5 = ::std::option::Option::None;
    }

    pub fn has_tp_scrolls_purchased_5(&self) -> bool {
        self.tp_scrolls_purchased_5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tp_scrolls_purchased_5(&mut self, v: u32) {
        self.tp_scrolls_purchased_5 = ::std::option::Option::Some(v);
    }

    // optional uint32 neutral_gold = 27;

    pub fn neutral_gold(&self) -> u32 {
        self.neutral_gold.unwrap_or(0)
    }

    pub fn clear_neutral_gold(&mut self) {
        self.neutral_gold = ::std::option::Option::None;
    }

    pub fn has_neutral_gold(&self) -> bool {
        self.neutral_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_neutral_gold(&mut self, v: u32) {
        self.neutral_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 courier_gold = 28;

    pub fn courier_gold(&self) -> u32 {
        self.courier_gold.unwrap_or(0)
    }

    pub fn clear_courier_gold(&mut self) {
        self.courier_gold = ::std::option::Option::None;
    }

    pub fn has_courier_gold(&self) -> bool {
        self.courier_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_courier_gold(&mut self, v: u32) {
        self.courier_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 roshan_gold = 29;

    pub fn roshan_gold(&self) -> u32 {
        self.roshan_gold.unwrap_or(0)
    }

    pub fn clear_roshan_gold(&mut self) {
        self.roshan_gold = ::std::option::Option::None;
    }

    pub fn has_roshan_gold(&self) -> bool {
        self.roshan_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roshan_gold(&mut self, v: u32) {
        self.roshan_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 income_gold = 30;

    pub fn income_gold(&self) -> u32 {
        self.income_gold.unwrap_or(0)
    }

    pub fn clear_income_gold(&mut self) {
        self.income_gold = ::std::option::Option::None;
    }

    pub fn has_income_gold(&self) -> bool {
        self.income_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_income_gold(&mut self, v: u32) {
        self.income_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 item_value = 36;

    pub fn item_value(&self) -> u32 {
        self.item_value.unwrap_or(0)
    }

    pub fn clear_item_value(&mut self) {
        self.item_value = ::std::option::Option::None;
    }

    pub fn has_item_value(&self) -> bool {
        self.item_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_value(&mut self, v: u32) {
        self.item_value = ::std::option::Option::Some(v);
    }

    // optional uint32 support_gold_spent = 37;

    pub fn support_gold_spent(&self) -> u32 {
        self.support_gold_spent.unwrap_or(0)
    }

    pub fn clear_support_gold_spent(&mut self) {
        self.support_gold_spent = ::std::option::Option::None;
    }

    pub fn has_support_gold_spent(&self) -> bool {
        self.support_gold_spent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_gold_spent(&mut self, v: u32) {
        self.support_gold_spent = ::std::option::Option::Some(v);
    }

    // optional uint32 camps_stacked = 38;

    pub fn camps_stacked(&self) -> u32 {
        self.camps_stacked.unwrap_or(0)
    }

    pub fn clear_camps_stacked(&mut self) {
        self.camps_stacked = ::std::option::Option::None;
    }

    pub fn has_camps_stacked(&self) -> bool {
        self.camps_stacked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camps_stacked(&mut self, v: u32) {
        self.camps_stacked = ::std::option::Option::Some(v);
    }

    // optional uint32 wards_placed = 39;

    pub fn wards_placed(&self) -> u32 {
        self.wards_placed.unwrap_or(0)
    }

    pub fn clear_wards_placed(&mut self) {
        self.wards_placed = ::std::option::Option::None;
    }

    pub fn has_wards_placed(&self) -> bool {
        self.wards_placed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wards_placed(&mut self, v: u32) {
        self.wards_placed = ::std::option::Option::Some(v);
    }

    // optional uint32 triple_kills = 40;

    pub fn triple_kills(&self) -> u32 {
        self.triple_kills.unwrap_or(0)
    }

    pub fn clear_triple_kills(&mut self) {
        self.triple_kills = ::std::option::Option::None;
    }

    pub fn has_triple_kills(&self) -> bool {
        self.triple_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_triple_kills(&mut self, v: u32) {
        self.triple_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 rampages = 41;

    pub fn rampages(&self) -> u32 {
        self.rampages.unwrap_or(0)
    }

    pub fn clear_rampages(&mut self) {
        self.rampages = ::std::option::Option::None;
    }

    pub fn has_rampages(&self) -> bool {
        self.rampages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rampages(&mut self, v: u32) {
        self.rampages = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMatchPlayerTimedStats {
    const NAME: &'static str = "CMatchPlayerTimedStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.time = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.assists = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.xp = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.last_hits = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.denies = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.bounty_rune_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.range_creep_upgrade_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.observer_wards_dewarded = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.reliable_gold_earned = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.gold_loss_prevented = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.hero_kill_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.creep_kill_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.building_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.other_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.comeback_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.experimental_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.experimental2_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.creep_deny_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.tp_scrolls_purchased_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.tp_scrolls_purchased_2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.tp_scrolls_purchased_3 = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.tp_scrolls_purchased_4 = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.tp_scrolls_purchased_5 = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.neutral_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.courier_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                232 => {
                    self.roshan_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.income_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                288 => {
                    self.item_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                296 => {
                    self.support_gold_spent = ::std::option::Option::Some(is.read_uint32()?);
                },
                304 => {
                    self.camps_stacked = ::std::option::Option::Some(is.read_uint32()?);
                },
                312 => {
                    self.wards_placed = ::std::option::Option::Some(is.read_uint32()?);
                },
                320 => {
                    self.triple_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                328 => {
                    self.rampages = ::std::option::Option::Some(is.read_uint32()?);
                },
                338 => {
                    self.custom_stats.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.deaths {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.assists {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.net_worth {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.xp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.last_hits {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.denies {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.bounty_rune_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.range_creep_upgrade_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.observer_wards_dewarded {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.reliable_gold_earned {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.gold_loss_prevented {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.hero_kill_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.creep_kill_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.building_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.other_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.comeback_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.experimental_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.experimental2_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.creep_deny_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.tp_scrolls_purchased_1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.tp_scrolls_purchased_2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.tp_scrolls_purchased_3 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.tp_scrolls_purchased_4 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.tp_scrolls_purchased_5 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.neutral_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.courier_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.roshan_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.income_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(30, v);
        }
        if let Some(v) = self.item_value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(36, v);
        }
        if let Some(v) = self.support_gold_spent {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(37, v);
        }
        if let Some(v) = self.camps_stacked {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(38, v);
        }
        if let Some(v) = self.wards_placed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(39, v);
        }
        if let Some(v) = self.triple_kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(40, v);
        }
        if let Some(v) = self.rampages {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(41, v);
        }
        for value in &self.custom_stats {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.time {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.assists {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.net_worth {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.xp {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.last_hits {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.denies {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.bounty_rune_gold {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.range_creep_upgrade_gold {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.observer_wards_dewarded {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.reliable_gold_earned {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.gold_loss_prevented {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.hero_kill_gold {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.creep_kill_gold {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.building_gold {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.other_gold {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.comeback_gold {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.experimental_gold {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.experimental2_gold {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.creep_deny_gold {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.tp_scrolls_purchased_1 {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.tp_scrolls_purchased_2 {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.tp_scrolls_purchased_3 {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.tp_scrolls_purchased_4 {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.tp_scrolls_purchased_5 {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.neutral_gold {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.courier_gold {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.roshan_gold {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.income_gold {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.item_value {
            os.write_uint32(36, v)?;
        }
        if let Some(v) = self.support_gold_spent {
            os.write_uint32(37, v)?;
        }
        if let Some(v) = self.camps_stacked {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.wards_placed {
            os.write_uint32(39, v)?;
        }
        if let Some(v) = self.triple_kills {
            os.write_uint32(40, v)?;
        }
        if let Some(v) = self.rampages {
            os.write_uint32(41, v)?;
        }
        for v in &self.custom_stats {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(42, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMatchPlayerTimedStats {
        CMatchPlayerTimedStats::new()
    }

    fn clear(&mut self) {
        self.time = ::std::option::Option::None;
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.assists = ::std::option::Option::None;
        self.net_worth = ::std::option::Option::None;
        self.xp = ::std::option::Option::None;
        self.last_hits = ::std::option::Option::None;
        self.denies = ::std::option::Option::None;
        self.bounty_rune_gold = ::std::option::Option::None;
        self.range_creep_upgrade_gold = ::std::option::Option::None;
        self.observer_wards_dewarded = ::std::option::Option::None;
        self.reliable_gold_earned = ::std::option::Option::None;
        self.gold_loss_prevented = ::std::option::Option::None;
        self.hero_kill_gold = ::std::option::Option::None;
        self.creep_kill_gold = ::std::option::Option::None;
        self.building_gold = ::std::option::Option::None;
        self.other_gold = ::std::option::Option::None;
        self.comeback_gold = ::std::option::Option::None;
        self.experimental_gold = ::std::option::Option::None;
        self.experimental2_gold = ::std::option::Option::None;
        self.creep_deny_gold = ::std::option::Option::None;
        self.tp_scrolls_purchased_1 = ::std::option::Option::None;
        self.tp_scrolls_purchased_2 = ::std::option::Option::None;
        self.tp_scrolls_purchased_3 = ::std::option::Option::None;
        self.tp_scrolls_purchased_4 = ::std::option::Option::None;
        self.tp_scrolls_purchased_5 = ::std::option::Option::None;
        self.neutral_gold = ::std::option::Option::None;
        self.courier_gold = ::std::option::Option::None;
        self.roshan_gold = ::std::option::Option::None;
        self.income_gold = ::std::option::Option::None;
        self.item_value = ::std::option::Option::None;
        self.support_gold_spent = ::std::option::Option::None;
        self.camps_stacked = ::std::option::Option::None;
        self.wards_placed = ::std::option::Option::None;
        self.triple_kills = ::std::option::Option::None;
        self.rampages = ::std::option::Option::None;
        self.custom_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMatchPlayerTimedStats {
        static instance: CMatchPlayerTimedStats = CMatchPlayerTimedStats {
            time: ::std::option::Option::None,
            kills: ::std::option::Option::None,
            deaths: ::std::option::Option::None,
            assists: ::std::option::Option::None,
            net_worth: ::std::option::Option::None,
            xp: ::std::option::Option::None,
            last_hits: ::std::option::Option::None,
            denies: ::std::option::Option::None,
            bounty_rune_gold: ::std::option::Option::None,
            range_creep_upgrade_gold: ::std::option::Option::None,
            observer_wards_dewarded: ::std::option::Option::None,
            reliable_gold_earned: ::std::option::Option::None,
            gold_loss_prevented: ::std::option::Option::None,
            hero_kill_gold: ::std::option::Option::None,
            creep_kill_gold: ::std::option::Option::None,
            building_gold: ::std::option::Option::None,
            other_gold: ::std::option::Option::None,
            comeback_gold: ::std::option::Option::None,
            experimental_gold: ::std::option::Option::None,
            experimental2_gold: ::std::option::Option::None,
            creep_deny_gold: ::std::option::Option::None,
            tp_scrolls_purchased_1: ::std::option::Option::None,
            tp_scrolls_purchased_2: ::std::option::Option::None,
            tp_scrolls_purchased_3: ::std::option::Option::None,
            tp_scrolls_purchased_4: ::std::option::Option::None,
            tp_scrolls_purchased_5: ::std::option::Option::None,
            neutral_gold: ::std::option::Option::None,
            courier_gold: ::std::option::Option::None,
            roshan_gold: ::std::option::Option::None,
            income_gold: ::std::option::Option::None,
            item_value: ::std::option::Option::None,
            support_gold_spent: ::std::option::Option::None,
            camps_stacked: ::std::option::Option::None,
            wards_placed: ::std::option::Option::None,
            triple_kills: ::std::option::Option::None,
            rampages: ::std::option::Option::None,
            custom_stats: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMatchTeamTimedStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMatchTeamTimedStats {
    // message fields
    // @@protoc_insertion_point(field:CMatchTeamTimedStats.time)
    pub time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchTeamTimedStats.enemy_towers_killed)
    pub enemy_towers_killed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchTeamTimedStats.enemy_barracks_killed)
    pub enemy_barracks_killed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchTeamTimedStats.enemy_towers_status)
    pub enemy_towers_status: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchTeamTimedStats.enemy_barracks_status)
    pub enemy_barracks_status: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMatchTeamTimedStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMatchTeamTimedStats {
    fn default() -> &'a CMatchTeamTimedStats {
        <CMatchTeamTimedStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMatchTeamTimedStats {
    pub fn new() -> CMatchTeamTimedStats {
        ::std::default::Default::default()
    }

    // optional uint32 time = 1;

    pub fn time(&self) -> u32 {
        self.time.unwrap_or(0)
    }

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: u32) {
        self.time = ::std::option::Option::Some(v);
    }

    // optional uint32 enemy_towers_killed = 2;

    pub fn enemy_towers_killed(&self) -> u32 {
        self.enemy_towers_killed.unwrap_or(0)
    }

    pub fn clear_enemy_towers_killed(&mut self) {
        self.enemy_towers_killed = ::std::option::Option::None;
    }

    pub fn has_enemy_towers_killed(&self) -> bool {
        self.enemy_towers_killed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enemy_towers_killed(&mut self, v: u32) {
        self.enemy_towers_killed = ::std::option::Option::Some(v);
    }

    // optional uint32 enemy_barracks_killed = 3;

    pub fn enemy_barracks_killed(&self) -> u32 {
        self.enemy_barracks_killed.unwrap_or(0)
    }

    pub fn clear_enemy_barracks_killed(&mut self) {
        self.enemy_barracks_killed = ::std::option::Option::None;
    }

    pub fn has_enemy_barracks_killed(&self) -> bool {
        self.enemy_barracks_killed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enemy_barracks_killed(&mut self, v: u32) {
        self.enemy_barracks_killed = ::std::option::Option::Some(v);
    }

    // optional uint32 enemy_towers_status = 4;

    pub fn enemy_towers_status(&self) -> u32 {
        self.enemy_towers_status.unwrap_or(0)
    }

    pub fn clear_enemy_towers_status(&mut self) {
        self.enemy_towers_status = ::std::option::Option::None;
    }

    pub fn has_enemy_towers_status(&self) -> bool {
        self.enemy_towers_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enemy_towers_status(&mut self, v: u32) {
        self.enemy_towers_status = ::std::option::Option::Some(v);
    }

    // optional uint32 enemy_barracks_status = 5;

    pub fn enemy_barracks_status(&self) -> u32 {
        self.enemy_barracks_status.unwrap_or(0)
    }

    pub fn clear_enemy_barracks_status(&mut self) {
        self.enemy_barracks_status = ::std::option::Option::None;
    }

    pub fn has_enemy_barracks_status(&self) -> bool {
        self.enemy_barracks_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enemy_barracks_status(&mut self, v: u32) {
        self.enemy_barracks_status = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMatchTeamTimedStats {
    const NAME: &'static str = "CMatchTeamTimedStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.time = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.enemy_towers_killed = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.enemy_barracks_killed = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.enemy_towers_status = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.enemy_barracks_status = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.enemy_towers_killed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.enemy_barracks_killed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.enemy_towers_status {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.enemy_barracks_status {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.time {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.enemy_towers_killed {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.enemy_barracks_killed {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.enemy_towers_status {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.enemy_barracks_status {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMatchTeamTimedStats {
        CMatchTeamTimedStats::new()
    }

    fn clear(&mut self) {
        self.time = ::std::option::Option::None;
        self.enemy_towers_killed = ::std::option::Option::None;
        self.enemy_barracks_killed = ::std::option::Option::None;
        self.enemy_towers_status = ::std::option::Option::None;
        self.enemy_barracks_status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMatchTeamTimedStats {
        static instance: CMatchTeamTimedStats = CMatchTeamTimedStats {
            time: ::std::option::Option::None,
            enemy_towers_killed: ::std::option::Option::None,
            enemy_barracks_killed: ::std::option::Option::None,
            enemy_towers_status: ::std::option::Option::None,
            enemy_barracks_status: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMatchAdditionalUnitInventory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMatchAdditionalUnitInventory {
    // message fields
    // @@protoc_insertion_point(field:CMatchAdditionalUnitInventory.unit_name)
    pub unit_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMatchAdditionalUnitInventory.items)
    pub items: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMatchAdditionalUnitInventory.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMatchAdditionalUnitInventory {
    fn default() -> &'a CMatchAdditionalUnitInventory {
        <CMatchAdditionalUnitInventory as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMatchAdditionalUnitInventory {
    pub fn new() -> CMatchAdditionalUnitInventory {
        ::std::default::Default::default()
    }

    // optional string unit_name = 1;

    pub fn unit_name(&self) -> &str {
        match self.unit_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unit_name(&mut self) {
        self.unit_name = ::std::option::Option::None;
    }

    pub fn has_unit_name(&self) -> bool {
        self.unit_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_name(&mut self, v: ::std::string::String) {
        self.unit_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit_name(&mut self) -> &mut ::std::string::String {
        if self.unit_name.is_none() {
            self.unit_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unit_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit_name(&mut self) -> ::std::string::String {
        self.unit_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMatchAdditionalUnitInventory {
    const NAME: &'static str = "CMatchAdditionalUnitInventory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.unit_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.items)?;
                },
                16 => {
                    self.items.push(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unit_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        for value in &self.items {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.unit_name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.items {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMatchAdditionalUnitInventory {
        CMatchAdditionalUnitInventory::new()
    }

    fn clear(&mut self) {
        self.unit_name = ::std::option::Option::None;
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMatchAdditionalUnitInventory {
        static instance: CMatchAdditionalUnitInventory = CMatchAdditionalUnitInventory {
            unit_name: ::std::option::Option::None,
            items: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMatchPlayerPermanentBuff)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMatchPlayerPermanentBuff {
    // message fields
    // @@protoc_insertion_point(field:CMatchPlayerPermanentBuff.permanent_buff)
    pub permanent_buff: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerPermanentBuff.stack_count)
    pub stack_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchPlayerPermanentBuff.grant_time)
    pub grant_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMatchPlayerPermanentBuff.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMatchPlayerPermanentBuff {
    fn default() -> &'a CMatchPlayerPermanentBuff {
        <CMatchPlayerPermanentBuff as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMatchPlayerPermanentBuff {
    pub fn new() -> CMatchPlayerPermanentBuff {
        ::std::default::Default::default()
    }

    // optional uint32 permanent_buff = 1;

    pub fn permanent_buff(&self) -> u32 {
        self.permanent_buff.unwrap_or(0)
    }

    pub fn clear_permanent_buff(&mut self) {
        self.permanent_buff = ::std::option::Option::None;
    }

    pub fn has_permanent_buff(&self) -> bool {
        self.permanent_buff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permanent_buff(&mut self, v: u32) {
        self.permanent_buff = ::std::option::Option::Some(v);
    }

    // optional uint32 stack_count = 2;

    pub fn stack_count(&self) -> u32 {
        self.stack_count.unwrap_or(0)
    }

    pub fn clear_stack_count(&mut self) {
        self.stack_count = ::std::option::Option::None;
    }

    pub fn has_stack_count(&self) -> bool {
        self.stack_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_count(&mut self, v: u32) {
        self.stack_count = ::std::option::Option::Some(v);
    }

    // optional uint32 grant_time = 3;

    pub fn grant_time(&self) -> u32 {
        self.grant_time.unwrap_or(0)
    }

    pub fn clear_grant_time(&mut self) {
        self.grant_time = ::std::option::Option::None;
    }

    pub fn has_grant_time(&self) -> bool {
        self.grant_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grant_time(&mut self, v: u32) {
        self.grant_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMatchPlayerPermanentBuff {
    const NAME: &'static str = "CMatchPlayerPermanentBuff";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.permanent_buff = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.stack_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.grant_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.permanent_buff {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.stack_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.grant_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.permanent_buff {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.stack_count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.grant_time {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMatchPlayerPermanentBuff {
        CMatchPlayerPermanentBuff::new()
    }

    fn clear(&mut self) {
        self.permanent_buff = ::std::option::Option::None;
        self.stack_count = ::std::option::Option::None;
        self.grant_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMatchPlayerPermanentBuff {
        static instance: CMatchPlayerPermanentBuff = CMatchPlayerPermanentBuff {
            permanent_buff: ::std::option::Option::None,
            stack_count: ::std::option::Option::None,
            grant_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMatchHeroSelectEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMatchHeroSelectEvent {
    // message fields
    // @@protoc_insertion_point(field:CMatchHeroSelectEvent.is_pick)
    pub is_pick: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMatchHeroSelectEvent.team)
    pub team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchHeroSelectEvent.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMatchHeroSelectEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMatchHeroSelectEvent {
    fn default() -> &'a CMatchHeroSelectEvent {
        <CMatchHeroSelectEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMatchHeroSelectEvent {
    pub fn new() -> CMatchHeroSelectEvent {
        ::std::default::Default::default()
    }

    // optional bool is_pick = 1;

    pub fn is_pick(&self) -> bool {
        self.is_pick.unwrap_or(false)
    }

    pub fn clear_is_pick(&mut self) {
        self.is_pick = ::std::option::Option::None;
    }

    pub fn has_is_pick(&self) -> bool {
        self.is_pick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_pick(&mut self, v: bool) {
        self.is_pick = ::std::option::Option::Some(v);
    }

    // optional uint32 team = 2;

    pub fn team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 3;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMatchHeroSelectEvent {
    const NAME: &'static str = "CMatchHeroSelectEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_pick = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.team = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_pick {
            my_size += 1 + 1;
        }
        if let Some(v) = self.team {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.is_pick {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.team {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMatchHeroSelectEvent {
        CMatchHeroSelectEvent::new()
    }

    fn clear(&mut self) {
        self.is_pick = ::std::option::Option::None;
        self.team = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMatchHeroSelectEvent {
        static instance: CMatchHeroSelectEvent = CMatchHeroSelectEvent {
            is_pick: ::std::option::Option::None,
            team: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMatchClip)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMatchClip {
    // message fields
    // @@protoc_insertion_point(field:CMatchClip.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMatchClip.player_account_id)
    pub player_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchClip.game_time_seconds)
    pub game_time_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchClip.duration_seconds)
    pub duration_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchClip.player_id)
    pub player_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchClip.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMatchClip.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMatchClip.camera_mode)
    pub camera_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMatchClip.comment)
    pub comment: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMatchClip.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMatchClip {
    fn default() -> &'a CMatchClip {
        <CMatchClip as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMatchClip {
    pub fn new() -> CMatchClip {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 player_account_id = 2;

    pub fn player_account_id(&self) -> u32 {
        self.player_account_id.unwrap_or(0)
    }

    pub fn clear_player_account_id(&mut self) {
        self.player_account_id = ::std::option::Option::None;
    }

    pub fn has_player_account_id(&self) -> bool {
        self.player_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_account_id(&mut self, v: u32) {
        self.player_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 game_time_seconds = 3;

    pub fn game_time_seconds(&self) -> u32 {
        self.game_time_seconds.unwrap_or(0)
    }

    pub fn clear_game_time_seconds(&mut self) {
        self.game_time_seconds = ::std::option::Option::None;
    }

    pub fn has_game_time_seconds(&self) -> bool {
        self.game_time_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_time_seconds(&mut self, v: u32) {
        self.game_time_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 duration_seconds = 4;

    pub fn duration_seconds(&self) -> u32 {
        self.duration_seconds.unwrap_or(0)
    }

    pub fn clear_duration_seconds(&mut self) {
        self.duration_seconds = ::std::option::Option::None;
    }

    pub fn has_duration_seconds(&self) -> bool {
        self.duration_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_seconds(&mut self, v: u32) {
        self.duration_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 player_id = 5;

    pub fn player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 6;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional int32 ability_id = 7;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(-1i32)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional uint32 camera_mode = 8;

    pub fn camera_mode(&self) -> u32 {
        self.camera_mode.unwrap_or(0)
    }

    pub fn clear_camera_mode(&mut self) {
        self.camera_mode = ::std::option::Option::None;
    }

    pub fn has_camera_mode(&self) -> bool {
        self.camera_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camera_mode(&mut self, v: u32) {
        self.camera_mode = ::std::option::Option::Some(v);
    }

    // optional string comment = 9;

    pub fn comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_comment(&mut self) {
        self.comment = ::std::option::Option::None;
    }

    pub fn has_comment(&self) -> bool {
        self.comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        if self.comment.is_none() {
            self.comment = ::std::option::Option::Some(::std::string::String::new());
        }
        self.comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        self.comment.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMatchClip {
    const NAME: &'static str = "CMatchClip";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.player_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.game_time_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.duration_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.player_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.camera_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    self.comment = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.player_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.game_time_seconds {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.duration_seconds {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.camera_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.comment.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(9, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.player_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.game_time_seconds {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.duration_seconds {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.player_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.ability_id {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.camera_mode {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.comment.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMatchClip {
        CMatchClip::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.player_account_id = ::std::option::Option::None;
        self.game_time_seconds = ::std::option::Option::None;
        self.duration_seconds = ::std::option::Option::None;
        self.player_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.ability_id = ::std::option::Option::None;
        self.camera_mode = ::std::option::Option::None;
        self.comment = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMatchClip {
        static instance: CMatchClip = CMatchClip {
            match_id: ::std::option::Option::None,
            player_account_id: ::std::option::Option::None,
            game_time_seconds: ::std::option::Option::None,
            duration_seconds: ::std::option::Option::None,
            player_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            ability_id: ::std::option::Option::None,
            camera_mode: ::std::option::Option::None,
            comment: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CPartySearchClientParty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CPartySearchClientParty {
    // message fields
    // @@protoc_insertion_point(field:CPartySearchClientParty.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CPartySearchClientParty.beacon_type)
    pub beacon_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CPartySearchClientParty.party_members)
    pub party_members: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CPartySearchClientParty.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CPartySearchClientParty {
    fn default() -> &'a CPartySearchClientParty {
        <CPartySearchClientParty as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CPartySearchClientParty {
    pub fn new() -> CPartySearchClientParty {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional int32 beacon_type = 2;

    pub fn beacon_type(&self) -> i32 {
        self.beacon_type.unwrap_or(0)
    }

    pub fn clear_beacon_type(&mut self) {
        self.beacon_type = ::std::option::Option::None;
    }

    pub fn has_beacon_type(&self) -> bool {
        self.beacon_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beacon_type(&mut self, v: i32) {
        self.beacon_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CPartySearchClientParty {
    const NAME: &'static str = "CPartySearchClientParty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.beacon_type = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    is.read_repeated_packed_fixed32_into(&mut self.party_members)?;
                },
                29 => {
                    self.party_members.push(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.beacon_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += 5 * self.party_members.len() as u64;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.beacon_type {
            os.write_int32(2, v)?;
        }
        for v in &self.party_members {
            os.write_fixed32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CPartySearchClientParty {
        CPartySearchClientParty::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.beacon_type = ::std::option::Option::None;
        self.party_members.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CPartySearchClientParty {
        static instance: CPartySearchClientParty = CPartySearchClientParty {
            party_id: ::std::option::Option::None,
            beacon_type: ::std::option::Option::None,
            party_members: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAHasItemQuery)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAHasItemQuery {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAHasItemQuery.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAHasItemQuery.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAHasItemQuery.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAHasItemQuery {
    fn default() -> &'a CMsgDOTAHasItemQuery {
        <CMsgDOTAHasItemQuery as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAHasItemQuery {
    pub fn new() -> CMsgDOTAHasItemQuery {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 2;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAHasItemQuery {
    const NAME: &'static str = "CMsgDOTAHasItemQuery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAHasItemQuery {
        CMsgDOTAHasItemQuery::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAHasItemQuery {
        static instance: CMsgDOTAHasItemQuery = CMsgDOTAHasItemQuery {
            account_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAHasItemResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAHasItemResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAHasItemResponse.has_item)
    pub has_item: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAHasItemResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAHasItemResponse {
    fn default() -> &'a CMsgDOTAHasItemResponse {
        <CMsgDOTAHasItemResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAHasItemResponse {
    pub fn new() -> CMsgDOTAHasItemResponse {
        ::std::default::Default::default()
    }

    // optional bool has_item = 1;

    pub fn has_item(&self) -> bool {
        self.has_item.unwrap_or(false)
    }

    pub fn clear_has_item(&mut self) {
        self.has_item = ::std::option::Option::None;
    }

    pub fn has_has_item(&self) -> bool {
        self.has_item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_item(&mut self, v: bool) {
        self.has_item = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAHasItemResponse {
    const NAME: &'static str = "CMsgDOTAHasItemResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.has_item = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.has_item {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.has_item {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAHasItemResponse {
        CMsgDOTAHasItemResponse::new()
    }

    fn clear(&mut self) {
        self.has_item = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAHasItemResponse {
        static instance: CMsgDOTAHasItemResponse = CMsgDOTAHasItemResponse {
            has_item: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCGetPlayerCardItemInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCGetPlayerCardItemInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCGetPlayerCardItemInfo.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCGetPlayerCardItemInfo.player_card_item_ids)
    pub player_card_item_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgGCGetPlayerCardItemInfo.all_for_event)
    pub all_for_event: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCGetPlayerCardItemInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCGetPlayerCardItemInfo {
    fn default() -> &'a CMsgGCGetPlayerCardItemInfo {
        <CMsgGCGetPlayerCardItemInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCGetPlayerCardItemInfo {
    pub fn new() -> CMsgGCGetPlayerCardItemInfo {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 all_for_event = 3;

    pub fn all_for_event(&self) -> u32 {
        self.all_for_event.unwrap_or(0)
    }

    pub fn clear_all_for_event(&mut self) {
        self.all_for_event = ::std::option::Option::None;
    }

    pub fn has_all_for_event(&self) -> bool {
        self.all_for_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_all_for_event(&mut self, v: u32) {
        self.all_for_event = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCGetPlayerCardItemInfo {
    const NAME: &'static str = "CMsgGCGetPlayerCardItemInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.player_card_item_ids)?;
                },
                16 => {
                    self.player_card_item_ids.push(is.read_uint64()?);
                },
                24 => {
                    self.all_for_event = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.player_card_item_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, *value);
        };
        if let Some(v) = self.all_for_event {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.player_card_item_ids {
            os.write_uint64(2, *v)?;
        };
        if let Some(v) = self.all_for_event {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCGetPlayerCardItemInfo {
        CMsgGCGetPlayerCardItemInfo::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.player_card_item_ids.clear();
        self.all_for_event = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCGetPlayerCardItemInfo {
        static instance: CMsgGCGetPlayerCardItemInfo = CMsgGCGetPlayerCardItemInfo {
            account_id: ::std::option::Option::None,
            player_card_item_ids: ::std::vec::Vec::new(),
            all_for_event: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCGetPlayerCardItemInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCGetPlayerCardItemInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCGetPlayerCardItemInfoResponse.player_card_infos)
    pub player_card_infos: ::std::vec::Vec<cmsg_gcget_player_card_item_info_response::PlayerCardInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCGetPlayerCardItemInfoResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCGetPlayerCardItemInfoResponse {
    fn default() -> &'a CMsgGCGetPlayerCardItemInfoResponse {
        <CMsgGCGetPlayerCardItemInfoResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCGetPlayerCardItemInfoResponse {
    pub fn new() -> CMsgGCGetPlayerCardItemInfoResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCGetPlayerCardItemInfoResponse {
    const NAME: &'static str = "CMsgGCGetPlayerCardItemInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_card_infos.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_card_infos {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.player_card_infos {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCGetPlayerCardItemInfoResponse {
        CMsgGCGetPlayerCardItemInfoResponse::new()
    }

    fn clear(&mut self) {
        self.player_card_infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCGetPlayerCardItemInfoResponse {
        static instance: CMsgGCGetPlayerCardItemInfoResponse = CMsgGCGetPlayerCardItemInfoResponse {
            player_card_infos: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCGetPlayerCardItemInfoResponse`
pub mod cmsg_gcget_player_card_item_info_response {
    // @@protoc_insertion_point(message:CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerCardInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo.player_card_item_id)
        pub player_card_item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo.packed_bonuses)
        pub packed_bonuses: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerCardInfo {
        fn default() -> &'a PlayerCardInfo {
            <PlayerCardInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerCardInfo {
        pub fn new() -> PlayerCardInfo {
            ::std::default::Default::default()
        }

        // optional uint64 player_card_item_id = 1;

        pub fn player_card_item_id(&self) -> u64 {
            self.player_card_item_id.unwrap_or(0)
        }

        pub fn clear_player_card_item_id(&mut self) {
            self.player_card_item_id = ::std::option::Option::None;
        }

        pub fn has_player_card_item_id(&self) -> bool {
            self.player_card_item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_card_item_id(&mut self, v: u64) {
            self.player_card_item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 account_id = 2;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint64 packed_bonuses = 3;

        pub fn packed_bonuses(&self) -> u64 {
            self.packed_bonuses.unwrap_or(0)
        }

        pub fn clear_packed_bonuses(&mut self) {
            self.packed_bonuses = ::std::option::Option::None;
        }

        pub fn has_packed_bonuses(&self) -> bool {
            self.packed_bonuses.is_some()
        }

        // Param is passed by value, moved
        pub fn set_packed_bonuses(&mut self, v: u64) {
            self.packed_bonuses = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerCardInfo {
        const NAME: &'static str = "PlayerCardInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_card_item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.packed_bonuses = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_card_item_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.packed_bonuses {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.player_card_item_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.account_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.packed_bonuses {
                os.write_uint64(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerCardInfo {
            PlayerCardInfo::new()
        }

        fn clear(&mut self) {
            self.player_card_item_id = ::std::option::Option::None;
            self.account_id = ::std::option::Option::None;
            self.packed_bonuses = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerCardInfo {
            static instance: PlayerCardInfo = PlayerCardInfo {
                player_card_item_id: ::std::option::Option::None,
                account_id: ::std::option::Option::None,
                packed_bonuses: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CSODOTAMapLocationState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAMapLocationState {
    // message fields
    // @@protoc_insertion_point(field:CSODOTAMapLocationState.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAMapLocationState.location_id)
    pub location_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSODOTAMapLocationState.completed)
    pub completed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSODOTAMapLocationState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAMapLocationState {
    fn default() -> &'a CSODOTAMapLocationState {
        <CSODOTAMapLocationState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSODOTAMapLocationState {
    pub fn new() -> CSODOTAMapLocationState {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional int32 location_id = 2;

    pub fn location_id(&self) -> i32 {
        self.location_id.unwrap_or(0)
    }

    pub fn clear_location_id(&mut self) {
        self.location_id = ::std::option::Option::None;
    }

    pub fn has_location_id(&self) -> bool {
        self.location_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location_id(&mut self, v: i32) {
        self.location_id = ::std::option::Option::Some(v);
    }

    // optional bool completed = 3;

    pub fn completed(&self) -> bool {
        self.completed.unwrap_or(false)
    }

    pub fn clear_completed(&mut self) {
        self.completed = ::std::option::Option::None;
    }

    pub fn has_completed(&self) -> bool {
        self.completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed(&mut self, v: bool) {
        self.completed = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSODOTAMapLocationState {
    const NAME: &'static str = "CSODOTAMapLocationState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.location_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.completed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.location_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.completed {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.location_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.completed {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAMapLocationState {
        CSODOTAMapLocationState::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.location_id = ::std::option::Option::None;
        self.completed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAMapLocationState {
        static instance: CSODOTAMapLocationState = CSODOTAMapLocationState {
            account_id: ::std::option::Option::None,
            location_id: ::std::option::Option::None,
            completed: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLeagueAdminList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLeagueAdminList {
    // message fields
    // @@protoc_insertion_point(field:CMsgLeagueAdminList.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLeagueAdminList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLeagueAdminList {
    fn default() -> &'a CMsgLeagueAdminList {
        <CMsgLeagueAdminList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLeagueAdminList {
    pub fn new() -> CMsgLeagueAdminList {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLeagueAdminList {
    const NAME: &'static str = "CMsgLeagueAdminList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                8 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLeagueAdminList {
        CMsgLeagueAdminList::new()
    }

    fn clear(&mut self) {
        self.account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLeagueAdminList {
        static instance: CMsgLeagueAdminList = CMsgLeagueAdminList {
            account_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAProfileCard)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAProfileCard {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAProfileCard.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAProfileCard.slots)
    pub slots: ::std::vec::Vec<cmsg_dotaprofile_card::Slot>,
    // @@protoc_insertion_point(field:CMsgDOTAProfileCard.badge_points)
    pub badge_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAProfileCard.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAProfileCard.recent_battle_cup_victory)
    pub recent_battle_cup_victory: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleCupVictory>,
    // @@protoc_insertion_point(field:CMsgDOTAProfileCard.rank_tier)
    pub rank_tier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAProfileCard.leaderboard_rank)
    pub leaderboard_rank: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAProfileCard.is_plus_subscriber)
    pub is_plus_subscriber: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTAProfileCard.plus_original_start_date)
    pub plus_original_start_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAProfileCard.rank_tier_score)
    pub rank_tier_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAProfileCard.leaderboard_rank_core)
    pub leaderboard_rank_core: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAProfileCard.title)
    pub title: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAProfileCard.favorite_team_packed)
    pub favorite_team_packed: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTAProfileCard.lifetime_games)
    pub lifetime_games: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAProfileCard.event_level)
    pub event_level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAProfileCard.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAProfileCard {
    fn default() -> &'a CMsgDOTAProfileCard {
        <CMsgDOTAProfileCard as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAProfileCard {
    pub fn new() -> CMsgDOTAProfileCard {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 badge_points = 4;

    pub fn badge_points(&self) -> u32 {
        self.badge_points.unwrap_or(0)
    }

    pub fn clear_badge_points(&mut self) {
        self.badge_points = ::std::option::Option::None;
    }

    pub fn has_badge_points(&self) -> bool {
        self.badge_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_points(&mut self, v: u32) {
        self.badge_points = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 6;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 rank_tier = 8;

    pub fn rank_tier(&self) -> u32 {
        self.rank_tier.unwrap_or(0)
    }

    pub fn clear_rank_tier(&mut self) {
        self.rank_tier = ::std::option::Option::None;
    }

    pub fn has_rank_tier(&self) -> bool {
        self.rank_tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_tier(&mut self, v: u32) {
        self.rank_tier = ::std::option::Option::Some(v);
    }

    // optional uint32 leaderboard_rank = 9;

    pub fn leaderboard_rank(&self) -> u32 {
        self.leaderboard_rank.unwrap_or(0)
    }

    pub fn clear_leaderboard_rank(&mut self) {
        self.leaderboard_rank = ::std::option::Option::None;
    }

    pub fn has_leaderboard_rank(&self) -> bool {
        self.leaderboard_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_rank(&mut self, v: u32) {
        self.leaderboard_rank = ::std::option::Option::Some(v);
    }

    // optional bool is_plus_subscriber = 10;

    pub fn is_plus_subscriber(&self) -> bool {
        self.is_plus_subscriber.unwrap_or(false)
    }

    pub fn clear_is_plus_subscriber(&mut self) {
        self.is_plus_subscriber = ::std::option::Option::None;
    }

    pub fn has_is_plus_subscriber(&self) -> bool {
        self.is_plus_subscriber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_plus_subscriber(&mut self, v: bool) {
        self.is_plus_subscriber = ::std::option::Option::Some(v);
    }

    // optional uint32 plus_original_start_date = 11;

    pub fn plus_original_start_date(&self) -> u32 {
        self.plus_original_start_date.unwrap_or(0)
    }

    pub fn clear_plus_original_start_date(&mut self) {
        self.plus_original_start_date = ::std::option::Option::None;
    }

    pub fn has_plus_original_start_date(&self) -> bool {
        self.plus_original_start_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plus_original_start_date(&mut self, v: u32) {
        self.plus_original_start_date = ::std::option::Option::Some(v);
    }

    // optional uint32 rank_tier_score = 12;

    pub fn rank_tier_score(&self) -> u32 {
        self.rank_tier_score.unwrap_or(0)
    }

    pub fn clear_rank_tier_score(&mut self) {
        self.rank_tier_score = ::std::option::Option::None;
    }

    pub fn has_rank_tier_score(&self) -> bool {
        self.rank_tier_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_tier_score(&mut self, v: u32) {
        self.rank_tier_score = ::std::option::Option::Some(v);
    }

    // optional uint32 leaderboard_rank_core = 17;

    pub fn leaderboard_rank_core(&self) -> u32 {
        self.leaderboard_rank_core.unwrap_or(0)
    }

    pub fn clear_leaderboard_rank_core(&mut self) {
        self.leaderboard_rank_core = ::std::option::Option::None;
    }

    pub fn has_leaderboard_rank_core(&self) -> bool {
        self.leaderboard_rank_core.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_rank_core(&mut self, v: u32) {
        self.leaderboard_rank_core = ::std::option::Option::Some(v);
    }

    // optional uint32 title = 23;

    pub fn title(&self) -> u32 {
        self.title.unwrap_or(0)
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: u32) {
        self.title = ::std::option::Option::Some(v);
    }

    // optional uint64 favorite_team_packed = 24;

    pub fn favorite_team_packed(&self) -> u64 {
        self.favorite_team_packed.unwrap_or(0)
    }

    pub fn clear_favorite_team_packed(&mut self) {
        self.favorite_team_packed = ::std::option::Option::None;
    }

    pub fn has_favorite_team_packed(&self) -> bool {
        self.favorite_team_packed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite_team_packed(&mut self, v: u64) {
        self.favorite_team_packed = ::std::option::Option::Some(v);
    }

    // optional uint32 lifetime_games = 25;

    pub fn lifetime_games(&self) -> u32 {
        self.lifetime_games.unwrap_or(0)
    }

    pub fn clear_lifetime_games(&mut self) {
        self.lifetime_games = ::std::option::Option::None;
    }

    pub fn has_lifetime_games(&self) -> bool {
        self.lifetime_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifetime_games(&mut self, v: u32) {
        self.lifetime_games = ::std::option::Option::Some(v);
    }

    // optional uint32 event_level = 26;

    pub fn event_level(&self) -> u32 {
        self.event_level.unwrap_or(0)
    }

    pub fn clear_event_level(&mut self) {
        self.event_level = ::std::option::Option::None;
    }

    pub fn has_event_level(&self) -> bool {
        self.event_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_level(&mut self, v: u32) {
        self.event_level = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAProfileCard {
    const NAME: &'static str = "CMsgDOTAProfileCard";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.slots.push(is.read_message()?);
                },
                32 => {
                    self.badge_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.recent_battle_cup_victory)?;
                },
                64 => {
                    self.rank_tier = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.leaderboard_rank = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.is_plus_subscriber = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.plus_original_start_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.rank_tier_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.leaderboard_rank_core = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.title = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.favorite_team_packed = ::std::option::Option::Some(is.read_uint64()?);
                },
                200 => {
                    self.lifetime_games = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.event_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.slots {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.badge_points {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.recent_battle_cup_victory.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rank_tier {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.leaderboard_rank {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.is_plus_subscriber {
            my_size += 1 + 1;
        }
        if let Some(v) = self.plus_original_start_date {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.rank_tier_score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.leaderboard_rank_core {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.title {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.favorite_team_packed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(24, v);
        }
        if let Some(v) = self.lifetime_games {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.event_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(26, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.slots {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.badge_points {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.recent_battle_cup_victory.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.rank_tier {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.leaderboard_rank {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.is_plus_subscriber {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.plus_original_start_date {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.rank_tier_score {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.leaderboard_rank_core {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.title {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.favorite_team_packed {
            os.write_uint64(24, v)?;
        }
        if let Some(v) = self.lifetime_games {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.event_level {
            os.write_uint32(26, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAProfileCard {
        CMsgDOTAProfileCard::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.slots.clear();
        self.badge_points = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.recent_battle_cup_victory.clear();
        self.rank_tier = ::std::option::Option::None;
        self.leaderboard_rank = ::std::option::Option::None;
        self.is_plus_subscriber = ::std::option::Option::None;
        self.plus_original_start_date = ::std::option::Option::None;
        self.rank_tier_score = ::std::option::Option::None;
        self.leaderboard_rank_core = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.favorite_team_packed = ::std::option::Option::None;
        self.lifetime_games = ::std::option::Option::None;
        self.event_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAProfileCard {
        static instance: CMsgDOTAProfileCard = CMsgDOTAProfileCard {
            account_id: ::std::option::Option::None,
            slots: ::std::vec::Vec::new(),
            badge_points: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            recent_battle_cup_victory: ::steam_vent_proto_common::protobuf::MessageField::none(),
            rank_tier: ::std::option::Option::None,
            leaderboard_rank: ::std::option::Option::None,
            is_plus_subscriber: ::std::option::Option::None,
            plus_original_start_date: ::std::option::Option::None,
            rank_tier_score: ::std::option::Option::None,
            leaderboard_rank_core: ::std::option::Option::None,
            title: ::std::option::Option::None,
            favorite_team_packed: ::std::option::Option::None,
            lifetime_games: ::std::option::Option::None,
            event_level: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTAProfileCard`
pub mod cmsg_dotaprofile_card {
    // @@protoc_insertion_point(message:CMsgDOTAProfileCard.Slot)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Slot {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAProfileCard.Slot.slot_id)
        pub slot_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAProfileCard.Slot.trophy)
        pub trophy: ::steam_vent_proto_common::protobuf::MessageField<slot::Trophy>,
        // @@protoc_insertion_point(field:CMsgDOTAProfileCard.Slot.stat)
        pub stat: ::steam_vent_proto_common::protobuf::MessageField<slot::Stat>,
        // @@protoc_insertion_point(field:CMsgDOTAProfileCard.Slot.item)
        pub item: ::steam_vent_proto_common::protobuf::MessageField<slot::Item>,
        // @@protoc_insertion_point(field:CMsgDOTAProfileCard.Slot.hero)
        pub hero: ::steam_vent_proto_common::protobuf::MessageField<slot::Hero>,
        // @@protoc_insertion_point(field:CMsgDOTAProfileCard.Slot.emoticon)
        pub emoticon: ::steam_vent_proto_common::protobuf::MessageField<slot::Emoticon>,
        // @@protoc_insertion_point(field:CMsgDOTAProfileCard.Slot.team)
        pub team: ::steam_vent_proto_common::protobuf::MessageField<slot::Team>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAProfileCard.Slot.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Slot {
        fn default() -> &'a Slot {
            <Slot as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Slot {
        pub fn new() -> Slot {
            ::std::default::Default::default()
        }

        // optional uint32 slot_id = 1;

        pub fn slot_id(&self) -> u32 {
            self.slot_id.unwrap_or(0)
        }

        pub fn clear_slot_id(&mut self) {
            self.slot_id = ::std::option::Option::None;
        }

        pub fn has_slot_id(&self) -> bool {
            self.slot_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot_id(&mut self, v: u32) {
            self.slot_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Slot {
        const NAME: &'static str = "Slot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.trophy)?;
                    },
                    26 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.stat)?;
                    },
                    34 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.item)?;
                    },
                    42 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.hero)?;
                    },
                    50 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.emoticon)?;
                    },
                    58 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.team)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.slot_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.trophy.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.stat.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.item.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.hero.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.emoticon.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.team.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.slot_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.trophy.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.stat.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.item.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.hero.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if let Some(v) = self.emoticon.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            if let Some(v) = self.team.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Slot {
            Slot::new()
        }

        fn clear(&mut self) {
            self.slot_id = ::std::option::Option::None;
            self.trophy.clear();
            self.stat.clear();
            self.item.clear();
            self.hero.clear();
            self.emoticon.clear();
            self.team.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Slot {
            static instance: Slot = Slot {
                slot_id: ::std::option::Option::None,
                trophy: ::steam_vent_proto_common::protobuf::MessageField::none(),
                stat: ::steam_vent_proto_common::protobuf::MessageField::none(),
                item: ::steam_vent_proto_common::protobuf::MessageField::none(),
                hero: ::steam_vent_proto_common::protobuf::MessageField::none(),
                emoticon: ::steam_vent_proto_common::protobuf::MessageField::none(),
                team: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Slot`
    pub mod slot {
        // @@protoc_insertion_point(message:CMsgDOTAProfileCard.Slot.Trophy)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Trophy {
            // message fields
            // @@protoc_insertion_point(field:CMsgDOTAProfileCard.Slot.Trophy.trophy_id)
            pub trophy_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgDOTAProfileCard.Slot.Trophy.trophy_score)
            pub trophy_score: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgDOTAProfileCard.Slot.Trophy.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Trophy {
            fn default() -> &'a Trophy {
                <Trophy as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl Trophy {
            pub fn new() -> Trophy {
                ::std::default::Default::default()
            }

            // optional uint32 trophy_id = 1;

            pub fn trophy_id(&self) -> u32 {
                self.trophy_id.unwrap_or(0)
            }

            pub fn clear_trophy_id(&mut self) {
                self.trophy_id = ::std::option::Option::None;
            }

            pub fn has_trophy_id(&self) -> bool {
                self.trophy_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_trophy_id(&mut self, v: u32) {
                self.trophy_id = ::std::option::Option::Some(v);
            }

            // optional uint32 trophy_score = 2;

            pub fn trophy_score(&self) -> u32 {
                self.trophy_score.unwrap_or(0)
            }

            pub fn clear_trophy_score(&mut self) {
                self.trophy_score = ::std::option::Option::None;
            }

            pub fn has_trophy_score(&self) -> bool {
                self.trophy_score.is_some()
            }

            // Param is passed by value, moved
            pub fn set_trophy_score(&mut self, v: u32) {
                self.trophy_score = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for Trophy {
            const NAME: &'static str = "Trophy";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.trophy_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.trophy_score = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.trophy_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.trophy_score {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.trophy_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.trophy_score {
                    os.write_uint32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Trophy {
                Trophy::new()
            }

            fn clear(&mut self) {
                self.trophy_id = ::std::option::Option::None;
                self.trophy_score = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Trophy {
                static instance: Trophy = Trophy {
                    trophy_id: ::std::option::Option::None,
                    trophy_score: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CMsgDOTAProfileCard.Slot.Stat)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Stat {
            // message fields
            // @@protoc_insertion_point(field:CMsgDOTAProfileCard.Slot.Stat.stat_id)
            pub stat_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::EStatID>>,
            // @@protoc_insertion_point(field:CMsgDOTAProfileCard.Slot.Stat.stat_score)
            pub stat_score: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgDOTAProfileCard.Slot.Stat.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Stat {
            fn default() -> &'a Stat {
                <Stat as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl Stat {
            pub fn new() -> Stat {
                ::std::default::Default::default()
            }

            // optional .CMsgDOTAProfileCard.EStatID stat_id = 1;

            pub fn stat_id(&self) -> super::EStatID {
                match self.stat_id {
                    Some(e) => e.enum_value_or(super::EStatID::k_eStat_Wins),
                    None => super::EStatID::k_eStat_Wins,
                }
            }

            pub fn clear_stat_id(&mut self) {
                self.stat_id = ::std::option::Option::None;
            }

            pub fn has_stat_id(&self) -> bool {
                self.stat_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_stat_id(&mut self, v: super::EStatID) {
                self.stat_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
            }

            // optional uint32 stat_score = 2;

            pub fn stat_score(&self) -> u32 {
                self.stat_score.unwrap_or(0)
            }

            pub fn clear_stat_score(&mut self) {
                self.stat_score = ::std::option::Option::None;
            }

            pub fn has_stat_score(&self) -> bool {
                self.stat_score.is_some()
            }

            // Param is passed by value, moved
            pub fn set_stat_score(&mut self, v: u32) {
                self.stat_score = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for Stat {
            const NAME: &'static str = "Stat";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.stat_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        16 => {
                            self.stat_score = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.stat_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
                }
                if let Some(v) = self.stat_score {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.stat_id {
                    os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
                }
                if let Some(v) = self.stat_score {
                    os.write_uint32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Stat {
                Stat::new()
            }

            fn clear(&mut self) {
                self.stat_id = ::std::option::Option::None;
                self.stat_score = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Stat {
                static instance: Stat = Stat {
                    stat_id: ::std::option::Option::None,
                    stat_score: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CMsgDOTAProfileCard.Slot.Item)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Item {
            // message fields
            // @@protoc_insertion_point(field:CMsgDOTAProfileCard.Slot.Item.serialized_item)
            pub serialized_item: ::std::option::Option<::std::vec::Vec<u8>>,
            // @@protoc_insertion_point(field:CMsgDOTAProfileCard.Slot.Item.item_id)
            pub item_id: ::std::option::Option<u64>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgDOTAProfileCard.Slot.Item.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Item {
            fn default() -> &'a Item {
                <Item as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl Item {
            pub fn new() -> Item {
                ::std::default::Default::default()
            }

            // optional bytes serialized_item = 1;

            pub fn serialized_item(&self) -> &[u8] {
                match self.serialized_item.as_ref() {
                    Some(v) => v,
                    None => &[],
                }
            }

            pub fn clear_serialized_item(&mut self) {
                self.serialized_item = ::std::option::Option::None;
            }

            pub fn has_serialized_item(&self) -> bool {
                self.serialized_item.is_some()
            }

            // Param is passed by value, moved
            pub fn set_serialized_item(&mut self, v: ::std::vec::Vec<u8>) {
                self.serialized_item = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_serialized_item(&mut self) -> &mut ::std::vec::Vec<u8> {
                if self.serialized_item.is_none() {
                    self.serialized_item = ::std::option::Option::Some(::std::vec::Vec::new());
                }
                self.serialized_item.as_mut().unwrap()
            }

            // Take field
            pub fn take_serialized_item(&mut self) -> ::std::vec::Vec<u8> {
                self.serialized_item.take().unwrap_or_else(|| ::std::vec::Vec::new())
            }

            // optional uint64 item_id = 2;

            pub fn item_id(&self) -> u64 {
                self.item_id.unwrap_or(0)
            }

            pub fn clear_item_id(&mut self) {
                self.item_id = ::std::option::Option::None;
            }

            pub fn has_item_id(&self) -> bool {
                self.item_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_item_id(&mut self, v: u64) {
                self.item_id = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for Item {
            const NAME: &'static str = "Item";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.serialized_item = ::std::option::Option::Some(is.read_bytes()?);
                        },
                        16 => {
                            self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.serialized_item.as_ref() {
                    my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(1, &v);
                }
                if let Some(v) = self.item_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.serialized_item.as_ref() {
                    os.write_bytes(1, v)?;
                }
                if let Some(v) = self.item_id {
                    os.write_uint64(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Item {
                Item::new()
            }

            fn clear(&mut self) {
                self.serialized_item = ::std::option::Option::None;
                self.item_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Item {
                static instance: Item = Item {
                    serialized_item: ::std::option::Option::None,
                    item_id: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CMsgDOTAProfileCard.Slot.Hero)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Hero {
            // message fields
            // @@protoc_insertion_point(field:CMsgDOTAProfileCard.Slot.Hero.hero_id)
            pub hero_id: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CMsgDOTAProfileCard.Slot.Hero.hero_wins)
            pub hero_wins: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgDOTAProfileCard.Slot.Hero.hero_losses)
            pub hero_losses: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgDOTAProfileCard.Slot.Hero.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Hero {
            fn default() -> &'a Hero {
                <Hero as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl Hero {
            pub fn new() -> Hero {
                ::std::default::Default::default()
            }

            // optional int32 hero_id = 1;

            pub fn hero_id(&self) -> i32 {
                self.hero_id.unwrap_or(0)
            }

            pub fn clear_hero_id(&mut self) {
                self.hero_id = ::std::option::Option::None;
            }

            pub fn has_hero_id(&self) -> bool {
                self.hero_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_id(&mut self, v: i32) {
                self.hero_id = ::std::option::Option::Some(v);
            }

            // optional uint32 hero_wins = 2;

            pub fn hero_wins(&self) -> u32 {
                self.hero_wins.unwrap_or(0)
            }

            pub fn clear_hero_wins(&mut self) {
                self.hero_wins = ::std::option::Option::None;
            }

            pub fn has_hero_wins(&self) -> bool {
                self.hero_wins.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_wins(&mut self, v: u32) {
                self.hero_wins = ::std::option::Option::Some(v);
            }

            // optional uint32 hero_losses = 3;

            pub fn hero_losses(&self) -> u32 {
                self.hero_losses.unwrap_or(0)
            }

            pub fn clear_hero_losses(&mut self) {
                self.hero_losses = ::std::option::Option::None;
            }

            pub fn has_hero_losses(&self) -> bool {
                self.hero_losses.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_losses(&mut self, v: u32) {
                self.hero_losses = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for Hero {
            const NAME: &'static str = "Hero";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                        },
                        16 => {
                            self.hero_wins = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.hero_losses = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.hero_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
                }
                if let Some(v) = self.hero_wins {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.hero_losses {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.hero_id {
                    os.write_int32(1, v)?;
                }
                if let Some(v) = self.hero_wins {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.hero_losses {
                    os.write_uint32(3, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Hero {
                Hero::new()
            }

            fn clear(&mut self) {
                self.hero_id = ::std::option::Option::None;
                self.hero_wins = ::std::option::Option::None;
                self.hero_losses = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Hero {
                static instance: Hero = Hero {
                    hero_id: ::std::option::Option::None,
                    hero_wins: ::std::option::Option::None,
                    hero_losses: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CMsgDOTAProfileCard.Slot.Emoticon)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Emoticon {
            // message fields
            // @@protoc_insertion_point(field:CMsgDOTAProfileCard.Slot.Emoticon.emoticon_id)
            pub emoticon_id: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgDOTAProfileCard.Slot.Emoticon.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Emoticon {
            fn default() -> &'a Emoticon {
                <Emoticon as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl Emoticon {
            pub fn new() -> Emoticon {
                ::std::default::Default::default()
            }

            // optional uint32 emoticon_id = 1;

            pub fn emoticon_id(&self) -> u32 {
                self.emoticon_id.unwrap_or(0)
            }

            pub fn clear_emoticon_id(&mut self) {
                self.emoticon_id = ::std::option::Option::None;
            }

            pub fn has_emoticon_id(&self) -> bool {
                self.emoticon_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_emoticon_id(&mut self, v: u32) {
                self.emoticon_id = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for Emoticon {
            const NAME: &'static str = "Emoticon";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.emoticon_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.emoticon_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.emoticon_id {
                    os.write_uint32(1, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Emoticon {
                Emoticon::new()
            }

            fn clear(&mut self) {
                self.emoticon_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Emoticon {
                static instance: Emoticon = Emoticon {
                    emoticon_id: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CMsgDOTAProfileCard.Slot.Team)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Team {
            // message fields
            // @@protoc_insertion_point(field:CMsgDOTAProfileCard.Slot.Team.team_id)
            pub team_id: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgDOTAProfileCard.Slot.Team.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Team {
            fn default() -> &'a Team {
                <Team as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl Team {
            pub fn new() -> Team {
                ::std::default::Default::default()
            }

            // optional uint32 team_id = 1;

            pub fn team_id(&self) -> u32 {
                self.team_id.unwrap_or(0)
            }

            pub fn clear_team_id(&mut self) {
                self.team_id = ::std::option::Option::None;
            }

            pub fn has_team_id(&self) -> bool {
                self.team_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_team_id(&mut self, v: u32) {
                self.team_id = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for Team {
            const NAME: &'static str = "Team";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.team_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.team_id {
                    os.write_uint32(1, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Team {
                Team::new()
            }

            fn clear(&mut self) {
                self.team_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Team {
                static instance: Team = Team {
                    team_id: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgDOTAProfileCard.EStatID)
    pub enum EStatID {
        // @@protoc_insertion_point(enum_value:CMsgDOTAProfileCard.EStatID.k_eStat_Wins)
        k_eStat_Wins = 3,
        // @@protoc_insertion_point(enum_value:CMsgDOTAProfileCard.EStatID.k_eStat_Commends)
        k_eStat_Commends = 4,
        // @@protoc_insertion_point(enum_value:CMsgDOTAProfileCard.EStatID.k_eStat_GamesPlayed)
        k_eStat_GamesPlayed = 5,
        // @@protoc_insertion_point(enum_value:CMsgDOTAProfileCard.EStatID.k_eStat_FirstMatchDate)
        k_eStat_FirstMatchDate = 6,
        // @@protoc_insertion_point(enum_value:CMsgDOTAProfileCard.EStatID.k_eStat_PreviousSeasonRank)
        k_eStat_PreviousSeasonRank = 7,
        // @@protoc_insertion_point(enum_value:CMsgDOTAProfileCard.EStatID.k_eStat_GamesMVP)
        k_eStat_GamesMVP = 8,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EStatID {
        const NAME: &'static str = "EStatID";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EStatID> {
            match value {
                3 => ::std::option::Option::Some(EStatID::k_eStat_Wins),
                4 => ::std::option::Option::Some(EStatID::k_eStat_Commends),
                5 => ::std::option::Option::Some(EStatID::k_eStat_GamesPlayed),
                6 => ::std::option::Option::Some(EStatID::k_eStat_FirstMatchDate),
                7 => ::std::option::Option::Some(EStatID::k_eStat_PreviousSeasonRank),
                8 => ::std::option::Option::Some(EStatID::k_eStat_GamesMVP),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EStatID> {
            match str {
                "k_eStat_Wins" => ::std::option::Option::Some(EStatID::k_eStat_Wins),
                "k_eStat_Commends" => ::std::option::Option::Some(EStatID::k_eStat_Commends),
                "k_eStat_GamesPlayed" => ::std::option::Option::Some(EStatID::k_eStat_GamesPlayed),
                "k_eStat_FirstMatchDate" => ::std::option::Option::Some(EStatID::k_eStat_FirstMatchDate),
                "k_eStat_PreviousSeasonRank" => ::std::option::Option::Some(EStatID::k_eStat_PreviousSeasonRank),
                "k_eStat_GamesMVP" => ::std::option::Option::Some(EStatID::k_eStat_GamesMVP),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EStatID] = &[
            EStatID::k_eStat_Wins,
            EStatID::k_eStat_Commends,
            EStatID::k_eStat_GamesPlayed,
            EStatID::k_eStat_FirstMatchDate,
            EStatID::k_eStat_PreviousSeasonRank,
            EStatID::k_eStat_GamesMVP,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for EStatID {
        fn default() -> Self {
            EStatID::k_eStat_Wins
        }
    }

}

// @@protoc_insertion_point(message:CSODOTAPlayerChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAPlayerChallenge {
    // message fields
    // @@protoc_insertion_point(field:CSODOTAPlayerChallenge.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAPlayerChallenge.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAPlayerChallenge.slot_id)
    pub slot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAPlayerChallenge.int_param_0)
    pub int_param_0: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAPlayerChallenge.int_param_1)
    pub int_param_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAPlayerChallenge.created_time)
    pub created_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAPlayerChallenge.completed)
    pub completed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAPlayerChallenge.sequence_id)
    pub sequence_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAPlayerChallenge.challenge_tier)
    pub challenge_tier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAPlayerChallenge.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAPlayerChallenge.attempts)
    pub attempts: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAPlayerChallenge.complete_limit)
    pub complete_limit: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAPlayerChallenge.quest_rank)
    pub quest_rank: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAPlayerChallenge.max_quest_rank)
    pub max_quest_rank: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAPlayerChallenge.instance_id)
    pub instance_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAPlayerChallenge.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSODOTAPlayerChallenge.template_id)
    pub template_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSODOTAPlayerChallenge.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAPlayerChallenge {
    fn default() -> &'a CSODOTAPlayerChallenge {
        <CSODOTAPlayerChallenge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSODOTAPlayerChallenge {
    pub fn new() -> CSODOTAPlayerChallenge {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 2;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_id = 3;

    pub fn slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    // optional uint32 int_param_0 = 5;

    pub fn int_param_0(&self) -> u32 {
        self.int_param_0.unwrap_or(0)
    }

    pub fn clear_int_param_0(&mut self) {
        self.int_param_0 = ::std::option::Option::None;
    }

    pub fn has_int_param_0(&self) -> bool {
        self.int_param_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_param_0(&mut self, v: u32) {
        self.int_param_0 = ::std::option::Option::Some(v);
    }

    // optional uint32 int_param_1 = 6;

    pub fn int_param_1(&self) -> u32 {
        self.int_param_1.unwrap_or(0)
    }

    pub fn clear_int_param_1(&mut self) {
        self.int_param_1 = ::std::option::Option::None;
    }

    pub fn has_int_param_1(&self) -> bool {
        self.int_param_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_param_1(&mut self, v: u32) {
        self.int_param_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 created_time = 7;

    pub fn created_time(&self) -> u32 {
        self.created_time.unwrap_or(0)
    }

    pub fn clear_created_time(&mut self) {
        self.created_time = ::std::option::Option::None;
    }

    pub fn has_created_time(&self) -> bool {
        self.created_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_time(&mut self, v: u32) {
        self.created_time = ::std::option::Option::Some(v);
    }

    // optional uint32 completed = 8;

    pub fn completed(&self) -> u32 {
        self.completed.unwrap_or(0)
    }

    pub fn clear_completed(&mut self) {
        self.completed = ::std::option::Option::None;
    }

    pub fn has_completed(&self) -> bool {
        self.completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed(&mut self, v: u32) {
        self.completed = ::std::option::Option::Some(v);
    }

    // optional uint32 sequence_id = 9;

    pub fn sequence_id(&self) -> u32 {
        self.sequence_id.unwrap_or(0)
    }

    pub fn clear_sequence_id(&mut self) {
        self.sequence_id = ::std::option::Option::None;
    }

    pub fn has_sequence_id(&self) -> bool {
        self.sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: u32) {
        self.sequence_id = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_tier = 10;

    pub fn challenge_tier(&self) -> u32 {
        self.challenge_tier.unwrap_or(0)
    }

    pub fn clear_challenge_tier(&mut self) {
        self.challenge_tier = ::std::option::Option::None;
    }

    pub fn has_challenge_tier(&self) -> bool {
        self.challenge_tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_tier(&mut self, v: u32) {
        self.challenge_tier = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 11;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 attempts = 12;

    pub fn attempts(&self) -> u32 {
        self.attempts.unwrap_or(0)
    }

    pub fn clear_attempts(&mut self) {
        self.attempts = ::std::option::Option::None;
    }

    pub fn has_attempts(&self) -> bool {
        self.attempts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attempts(&mut self, v: u32) {
        self.attempts = ::std::option::Option::Some(v);
    }

    // optional uint32 complete_limit = 13;

    pub fn complete_limit(&self) -> u32 {
        self.complete_limit.unwrap_or(0)
    }

    pub fn clear_complete_limit(&mut self) {
        self.complete_limit = ::std::option::Option::None;
    }

    pub fn has_complete_limit(&self) -> bool {
        self.complete_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_complete_limit(&mut self, v: u32) {
        self.complete_limit = ::std::option::Option::Some(v);
    }

    // optional uint32 quest_rank = 14;

    pub fn quest_rank(&self) -> u32 {
        self.quest_rank.unwrap_or(0)
    }

    pub fn clear_quest_rank(&mut self) {
        self.quest_rank = ::std::option::Option::None;
    }

    pub fn has_quest_rank(&self) -> bool {
        self.quest_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_rank(&mut self, v: u32) {
        self.quest_rank = ::std::option::Option::Some(v);
    }

    // optional uint32 max_quest_rank = 15;

    pub fn max_quest_rank(&self) -> u32 {
        self.max_quest_rank.unwrap_or(0)
    }

    pub fn clear_max_quest_rank(&mut self) {
        self.max_quest_rank = ::std::option::Option::None;
    }

    pub fn has_max_quest_rank(&self) -> bool {
        self.max_quest_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_quest_rank(&mut self, v: u32) {
        self.max_quest_rank = ::std::option::Option::Some(v);
    }

    // optional uint32 instance_id = 16;

    pub fn instance_id(&self) -> u32 {
        self.instance_id.unwrap_or(0)
    }

    pub fn clear_instance_id(&mut self) {
        self.instance_id = ::std::option::Option::None;
    }

    pub fn has_instance_id(&self) -> bool {
        self.instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: u32) {
        self.instance_id = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 17;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 template_id = 18;

    pub fn template_id(&self) -> u32 {
        self.template_id.unwrap_or(0)
    }

    pub fn clear_template_id(&mut self) {
        self.template_id = ::std::option::Option::None;
    }

    pub fn has_template_id(&self) -> bool {
        self.template_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_id(&mut self, v: u32) {
        self.template_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSODOTAPlayerChallenge {
    const NAME: &'static str = "CSODOTAPlayerChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.int_param_0 = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.int_param_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.created_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.completed = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.sequence_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.challenge_tier = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.attempts = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.complete_limit = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.quest_rank = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.max_quest_rank = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.instance_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                144 => {
                    self.template_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.slot_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.int_param_0 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.int_param_1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.created_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.completed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.sequence_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.challenge_tier {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.attempts {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.complete_limit {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.quest_rank {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.max_quest_rank {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.instance_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(17, v);
        }
        if let Some(v) = self.template_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.int_param_0 {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.int_param_1 {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.created_time {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.completed {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.sequence_id {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.challenge_tier {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.attempts {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.complete_limit {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.quest_rank {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.max_quest_rank {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.instance_id {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.template_id {
            os.write_uint32(18, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAPlayerChallenge {
        CSODOTAPlayerChallenge::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.slot_id = ::std::option::Option::None;
        self.int_param_0 = ::std::option::Option::None;
        self.int_param_1 = ::std::option::Option::None;
        self.created_time = ::std::option::Option::None;
        self.completed = ::std::option::Option::None;
        self.sequence_id = ::std::option::Option::None;
        self.challenge_tier = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.attempts = ::std::option::Option::None;
        self.complete_limit = ::std::option::Option::None;
        self.quest_rank = ::std::option::Option::None;
        self.max_quest_rank = ::std::option::Option::None;
        self.instance_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.template_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAPlayerChallenge {
        static instance: CSODOTAPlayerChallenge = CSODOTAPlayerChallenge {
            account_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            slot_id: ::std::option::Option::None,
            int_param_0: ::std::option::Option::None,
            int_param_1: ::std::option::Option::None,
            created_time: ::std::option::Option::None,
            completed: ::std::option::Option::None,
            sequence_id: ::std::option::Option::None,
            challenge_tier: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            attempts: ::std::option::Option::None,
            complete_limit: ::std::option::Option::None,
            quest_rank: ::std::option::Option::None,
            max_quest_rank: ::std::option::Option::None,
            instance_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            template_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRerollPlayerChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRerollPlayerChallenge {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRerollPlayerChallenge.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRerollPlayerChallenge.sequence_id)
    pub sequence_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCRerollPlayerChallenge.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRerollPlayerChallenge.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRerollPlayerChallenge {
    fn default() -> &'a CMsgClientToGCRerollPlayerChallenge {
        <CMsgClientToGCRerollPlayerChallenge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRerollPlayerChallenge {
    pub fn new() -> CMsgClientToGCRerollPlayerChallenge {
        ::std::default::Default::default()
    }

    // optional .EEvent event_id = 1;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 sequence_id = 3;

    pub fn sequence_id(&self) -> u32 {
        self.sequence_id.unwrap_or(0)
    }

    pub fn clear_sequence_id(&mut self) {
        self.sequence_id = ::std::option::Option::None;
    }

    pub fn has_sequence_id(&self) -> bool {
        self.sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: u32) {
        self.sequence_id = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 4;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRerollPlayerChallenge {
    const NAME: &'static str = "CMsgClientToGCRerollPlayerChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.sequence_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.sequence_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.sequence_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRerollPlayerChallenge {
        CMsgClientToGCRerollPlayerChallenge::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.sequence_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRerollPlayerChallenge {
        static instance: CMsgClientToGCRerollPlayerChallenge = CMsgClientToGCRerollPlayerChallenge {
            event_id: ::std::option::Option::None,
            sequence_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCRerollPlayerChallengeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRerollPlayerChallengeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRerollPlayerChallengeResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_gcreroll_player_challenge_response::EResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRerollPlayerChallengeResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRerollPlayerChallengeResponse {
    fn default() -> &'a CMsgGCRerollPlayerChallengeResponse {
        <CMsgGCRerollPlayerChallengeResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRerollPlayerChallengeResponse {
    pub fn new() -> CMsgGCRerollPlayerChallengeResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgGCRerollPlayerChallengeResponse.EResult result = 1;

    pub fn result(&self) -> cmsg_gcreroll_player_challenge_response::EResult {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_gcreroll_player_challenge_response::EResult::eResult_Success),
            None => cmsg_gcreroll_player_challenge_response::EResult::eResult_Success,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_gcreroll_player_challenge_response::EResult) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCRerollPlayerChallengeResponse {
    const NAME: &'static str = "CMsgGCRerollPlayerChallengeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRerollPlayerChallengeResponse {
        CMsgGCRerollPlayerChallengeResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRerollPlayerChallengeResponse {
        static instance: CMsgGCRerollPlayerChallengeResponse = CMsgGCRerollPlayerChallengeResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCRerollPlayerChallengeResponse`
pub mod cmsg_gcreroll_player_challenge_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGCRerollPlayerChallengeResponse.EResult)
    pub enum EResult {
        // @@protoc_insertion_point(enum_value:CMsgGCRerollPlayerChallengeResponse.EResult.eResult_Success)
        eResult_Success = 0,
        // @@protoc_insertion_point(enum_value:CMsgGCRerollPlayerChallengeResponse.EResult.eResult_Dropped)
        eResult_Dropped = 1,
        // @@protoc_insertion_point(enum_value:CMsgGCRerollPlayerChallengeResponse.EResult.eResult_NotFound)
        eResult_NotFound = 2,
        // @@protoc_insertion_point(enum_value:CMsgGCRerollPlayerChallengeResponse.EResult.eResult_CantReroll)
        eResult_CantReroll = 3,
        // @@protoc_insertion_point(enum_value:CMsgGCRerollPlayerChallengeResponse.EResult.eResult_ServerError)
        eResult_ServerError = 4,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResult {
        const NAME: &'static str = "EResult";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResult> {
            match value {
                0 => ::std::option::Option::Some(EResult::eResult_Success),
                1 => ::std::option::Option::Some(EResult::eResult_Dropped),
                2 => ::std::option::Option::Some(EResult::eResult_NotFound),
                3 => ::std::option::Option::Some(EResult::eResult_CantReroll),
                4 => ::std::option::Option::Some(EResult::eResult_ServerError),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResult> {
            match str {
                "eResult_Success" => ::std::option::Option::Some(EResult::eResult_Success),
                "eResult_Dropped" => ::std::option::Option::Some(EResult::eResult_Dropped),
                "eResult_NotFound" => ::std::option::Option::Some(EResult::eResult_NotFound),
                "eResult_CantReroll" => ::std::option::Option::Some(EResult::eResult_CantReroll),
                "eResult_ServerError" => ::std::option::Option::Some(EResult::eResult_ServerError),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResult] = &[
            EResult::eResult_Success,
            EResult::eResult_Dropped,
            EResult::eResult_NotFound,
            EResult::eResult_CantReroll,
            EResult::eResult_ServerError,
        ];
    }

    impl ::std::default::Default for EResult {
        fn default() -> Self {
            EResult::eResult_Success
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCTopCustomGamesList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCTopCustomGamesList {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCTopCustomGamesList.top_custom_games)
    pub top_custom_games: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgGCTopCustomGamesList.game_of_the_day)
    pub game_of_the_day: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCTopCustomGamesList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCTopCustomGamesList {
    fn default() -> &'a CMsgGCTopCustomGamesList {
        <CMsgGCTopCustomGamesList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCTopCustomGamesList {
    pub fn new() -> CMsgGCTopCustomGamesList {
        ::std::default::Default::default()
    }

    // optional uint64 game_of_the_day = 2;

    pub fn game_of_the_day(&self) -> u64 {
        self.game_of_the_day.unwrap_or(0)
    }

    pub fn clear_game_of_the_day(&mut self) {
        self.game_of_the_day = ::std::option::Option::None;
    }

    pub fn has_game_of_the_day(&self) -> bool {
        self.game_of_the_day.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_of_the_day(&mut self, v: u64) {
        self.game_of_the_day = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCTopCustomGamesList {
    const NAME: &'static str = "CMsgGCTopCustomGamesList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.top_custom_games)?;
                },
                8 => {
                    self.top_custom_games.push(is.read_uint64()?);
                },
                16 => {
                    self.game_of_the_day = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.top_custom_games {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, *value);
        };
        if let Some(v) = self.game_of_the_day {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.top_custom_games {
            os.write_uint64(1, *v)?;
        };
        if let Some(v) = self.game_of_the_day {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCTopCustomGamesList {
        CMsgGCTopCustomGamesList::new()
    }

    fn clear(&mut self) {
        self.top_custom_games.clear();
        self.game_of_the_day = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCTopCustomGamesList {
        static instance: CMsgGCTopCustomGamesList = CMsgGCTopCustomGamesList {
            top_custom_games: ::std::vec::Vec::new(),
            game_of_the_day: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTARealtimeGameStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTARealtimeGameStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.match)
    pub match_: ::steam_vent_proto_common::protobuf::MessageField<cmsg_dotarealtime_game_stats::MatchDetails>,
    // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.teams)
    pub teams: ::std::vec::Vec<cmsg_dotarealtime_game_stats::TeamDetails>,
    // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.buildings)
    pub buildings: ::std::vec::Vec<cmsg_dotarealtime_game_stats::BuildingDetails>,
    // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.graph_data)
    pub graph_data: ::steam_vent_proto_common::protobuf::MessageField<cmsg_dotarealtime_game_stats::GraphData>,
    // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.delta_frame)
    pub delta_frame: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTARealtimeGameStats {
    fn default() -> &'a CMsgDOTARealtimeGameStats {
        <CMsgDOTARealtimeGameStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTARealtimeGameStats {
    pub fn new() -> CMsgDOTARealtimeGameStats {
        ::std::default::Default::default()
    }

    // optional bool delta_frame = 5;

    pub fn delta_frame(&self) -> bool {
        self.delta_frame.unwrap_or(false)
    }

    pub fn clear_delta_frame(&mut self) {
        self.delta_frame = ::std::option::Option::None;
    }

    pub fn has_delta_frame(&self) -> bool {
        self.delta_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta_frame(&mut self, v: bool) {
        self.delta_frame = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTARealtimeGameStats {
    const NAME: &'static str = "CMsgDOTARealtimeGameStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.match_)?;
                },
                18 => {
                    self.teams.push(is.read_message()?);
                },
                26 => {
                    self.buildings.push(is.read_message()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.graph_data)?;
                },
                40 => {
                    self.delta_frame = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.buildings {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.graph_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.delta_frame {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.teams {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.buildings {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.graph_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.delta_frame {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTARealtimeGameStats {
        CMsgDOTARealtimeGameStats::new()
    }

    fn clear(&mut self) {
        self.match_.clear();
        self.teams.clear();
        self.buildings.clear();
        self.graph_data.clear();
        self.delta_frame = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTARealtimeGameStats {
        static instance: CMsgDOTARealtimeGameStats = CMsgDOTARealtimeGameStats {
            match_: ::steam_vent_proto_common::protobuf::MessageField::none(),
            teams: ::std::vec::Vec::new(),
            buildings: ::std::vec::Vec::new(),
            graph_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            delta_frame: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTARealtimeGameStats`
pub mod cmsg_dotarealtime_game_stats {
    // @@protoc_insertion_point(message:CMsgDOTARealtimeGameStats.TeamDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeamDetails {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.TeamDetails.team_number)
        pub team_number: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.TeamDetails.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.TeamDetails.team_name)
        pub team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.TeamDetails.team_logo)
        pub team_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.TeamDetails.team_tag)
        pub team_tag: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.TeamDetails.score)
        pub score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.TeamDetails.net_worth)
        pub net_worth: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.TeamDetails.players)
        pub players: ::std::vec::Vec<PlayerDetails>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.TeamDetails.only_team)
        pub only_team: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.TeamDetails.cheers)
        pub cheers: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.TeamDetails.team_logo_url)
        pub team_logo_url: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStats.TeamDetails.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamDetails {
        fn default() -> &'a TeamDetails {
            <TeamDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl TeamDetails {
        pub fn new() -> TeamDetails {
            ::std::default::Default::default()
        }

        // optional uint32 team_number = 1;

        pub fn team_number(&self) -> u32 {
            self.team_number.unwrap_or(0)
        }

        pub fn clear_team_number(&mut self) {
            self.team_number = ::std::option::Option::None;
        }

        pub fn has_team_number(&self) -> bool {
            self.team_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_number(&mut self, v: u32) {
            self.team_number = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id = 2;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional string team_name = 3;

        pub fn team_name(&self) -> &str {
            match self.team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_name(&mut self) {
            self.team_name = ::std::option::Option::None;
        }

        pub fn has_team_name(&self) -> bool {
            self.team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_name(&mut self, v: ::std::string::String) {
            self.team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
            if self.team_name.is_none() {
                self.team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_name(&mut self) -> ::std::string::String {
            self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 team_logo = 4;

        pub fn team_logo(&self) -> u64 {
            self.team_logo.unwrap_or(0)
        }

        pub fn clear_team_logo(&mut self) {
            self.team_logo = ::std::option::Option::None;
        }

        pub fn has_team_logo(&self) -> bool {
            self.team_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo(&mut self, v: u64) {
            self.team_logo = ::std::option::Option::Some(v);
        }

        // optional string team_tag = 10;

        pub fn team_tag(&self) -> &str {
            match self.team_tag.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_tag(&mut self) {
            self.team_tag = ::std::option::Option::None;
        }

        pub fn has_team_tag(&self) -> bool {
            self.team_tag.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_tag(&mut self, v: ::std::string::String) {
            self.team_tag = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_tag(&mut self) -> &mut ::std::string::String {
            if self.team_tag.is_none() {
                self.team_tag = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_tag.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_tag(&mut self) -> ::std::string::String {
            self.team_tag.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 score = 5;

        pub fn score(&self) -> u32 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: u32) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional uint32 net_worth = 9;

        pub fn net_worth(&self) -> u32 {
            self.net_worth.unwrap_or(0)
        }

        pub fn clear_net_worth(&mut self) {
            self.net_worth = ::std::option::Option::None;
        }

        pub fn has_net_worth(&self) -> bool {
            self.net_worth.is_some()
        }

        // Param is passed by value, moved
        pub fn set_net_worth(&mut self, v: u32) {
            self.net_worth = ::std::option::Option::Some(v);
        }

        // optional bool only_team = 7;

        pub fn only_team(&self) -> bool {
            self.only_team.unwrap_or(false)
        }

        pub fn clear_only_team(&mut self) {
            self.only_team = ::std::option::Option::None;
        }

        pub fn has_only_team(&self) -> bool {
            self.only_team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_only_team(&mut self, v: bool) {
            self.only_team = ::std::option::Option::Some(v);
        }

        // optional uint32 cheers = 8;

        pub fn cheers(&self) -> u32 {
            self.cheers.unwrap_or(0)
        }

        pub fn clear_cheers(&mut self) {
            self.cheers = ::std::option::Option::None;
        }

        pub fn has_cheers(&self) -> bool {
            self.cheers.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cheers(&mut self, v: u32) {
            self.cheers = ::std::option::Option::Some(v);
        }

        // optional string team_logo_url = 11;

        pub fn team_logo_url(&self) -> &str {
            match self.team_logo_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_logo_url(&mut self) {
            self.team_logo_url = ::std::option::Option::None;
        }

        pub fn has_team_logo_url(&self) -> bool {
            self.team_logo_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo_url(&mut self, v: ::std::string::String) {
            self.team_logo_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_logo_url(&mut self) -> &mut ::std::string::String {
            if self.team_logo_url.is_none() {
                self.team_logo_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_logo_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_logo_url(&mut self) -> ::std::string::String {
            self.team_logo_url.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for TeamDetails {
        const NAME: &'static str = "TeamDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team_number = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    33 => {
                        self.team_logo = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    82 => {
                        self.team_tag = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    50 => {
                        self.players.push(is.read_message()?);
                    },
                    56 => {
                        self.only_team = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.cheers = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    90 => {
                        self.team_logo_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team_number {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.team_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.team_logo {
                my_size += 1 + 8;
            }
            if let Some(v) = self.team_tag.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &v);
            }
            if let Some(v) = self.score {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.net_worth {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            for value in &self.players {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.only_team {
                my_size += 1 + 1;
            }
            if let Some(v) = self.cheers {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.team_logo_url.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(11, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.team_number {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.team_name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.team_logo {
                os.write_fixed64(4, v)?;
            }
            if let Some(v) = self.team_tag.as_ref() {
                os.write_string(10, v)?;
            }
            if let Some(v) = self.score {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.net_worth {
                os.write_uint32(9, v)?;
            }
            for v in &self.players {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            if let Some(v) = self.only_team {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.cheers {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.team_logo_url.as_ref() {
                os.write_string(11, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamDetails {
            TeamDetails::new()
        }

        fn clear(&mut self) {
            self.team_number = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.team_name = ::std::option::Option::None;
            self.team_logo = ::std::option::Option::None;
            self.team_tag = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.net_worth = ::std::option::Option::None;
            self.players.clear();
            self.only_team = ::std::option::Option::None;
            self.cheers = ::std::option::Option::None;
            self.team_logo_url = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamDetails {
            static instance: TeamDetails = TeamDetails {
                team_number: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                team_name: ::std::option::Option::None,
                team_logo: ::std::option::Option::None,
                team_tag: ::std::option::Option::None,
                score: ::std::option::Option::None,
                net_worth: ::std::option::Option::None,
                players: ::std::vec::Vec::new(),
                only_team: ::std::option::Option::None,
                cheers: ::std::option::Option::None,
                team_logo_url: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTARealtimeGameStats.ItemDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemDetails {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.ItemDetails.item_ability_id)
        pub item_ability_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.ItemDetails.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.ItemDetails.time)
        pub time: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.ItemDetails.sold)
        pub sold: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.ItemDetails.stackcount)
        pub stackcount: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStats.ItemDetails.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemDetails {
        fn default() -> &'a ItemDetails {
            <ItemDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ItemDetails {
        pub fn new() -> ItemDetails {
            ::std::default::Default::default()
        }

        // optional int32 item_ability_id = 1;

        pub fn item_ability_id(&self) -> i32 {
            self.item_ability_id.unwrap_or(-1i32)
        }

        pub fn clear_item_ability_id(&mut self) {
            self.item_ability_id = ::std::option::Option::None;
        }

        pub fn has_item_ability_id(&self) -> bool {
            self.item_ability_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_ability_id(&mut self, v: i32) {
            self.item_ability_id = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 time = 3;

        pub fn time(&self) -> i32 {
            self.time.unwrap_or(0)
        }

        pub fn clear_time(&mut self) {
            self.time = ::std::option::Option::None;
        }

        pub fn has_time(&self) -> bool {
            self.time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time(&mut self, v: i32) {
            self.time = ::std::option::Option::Some(v);
        }

        // optional bool sold = 4;

        pub fn sold(&self) -> bool {
            self.sold.unwrap_or(false)
        }

        pub fn clear_sold(&mut self) {
            self.sold = ::std::option::Option::None;
        }

        pub fn has_sold(&self) -> bool {
            self.sold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sold(&mut self, v: bool) {
            self.sold = ::std::option::Option::Some(v);
        }

        // optional uint32 stackcount = 5;

        pub fn stackcount(&self) -> u32 {
            self.stackcount.unwrap_or(0)
        }

        pub fn clear_stackcount(&mut self) {
            self.stackcount = ::std::option::Option::None;
        }

        pub fn has_stackcount(&self) -> bool {
            self.stackcount.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stackcount(&mut self, v: u32) {
            self.stackcount = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ItemDetails {
        const NAME: &'static str = "ItemDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.time = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.sold = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.stackcount = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_ability_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.time {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.sold {
                my_size += 1 + 1;
            }
            if let Some(v) = self.stackcount {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item_ability_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.time {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.sold {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.stackcount {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemDetails {
            ItemDetails::new()
        }

        fn clear(&mut self) {
            self.item_ability_id = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.time = ::std::option::Option::None;
            self.sold = ::std::option::Option::None;
            self.stackcount = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemDetails {
            static instance: ItemDetails = ItemDetails {
                item_ability_id: ::std::option::Option::None,
                name: ::std::option::Option::None,
                time: ::std::option::Option::None,
                sold: ::std::option::Option::None,
                stackcount: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTARealtimeGameStats.AbilityDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AbilityDetails {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.AbilityDetails.id)
        pub id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.AbilityDetails.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.AbilityDetails.level)
        pub level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.AbilityDetails.cooldown)
        pub cooldown: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.AbilityDetails.cooldown_max)
        pub cooldown_max: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStats.AbilityDetails.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AbilityDetails {
        fn default() -> &'a AbilityDetails {
            <AbilityDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl AbilityDetails {
        pub fn new() -> AbilityDetails {
            ::std::default::Default::default()
        }

        // optional int32 id = 1;

        pub fn id(&self) -> i32 {
            self.id.unwrap_or(-1i32)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: i32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 level = 3;

        pub fn level(&self) -> u32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: u32) {
            self.level = ::std::option::Option::Some(v);
        }

        // optional float cooldown = 4;

        pub fn cooldown(&self) -> f32 {
            self.cooldown.unwrap_or(0.)
        }

        pub fn clear_cooldown(&mut self) {
            self.cooldown = ::std::option::Option::None;
        }

        pub fn has_cooldown(&self) -> bool {
            self.cooldown.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cooldown(&mut self, v: f32) {
            self.cooldown = ::std::option::Option::Some(v);
        }

        // optional float cooldown_max = 5;

        pub fn cooldown_max(&self) -> f32 {
            self.cooldown_max.unwrap_or(0.)
        }

        pub fn clear_cooldown_max(&mut self) {
            self.cooldown_max = ::std::option::Option::None;
        }

        pub fn has_cooldown_max(&self) -> bool {
            self.cooldown_max.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cooldown_max(&mut self, v: f32) {
            self.cooldown_max = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for AbilityDetails {
        const NAME: &'static str = "AbilityDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    37 => {
                        self.cooldown = ::std::option::Option::Some(is.read_float()?);
                    },
                    45 => {
                        self.cooldown_max = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.level {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.cooldown {
                my_size += 1 + 4;
            }
            if let Some(v) = self.cooldown_max {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.level {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.cooldown {
                os.write_float(4, v)?;
            }
            if let Some(v) = self.cooldown_max {
                os.write_float(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AbilityDetails {
            AbilityDetails::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.level = ::std::option::Option::None;
            self.cooldown = ::std::option::Option::None;
            self.cooldown_max = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AbilityDetails {
            static instance: AbilityDetails = AbilityDetails {
                id: ::std::option::Option::None,
                name: ::std::option::Option::None,
                level: ::std::option::Option::None,
                cooldown: ::std::option::Option::None,
                cooldown_max: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTARealtimeGameStats.HeroToHeroStats)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct HeroToHeroStats {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.HeroToHeroStats.victimid)
        pub victimid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.HeroToHeroStats.kills)
        pub kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.HeroToHeroStats.assists)
        pub assists: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStats.HeroToHeroStats.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HeroToHeroStats {
        fn default() -> &'a HeroToHeroStats {
            <HeroToHeroStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl HeroToHeroStats {
        pub fn new() -> HeroToHeroStats {
            ::std::default::Default::default()
        }

        // optional int32 victimid = 1;

        pub fn victimid(&self) -> i32 {
            self.victimid.unwrap_or(-1i32)
        }

        pub fn clear_victimid(&mut self) {
            self.victimid = ::std::option::Option::None;
        }

        pub fn has_victimid(&self) -> bool {
            self.victimid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_victimid(&mut self, v: i32) {
            self.victimid = ::std::option::Option::Some(v);
        }

        // optional uint32 kills = 2;

        pub fn kills(&self) -> u32 {
            self.kills.unwrap_or(0)
        }

        pub fn clear_kills(&mut self) {
            self.kills = ::std::option::Option::None;
        }

        pub fn has_kills(&self) -> bool {
            self.kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kills(&mut self, v: u32) {
            self.kills = ::std::option::Option::Some(v);
        }

        // optional uint32 assists = 3;

        pub fn assists(&self) -> u32 {
            self.assists.unwrap_or(0)
        }

        pub fn clear_assists(&mut self) {
            self.assists = ::std::option::Option::None;
        }

        pub fn has_assists(&self) -> bool {
            self.assists.is_some()
        }

        // Param is passed by value, moved
        pub fn set_assists(&mut self, v: u32) {
            self.assists = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for HeroToHeroStats {
        const NAME: &'static str = "HeroToHeroStats";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.victimid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.assists = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.victimid {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.kills {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.assists {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.victimid {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.kills {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.assists {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HeroToHeroStats {
            HeroToHeroStats::new()
        }

        fn clear(&mut self) {
            self.victimid = ::std::option::Option::None;
            self.kills = ::std::option::Option::None;
            self.assists = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HeroToHeroStats {
            static instance: HeroToHeroStats = HeroToHeroStats {
                victimid: ::std::option::Option::None,
                kills: ::std::option::Option::None,
                assists: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTARealtimeGameStats.AbilityList)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AbilityList {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.AbilityList.id)
        pub id: ::std::vec::Vec<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStats.AbilityList.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AbilityList {
        fn default() -> &'a AbilityList {
            <AbilityList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl AbilityList {
        pub fn new() -> AbilityList {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for AbilityList {
        const NAME: &'static str = "AbilityList";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_int32_into(&mut self.id)?;
                    },
                    8 => {
                        self.id.push(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, *value);
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            for v in &self.id {
                os.write_int32(1, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AbilityList {
            AbilityList::new()
        }

        fn clear(&mut self) {
            self.id.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AbilityList {
            static instance: AbilityList = AbilityList {
                id: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTARealtimeGameStats.PlayerDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerDetails {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.playerid)
        pub playerid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.team)
        pub team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.heroid)
        pub heroid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.healthpoints)
        pub healthpoints: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.maxhealthpoints)
        pub maxhealthpoints: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.healthregenrate)
        pub healthregenrate: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.manapoints)
        pub manapoints: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.maxmanapoints)
        pub maxmanapoints: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.manaregenrate)
        pub manaregenrate: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.base_strength)
        pub base_strength: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.base_agility)
        pub base_agility: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.base_intelligence)
        pub base_intelligence: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.base_armor)
        pub base_armor: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.base_movespeed)
        pub base_movespeed: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.base_damage)
        pub base_damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.strength)
        pub strength: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.agility)
        pub agility: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.intelligence)
        pub intelligence: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.armor)
        pub armor: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.movespeed)
        pub movespeed: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.damage)
        pub damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.hero_damage)
        pub hero_damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.tower_damage)
        pub tower_damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.abilities)
        pub abilities: ::std::vec::Vec<AbilityDetails>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.level)
        pub level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.kill_count)
        pub kill_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.death_count)
        pub death_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.assists_count)
        pub assists_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.denies_count)
        pub denies_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.lh_count)
        pub lh_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.hero_healing)
        pub hero_healing: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.gold_per_min)
        pub gold_per_min: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.xp_per_min)
        pub xp_per_min: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.net_gold)
        pub net_gold: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.gold)
        pub gold: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.x)
        pub x: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.y)
        pub y: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.respawn_time)
        pub respawn_time: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.ultimate_cooldown)
        pub ultimate_cooldown: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.has_buyback)
        pub has_buyback: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.items)
        pub items: ::std::vec::Vec<ItemDetails>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.stashitems)
        pub stashitems: ::std::vec::Vec<ItemDetails>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.itemshoppinglist)
        pub itemshoppinglist: ::std::vec::Vec<ItemDetails>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.levelpoints)
        pub levelpoints: ::std::vec::Vec<AbilityList>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.hero_to_hero_stats)
        pub hero_to_hero_stats: ::std::vec::Vec<HeroToHeroStats>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.has_ultimate)
        pub has_ultimate: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.has_ultimate_mana)
        pub has_ultimate_mana: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PlayerDetails.team_slot)
        pub team_slot: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStats.PlayerDetails.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerDetails {
        fn default() -> &'a PlayerDetails {
            <PlayerDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerDetails {
        pub fn new() -> PlayerDetails {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional int32 playerid = 2;

        pub fn playerid(&self) -> i32 {
            self.playerid.unwrap_or(-1i32)
        }

        pub fn clear_playerid(&mut self) {
            self.playerid = ::std::option::Option::None;
        }

        pub fn has_playerid(&self) -> bool {
            self.playerid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_playerid(&mut self, v: i32) {
            self.playerid = ::std::option::Option::Some(v);
        }

        // optional string name = 3;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 team = 4;

        pub fn team(&self) -> u32 {
            self.team.unwrap_or(0)
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: u32) {
            self.team = ::std::option::Option::Some(v);
        }

        // optional int32 heroid = 5;

        pub fn heroid(&self) -> i32 {
            self.heroid.unwrap_or(0)
        }

        pub fn clear_heroid(&mut self) {
            self.heroid = ::std::option::Option::None;
        }

        pub fn has_heroid(&self) -> bool {
            self.heroid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_heroid(&mut self, v: i32) {
            self.heroid = ::std::option::Option::Some(v);
        }

        // optional uint32 healthpoints = 6;

        pub fn healthpoints(&self) -> u32 {
            self.healthpoints.unwrap_or(0)
        }

        pub fn clear_healthpoints(&mut self) {
            self.healthpoints = ::std::option::Option::None;
        }

        pub fn has_healthpoints(&self) -> bool {
            self.healthpoints.is_some()
        }

        // Param is passed by value, moved
        pub fn set_healthpoints(&mut self, v: u32) {
            self.healthpoints = ::std::option::Option::Some(v);
        }

        // optional uint32 maxhealthpoints = 7;

        pub fn maxhealthpoints(&self) -> u32 {
            self.maxhealthpoints.unwrap_or(0)
        }

        pub fn clear_maxhealthpoints(&mut self) {
            self.maxhealthpoints = ::std::option::Option::None;
        }

        pub fn has_maxhealthpoints(&self) -> bool {
            self.maxhealthpoints.is_some()
        }

        // Param is passed by value, moved
        pub fn set_maxhealthpoints(&mut self, v: u32) {
            self.maxhealthpoints = ::std::option::Option::Some(v);
        }

        // optional float healthregenrate = 8;

        pub fn healthregenrate(&self) -> f32 {
            self.healthregenrate.unwrap_or(0.)
        }

        pub fn clear_healthregenrate(&mut self) {
            self.healthregenrate = ::std::option::Option::None;
        }

        pub fn has_healthregenrate(&self) -> bool {
            self.healthregenrate.is_some()
        }

        // Param is passed by value, moved
        pub fn set_healthregenrate(&mut self, v: f32) {
            self.healthregenrate = ::std::option::Option::Some(v);
        }

        // optional uint32 manapoints = 9;

        pub fn manapoints(&self) -> u32 {
            self.manapoints.unwrap_or(0)
        }

        pub fn clear_manapoints(&mut self) {
            self.manapoints = ::std::option::Option::None;
        }

        pub fn has_manapoints(&self) -> bool {
            self.manapoints.is_some()
        }

        // Param is passed by value, moved
        pub fn set_manapoints(&mut self, v: u32) {
            self.manapoints = ::std::option::Option::Some(v);
        }

        // optional uint32 maxmanapoints = 10;

        pub fn maxmanapoints(&self) -> u32 {
            self.maxmanapoints.unwrap_or(0)
        }

        pub fn clear_maxmanapoints(&mut self) {
            self.maxmanapoints = ::std::option::Option::None;
        }

        pub fn has_maxmanapoints(&self) -> bool {
            self.maxmanapoints.is_some()
        }

        // Param is passed by value, moved
        pub fn set_maxmanapoints(&mut self, v: u32) {
            self.maxmanapoints = ::std::option::Option::Some(v);
        }

        // optional float manaregenrate = 11;

        pub fn manaregenrate(&self) -> f32 {
            self.manaregenrate.unwrap_or(0.)
        }

        pub fn clear_manaregenrate(&mut self) {
            self.manaregenrate = ::std::option::Option::None;
        }

        pub fn has_manaregenrate(&self) -> bool {
            self.manaregenrate.is_some()
        }

        // Param is passed by value, moved
        pub fn set_manaregenrate(&mut self, v: f32) {
            self.manaregenrate = ::std::option::Option::Some(v);
        }

        // optional uint32 base_strength = 12;

        pub fn base_strength(&self) -> u32 {
            self.base_strength.unwrap_or(0)
        }

        pub fn clear_base_strength(&mut self) {
            self.base_strength = ::std::option::Option::None;
        }

        pub fn has_base_strength(&self) -> bool {
            self.base_strength.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_strength(&mut self, v: u32) {
            self.base_strength = ::std::option::Option::Some(v);
        }

        // optional uint32 base_agility = 13;

        pub fn base_agility(&self) -> u32 {
            self.base_agility.unwrap_or(0)
        }

        pub fn clear_base_agility(&mut self) {
            self.base_agility = ::std::option::Option::None;
        }

        pub fn has_base_agility(&self) -> bool {
            self.base_agility.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_agility(&mut self, v: u32) {
            self.base_agility = ::std::option::Option::Some(v);
        }

        // optional uint32 base_intelligence = 14;

        pub fn base_intelligence(&self) -> u32 {
            self.base_intelligence.unwrap_or(0)
        }

        pub fn clear_base_intelligence(&mut self) {
            self.base_intelligence = ::std::option::Option::None;
        }

        pub fn has_base_intelligence(&self) -> bool {
            self.base_intelligence.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_intelligence(&mut self, v: u32) {
            self.base_intelligence = ::std::option::Option::Some(v);
        }

        // optional int32 base_armor = 15;

        pub fn base_armor(&self) -> i32 {
            self.base_armor.unwrap_or(0)
        }

        pub fn clear_base_armor(&mut self) {
            self.base_armor = ::std::option::Option::None;
        }

        pub fn has_base_armor(&self) -> bool {
            self.base_armor.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_armor(&mut self, v: i32) {
            self.base_armor = ::std::option::Option::Some(v);
        }

        // optional uint32 base_movespeed = 16;

        pub fn base_movespeed(&self) -> u32 {
            self.base_movespeed.unwrap_or(0)
        }

        pub fn clear_base_movespeed(&mut self) {
            self.base_movespeed = ::std::option::Option::None;
        }

        pub fn has_base_movespeed(&self) -> bool {
            self.base_movespeed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_movespeed(&mut self, v: u32) {
            self.base_movespeed = ::std::option::Option::Some(v);
        }

        // optional uint32 base_damage = 17;

        pub fn base_damage(&self) -> u32 {
            self.base_damage.unwrap_or(0)
        }

        pub fn clear_base_damage(&mut self) {
            self.base_damage = ::std::option::Option::None;
        }

        pub fn has_base_damage(&self) -> bool {
            self.base_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_damage(&mut self, v: u32) {
            self.base_damage = ::std::option::Option::Some(v);
        }

        // optional uint32 strength = 18;

        pub fn strength(&self) -> u32 {
            self.strength.unwrap_or(0)
        }

        pub fn clear_strength(&mut self) {
            self.strength = ::std::option::Option::None;
        }

        pub fn has_strength(&self) -> bool {
            self.strength.is_some()
        }

        // Param is passed by value, moved
        pub fn set_strength(&mut self, v: u32) {
            self.strength = ::std::option::Option::Some(v);
        }

        // optional uint32 agility = 19;

        pub fn agility(&self) -> u32 {
            self.agility.unwrap_or(0)
        }

        pub fn clear_agility(&mut self) {
            self.agility = ::std::option::Option::None;
        }

        pub fn has_agility(&self) -> bool {
            self.agility.is_some()
        }

        // Param is passed by value, moved
        pub fn set_agility(&mut self, v: u32) {
            self.agility = ::std::option::Option::Some(v);
        }

        // optional uint32 intelligence = 20;

        pub fn intelligence(&self) -> u32 {
            self.intelligence.unwrap_or(0)
        }

        pub fn clear_intelligence(&mut self) {
            self.intelligence = ::std::option::Option::None;
        }

        pub fn has_intelligence(&self) -> bool {
            self.intelligence.is_some()
        }

        // Param is passed by value, moved
        pub fn set_intelligence(&mut self, v: u32) {
            self.intelligence = ::std::option::Option::Some(v);
        }

        // optional int32 armor = 21;

        pub fn armor(&self) -> i32 {
            self.armor.unwrap_or(0)
        }

        pub fn clear_armor(&mut self) {
            self.armor = ::std::option::Option::None;
        }

        pub fn has_armor(&self) -> bool {
            self.armor.is_some()
        }

        // Param is passed by value, moved
        pub fn set_armor(&mut self, v: i32) {
            self.armor = ::std::option::Option::Some(v);
        }

        // optional uint32 movespeed = 22;

        pub fn movespeed(&self) -> u32 {
            self.movespeed.unwrap_or(0)
        }

        pub fn clear_movespeed(&mut self) {
            self.movespeed = ::std::option::Option::None;
        }

        pub fn has_movespeed(&self) -> bool {
            self.movespeed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_movespeed(&mut self, v: u32) {
            self.movespeed = ::std::option::Option::Some(v);
        }

        // optional uint32 damage = 23;

        pub fn damage(&self) -> u32 {
            self.damage.unwrap_or(0)
        }

        pub fn clear_damage(&mut self) {
            self.damage = ::std::option::Option::None;
        }

        pub fn has_damage(&self) -> bool {
            self.damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_damage(&mut self, v: u32) {
            self.damage = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_damage = 24;

        pub fn hero_damage(&self) -> u32 {
            self.hero_damage.unwrap_or(0)
        }

        pub fn clear_hero_damage(&mut self) {
            self.hero_damage = ::std::option::Option::None;
        }

        pub fn has_hero_damage(&self) -> bool {
            self.hero_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_damage(&mut self, v: u32) {
            self.hero_damage = ::std::option::Option::Some(v);
        }

        // optional uint32 tower_damage = 25;

        pub fn tower_damage(&self) -> u32 {
            self.tower_damage.unwrap_or(0)
        }

        pub fn clear_tower_damage(&mut self) {
            self.tower_damage = ::std::option::Option::None;
        }

        pub fn has_tower_damage(&self) -> bool {
            self.tower_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tower_damage(&mut self, v: u32) {
            self.tower_damage = ::std::option::Option::Some(v);
        }

        // optional uint32 level = 27;

        pub fn level(&self) -> u32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: u32) {
            self.level = ::std::option::Option::Some(v);
        }

        // optional uint32 kill_count = 28;

        pub fn kill_count(&self) -> u32 {
            self.kill_count.unwrap_or(0)
        }

        pub fn clear_kill_count(&mut self) {
            self.kill_count = ::std::option::Option::None;
        }

        pub fn has_kill_count(&self) -> bool {
            self.kill_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kill_count(&mut self, v: u32) {
            self.kill_count = ::std::option::Option::Some(v);
        }

        // optional uint32 death_count = 29;

        pub fn death_count(&self) -> u32 {
            self.death_count.unwrap_or(0)
        }

        pub fn clear_death_count(&mut self) {
            self.death_count = ::std::option::Option::None;
        }

        pub fn has_death_count(&self) -> bool {
            self.death_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_death_count(&mut self, v: u32) {
            self.death_count = ::std::option::Option::Some(v);
        }

        // optional uint32 assists_count = 30;

        pub fn assists_count(&self) -> u32 {
            self.assists_count.unwrap_or(0)
        }

        pub fn clear_assists_count(&mut self) {
            self.assists_count = ::std::option::Option::None;
        }

        pub fn has_assists_count(&self) -> bool {
            self.assists_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_assists_count(&mut self, v: u32) {
            self.assists_count = ::std::option::Option::Some(v);
        }

        // optional uint32 denies_count = 31;

        pub fn denies_count(&self) -> u32 {
            self.denies_count.unwrap_or(0)
        }

        pub fn clear_denies_count(&mut self) {
            self.denies_count = ::std::option::Option::None;
        }

        pub fn has_denies_count(&self) -> bool {
            self.denies_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_denies_count(&mut self, v: u32) {
            self.denies_count = ::std::option::Option::Some(v);
        }

        // optional uint32 lh_count = 32;

        pub fn lh_count(&self) -> u32 {
            self.lh_count.unwrap_or(0)
        }

        pub fn clear_lh_count(&mut self) {
            self.lh_count = ::std::option::Option::None;
        }

        pub fn has_lh_count(&self) -> bool {
            self.lh_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lh_count(&mut self, v: u32) {
            self.lh_count = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_healing = 33;

        pub fn hero_healing(&self) -> u32 {
            self.hero_healing.unwrap_or(0)
        }

        pub fn clear_hero_healing(&mut self) {
            self.hero_healing = ::std::option::Option::None;
        }

        pub fn has_hero_healing(&self) -> bool {
            self.hero_healing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_healing(&mut self, v: u32) {
            self.hero_healing = ::std::option::Option::Some(v);
        }

        // optional uint32 gold_per_min = 34;

        pub fn gold_per_min(&self) -> u32 {
            self.gold_per_min.unwrap_or(0)
        }

        pub fn clear_gold_per_min(&mut self) {
            self.gold_per_min = ::std::option::Option::None;
        }

        pub fn has_gold_per_min(&self) -> bool {
            self.gold_per_min.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_per_min(&mut self, v: u32) {
            self.gold_per_min = ::std::option::Option::Some(v);
        }

        // optional uint32 xp_per_min = 35;

        pub fn xp_per_min(&self) -> u32 {
            self.xp_per_min.unwrap_or(0)
        }

        pub fn clear_xp_per_min(&mut self) {
            self.xp_per_min = ::std::option::Option::None;
        }

        pub fn has_xp_per_min(&self) -> bool {
            self.xp_per_min.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xp_per_min(&mut self, v: u32) {
            self.xp_per_min = ::std::option::Option::Some(v);
        }

        // optional uint32 net_gold = 36;

        pub fn net_gold(&self) -> u32 {
            self.net_gold.unwrap_or(0)
        }

        pub fn clear_net_gold(&mut self) {
            self.net_gold = ::std::option::Option::None;
        }

        pub fn has_net_gold(&self) -> bool {
            self.net_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_net_gold(&mut self, v: u32) {
            self.net_gold = ::std::option::Option::Some(v);
        }

        // optional uint32 gold = 37;

        pub fn gold(&self) -> u32 {
            self.gold.unwrap_or(0)
        }

        pub fn clear_gold(&mut self) {
            self.gold = ::std::option::Option::None;
        }

        pub fn has_gold(&self) -> bool {
            self.gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold(&mut self, v: u32) {
            self.gold = ::std::option::Option::Some(v);
        }

        // optional float x = 38;

        pub fn x(&self) -> f32 {
            self.x.unwrap_or(0.)
        }

        pub fn clear_x(&mut self) {
            self.x = ::std::option::Option::None;
        }

        pub fn has_x(&self) -> bool {
            self.x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_x(&mut self, v: f32) {
            self.x = ::std::option::Option::Some(v);
        }

        // optional float y = 39;

        pub fn y(&self) -> f32 {
            self.y.unwrap_or(0.)
        }

        pub fn clear_y(&mut self) {
            self.y = ::std::option::Option::None;
        }

        pub fn has_y(&self) -> bool {
            self.y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_y(&mut self, v: f32) {
            self.y = ::std::option::Option::Some(v);
        }

        // optional int32 respawn_time = 40;

        pub fn respawn_time(&self) -> i32 {
            self.respawn_time.unwrap_or(0)
        }

        pub fn clear_respawn_time(&mut self) {
            self.respawn_time = ::std::option::Option::None;
        }

        pub fn has_respawn_time(&self) -> bool {
            self.respawn_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_respawn_time(&mut self, v: i32) {
            self.respawn_time = ::std::option::Option::Some(v);
        }

        // optional uint32 ultimate_cooldown = 41;

        pub fn ultimate_cooldown(&self) -> u32 {
            self.ultimate_cooldown.unwrap_or(0)
        }

        pub fn clear_ultimate_cooldown(&mut self) {
            self.ultimate_cooldown = ::std::option::Option::None;
        }

        pub fn has_ultimate_cooldown(&self) -> bool {
            self.ultimate_cooldown.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ultimate_cooldown(&mut self, v: u32) {
            self.ultimate_cooldown = ::std::option::Option::Some(v);
        }

        // optional bool has_buyback = 42;

        pub fn has_buyback(&self) -> bool {
            self.has_buyback.unwrap_or(false)
        }

        pub fn clear_has_buyback(&mut self) {
            self.has_buyback = ::std::option::Option::None;
        }

        pub fn has_has_buyback(&self) -> bool {
            self.has_buyback.is_some()
        }

        // Param is passed by value, moved
        pub fn set_has_buyback(&mut self, v: bool) {
            self.has_buyback = ::std::option::Option::Some(v);
        }

        // optional bool has_ultimate = 48;

        pub fn has_ultimate(&self) -> bool {
            self.has_ultimate.unwrap_or(false)
        }

        pub fn clear_has_ultimate(&mut self) {
            self.has_ultimate = ::std::option::Option::None;
        }

        pub fn has_has_ultimate(&self) -> bool {
            self.has_ultimate.is_some()
        }

        // Param is passed by value, moved
        pub fn set_has_ultimate(&mut self, v: bool) {
            self.has_ultimate = ::std::option::Option::Some(v);
        }

        // optional bool has_ultimate_mana = 49;

        pub fn has_ultimate_mana(&self) -> bool {
            self.has_ultimate_mana.unwrap_or(false)
        }

        pub fn clear_has_ultimate_mana(&mut self) {
            self.has_ultimate_mana = ::std::option::Option::None;
        }

        pub fn has_has_ultimate_mana(&self) -> bool {
            self.has_ultimate_mana.is_some()
        }

        // Param is passed by value, moved
        pub fn set_has_ultimate_mana(&mut self, v: bool) {
            self.has_ultimate_mana = ::std::option::Option::Some(v);
        }

        // optional uint32 team_slot = 50;

        pub fn team_slot(&self) -> u32 {
            self.team_slot.unwrap_or(0)
        }

        pub fn clear_team_slot(&mut self) {
            self.team_slot = ::std::option::Option::None;
        }

        pub fn has_team_slot(&self) -> bool {
            self.team_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_slot(&mut self, v: u32) {
            self.team_slot = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerDetails {
        const NAME: &'static str = "PlayerDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.playerid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    26 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.heroid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.healthpoints = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.maxhealthpoints = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    69 => {
                        self.healthregenrate = ::std::option::Option::Some(is.read_float()?);
                    },
                    72 => {
                        self.manapoints = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.maxmanapoints = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    93 => {
                        self.manaregenrate = ::std::option::Option::Some(is.read_float()?);
                    },
                    96 => {
                        self.base_strength = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.base_agility = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.base_intelligence = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    120 => {
                        self.base_armor = ::std::option::Option::Some(is.read_int32()?);
                    },
                    128 => {
                        self.base_movespeed = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    136 => {
                        self.base_damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    144 => {
                        self.strength = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    152 => {
                        self.agility = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    160 => {
                        self.intelligence = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    168 => {
                        self.armor = ::std::option::Option::Some(is.read_int32()?);
                    },
                    176 => {
                        self.movespeed = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    184 => {
                        self.damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    192 => {
                        self.hero_damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    200 => {
                        self.tower_damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    210 => {
                        self.abilities.push(is.read_message()?);
                    },
                    216 => {
                        self.level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    224 => {
                        self.kill_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    232 => {
                        self.death_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    240 => {
                        self.assists_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    248 => {
                        self.denies_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    256 => {
                        self.lh_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    264 => {
                        self.hero_healing = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    272 => {
                        self.gold_per_min = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    280 => {
                        self.xp_per_min = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    288 => {
                        self.net_gold = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    296 => {
                        self.gold = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    309 => {
                        self.x = ::std::option::Option::Some(is.read_float()?);
                    },
                    317 => {
                        self.y = ::std::option::Option::Some(is.read_float()?);
                    },
                    320 => {
                        self.respawn_time = ::std::option::Option::Some(is.read_int32()?);
                    },
                    328 => {
                        self.ultimate_cooldown = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    336 => {
                        self.has_buyback = ::std::option::Option::Some(is.read_bool()?);
                    },
                    346 => {
                        self.items.push(is.read_message()?);
                    },
                    354 => {
                        self.stashitems.push(is.read_message()?);
                    },
                    362 => {
                        self.itemshoppinglist.push(is.read_message()?);
                    },
                    370 => {
                        self.levelpoints.push(is.read_message()?);
                    },
                    378 => {
                        self.hero_to_hero_stats.push(is.read_message()?);
                    },
                    384 => {
                        self.has_ultimate = ::std::option::Option::Some(is.read_bool()?);
                    },
                    392 => {
                        self.has_ultimate_mana = ::std::option::Option::Some(is.read_bool()?);
                    },
                    400 => {
                        self.team_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.playerid {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.team {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.heroid {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.healthpoints {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.maxhealthpoints {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.healthregenrate {
                my_size += 1 + 4;
            }
            if let Some(v) = self.manapoints {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.maxmanapoints {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.manaregenrate {
                my_size += 1 + 4;
            }
            if let Some(v) = self.base_strength {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.base_agility {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.base_intelligence {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
            }
            if let Some(v) = self.base_armor {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(15, v);
            }
            if let Some(v) = self.base_movespeed {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
            }
            if let Some(v) = self.base_damage {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
            }
            if let Some(v) = self.strength {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
            }
            if let Some(v) = self.agility {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
            }
            if let Some(v) = self.intelligence {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
            }
            if let Some(v) = self.armor {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(21, v);
            }
            if let Some(v) = self.movespeed {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
            }
            if let Some(v) = self.damage {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, v);
            }
            if let Some(v) = self.hero_damage {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(24, v);
            }
            if let Some(v) = self.tower_damage {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(25, v);
            }
            for value in &self.abilities {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.level {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(27, v);
            }
            if let Some(v) = self.kill_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(28, v);
            }
            if let Some(v) = self.death_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(29, v);
            }
            if let Some(v) = self.assists_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(30, v);
            }
            if let Some(v) = self.denies_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(31, v);
            }
            if let Some(v) = self.lh_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(32, v);
            }
            if let Some(v) = self.hero_healing {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(33, v);
            }
            if let Some(v) = self.gold_per_min {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(34, v);
            }
            if let Some(v) = self.xp_per_min {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(35, v);
            }
            if let Some(v) = self.net_gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(36, v);
            }
            if let Some(v) = self.gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(37, v);
            }
            if let Some(v) = self.x {
                my_size += 2 + 4;
            }
            if let Some(v) = self.y {
                my_size += 2 + 4;
            }
            if let Some(v) = self.respawn_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(40, v);
            }
            if let Some(v) = self.ultimate_cooldown {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(41, v);
            }
            if let Some(v) = self.has_buyback {
                my_size += 2 + 1;
            }
            for value in &self.items {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.stashitems {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.itemshoppinglist {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.levelpoints {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.hero_to_hero_stats {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.has_ultimate {
                my_size += 2 + 1;
            }
            if let Some(v) = self.has_ultimate_mana {
                my_size += 2 + 1;
            }
            if let Some(v) = self.team_slot {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(50, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.playerid {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.team {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.heroid {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.healthpoints {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.maxhealthpoints {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.healthregenrate {
                os.write_float(8, v)?;
            }
            if let Some(v) = self.manapoints {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.maxmanapoints {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.manaregenrate {
                os.write_float(11, v)?;
            }
            if let Some(v) = self.base_strength {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.base_agility {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.base_intelligence {
                os.write_uint32(14, v)?;
            }
            if let Some(v) = self.base_armor {
                os.write_int32(15, v)?;
            }
            if let Some(v) = self.base_movespeed {
                os.write_uint32(16, v)?;
            }
            if let Some(v) = self.base_damage {
                os.write_uint32(17, v)?;
            }
            if let Some(v) = self.strength {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.agility {
                os.write_uint32(19, v)?;
            }
            if let Some(v) = self.intelligence {
                os.write_uint32(20, v)?;
            }
            if let Some(v) = self.armor {
                os.write_int32(21, v)?;
            }
            if let Some(v) = self.movespeed {
                os.write_uint32(22, v)?;
            }
            if let Some(v) = self.damage {
                os.write_uint32(23, v)?;
            }
            if let Some(v) = self.hero_damage {
                os.write_uint32(24, v)?;
            }
            if let Some(v) = self.tower_damage {
                os.write_uint32(25, v)?;
            }
            for v in &self.abilities {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
            };
            if let Some(v) = self.level {
                os.write_uint32(27, v)?;
            }
            if let Some(v) = self.kill_count {
                os.write_uint32(28, v)?;
            }
            if let Some(v) = self.death_count {
                os.write_uint32(29, v)?;
            }
            if let Some(v) = self.assists_count {
                os.write_uint32(30, v)?;
            }
            if let Some(v) = self.denies_count {
                os.write_uint32(31, v)?;
            }
            if let Some(v) = self.lh_count {
                os.write_uint32(32, v)?;
            }
            if let Some(v) = self.hero_healing {
                os.write_uint32(33, v)?;
            }
            if let Some(v) = self.gold_per_min {
                os.write_uint32(34, v)?;
            }
            if let Some(v) = self.xp_per_min {
                os.write_uint32(35, v)?;
            }
            if let Some(v) = self.net_gold {
                os.write_uint32(36, v)?;
            }
            if let Some(v) = self.gold {
                os.write_uint32(37, v)?;
            }
            if let Some(v) = self.x {
                os.write_float(38, v)?;
            }
            if let Some(v) = self.y {
                os.write_float(39, v)?;
            }
            if let Some(v) = self.respawn_time {
                os.write_int32(40, v)?;
            }
            if let Some(v) = self.ultimate_cooldown {
                os.write_uint32(41, v)?;
            }
            if let Some(v) = self.has_buyback {
                os.write_bool(42, v)?;
            }
            for v in &self.items {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(43, v, os)?;
            };
            for v in &self.stashitems {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(44, v, os)?;
            };
            for v in &self.itemshoppinglist {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(45, v, os)?;
            };
            for v in &self.levelpoints {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(46, v, os)?;
            };
            for v in &self.hero_to_hero_stats {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(47, v, os)?;
            };
            if let Some(v) = self.has_ultimate {
                os.write_bool(48, v)?;
            }
            if let Some(v) = self.has_ultimate_mana {
                os.write_bool(49, v)?;
            }
            if let Some(v) = self.team_slot {
                os.write_uint32(50, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerDetails {
            PlayerDetails::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.playerid = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.team = ::std::option::Option::None;
            self.heroid = ::std::option::Option::None;
            self.healthpoints = ::std::option::Option::None;
            self.maxhealthpoints = ::std::option::Option::None;
            self.healthregenrate = ::std::option::Option::None;
            self.manapoints = ::std::option::Option::None;
            self.maxmanapoints = ::std::option::Option::None;
            self.manaregenrate = ::std::option::Option::None;
            self.base_strength = ::std::option::Option::None;
            self.base_agility = ::std::option::Option::None;
            self.base_intelligence = ::std::option::Option::None;
            self.base_armor = ::std::option::Option::None;
            self.base_movespeed = ::std::option::Option::None;
            self.base_damage = ::std::option::Option::None;
            self.strength = ::std::option::Option::None;
            self.agility = ::std::option::Option::None;
            self.intelligence = ::std::option::Option::None;
            self.armor = ::std::option::Option::None;
            self.movespeed = ::std::option::Option::None;
            self.damage = ::std::option::Option::None;
            self.hero_damage = ::std::option::Option::None;
            self.tower_damage = ::std::option::Option::None;
            self.abilities.clear();
            self.level = ::std::option::Option::None;
            self.kill_count = ::std::option::Option::None;
            self.death_count = ::std::option::Option::None;
            self.assists_count = ::std::option::Option::None;
            self.denies_count = ::std::option::Option::None;
            self.lh_count = ::std::option::Option::None;
            self.hero_healing = ::std::option::Option::None;
            self.gold_per_min = ::std::option::Option::None;
            self.xp_per_min = ::std::option::Option::None;
            self.net_gold = ::std::option::Option::None;
            self.gold = ::std::option::Option::None;
            self.x = ::std::option::Option::None;
            self.y = ::std::option::Option::None;
            self.respawn_time = ::std::option::Option::None;
            self.ultimate_cooldown = ::std::option::Option::None;
            self.has_buyback = ::std::option::Option::None;
            self.items.clear();
            self.stashitems.clear();
            self.itemshoppinglist.clear();
            self.levelpoints.clear();
            self.hero_to_hero_stats.clear();
            self.has_ultimate = ::std::option::Option::None;
            self.has_ultimate_mana = ::std::option::Option::None;
            self.team_slot = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerDetails {
            static instance: PlayerDetails = PlayerDetails {
                accountid: ::std::option::Option::None,
                playerid: ::std::option::Option::None,
                name: ::std::option::Option::None,
                team: ::std::option::Option::None,
                heroid: ::std::option::Option::None,
                healthpoints: ::std::option::Option::None,
                maxhealthpoints: ::std::option::Option::None,
                healthregenrate: ::std::option::Option::None,
                manapoints: ::std::option::Option::None,
                maxmanapoints: ::std::option::Option::None,
                manaregenrate: ::std::option::Option::None,
                base_strength: ::std::option::Option::None,
                base_agility: ::std::option::Option::None,
                base_intelligence: ::std::option::Option::None,
                base_armor: ::std::option::Option::None,
                base_movespeed: ::std::option::Option::None,
                base_damage: ::std::option::Option::None,
                strength: ::std::option::Option::None,
                agility: ::std::option::Option::None,
                intelligence: ::std::option::Option::None,
                armor: ::std::option::Option::None,
                movespeed: ::std::option::Option::None,
                damage: ::std::option::Option::None,
                hero_damage: ::std::option::Option::None,
                tower_damage: ::std::option::Option::None,
                abilities: ::std::vec::Vec::new(),
                level: ::std::option::Option::None,
                kill_count: ::std::option::Option::None,
                death_count: ::std::option::Option::None,
                assists_count: ::std::option::Option::None,
                denies_count: ::std::option::Option::None,
                lh_count: ::std::option::Option::None,
                hero_healing: ::std::option::Option::None,
                gold_per_min: ::std::option::Option::None,
                xp_per_min: ::std::option::Option::None,
                net_gold: ::std::option::Option::None,
                gold: ::std::option::Option::None,
                x: ::std::option::Option::None,
                y: ::std::option::Option::None,
                respawn_time: ::std::option::Option::None,
                ultimate_cooldown: ::std::option::Option::None,
                has_buyback: ::std::option::Option::None,
                items: ::std::vec::Vec::new(),
                stashitems: ::std::vec::Vec::new(),
                itemshoppinglist: ::std::vec::Vec::new(),
                levelpoints: ::std::vec::Vec::new(),
                hero_to_hero_stats: ::std::vec::Vec::new(),
                has_ultimate: ::std::option::Option::None,
                has_ultimate_mana: ::std::option::Option::None,
                team_slot: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTARealtimeGameStats.BuildingDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BuildingDetails {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.BuildingDetails.team)
        pub team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.BuildingDetails.heading)
        pub heading: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.BuildingDetails.lane)
        pub lane: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.BuildingDetails.tier)
        pub tier: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.BuildingDetails.type)
        pub type_: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.BuildingDetails.x)
        pub x: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.BuildingDetails.y)
        pub y: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.BuildingDetails.destroyed)
        pub destroyed: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStats.BuildingDetails.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BuildingDetails {
        fn default() -> &'a BuildingDetails {
            <BuildingDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl BuildingDetails {
        pub fn new() -> BuildingDetails {
            ::std::default::Default::default()
        }

        // optional uint32 team = 2;

        pub fn team(&self) -> u32 {
            self.team.unwrap_or(0)
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: u32) {
            self.team = ::std::option::Option::Some(v);
        }

        // optional float heading = 3;

        pub fn heading(&self) -> f32 {
            self.heading.unwrap_or(0.)
        }

        pub fn clear_heading(&mut self) {
            self.heading = ::std::option::Option::None;
        }

        pub fn has_heading(&self) -> bool {
            self.heading.is_some()
        }

        // Param is passed by value, moved
        pub fn set_heading(&mut self, v: f32) {
            self.heading = ::std::option::Option::Some(v);
        }

        // optional uint32 lane = 4;

        pub fn lane(&self) -> u32 {
            self.lane.unwrap_or(0)
        }

        pub fn clear_lane(&mut self) {
            self.lane = ::std::option::Option::None;
        }

        pub fn has_lane(&self) -> bool {
            self.lane.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lane(&mut self, v: u32) {
            self.lane = ::std::option::Option::Some(v);
        }

        // optional uint32 tier = 5;

        pub fn tier(&self) -> u32 {
            self.tier.unwrap_or(0)
        }

        pub fn clear_tier(&mut self) {
            self.tier = ::std::option::Option::None;
        }

        pub fn has_tier(&self) -> bool {
            self.tier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tier(&mut self, v: u32) {
            self.tier = ::std::option::Option::Some(v);
        }

        // optional uint32 type = 6;

        pub fn type_(&self) -> u32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: u32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional float x = 7;

        pub fn x(&self) -> f32 {
            self.x.unwrap_or(0.)
        }

        pub fn clear_x(&mut self) {
            self.x = ::std::option::Option::None;
        }

        pub fn has_x(&self) -> bool {
            self.x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_x(&mut self, v: f32) {
            self.x = ::std::option::Option::Some(v);
        }

        // optional float y = 8;

        pub fn y(&self) -> f32 {
            self.y.unwrap_or(0.)
        }

        pub fn clear_y(&mut self) {
            self.y = ::std::option::Option::None;
        }

        pub fn has_y(&self) -> bool {
            self.y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_y(&mut self, v: f32) {
            self.y = ::std::option::Option::Some(v);
        }

        // optional bool destroyed = 9;

        pub fn destroyed(&self) -> bool {
            self.destroyed.unwrap_or(false)
        }

        pub fn clear_destroyed(&mut self) {
            self.destroyed = ::std::option::Option::None;
        }

        pub fn has_destroyed(&self) -> bool {
            self.destroyed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_destroyed(&mut self, v: bool) {
            self.destroyed = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for BuildingDetails {
        const NAME: &'static str = "BuildingDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    16 => {
                        self.team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    29 => {
                        self.heading = ::std::option::Option::Some(is.read_float()?);
                    },
                    32 => {
                        self.lane = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.tier = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    61 => {
                        self.x = ::std::option::Option::Some(is.read_float()?);
                    },
                    69 => {
                        self.y = ::std::option::Option::Some(is.read_float()?);
                    },
                    72 => {
                        self.destroyed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.heading {
                my_size += 1 + 4;
            }
            if let Some(v) = self.lane {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.tier {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.type_ {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.x {
                my_size += 1 + 4;
            }
            if let Some(v) = self.y {
                my_size += 1 + 4;
            }
            if let Some(v) = self.destroyed {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.team {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.heading {
                os.write_float(3, v)?;
            }
            if let Some(v) = self.lane {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.tier {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.type_ {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.x {
                os.write_float(7, v)?;
            }
            if let Some(v) = self.y {
                os.write_float(8, v)?;
            }
            if let Some(v) = self.destroyed {
                os.write_bool(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BuildingDetails {
            BuildingDetails::new()
        }

        fn clear(&mut self) {
            self.team = ::std::option::Option::None;
            self.heading = ::std::option::Option::None;
            self.lane = ::std::option::Option::None;
            self.tier = ::std::option::Option::None;
            self.type_ = ::std::option::Option::None;
            self.x = ::std::option::Option::None;
            self.y = ::std::option::Option::None;
            self.destroyed = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BuildingDetails {
            static instance: BuildingDetails = BuildingDetails {
                team: ::std::option::Option::None,
                heading: ::std::option::Option::None,
                lane: ::std::option::Option::None,
                tier: ::std::option::Option::None,
                type_: ::std::option::Option::None,
                x: ::std::option::Option::None,
                y: ::std::option::Option::None,
                destroyed: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTARealtimeGameStats.KillDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct KillDetails {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.KillDetails.player_id)
        pub player_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.KillDetails.death_time)
        pub death_time: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.KillDetails.killer_player_id)
        pub killer_player_id: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStats.KillDetails.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a KillDetails {
        fn default() -> &'a KillDetails {
            <KillDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl KillDetails {
        pub fn new() -> KillDetails {
            ::std::default::Default::default()
        }

        // optional int32 player_id = 1;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(-1i32)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }

        // optional int32 death_time = 2;

        pub fn death_time(&self) -> i32 {
            self.death_time.unwrap_or(0)
        }

        pub fn clear_death_time(&mut self) {
            self.death_time = ::std::option::Option::None;
        }

        pub fn has_death_time(&self) -> bool {
            self.death_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_death_time(&mut self, v: i32) {
            self.death_time = ::std::option::Option::Some(v);
        }

        // optional int32 killer_player_id = 3;

        pub fn killer_player_id(&self) -> i32 {
            self.killer_player_id.unwrap_or(-1i32)
        }

        pub fn clear_killer_player_id(&mut self) {
            self.killer_player_id = ::std::option::Option::None;
        }

        pub fn has_killer_player_id(&self) -> bool {
            self.killer_player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_killer_player_id(&mut self, v: i32) {
            self.killer_player_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for KillDetails {
        const NAME: &'static str = "KillDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.death_time = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.killer_player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.death_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.killer_player_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.player_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.death_time {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.killer_player_id {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> KillDetails {
            KillDetails::new()
        }

        fn clear(&mut self) {
            self.player_id = ::std::option::Option::None;
            self.death_time = ::std::option::Option::None;
            self.killer_player_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static KillDetails {
            static instance: KillDetails = KillDetails {
                player_id: ::std::option::Option::None,
                death_time: ::std::option::Option::None,
                killer_player_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTARealtimeGameStats.BroadcasterDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BroadcasterDetails {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.BroadcasterDetails.player_id)
        pub player_id: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStats.BroadcasterDetails.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BroadcasterDetails {
        fn default() -> &'a BroadcasterDetails {
            <BroadcasterDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl BroadcasterDetails {
        pub fn new() -> BroadcasterDetails {
            ::std::default::Default::default()
        }

        // optional int32 player_id = 1;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(-1i32)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for BroadcasterDetails {
        const NAME: &'static str = "BroadcasterDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.player_id {
                os.write_int32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BroadcasterDetails {
            BroadcasterDetails::new()
        }

        fn clear(&mut self) {
            self.player_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BroadcasterDetails {
            static instance: BroadcasterDetails = BroadcasterDetails {
                player_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTARealtimeGameStats.PickBanDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PickBanDetails {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PickBanDetails.hero)
        pub hero: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.PickBanDetails.team)
        pub team: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStats.PickBanDetails.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PickBanDetails {
        fn default() -> &'a PickBanDetails {
            <PickBanDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PickBanDetails {
        pub fn new() -> PickBanDetails {
            ::std::default::Default::default()
        }

        // optional int32 hero = 1;

        pub fn hero(&self) -> i32 {
            self.hero.unwrap_or(0)
        }

        pub fn clear_hero(&mut self) {
            self.hero = ::std::option::Option::None;
        }

        pub fn has_hero(&self) -> bool {
            self.hero.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero(&mut self, v: i32) {
            self.hero = ::std::option::Option::Some(v);
        }

        // optional uint32 team = 2;

        pub fn team(&self) -> u32 {
            self.team.unwrap_or(0)
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: u32) {
            self.team = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PickBanDetails {
        const NAME: &'static str = "PickBanDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.team {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.hero {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.team {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PickBanDetails {
            PickBanDetails::new()
        }

        fn clear(&mut self) {
            self.hero = ::std::option::Option::None;
            self.team = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PickBanDetails {
            static instance: PickBanDetails = PickBanDetails {
                hero: ::std::option::Option::None,
                team: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTARealtimeGameStats.MatchDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MatchDetails {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.MatchDetails.server_steam_id)
        pub server_steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.MatchDetails.match_id)
        pub match_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.MatchDetails.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.MatchDetails.time_of_day)
        pub time_of_day: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.MatchDetails.is_nightstalker_night)
        pub is_nightstalker_night: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.MatchDetails.game_time)
        pub game_time: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.MatchDetails.game_state)
        pub game_state: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.MatchDetails.teamid_radiant)
        pub teamid_radiant: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.MatchDetails.teamid_dire)
        pub teamid_dire: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.MatchDetails.picks)
        pub picks: ::std::vec::Vec<PickBanDetails>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.MatchDetails.bans)
        pub bans: ::std::vec::Vec<PickBanDetails>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.MatchDetails.kills)
        pub kills: ::std::vec::Vec<KillDetails>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.MatchDetails.broadcasters)
        pub broadcasters: ::std::vec::Vec<BroadcasterDetails>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.MatchDetails.game_mode)
        pub game_mode: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.MatchDetails.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.MatchDetails.league_node_id)
        pub league_node_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.MatchDetails.single_team)
        pub single_team: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.MatchDetails.cheers_peak)
        pub cheers_peak: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.MatchDetails.lobby_type)
        pub lobby_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.MatchDetails.start_timestamp)
        pub start_timestamp: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStats.MatchDetails.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MatchDetails {
        fn default() -> &'a MatchDetails {
            <MatchDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl MatchDetails {
        pub fn new() -> MatchDetails {
            ::std::default::Default::default()
        }

        // optional fixed64 server_steam_id = 1;

        pub fn server_steam_id(&self) -> u64 {
            self.server_steam_id.unwrap_or(0)
        }

        pub fn clear_server_steam_id(&mut self) {
            self.server_steam_id = ::std::option::Option::None;
        }

        pub fn has_server_steam_id(&self) -> bool {
            self.server_steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_steam_id(&mut self, v: u64) {
            self.server_steam_id = ::std::option::Option::Some(v);
        }

        // optional uint64 match_id = 2;

        pub fn match_id(&self) -> u64 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u64) {
            self.match_id = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 3;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional float time_of_day = 4;

        pub fn time_of_day(&self) -> f32 {
            self.time_of_day.unwrap_or(0.)
        }

        pub fn clear_time_of_day(&mut self) {
            self.time_of_day = ::std::option::Option::None;
        }

        pub fn has_time_of_day(&self) -> bool {
            self.time_of_day.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_of_day(&mut self, v: f32) {
            self.time_of_day = ::std::option::Option::Some(v);
        }

        // optional bool is_nightstalker_night = 5;

        pub fn is_nightstalker_night(&self) -> bool {
            self.is_nightstalker_night.unwrap_or(false)
        }

        pub fn clear_is_nightstalker_night(&mut self) {
            self.is_nightstalker_night = ::std::option::Option::None;
        }

        pub fn has_is_nightstalker_night(&self) -> bool {
            self.is_nightstalker_night.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_nightstalker_night(&mut self, v: bool) {
            self.is_nightstalker_night = ::std::option::Option::Some(v);
        }

        // optional int32 game_time = 6;

        pub fn game_time(&self) -> i32 {
            self.game_time.unwrap_or(0)
        }

        pub fn clear_game_time(&mut self) {
            self.game_time = ::std::option::Option::None;
        }

        pub fn has_game_time(&self) -> bool {
            self.game_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_time(&mut self, v: i32) {
            self.game_time = ::std::option::Option::Some(v);
        }

        // optional uint32 game_state = 19;

        pub fn game_state(&self) -> u32 {
            self.game_state.unwrap_or(0)
        }

        pub fn clear_game_state(&mut self) {
            self.game_state = ::std::option::Option::None;
        }

        pub fn has_game_state(&self) -> bool {
            self.game_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_state(&mut self, v: u32) {
            self.game_state = ::std::option::Option::Some(v);
        }

        // optional uint32 teamid_radiant = 8;

        pub fn teamid_radiant(&self) -> u32 {
            self.teamid_radiant.unwrap_or(0)
        }

        pub fn clear_teamid_radiant(&mut self) {
            self.teamid_radiant = ::std::option::Option::None;
        }

        pub fn has_teamid_radiant(&self) -> bool {
            self.teamid_radiant.is_some()
        }

        // Param is passed by value, moved
        pub fn set_teamid_radiant(&mut self, v: u32) {
            self.teamid_radiant = ::std::option::Option::Some(v);
        }

        // optional uint32 teamid_dire = 9;

        pub fn teamid_dire(&self) -> u32 {
            self.teamid_dire.unwrap_or(0)
        }

        pub fn clear_teamid_dire(&mut self) {
            self.teamid_dire = ::std::option::Option::None;
        }

        pub fn has_teamid_dire(&self) -> bool {
            self.teamid_dire.is_some()
        }

        // Param is passed by value, moved
        pub fn set_teamid_dire(&mut self, v: u32) {
            self.teamid_dire = ::std::option::Option::Some(v);
        }

        // optional uint32 game_mode = 14;

        pub fn game_mode(&self) -> u32 {
            self.game_mode.unwrap_or(0)
        }

        pub fn clear_game_mode(&mut self) {
            self.game_mode = ::std::option::Option::None;
        }

        pub fn has_game_mode(&self) -> bool {
            self.game_mode.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_mode(&mut self, v: u32) {
            self.game_mode = ::std::option::Option::Some(v);
        }

        // optional uint32 league_id = 15;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }

        // optional uint32 league_node_id = 18;

        pub fn league_node_id(&self) -> u32 {
            self.league_node_id.unwrap_or(0)
        }

        pub fn clear_league_node_id(&mut self) {
            self.league_node_id = ::std::option::Option::None;
        }

        pub fn has_league_node_id(&self) -> bool {
            self.league_node_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_node_id(&mut self, v: u32) {
            self.league_node_id = ::std::option::Option::Some(v);
        }

        // optional bool single_team = 16;

        pub fn single_team(&self) -> bool {
            self.single_team.unwrap_or(false)
        }

        pub fn clear_single_team(&mut self) {
            self.single_team = ::std::option::Option::None;
        }

        pub fn has_single_team(&self) -> bool {
            self.single_team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_single_team(&mut self, v: bool) {
            self.single_team = ::std::option::Option::Some(v);
        }

        // optional uint32 cheers_peak = 17;

        pub fn cheers_peak(&self) -> u32 {
            self.cheers_peak.unwrap_or(0)
        }

        pub fn clear_cheers_peak(&mut self) {
            self.cheers_peak = ::std::option::Option::None;
        }

        pub fn has_cheers_peak(&self) -> bool {
            self.cheers_peak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cheers_peak(&mut self, v: u32) {
            self.cheers_peak = ::std::option::Option::Some(v);
        }

        // optional uint32 lobby_type = 20;

        pub fn lobby_type(&self) -> u32 {
            self.lobby_type.unwrap_or(0)
        }

        pub fn clear_lobby_type(&mut self) {
            self.lobby_type = ::std::option::Option::None;
        }

        pub fn has_lobby_type(&self) -> bool {
            self.lobby_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lobby_type(&mut self, v: u32) {
            self.lobby_type = ::std::option::Option::Some(v);
        }

        // optional uint32 start_timestamp = 21;

        pub fn start_timestamp(&self) -> u32 {
            self.start_timestamp.unwrap_or(0)
        }

        pub fn clear_start_timestamp(&mut self) {
            self.start_timestamp = ::std::option::Option::None;
        }

        pub fn has_start_timestamp(&self) -> bool {
            self.start_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_timestamp(&mut self, v: u32) {
            self.start_timestamp = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for MatchDetails {
        const NAME: &'static str = "MatchDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    24 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    37 => {
                        self.time_of_day = ::std::option::Option::Some(is.read_float()?);
                    },
                    40 => {
                        self.is_nightstalker_night = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.game_time = ::std::option::Option::Some(is.read_int32()?);
                    },
                    152 => {
                        self.game_state = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.teamid_radiant = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.teamid_dire = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    82 => {
                        self.picks.push(is.read_message()?);
                    },
                    90 => {
                        self.bans.push(is.read_message()?);
                    },
                    98 => {
                        self.kills.push(is.read_message()?);
                    },
                    106 => {
                        self.broadcasters.push(is.read_message()?);
                    },
                    112 => {
                        self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    120 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    144 => {
                        self.league_node_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    128 => {
                        self.single_team = ::std::option::Option::Some(is.read_bool()?);
                    },
                    136 => {
                        self.cheers_peak = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    160 => {
                        self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    168 => {
                        self.start_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.server_steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.match_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.time_of_day {
                my_size += 1 + 4;
            }
            if let Some(v) = self.is_nightstalker_night {
                my_size += 1 + 1;
            }
            if let Some(v) = self.game_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.game_state {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
            }
            if let Some(v) = self.teamid_radiant {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.teamid_dire {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            for value in &self.picks {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.bans {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.kills {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.broadcasters {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.game_mode {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
            }
            if let Some(v) = self.league_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
            }
            if let Some(v) = self.league_node_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
            }
            if let Some(v) = self.single_team {
                my_size += 2 + 1;
            }
            if let Some(v) = self.cheers_peak {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
            }
            if let Some(v) = self.lobby_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
            }
            if let Some(v) = self.start_timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.server_steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.match_id {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.time_of_day {
                os.write_float(4, v)?;
            }
            if let Some(v) = self.is_nightstalker_night {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.game_time {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.game_state {
                os.write_uint32(19, v)?;
            }
            if let Some(v) = self.teamid_radiant {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.teamid_dire {
                os.write_uint32(9, v)?;
            }
            for v in &self.picks {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
            };
            for v in &self.bans {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
            };
            for v in &self.kills {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
            };
            for v in &self.broadcasters {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
            };
            if let Some(v) = self.game_mode {
                os.write_uint32(14, v)?;
            }
            if let Some(v) = self.league_id {
                os.write_uint32(15, v)?;
            }
            if let Some(v) = self.league_node_id {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.single_team {
                os.write_bool(16, v)?;
            }
            if let Some(v) = self.cheers_peak {
                os.write_uint32(17, v)?;
            }
            if let Some(v) = self.lobby_type {
                os.write_uint32(20, v)?;
            }
            if let Some(v) = self.start_timestamp {
                os.write_uint32(21, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MatchDetails {
            MatchDetails::new()
        }

        fn clear(&mut self) {
            self.server_steam_id = ::std::option::Option::None;
            self.match_id = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.time_of_day = ::std::option::Option::None;
            self.is_nightstalker_night = ::std::option::Option::None;
            self.game_time = ::std::option::Option::None;
            self.game_state = ::std::option::Option::None;
            self.teamid_radiant = ::std::option::Option::None;
            self.teamid_dire = ::std::option::Option::None;
            self.picks.clear();
            self.bans.clear();
            self.kills.clear();
            self.broadcasters.clear();
            self.game_mode = ::std::option::Option::None;
            self.league_id = ::std::option::Option::None;
            self.league_node_id = ::std::option::Option::None;
            self.single_team = ::std::option::Option::None;
            self.cheers_peak = ::std::option::Option::None;
            self.lobby_type = ::std::option::Option::None;
            self.start_timestamp = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MatchDetails {
            static instance: MatchDetails = MatchDetails {
                server_steam_id: ::std::option::Option::None,
                match_id: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                time_of_day: ::std::option::Option::None,
                is_nightstalker_night: ::std::option::Option::None,
                game_time: ::std::option::Option::None,
                game_state: ::std::option::Option::None,
                teamid_radiant: ::std::option::Option::None,
                teamid_dire: ::std::option::Option::None,
                picks: ::std::vec::Vec::new(),
                bans: ::std::vec::Vec::new(),
                kills: ::std::vec::Vec::new(),
                broadcasters: ::std::vec::Vec::new(),
                game_mode: ::std::option::Option::None,
                league_id: ::std::option::Option::None,
                league_node_id: ::std::option::Option::None,
                single_team: ::std::option::Option::None,
                cheers_peak: ::std::option::Option::None,
                lobby_type: ::std::option::Option::None,
                start_timestamp: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTARealtimeGameStats.GraphData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GraphData {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.GraphData.graph_gold)
        pub graph_gold: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.GraphData.graph_xp)
        pub graph_xp: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.GraphData.graph_kill)
        pub graph_kill: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.GraphData.graph_tower)
        pub graph_tower: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.GraphData.graph_rax)
        pub graph_rax: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.GraphData.team_loc_stats)
        pub team_loc_stats: ::std::vec::Vec<graph_data::TeamLocationStats>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStats.GraphData.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GraphData {
        fn default() -> &'a GraphData {
            <GraphData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl GraphData {
        pub fn new() -> GraphData {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for GraphData {
        const NAME: &'static str = "GraphData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_int32_into(&mut self.graph_gold)?;
                    },
                    8 => {
                        self.graph_gold.push(is.read_int32()?);
                    },
                    18 => {
                        is.read_repeated_packed_int32_into(&mut self.graph_xp)?;
                    },
                    16 => {
                        self.graph_xp.push(is.read_int32()?);
                    },
                    26 => {
                        is.read_repeated_packed_int32_into(&mut self.graph_kill)?;
                    },
                    24 => {
                        self.graph_kill.push(is.read_int32()?);
                    },
                    34 => {
                        is.read_repeated_packed_int32_into(&mut self.graph_tower)?;
                    },
                    32 => {
                        self.graph_tower.push(is.read_int32()?);
                    },
                    42 => {
                        is.read_repeated_packed_int32_into(&mut self.graph_rax)?;
                    },
                    40 => {
                        self.graph_rax.push(is.read_int32()?);
                    },
                    50 => {
                        self.team_loc_stats.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.graph_gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, *value);
            };
            for value in &self.graph_xp {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, *value);
            };
            for value in &self.graph_kill {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, *value);
            };
            for value in &self.graph_tower {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, *value);
            };
            for value in &self.graph_rax {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, *value);
            };
            for value in &self.team_loc_stats {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            for v in &self.graph_gold {
                os.write_int32(1, *v)?;
            };
            for v in &self.graph_xp {
                os.write_int32(2, *v)?;
            };
            for v in &self.graph_kill {
                os.write_int32(3, *v)?;
            };
            for v in &self.graph_tower {
                os.write_int32(4, *v)?;
            };
            for v in &self.graph_rax {
                os.write_int32(5, *v)?;
            };
            for v in &self.team_loc_stats {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GraphData {
            GraphData::new()
        }

        fn clear(&mut self) {
            self.graph_gold.clear();
            self.graph_xp.clear();
            self.graph_kill.clear();
            self.graph_tower.clear();
            self.graph_rax.clear();
            self.team_loc_stats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GraphData {
            static instance: GraphData = GraphData {
                graph_gold: ::std::vec::Vec::new(),
                graph_xp: ::std::vec::Vec::new(),
                graph_kill: ::std::vec::Vec::new(),
                graph_tower: ::std::vec::Vec::new(),
                graph_rax: ::std::vec::Vec::new(),
                team_loc_stats: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `GraphData`
    pub mod graph_data {
        // @@protoc_insertion_point(message:CMsgDOTARealtimeGameStats.GraphData.LocationStats)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct LocationStats {
            // message fields
            // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.GraphData.LocationStats.stats)
            pub stats: ::std::vec::Vec<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStats.GraphData.LocationStats.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a LocationStats {
            fn default() -> &'a LocationStats {
                <LocationStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl LocationStats {
            pub fn new() -> LocationStats {
                ::std::default::Default::default()
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for LocationStats {
            const NAME: &'static str = "LocationStats";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            is.read_repeated_packed_int32_into(&mut self.stats)?;
                        },
                        8 => {
                            self.stats.push(is.read_int32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.stats {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, *value);
                };
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                for v in &self.stats {
                    os.write_int32(1, *v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> LocationStats {
                LocationStats::new()
            }

            fn clear(&mut self) {
                self.stats.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static LocationStats {
                static instance: LocationStats = LocationStats {
                    stats: ::std::vec::Vec::new(),
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CMsgDOTARealtimeGameStats.GraphData.TeamLocationStats)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct TeamLocationStats {
            // message fields
            // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStats.GraphData.TeamLocationStats.loc_stats)
            pub loc_stats: ::std::vec::Vec<LocationStats>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStats.GraphData.TeamLocationStats.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a TeamLocationStats {
            fn default() -> &'a TeamLocationStats {
                <TeamLocationStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl TeamLocationStats {
            pub fn new() -> TeamLocationStats {
                ::std::default::Default::default()
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for TeamLocationStats {
            const NAME: &'static str = "TeamLocationStats";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.loc_stats.push(is.read_message()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.loc_stats {
                    let len = value.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                for v in &self.loc_stats {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> TeamLocationStats {
                TeamLocationStats::new()
            }

            fn clear(&mut self) {
                self.loc_stats.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static TeamLocationStats {
                static instance: TeamLocationStats = TeamLocationStats {
                    loc_stats: ::std::vec::Vec::new(),
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:CMsgDOTARealtimeGameStats.GraphData.eStat)
        pub enum EStat {
            // @@protoc_insertion_point(enum_value:CMsgDOTARealtimeGameStats.GraphData.eStat.CreepGoldEarned)
            CreepGoldEarned = 0,
            // @@protoc_insertion_point(enum_value:CMsgDOTARealtimeGameStats.GraphData.eStat.KillGoldEarned)
            KillGoldEarned = 1,
            // @@protoc_insertion_point(enum_value:CMsgDOTARealtimeGameStats.GraphData.eStat.DeathAndBuybackGoldLost)
            DeathAndBuybackGoldLost = 2,
            // @@protoc_insertion_point(enum_value:CMsgDOTARealtimeGameStats.GraphData.eStat.XPEarned)
            XPEarned = 3,
        }

        impl ::steam_vent_proto_common::protobuf::Enum for EStat {
            const NAME: &'static str = "eStat";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<EStat> {
                match value {
                    0 => ::std::option::Option::Some(EStat::CreepGoldEarned),
                    1 => ::std::option::Option::Some(EStat::KillGoldEarned),
                    2 => ::std::option::Option::Some(EStat::DeathAndBuybackGoldLost),
                    3 => ::std::option::Option::Some(EStat::XPEarned),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<EStat> {
                match str {
                    "CreepGoldEarned" => ::std::option::Option::Some(EStat::CreepGoldEarned),
                    "KillGoldEarned" => ::std::option::Option::Some(EStat::KillGoldEarned),
                    "DeathAndBuybackGoldLost" => ::std::option::Option::Some(EStat::DeathAndBuybackGoldLost),
                    "XPEarned" => ::std::option::Option::Some(EStat::XPEarned),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [EStat] = &[
                EStat::CreepGoldEarned,
                EStat::KillGoldEarned,
                EStat::DeathAndBuybackGoldLost,
                EStat::XPEarned,
            ];
        }

        impl ::std::default::Default for EStat {
            fn default() -> Self {
                EStat::CreepGoldEarned
            }
        }


        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:CMsgDOTARealtimeGameStats.GraphData.eLocation)
        pub enum ELocation {
            // @@protoc_insertion_point(enum_value:CMsgDOTARealtimeGameStats.GraphData.eLocation.BotLane)
            BotLane = 0,
            // @@protoc_insertion_point(enum_value:CMsgDOTARealtimeGameStats.GraphData.eLocation.MidLane)
            MidLane = 1,
            // @@protoc_insertion_point(enum_value:CMsgDOTARealtimeGameStats.GraphData.eLocation.TopLane)
            TopLane = 2,
            // @@protoc_insertion_point(enum_value:CMsgDOTARealtimeGameStats.GraphData.eLocation.Jungle)
            Jungle = 3,
            // @@protoc_insertion_point(enum_value:CMsgDOTARealtimeGameStats.GraphData.eLocation.Ancients)
            Ancients = 4,
            // @@protoc_insertion_point(enum_value:CMsgDOTARealtimeGameStats.GraphData.eLocation.Other)
            Other = 5,
        }

        impl ::steam_vent_proto_common::protobuf::Enum for ELocation {
            const NAME: &'static str = "eLocation";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<ELocation> {
                match value {
                    0 => ::std::option::Option::Some(ELocation::BotLane),
                    1 => ::std::option::Option::Some(ELocation::MidLane),
                    2 => ::std::option::Option::Some(ELocation::TopLane),
                    3 => ::std::option::Option::Some(ELocation::Jungle),
                    4 => ::std::option::Option::Some(ELocation::Ancients),
                    5 => ::std::option::Option::Some(ELocation::Other),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<ELocation> {
                match str {
                    "BotLane" => ::std::option::Option::Some(ELocation::BotLane),
                    "MidLane" => ::std::option::Option::Some(ELocation::MidLane),
                    "TopLane" => ::std::option::Option::Some(ELocation::TopLane),
                    "Jungle" => ::std::option::Option::Some(ELocation::Jungle),
                    "Ancients" => ::std::option::Option::Some(ELocation::Ancients),
                    "Other" => ::std::option::Option::Some(ELocation::Other),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [ELocation] = &[
                ELocation::BotLane,
                ELocation::MidLane,
                ELocation::TopLane,
                ELocation::Jungle,
                ELocation::Ancients,
                ELocation::Other,
            ];
        }

        impl ::std::default::Default for ELocation {
            fn default() -> Self {
                ELocation::BotLane
            }
        }

    }
}

// @@protoc_insertion_point(message:CMsgDOTARealtimeGameStatsTerse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTARealtimeGameStatsTerse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.match)
    pub match_: ::steam_vent_proto_common::protobuf::MessageField<cmsg_dotarealtime_game_stats_terse::MatchDetails>,
    // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.teams)
    pub teams: ::std::vec::Vec<cmsg_dotarealtime_game_stats_terse::TeamDetails>,
    // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.buildings)
    pub buildings: ::std::vec::Vec<cmsg_dotarealtime_game_stats_terse::BuildingDetails>,
    // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.graph_data)
    pub graph_data: ::steam_vent_proto_common::protobuf::MessageField<cmsg_dotarealtime_game_stats_terse::GraphData>,
    // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.delta_frame)
    pub delta_frame: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStatsTerse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTARealtimeGameStatsTerse {
    fn default() -> &'a CMsgDOTARealtimeGameStatsTerse {
        <CMsgDOTARealtimeGameStatsTerse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTARealtimeGameStatsTerse {
    pub fn new() -> CMsgDOTARealtimeGameStatsTerse {
        ::std::default::Default::default()
    }

    // optional bool delta_frame = 5;

    pub fn delta_frame(&self) -> bool {
        self.delta_frame.unwrap_or(false)
    }

    pub fn clear_delta_frame(&mut self) {
        self.delta_frame = ::std::option::Option::None;
    }

    pub fn has_delta_frame(&self) -> bool {
        self.delta_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta_frame(&mut self, v: bool) {
        self.delta_frame = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTARealtimeGameStatsTerse {
    const NAME: &'static str = "CMsgDOTARealtimeGameStatsTerse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.match_)?;
                },
                18 => {
                    self.teams.push(is.read_message()?);
                },
                26 => {
                    self.buildings.push(is.read_message()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.graph_data)?;
                },
                40 => {
                    self.delta_frame = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.buildings {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.graph_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.delta_frame {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.teams {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.buildings {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.graph_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.delta_frame {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTARealtimeGameStatsTerse {
        CMsgDOTARealtimeGameStatsTerse::new()
    }

    fn clear(&mut self) {
        self.match_.clear();
        self.teams.clear();
        self.buildings.clear();
        self.graph_data.clear();
        self.delta_frame = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTARealtimeGameStatsTerse {
        static instance: CMsgDOTARealtimeGameStatsTerse = CMsgDOTARealtimeGameStatsTerse {
            match_: ::steam_vent_proto_common::protobuf::MessageField::none(),
            teams: ::std::vec::Vec::new(),
            buildings: ::std::vec::Vec::new(),
            graph_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            delta_frame: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTARealtimeGameStatsTerse`
pub mod cmsg_dotarealtime_game_stats_terse {
    // @@protoc_insertion_point(message:CMsgDOTARealtimeGameStatsTerse.TeamDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeamDetails {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.TeamDetails.team_number)
        pub team_number: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.TeamDetails.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.TeamDetails.team_name)
        pub team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.TeamDetails.team_tag)
        pub team_tag: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.TeamDetails.team_logo)
        pub team_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.TeamDetails.score)
        pub score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.TeamDetails.net_worth)
        pub net_worth: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.TeamDetails.team_logo_url)
        pub team_logo_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.TeamDetails.players)
        pub players: ::std::vec::Vec<PlayerDetails>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStatsTerse.TeamDetails.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamDetails {
        fn default() -> &'a TeamDetails {
            <TeamDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl TeamDetails {
        pub fn new() -> TeamDetails {
            ::std::default::Default::default()
        }

        // optional uint32 team_number = 1;

        pub fn team_number(&self) -> u32 {
            self.team_number.unwrap_or(0)
        }

        pub fn clear_team_number(&mut self) {
            self.team_number = ::std::option::Option::None;
        }

        pub fn has_team_number(&self) -> bool {
            self.team_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_number(&mut self, v: u32) {
            self.team_number = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id = 2;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional string team_name = 3;

        pub fn team_name(&self) -> &str {
            match self.team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_name(&mut self) {
            self.team_name = ::std::option::Option::None;
        }

        pub fn has_team_name(&self) -> bool {
            self.team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_name(&mut self, v: ::std::string::String) {
            self.team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
            if self.team_name.is_none() {
                self.team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_name(&mut self) -> ::std::string::String {
            self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string team_tag = 8;

        pub fn team_tag(&self) -> &str {
            match self.team_tag.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_tag(&mut self) {
            self.team_tag = ::std::option::Option::None;
        }

        pub fn has_team_tag(&self) -> bool {
            self.team_tag.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_tag(&mut self, v: ::std::string::String) {
            self.team_tag = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_tag(&mut self) -> &mut ::std::string::String {
            if self.team_tag.is_none() {
                self.team_tag = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_tag.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_tag(&mut self) -> ::std::string::String {
            self.team_tag.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 team_logo = 4;

        pub fn team_logo(&self) -> u64 {
            self.team_logo.unwrap_or(0)
        }

        pub fn clear_team_logo(&mut self) {
            self.team_logo = ::std::option::Option::None;
        }

        pub fn has_team_logo(&self) -> bool {
            self.team_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo(&mut self, v: u64) {
            self.team_logo = ::std::option::Option::Some(v);
        }

        // optional uint32 score = 5;

        pub fn score(&self) -> u32 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: u32) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional uint32 net_worth = 7;

        pub fn net_worth(&self) -> u32 {
            self.net_worth.unwrap_or(0)
        }

        pub fn clear_net_worth(&mut self) {
            self.net_worth = ::std::option::Option::None;
        }

        pub fn has_net_worth(&self) -> bool {
            self.net_worth.is_some()
        }

        // Param is passed by value, moved
        pub fn set_net_worth(&mut self, v: u32) {
            self.net_worth = ::std::option::Option::Some(v);
        }

        // optional string team_logo_url = 9;

        pub fn team_logo_url(&self) -> &str {
            match self.team_logo_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_logo_url(&mut self) {
            self.team_logo_url = ::std::option::Option::None;
        }

        pub fn has_team_logo_url(&self) -> bool {
            self.team_logo_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo_url(&mut self, v: ::std::string::String) {
            self.team_logo_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_logo_url(&mut self) -> &mut ::std::string::String {
            if self.team_logo_url.is_none() {
                self.team_logo_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_logo_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_logo_url(&mut self) -> ::std::string::String {
            self.team_logo_url.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for TeamDetails {
        const NAME: &'static str = "TeamDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team_number = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    66 => {
                        self.team_tag = ::std::option::Option::Some(is.read_string()?);
                    },
                    33 => {
                        self.team_logo = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    40 => {
                        self.score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    74 => {
                        self.team_logo_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.players.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team_number {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.team_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.team_tag.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.team_logo {
                my_size += 1 + 8;
            }
            if let Some(v) = self.score {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.net_worth {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.team_logo_url.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(9, &v);
            }
            for value in &self.players {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.team_number {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.team_name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.team_tag.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.team_logo {
                os.write_fixed64(4, v)?;
            }
            if let Some(v) = self.score {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.net_worth {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.team_logo_url.as_ref() {
                os.write_string(9, v)?;
            }
            for v in &self.players {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamDetails {
            TeamDetails::new()
        }

        fn clear(&mut self) {
            self.team_number = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.team_name = ::std::option::Option::None;
            self.team_tag = ::std::option::Option::None;
            self.team_logo = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.net_worth = ::std::option::Option::None;
            self.team_logo_url = ::std::option::Option::None;
            self.players.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamDetails {
            static instance: TeamDetails = TeamDetails {
                team_number: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                team_name: ::std::option::Option::None,
                team_tag: ::std::option::Option::None,
                team_logo: ::std::option::Option::None,
                score: ::std::option::Option::None,
                net_worth: ::std::option::Option::None,
                team_logo_url: ::std::option::Option::None,
                players: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTARealtimeGameStatsTerse.PlayerDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerDetails {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.PlayerDetails.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.PlayerDetails.playerid)
        pub playerid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.PlayerDetails.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.PlayerDetails.team)
        pub team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.PlayerDetails.heroid)
        pub heroid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.PlayerDetails.level)
        pub level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.PlayerDetails.kill_count)
        pub kill_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.PlayerDetails.death_count)
        pub death_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.PlayerDetails.assists_count)
        pub assists_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.PlayerDetails.denies_count)
        pub denies_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.PlayerDetails.lh_count)
        pub lh_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.PlayerDetails.gold)
        pub gold: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.PlayerDetails.x)
        pub x: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.PlayerDetails.y)
        pub y: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.PlayerDetails.net_worth)
        pub net_worth: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.PlayerDetails.abilities)
        pub abilities: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.PlayerDetails.items)
        pub items: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.PlayerDetails.team_slot)
        pub team_slot: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStatsTerse.PlayerDetails.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerDetails {
        fn default() -> &'a PlayerDetails {
            <PlayerDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerDetails {
        pub fn new() -> PlayerDetails {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional int32 playerid = 2;

        pub fn playerid(&self) -> i32 {
            self.playerid.unwrap_or(-1i32)
        }

        pub fn clear_playerid(&mut self) {
            self.playerid = ::std::option::Option::None;
        }

        pub fn has_playerid(&self) -> bool {
            self.playerid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_playerid(&mut self, v: i32) {
            self.playerid = ::std::option::Option::Some(v);
        }

        // optional string name = 3;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 team = 4;

        pub fn team(&self) -> u32 {
            self.team.unwrap_or(0)
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: u32) {
            self.team = ::std::option::Option::Some(v);
        }

        // optional int32 heroid = 5;

        pub fn heroid(&self) -> i32 {
            self.heroid.unwrap_or(0)
        }

        pub fn clear_heroid(&mut self) {
            self.heroid = ::std::option::Option::None;
        }

        pub fn has_heroid(&self) -> bool {
            self.heroid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_heroid(&mut self, v: i32) {
            self.heroid = ::std::option::Option::Some(v);
        }

        // optional uint32 level = 6;

        pub fn level(&self) -> u32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: u32) {
            self.level = ::std::option::Option::Some(v);
        }

        // optional uint32 kill_count = 7;

        pub fn kill_count(&self) -> u32 {
            self.kill_count.unwrap_or(0)
        }

        pub fn clear_kill_count(&mut self) {
            self.kill_count = ::std::option::Option::None;
        }

        pub fn has_kill_count(&self) -> bool {
            self.kill_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kill_count(&mut self, v: u32) {
            self.kill_count = ::std::option::Option::Some(v);
        }

        // optional uint32 death_count = 8;

        pub fn death_count(&self) -> u32 {
            self.death_count.unwrap_or(0)
        }

        pub fn clear_death_count(&mut self) {
            self.death_count = ::std::option::Option::None;
        }

        pub fn has_death_count(&self) -> bool {
            self.death_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_death_count(&mut self, v: u32) {
            self.death_count = ::std::option::Option::Some(v);
        }

        // optional uint32 assists_count = 9;

        pub fn assists_count(&self) -> u32 {
            self.assists_count.unwrap_or(0)
        }

        pub fn clear_assists_count(&mut self) {
            self.assists_count = ::std::option::Option::None;
        }

        pub fn has_assists_count(&self) -> bool {
            self.assists_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_assists_count(&mut self, v: u32) {
            self.assists_count = ::std::option::Option::Some(v);
        }

        // optional uint32 denies_count = 10;

        pub fn denies_count(&self) -> u32 {
            self.denies_count.unwrap_or(0)
        }

        pub fn clear_denies_count(&mut self) {
            self.denies_count = ::std::option::Option::None;
        }

        pub fn has_denies_count(&self) -> bool {
            self.denies_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_denies_count(&mut self, v: u32) {
            self.denies_count = ::std::option::Option::Some(v);
        }

        // optional uint32 lh_count = 11;

        pub fn lh_count(&self) -> u32 {
            self.lh_count.unwrap_or(0)
        }

        pub fn clear_lh_count(&mut self) {
            self.lh_count = ::std::option::Option::None;
        }

        pub fn has_lh_count(&self) -> bool {
            self.lh_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lh_count(&mut self, v: u32) {
            self.lh_count = ::std::option::Option::Some(v);
        }

        // optional uint32 gold = 12;

        pub fn gold(&self) -> u32 {
            self.gold.unwrap_or(0)
        }

        pub fn clear_gold(&mut self) {
            self.gold = ::std::option::Option::None;
        }

        pub fn has_gold(&self) -> bool {
            self.gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold(&mut self, v: u32) {
            self.gold = ::std::option::Option::Some(v);
        }

        // optional float x = 13;

        pub fn x(&self) -> f32 {
            self.x.unwrap_or(0.)
        }

        pub fn clear_x(&mut self) {
            self.x = ::std::option::Option::None;
        }

        pub fn has_x(&self) -> bool {
            self.x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_x(&mut self, v: f32) {
            self.x = ::std::option::Option::Some(v);
        }

        // optional float y = 14;

        pub fn y(&self) -> f32 {
            self.y.unwrap_or(0.)
        }

        pub fn clear_y(&mut self) {
            self.y = ::std::option::Option::None;
        }

        pub fn has_y(&self) -> bool {
            self.y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_y(&mut self, v: f32) {
            self.y = ::std::option::Option::Some(v);
        }

        // optional uint32 net_worth = 15;

        pub fn net_worth(&self) -> u32 {
            self.net_worth.unwrap_or(0)
        }

        pub fn clear_net_worth(&mut self) {
            self.net_worth = ::std::option::Option::None;
        }

        pub fn has_net_worth(&self) -> bool {
            self.net_worth.is_some()
        }

        // Param is passed by value, moved
        pub fn set_net_worth(&mut self, v: u32) {
            self.net_worth = ::std::option::Option::Some(v);
        }

        // optional uint32 team_slot = 18;

        pub fn team_slot(&self) -> u32 {
            self.team_slot.unwrap_or(0)
        }

        pub fn clear_team_slot(&mut self) {
            self.team_slot = ::std::option::Option::None;
        }

        pub fn has_team_slot(&self) -> bool {
            self.team_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_slot(&mut self, v: u32) {
            self.team_slot = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerDetails {
        const NAME: &'static str = "PlayerDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.playerid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    26 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.heroid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.kill_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.death_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.assists_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.denies_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.lh_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.gold = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    109 => {
                        self.x = ::std::option::Option::Some(is.read_float()?);
                    },
                    117 => {
                        self.y = ::std::option::Option::Some(is.read_float()?);
                    },
                    120 => {
                        self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    130 => {
                        is.read_repeated_packed_int32_into(&mut self.abilities)?;
                    },
                    128 => {
                        self.abilities.push(is.read_int32()?);
                    },
                    138 => {
                        is.read_repeated_packed_int32_into(&mut self.items)?;
                    },
                    136 => {
                        self.items.push(is.read_int32()?);
                    },
                    144 => {
                        self.team_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.playerid {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.team {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.heroid {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.level {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.kill_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.death_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.assists_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.denies_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.lh_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.x {
                my_size += 1 + 4;
            }
            if let Some(v) = self.y {
                my_size += 1 + 4;
            }
            if let Some(v) = self.net_worth {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
            }
            for value in &self.abilities {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(16, *value);
            };
            for value in &self.items {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(17, *value);
            };
            if let Some(v) = self.team_slot {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.playerid {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.team {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.heroid {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.level {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.kill_count {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.death_count {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.assists_count {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.denies_count {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.lh_count {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.gold {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.x {
                os.write_float(13, v)?;
            }
            if let Some(v) = self.y {
                os.write_float(14, v)?;
            }
            if let Some(v) = self.net_worth {
                os.write_uint32(15, v)?;
            }
            for v in &self.abilities {
                os.write_int32(16, *v)?;
            };
            for v in &self.items {
                os.write_int32(17, *v)?;
            };
            if let Some(v) = self.team_slot {
                os.write_uint32(18, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerDetails {
            PlayerDetails::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.playerid = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.team = ::std::option::Option::None;
            self.heroid = ::std::option::Option::None;
            self.level = ::std::option::Option::None;
            self.kill_count = ::std::option::Option::None;
            self.death_count = ::std::option::Option::None;
            self.assists_count = ::std::option::Option::None;
            self.denies_count = ::std::option::Option::None;
            self.lh_count = ::std::option::Option::None;
            self.gold = ::std::option::Option::None;
            self.x = ::std::option::Option::None;
            self.y = ::std::option::Option::None;
            self.net_worth = ::std::option::Option::None;
            self.abilities.clear();
            self.items.clear();
            self.team_slot = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerDetails {
            static instance: PlayerDetails = PlayerDetails {
                accountid: ::std::option::Option::None,
                playerid: ::std::option::Option::None,
                name: ::std::option::Option::None,
                team: ::std::option::Option::None,
                heroid: ::std::option::Option::None,
                level: ::std::option::Option::None,
                kill_count: ::std::option::Option::None,
                death_count: ::std::option::Option::None,
                assists_count: ::std::option::Option::None,
                denies_count: ::std::option::Option::None,
                lh_count: ::std::option::Option::None,
                gold: ::std::option::Option::None,
                x: ::std::option::Option::None,
                y: ::std::option::Option::None,
                net_worth: ::std::option::Option::None,
                abilities: ::std::vec::Vec::new(),
                items: ::std::vec::Vec::new(),
                team_slot: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTARealtimeGameStatsTerse.BuildingDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BuildingDetails {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.BuildingDetails.team)
        pub team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.BuildingDetails.heading)
        pub heading: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.BuildingDetails.type)
        pub type_: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.BuildingDetails.lane)
        pub lane: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.BuildingDetails.tier)
        pub tier: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.BuildingDetails.x)
        pub x: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.BuildingDetails.y)
        pub y: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.BuildingDetails.destroyed)
        pub destroyed: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStatsTerse.BuildingDetails.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BuildingDetails {
        fn default() -> &'a BuildingDetails {
            <BuildingDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl BuildingDetails {
        pub fn new() -> BuildingDetails {
            ::std::default::Default::default()
        }

        // optional uint32 team = 1;

        pub fn team(&self) -> u32 {
            self.team.unwrap_or(0)
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: u32) {
            self.team = ::std::option::Option::Some(v);
        }

        // optional float heading = 2;

        pub fn heading(&self) -> f32 {
            self.heading.unwrap_or(0.)
        }

        pub fn clear_heading(&mut self) {
            self.heading = ::std::option::Option::None;
        }

        pub fn has_heading(&self) -> bool {
            self.heading.is_some()
        }

        // Param is passed by value, moved
        pub fn set_heading(&mut self, v: f32) {
            self.heading = ::std::option::Option::Some(v);
        }

        // optional uint32 type = 3;

        pub fn type_(&self) -> u32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: u32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional uint32 lane = 4;

        pub fn lane(&self) -> u32 {
            self.lane.unwrap_or(0)
        }

        pub fn clear_lane(&mut self) {
            self.lane = ::std::option::Option::None;
        }

        pub fn has_lane(&self) -> bool {
            self.lane.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lane(&mut self, v: u32) {
            self.lane = ::std::option::Option::Some(v);
        }

        // optional uint32 tier = 5;

        pub fn tier(&self) -> u32 {
            self.tier.unwrap_or(0)
        }

        pub fn clear_tier(&mut self) {
            self.tier = ::std::option::Option::None;
        }

        pub fn has_tier(&self) -> bool {
            self.tier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tier(&mut self, v: u32) {
            self.tier = ::std::option::Option::Some(v);
        }

        // optional float x = 6;

        pub fn x(&self) -> f32 {
            self.x.unwrap_or(0.)
        }

        pub fn clear_x(&mut self) {
            self.x = ::std::option::Option::None;
        }

        pub fn has_x(&self) -> bool {
            self.x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_x(&mut self, v: f32) {
            self.x = ::std::option::Option::Some(v);
        }

        // optional float y = 7;

        pub fn y(&self) -> f32 {
            self.y.unwrap_or(0.)
        }

        pub fn clear_y(&mut self) {
            self.y = ::std::option::Option::None;
        }

        pub fn has_y(&self) -> bool {
            self.y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_y(&mut self, v: f32) {
            self.y = ::std::option::Option::Some(v);
        }

        // optional bool destroyed = 8;

        pub fn destroyed(&self) -> bool {
            self.destroyed.unwrap_or(false)
        }

        pub fn clear_destroyed(&mut self) {
            self.destroyed = ::std::option::Option::None;
        }

        pub fn has_destroyed(&self) -> bool {
            self.destroyed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_destroyed(&mut self, v: bool) {
            self.destroyed = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for BuildingDetails {
        const NAME: &'static str = "BuildingDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    21 => {
                        self.heading = ::std::option::Option::Some(is.read_float()?);
                    },
                    24 => {
                        self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.lane = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.tier = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    53 => {
                        self.x = ::std::option::Option::Some(is.read_float()?);
                    },
                    61 => {
                        self.y = ::std::option::Option::Some(is.read_float()?);
                    },
                    64 => {
                        self.destroyed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.heading {
                my_size += 1 + 4;
            }
            if let Some(v) = self.type_ {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.lane {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.tier {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.x {
                my_size += 1 + 4;
            }
            if let Some(v) = self.y {
                my_size += 1 + 4;
            }
            if let Some(v) = self.destroyed {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.team {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.heading {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.type_ {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.lane {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.tier {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.x {
                os.write_float(6, v)?;
            }
            if let Some(v) = self.y {
                os.write_float(7, v)?;
            }
            if let Some(v) = self.destroyed {
                os.write_bool(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BuildingDetails {
            BuildingDetails::new()
        }

        fn clear(&mut self) {
            self.team = ::std::option::Option::None;
            self.heading = ::std::option::Option::None;
            self.type_ = ::std::option::Option::None;
            self.lane = ::std::option::Option::None;
            self.tier = ::std::option::Option::None;
            self.x = ::std::option::Option::None;
            self.y = ::std::option::Option::None;
            self.destroyed = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BuildingDetails {
            static instance: BuildingDetails = BuildingDetails {
                team: ::std::option::Option::None,
                heading: ::std::option::Option::None,
                type_: ::std::option::Option::None,
                lane: ::std::option::Option::None,
                tier: ::std::option::Option::None,
                x: ::std::option::Option::None,
                y: ::std::option::Option::None,
                destroyed: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTARealtimeGameStatsTerse.PickBanDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PickBanDetails {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.PickBanDetails.hero)
        pub hero: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.PickBanDetails.team)
        pub team: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStatsTerse.PickBanDetails.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PickBanDetails {
        fn default() -> &'a PickBanDetails {
            <PickBanDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PickBanDetails {
        pub fn new() -> PickBanDetails {
            ::std::default::Default::default()
        }

        // optional int32 hero = 1;

        pub fn hero(&self) -> i32 {
            self.hero.unwrap_or(0)
        }

        pub fn clear_hero(&mut self) {
            self.hero = ::std::option::Option::None;
        }

        pub fn has_hero(&self) -> bool {
            self.hero.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero(&mut self, v: i32) {
            self.hero = ::std::option::Option::Some(v);
        }

        // optional uint32 team = 2;

        pub fn team(&self) -> u32 {
            self.team.unwrap_or(0)
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: u32) {
            self.team = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PickBanDetails {
        const NAME: &'static str = "PickBanDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.team {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.hero {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.team {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PickBanDetails {
            PickBanDetails::new()
        }

        fn clear(&mut self) {
            self.hero = ::std::option::Option::None;
            self.team = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PickBanDetails {
            static instance: PickBanDetails = PickBanDetails {
                hero: ::std::option::Option::None,
                team: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTARealtimeGameStatsTerse.MatchDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MatchDetails {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.MatchDetails.server_steam_id)
        pub server_steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.MatchDetails.match_id)
        pub match_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.MatchDetails.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.MatchDetails.game_time)
        pub game_time: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.MatchDetails.steam_broadcaster_account_ids)
        pub steam_broadcaster_account_ids: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.MatchDetails.game_mode)
        pub game_mode: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.MatchDetails.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.MatchDetails.league_node_id)
        pub league_node_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.MatchDetails.game_state)
        pub game_state: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.MatchDetails.picks)
        pub picks: ::std::vec::Vec<PickBanDetails>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.MatchDetails.bans)
        pub bans: ::std::vec::Vec<PickBanDetails>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.MatchDetails.lobby_type)
        pub lobby_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.MatchDetails.start_timestamp)
        pub start_timestamp: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStatsTerse.MatchDetails.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MatchDetails {
        fn default() -> &'a MatchDetails {
            <MatchDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl MatchDetails {
        pub fn new() -> MatchDetails {
            ::std::default::Default::default()
        }

        // optional fixed64 server_steam_id = 1;

        pub fn server_steam_id(&self) -> u64 {
            self.server_steam_id.unwrap_or(0)
        }

        pub fn clear_server_steam_id(&mut self) {
            self.server_steam_id = ::std::option::Option::None;
        }

        pub fn has_server_steam_id(&self) -> bool {
            self.server_steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_steam_id(&mut self, v: u64) {
            self.server_steam_id = ::std::option::Option::Some(v);
        }

        // optional uint64 match_id = 2;

        pub fn match_id(&self) -> u64 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u64) {
            self.match_id = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 3;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional int32 game_time = 4;

        pub fn game_time(&self) -> i32 {
            self.game_time.unwrap_or(0)
        }

        pub fn clear_game_time(&mut self) {
            self.game_time = ::std::option::Option::None;
        }

        pub fn has_game_time(&self) -> bool {
            self.game_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_time(&mut self, v: i32) {
            self.game_time = ::std::option::Option::Some(v);
        }

        // optional uint32 game_mode = 7;

        pub fn game_mode(&self) -> u32 {
            self.game_mode.unwrap_or(0)
        }

        pub fn clear_game_mode(&mut self) {
            self.game_mode = ::std::option::Option::None;
        }

        pub fn has_game_mode(&self) -> bool {
            self.game_mode.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_mode(&mut self, v: u32) {
            self.game_mode = ::std::option::Option::Some(v);
        }

        // optional uint32 league_id = 8;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }

        // optional uint32 league_node_id = 9;

        pub fn league_node_id(&self) -> u32 {
            self.league_node_id.unwrap_or(0)
        }

        pub fn clear_league_node_id(&mut self) {
            self.league_node_id = ::std::option::Option::None;
        }

        pub fn has_league_node_id(&self) -> bool {
            self.league_node_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_node_id(&mut self, v: u32) {
            self.league_node_id = ::std::option::Option::Some(v);
        }

        // optional uint32 game_state = 10;

        pub fn game_state(&self) -> u32 {
            self.game_state.unwrap_or(0)
        }

        pub fn clear_game_state(&mut self) {
            self.game_state = ::std::option::Option::None;
        }

        pub fn has_game_state(&self) -> bool {
            self.game_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_state(&mut self, v: u32) {
            self.game_state = ::std::option::Option::Some(v);
        }

        // optional uint32 lobby_type = 13;

        pub fn lobby_type(&self) -> u32 {
            self.lobby_type.unwrap_or(0)
        }

        pub fn clear_lobby_type(&mut self) {
            self.lobby_type = ::std::option::Option::None;
        }

        pub fn has_lobby_type(&self) -> bool {
            self.lobby_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lobby_type(&mut self, v: u32) {
            self.lobby_type = ::std::option::Option::Some(v);
        }

        // optional uint32 start_timestamp = 14;

        pub fn start_timestamp(&self) -> u32 {
            self.start_timestamp.unwrap_or(0)
        }

        pub fn clear_start_timestamp(&mut self) {
            self.start_timestamp = ::std::option::Option::None;
        }

        pub fn has_start_timestamp(&self) -> bool {
            self.start_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_timestamp(&mut self, v: u32) {
            self.start_timestamp = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for MatchDetails {
        const NAME: &'static str = "MatchDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    24 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.game_time = ::std::option::Option::Some(is.read_int32()?);
                    },
                    50 => {
                        is.read_repeated_packed_uint32_into(&mut self.steam_broadcaster_account_ids)?;
                    },
                    48 => {
                        self.steam_broadcaster_account_ids.push(is.read_uint32()?);
                    },
                    56 => {
                        self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.league_node_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.game_state = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    90 => {
                        self.picks.push(is.read_message()?);
                    },
                    98 => {
                        self.bans.push(is.read_message()?);
                    },
                    104 => {
                        self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.start_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.server_steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.match_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.game_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            for value in &self.steam_broadcaster_account_ids {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, *value);
            };
            if let Some(v) = self.game_mode {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.league_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.league_node_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.game_state {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
            }
            for value in &self.picks {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.bans {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.lobby_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.start_timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.server_steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.match_id {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.game_time {
                os.write_int32(4, v)?;
            }
            for v in &self.steam_broadcaster_account_ids {
                os.write_uint32(6, *v)?;
            };
            if let Some(v) = self.game_mode {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.league_id {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.league_node_id {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.game_state {
                os.write_uint32(10, v)?;
            }
            for v in &self.picks {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
            };
            for v in &self.bans {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
            };
            if let Some(v) = self.lobby_type {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.start_timestamp {
                os.write_uint32(14, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MatchDetails {
            MatchDetails::new()
        }

        fn clear(&mut self) {
            self.server_steam_id = ::std::option::Option::None;
            self.match_id = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.game_time = ::std::option::Option::None;
            self.steam_broadcaster_account_ids.clear();
            self.game_mode = ::std::option::Option::None;
            self.league_id = ::std::option::Option::None;
            self.league_node_id = ::std::option::Option::None;
            self.game_state = ::std::option::Option::None;
            self.picks.clear();
            self.bans.clear();
            self.lobby_type = ::std::option::Option::None;
            self.start_timestamp = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MatchDetails {
            static instance: MatchDetails = MatchDetails {
                server_steam_id: ::std::option::Option::None,
                match_id: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                game_time: ::std::option::Option::None,
                steam_broadcaster_account_ids: ::std::vec::Vec::new(),
                game_mode: ::std::option::Option::None,
                league_id: ::std::option::Option::None,
                league_node_id: ::std::option::Option::None,
                game_state: ::std::option::Option::None,
                picks: ::std::vec::Vec::new(),
                bans: ::std::vec::Vec::new(),
                lobby_type: ::std::option::Option::None,
                start_timestamp: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTARealtimeGameStatsTerse.GraphData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GraphData {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTARealtimeGameStatsTerse.GraphData.graph_gold)
        pub graph_gold: ::std::vec::Vec<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTARealtimeGameStatsTerse.GraphData.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GraphData {
        fn default() -> &'a GraphData {
            <GraphData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl GraphData {
        pub fn new() -> GraphData {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for GraphData {
        const NAME: &'static str = "GraphData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_int32_into(&mut self.graph_gold)?;
                    },
                    8 => {
                        self.graph_gold.push(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.graph_gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, *value);
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            for v in &self.graph_gold {
                os.write_int32(1, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GraphData {
            GraphData::new()
        }

        fn clear(&mut self) {
            self.graph_gold.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GraphData {
            static instance: GraphData = GraphData {
                graph_gold: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTABroadcastTimelineEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTABroadcastTimelineEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTABroadcastTimelineEvent.event)
    pub event: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EBroadcastTimelineEvent>>,
    // @@protoc_insertion_point(field:CMsgDOTABroadcastTimelineEvent.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTABroadcastTimelineEvent.data)
    pub data: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTABroadcastTimelineEvent.string_data)
    pub string_data: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTABroadcastTimelineEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTABroadcastTimelineEvent {
    fn default() -> &'a CMsgDOTABroadcastTimelineEvent {
        <CMsgDOTABroadcastTimelineEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTABroadcastTimelineEvent {
    pub fn new() -> CMsgDOTABroadcastTimelineEvent {
        ::std::default::Default::default()
    }

    // optional .EBroadcastTimelineEvent event = 1;

    pub fn event(&self) -> EBroadcastTimelineEvent {
        match self.event {
            Some(e) => e.enum_value_or(EBroadcastTimelineEvent::EBroadcastTimelineEvent_MatchStarted),
            None => EBroadcastTimelineEvent::EBroadcastTimelineEvent_MatchStarted,
        }
    }

    pub fn clear_event(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_event(&self) -> bool {
        self.event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: EBroadcastTimelineEvent) {
        self.event = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 data = 3;

    pub fn data(&self) -> u32 {
        self.data.unwrap_or(0)
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: u32) {
        self.data = ::std::option::Option::Some(v);
    }

    // optional string string_data = 4;

    pub fn string_data(&self) -> &str {
        match self.string_data.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string_data(&mut self) {
        self.string_data = ::std::option::Option::None;
    }

    pub fn has_string_data(&self) -> bool {
        self.string_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_data(&mut self, v: ::std::string::String) {
        self.string_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_data(&mut self) -> &mut ::std::string::String {
        if self.string_data.is_none() {
            self.string_data = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_data(&mut self) -> ::std::string::String {
        self.string_data.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTABroadcastTimelineEvent {
    const NAME: &'static str = "CMsgDOTABroadcastTimelineEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                21 => {
                    self.timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.data = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.string_data = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.data {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.string_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.data {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.string_data.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTABroadcastTimelineEvent {
        CMsgDOTABroadcastTimelineEvent::new()
    }

    fn clear(&mut self) {
        self.event = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.string_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTABroadcastTimelineEvent {
        static instance: CMsgDOTABroadcastTimelineEvent = CMsgDOTABroadcastTimelineEvent {
            event: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            data: ::std::option::Option::None,
            string_data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientMatchGroupsVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientMatchGroupsVersion {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientMatchGroupsVersion.matchgroups_version)
    pub matchgroups_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientMatchGroupsVersion.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientMatchGroupsVersion {
    fn default() -> &'a CMsgGCToClientMatchGroupsVersion {
        <CMsgGCToClientMatchGroupsVersion as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientMatchGroupsVersion {
    pub fn new() -> CMsgGCToClientMatchGroupsVersion {
        ::std::default::Default::default()
    }

    // optional uint32 matchgroups_version = 1;

    pub fn matchgroups_version(&self) -> u32 {
        self.matchgroups_version.unwrap_or(0)
    }

    pub fn clear_matchgroups_version(&mut self) {
        self.matchgroups_version = ::std::option::Option::None;
    }

    pub fn has_matchgroups_version(&self) -> bool {
        self.matchgroups_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchgroups_version(&mut self, v: u32) {
        self.matchgroups_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientMatchGroupsVersion {
    const NAME: &'static str = "CMsgGCToClientMatchGroupsVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.matchgroups_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.matchgroups_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.matchgroups_version {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientMatchGroupsVersion {
        CMsgGCToClientMatchGroupsVersion::new()
    }

    fn clear(&mut self) {
        self.matchgroups_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientMatchGroupsVersion {
        static instance: CMsgGCToClientMatchGroupsVersion = CMsgGCToClientMatchGroupsVersion {
            matchgroups_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTASDOHeroStatsHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASDOHeroStatsHistory {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTASDOHeroStatsHistory.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTASDOHeroStatsHistory.game_mode)
    pub game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASDOHeroStatsHistory.lobby_type)
    pub lobby_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASDOHeroStatsHistory.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASDOHeroStatsHistory.won)
    pub won: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTASDOHeroStatsHistory.gpm)
    pub gpm: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASDOHeroStatsHistory.xpm)
    pub xpm: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASDOHeroStatsHistory.kills)
    pub kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASDOHeroStatsHistory.deaths)
    pub deaths: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASDOHeroStatsHistory.assists)
    pub assists: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTASDOHeroStatsHistory.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASDOHeroStatsHistory {
    fn default() -> &'a CMsgDOTASDOHeroStatsHistory {
        <CMsgDOTASDOHeroStatsHistory as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASDOHeroStatsHistory {
    pub fn new() -> CMsgDOTASDOHeroStatsHistory {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 game_mode = 2;

    pub fn game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_type = 3;

    pub fn lobby_type(&self) -> u32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: u32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional uint32 start_time = 4;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional bool won = 5;

    pub fn won(&self) -> bool {
        self.won.unwrap_or(false)
    }

    pub fn clear_won(&mut self) {
        self.won = ::std::option::Option::None;
    }

    pub fn has_won(&self) -> bool {
        self.won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_won(&mut self, v: bool) {
        self.won = ::std::option::Option::Some(v);
    }

    // optional uint32 gpm = 6;

    pub fn gpm(&self) -> u32 {
        self.gpm.unwrap_or(0)
    }

    pub fn clear_gpm(&mut self) {
        self.gpm = ::std::option::Option::None;
    }

    pub fn has_gpm(&self) -> bool {
        self.gpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpm(&mut self, v: u32) {
        self.gpm = ::std::option::Option::Some(v);
    }

    // optional uint32 xpm = 7;

    pub fn xpm(&self) -> u32 {
        self.xpm.unwrap_or(0)
    }

    pub fn clear_xpm(&mut self) {
        self.xpm = ::std::option::Option::None;
    }

    pub fn has_xpm(&self) -> bool {
        self.xpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xpm(&mut self, v: u32) {
        self.xpm = ::std::option::Option::Some(v);
    }

    // optional uint32 kills = 8;

    pub fn kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional uint32 deaths = 9;

    pub fn deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 assists = 10;

    pub fn assists(&self) -> u32 {
        self.assists.unwrap_or(0)
    }

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: u32) {
        self.assists = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTASDOHeroStatsHistory {
    const NAME: &'static str = "CMsgDOTASDOHeroStatsHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.won = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.gpm = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.xpm = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.assists = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.start_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.won {
            my_size += 1 + 1;
        }
        if let Some(v) = self.gpm {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.xpm {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.deaths {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.assists {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.won {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.gpm {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.xpm {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.assists {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASDOHeroStatsHistory {
        CMsgDOTASDOHeroStatsHistory::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.won = ::std::option::Option::None;
        self.gpm = ::std::option::Option::None;
        self.xpm = ::std::option::Option::None;
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.assists = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASDOHeroStatsHistory {
        static instance: CMsgDOTASDOHeroStatsHistory = CMsgDOTASDOHeroStatsHistory {
            match_id: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            won: ::std::option::Option::None,
            gpm: ::std::option::Option::None,
            xpm: ::std::option::Option::None,
            kills: ::std::option::Option::None,
            deaths: ::std::option::Option::None,
            assists: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPredictionChoice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPredictionChoice {
    // message fields
    // @@protoc_insertion_point(field:CMsgPredictionChoice.value)
    pub value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPredictionChoice.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPredictionChoice.min_raw_value)
    pub min_raw_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPredictionChoice.max_raw_value)
    pub max_raw_value: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPredictionChoice.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPredictionChoice {
    fn default() -> &'a CMsgPredictionChoice {
        <CMsgPredictionChoice as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPredictionChoice {
    pub fn new() -> CMsgPredictionChoice {
        ::std::default::Default::default()
    }

    // optional uint32 value = 1;

    pub fn value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 min_raw_value = 3;

    pub fn min_raw_value(&self) -> u32 {
        self.min_raw_value.unwrap_or(0)
    }

    pub fn clear_min_raw_value(&mut self) {
        self.min_raw_value = ::std::option::Option::None;
    }

    pub fn has_min_raw_value(&self) -> bool {
        self.min_raw_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_raw_value(&mut self, v: u32) {
        self.min_raw_value = ::std::option::Option::Some(v);
    }

    // optional uint32 max_raw_value = 4;

    pub fn max_raw_value(&self) -> u32 {
        self.max_raw_value.unwrap_or(0)
    }

    pub fn clear_max_raw_value(&mut self) {
        self.max_raw_value = ::std::option::Option::None;
    }

    pub fn has_max_raw_value(&self) -> bool {
        self.max_raw_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_raw_value(&mut self, v: u32) {
        self.max_raw_value = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPredictionChoice {
    const NAME: &'static str = "CMsgPredictionChoice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.value = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.min_raw_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.max_raw_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.min_raw_value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.max_raw_value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.value {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.min_raw_value {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.max_raw_value {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPredictionChoice {
        CMsgPredictionChoice::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.min_raw_value = ::std::option::Option::None;
        self.max_raw_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPredictionChoice {
        static instance: CMsgPredictionChoice = CMsgPredictionChoice {
            value: ::std::option::Option::None,
            name: ::std::option::Option::None,
            min_raw_value: ::std::option::Option::None,
            max_raw_value: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgInGamePrediction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgInGamePrediction {
    // message fields
    // @@protoc_insertion_point(field:CMsgInGamePrediction.id)
    pub id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgInGamePrediction.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgInGamePrediction.type)
    pub type_: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_in_game_prediction::EPredictionType>>,
    // @@protoc_insertion_point(field:CMsgInGamePrediction.group)
    pub group: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_in_game_prediction::ERandomSelectionGroup_t>>,
    // @@protoc_insertion_point(field:CMsgInGamePrediction.question)
    pub question: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgInGamePrediction.choices)
    pub choices: ::std::vec::Vec<CMsgPredictionChoice>,
    // @@protoc_insertion_point(field:CMsgInGamePrediction.required_heroes)
    pub required_heroes: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgInGamePrediction.query_name)
    pub query_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgInGamePrediction.query_values)
    pub query_values: ::std::vec::Vec<cmsg_in_game_prediction::QueryKeyValues>,
    // @@protoc_insertion_point(field:CMsgInGamePrediction.answer_resolution_type)
    pub answer_resolution_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_in_game_prediction::EResolutionType_t>>,
    // @@protoc_insertion_point(field:CMsgInGamePrediction.points_to_grant)
    pub points_to_grant: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgInGamePrediction.reward_action)
    pub reward_action: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgInGamePrediction.debug_force_selection)
    pub debug_force_selection: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgInGamePrediction.raw_value_type)
    pub raw_value_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_in_game_prediction::ERawValueType_t>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgInGamePrediction.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgInGamePrediction {
    fn default() -> &'a CMsgInGamePrediction {
        <CMsgInGamePrediction as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgInGamePrediction {
    pub fn new() -> CMsgInGamePrediction {
        ::std::default::Default::default()
    }

    // optional uint32 id = 1;

    pub fn id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CMsgInGamePrediction.EPredictionType type = 3;

    pub fn type_(&self) -> cmsg_in_game_prediction::EPredictionType {
        match self.type_ {
            Some(e) => e.enum_value_or(cmsg_in_game_prediction::EPredictionType::Generic),
            None => cmsg_in_game_prediction::EPredictionType::Generic,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: cmsg_in_game_prediction::EPredictionType) {
        self.type_ = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .CMsgInGamePrediction.ERandomSelectionGroup_t group = 4;

    pub fn group(&self) -> cmsg_in_game_prediction::ERandomSelectionGroup_t {
        match self.group {
            Some(e) => e.enum_value_or(cmsg_in_game_prediction::ERandomSelectionGroup_t::EarlyGame),
            None => cmsg_in_game_prediction::ERandomSelectionGroup_t::EarlyGame,
        }
    }

    pub fn clear_group(&mut self) {
        self.group = ::std::option::Option::None;
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: cmsg_in_game_prediction::ERandomSelectionGroup_t) {
        self.group = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string question = 5;

    pub fn question(&self) -> &str {
        match self.question.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_question(&mut self) {
        self.question = ::std::option::Option::None;
    }

    pub fn has_question(&self) -> bool {
        self.question.is_some()
    }

    // Param is passed by value, moved
    pub fn set_question(&mut self, v: ::std::string::String) {
        self.question = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_question(&mut self) -> &mut ::std::string::String {
        if self.question.is_none() {
            self.question = ::std::option::Option::Some(::std::string::String::new());
        }
        self.question.as_mut().unwrap()
    }

    // Take field
    pub fn take_question(&mut self) -> ::std::string::String {
        self.question.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string query_name = 8;

    pub fn query_name(&self) -> &str {
        match self.query_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_query_name(&mut self) {
        self.query_name = ::std::option::Option::None;
    }

    pub fn has_query_name(&self) -> bool {
        self.query_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query_name(&mut self, v: ::std::string::String) {
        self.query_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query_name(&mut self) -> &mut ::std::string::String {
        if self.query_name.is_none() {
            self.query_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.query_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_query_name(&mut self) -> ::std::string::String {
        self.query_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CMsgInGamePrediction.EResolutionType_t answer_resolution_type = 10;

    pub fn answer_resolution_type(&self) -> cmsg_in_game_prediction::EResolutionType_t {
        match self.answer_resolution_type {
            Some(e) => e.enum_value_or(cmsg_in_game_prediction::EResolutionType_t::InvalidQuery),
            None => cmsg_in_game_prediction::EResolutionType_t::InvalidQuery,
        }
    }

    pub fn clear_answer_resolution_type(&mut self) {
        self.answer_resolution_type = ::std::option::Option::None;
    }

    pub fn has_answer_resolution_type(&self) -> bool {
        self.answer_resolution_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer_resolution_type(&mut self, v: cmsg_in_game_prediction::EResolutionType_t) {
        self.answer_resolution_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 points_to_grant = 11;

    pub fn points_to_grant(&self) -> u32 {
        self.points_to_grant.unwrap_or(0)
    }

    pub fn clear_points_to_grant(&mut self) {
        self.points_to_grant = ::std::option::Option::None;
    }

    pub fn has_points_to_grant(&self) -> bool {
        self.points_to_grant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_to_grant(&mut self, v: u32) {
        self.points_to_grant = ::std::option::Option::Some(v);
    }

    // optional uint32 reward_action = 12;

    pub fn reward_action(&self) -> u32 {
        self.reward_action.unwrap_or(0)
    }

    pub fn clear_reward_action(&mut self) {
        self.reward_action = ::std::option::Option::None;
    }

    pub fn has_reward_action(&self) -> bool {
        self.reward_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_action(&mut self, v: u32) {
        self.reward_action = ::std::option::Option::Some(v);
    }

    // optional uint32 debug_force_selection = 13;

    pub fn debug_force_selection(&self) -> u32 {
        self.debug_force_selection.unwrap_or(0)
    }

    pub fn clear_debug_force_selection(&mut self) {
        self.debug_force_selection = ::std::option::Option::None;
    }

    pub fn has_debug_force_selection(&self) -> bool {
        self.debug_force_selection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_force_selection(&mut self, v: u32) {
        self.debug_force_selection = ::std::option::Option::Some(v);
    }

    // optional .CMsgInGamePrediction.ERawValueType_t raw_value_type = 14;

    pub fn raw_value_type(&self) -> cmsg_in_game_prediction::ERawValueType_t {
        match self.raw_value_type {
            Some(e) => e.enum_value_or(cmsg_in_game_prediction::ERawValueType_t::Number),
            None => cmsg_in_game_prediction::ERawValueType_t::Number,
        }
    }

    pub fn clear_raw_value_type(&mut self) {
        self.raw_value_type = ::std::option::Option::None;
    }

    pub fn has_raw_value_type(&self) -> bool {
        self.raw_value_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_value_type(&mut self, v: cmsg_in_game_prediction::ERawValueType_t) {
        self.raw_value_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgInGamePrediction {
    const NAME: &'static str = "CMsgInGamePrediction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.group = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.question = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.choices.push(is.read_message()?);
                },
                58 => {
                    self.required_heroes.push(is.read_string()?);
                },
                66 => {
                    self.query_name = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.query_values.push(is.read_message()?);
                },
                80 => {
                    self.answer_resolution_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                88 => {
                    self.points_to_grant = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.reward_action = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.debug_force_selection = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.raw_value_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.group {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.question.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        for value in &self.choices {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.required_heroes {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.query_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(8, &v);
        }
        for value in &self.query_values {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.answer_resolution_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.points_to_grant {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.reward_action {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.debug_force_selection {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.raw_value_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(14, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.group {
            os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.question.as_ref() {
            os.write_string(5, v)?;
        }
        for v in &self.choices {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.required_heroes {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.query_name.as_ref() {
            os.write_string(8, v)?;
        }
        for v in &self.query_values {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.answer_resolution_type {
            os.write_enum(10, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.points_to_grant {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.reward_action {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.debug_force_selection {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.raw_value_type {
            os.write_enum(14, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgInGamePrediction {
        CMsgInGamePrediction::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.group = ::std::option::Option::None;
        self.question = ::std::option::Option::None;
        self.choices.clear();
        self.required_heroes.clear();
        self.query_name = ::std::option::Option::None;
        self.query_values.clear();
        self.answer_resolution_type = ::std::option::Option::None;
        self.points_to_grant = ::std::option::Option::None;
        self.reward_action = ::std::option::Option::None;
        self.debug_force_selection = ::std::option::Option::None;
        self.raw_value_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgInGamePrediction {
        static instance: CMsgInGamePrediction = CMsgInGamePrediction {
            id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            group: ::std::option::Option::None,
            question: ::std::option::Option::None,
            choices: ::std::vec::Vec::new(),
            required_heroes: ::std::vec::Vec::new(),
            query_name: ::std::option::Option::None,
            query_values: ::std::vec::Vec::new(),
            answer_resolution_type: ::std::option::Option::None,
            points_to_grant: ::std::option::Option::None,
            reward_action: ::std::option::Option::None,
            debug_force_selection: ::std::option::Option::None,
            raw_value_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgInGamePrediction`
pub mod cmsg_in_game_prediction {
    // @@protoc_insertion_point(message:CMsgInGamePrediction.QueryKeyValues)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct QueryKeyValues {
        // message fields
        // @@protoc_insertion_point(field:CMsgInGamePrediction.QueryKeyValues.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgInGamePrediction.QueryKeyValues.value)
        pub value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgInGamePrediction.QueryKeyValues.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a QueryKeyValues {
        fn default() -> &'a QueryKeyValues {
            <QueryKeyValues as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl QueryKeyValues {
        pub fn new() -> QueryKeyValues {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for QueryKeyValues {
        const NAME: &'static str = "QueryKeyValues";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> QueryKeyValues {
            QueryKeyValues::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static QueryKeyValues {
            static instance: QueryKeyValues = QueryKeyValues {
                name: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgInGamePrediction.ERawValueType_t)
    pub enum ERawValueType_t {
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.ERawValueType_t.Number)
        Number = 0,
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.ERawValueType_t.Time)
        Time = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for ERawValueType_t {
        const NAME: &'static str = "ERawValueType_t";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ERawValueType_t> {
            match value {
                0 => ::std::option::Option::Some(ERawValueType_t::Number),
                1 => ::std::option::Option::Some(ERawValueType_t::Time),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ERawValueType_t> {
            match str {
                "Number" => ::std::option::Option::Some(ERawValueType_t::Number),
                "Time" => ::std::option::Option::Some(ERawValueType_t::Time),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ERawValueType_t] = &[
            ERawValueType_t::Number,
            ERawValueType_t::Time,
        ];
    }

    impl ::std::default::Default for ERawValueType_t {
        fn default() -> Self {
            ERawValueType_t::Number
        }
    }


    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgInGamePrediction.EPredictionType)
    pub enum EPredictionType {
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.EPredictionType.Generic)
        Generic = 0,
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.EPredictionType.Hero)
        Hero = 1,
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.EPredictionType.Team)
        Team = 2,
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.EPredictionType.Player)
        Player = 3,
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.EPredictionType.Special)
        Special = 4,
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.EPredictionType.YesNo)
        YesNo = 5,
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.EPredictionType.QualifiersTeam)
        QualifiersTeam = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EPredictionType {
        const NAME: &'static str = "EPredictionType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EPredictionType> {
            match value {
                0 => ::std::option::Option::Some(EPredictionType::Generic),
                1 => ::std::option::Option::Some(EPredictionType::Hero),
                2 => ::std::option::Option::Some(EPredictionType::Team),
                3 => ::std::option::Option::Some(EPredictionType::Player),
                4 => ::std::option::Option::Some(EPredictionType::Special),
                5 => ::std::option::Option::Some(EPredictionType::YesNo),
                6 => ::std::option::Option::Some(EPredictionType::QualifiersTeam),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EPredictionType> {
            match str {
                "Generic" => ::std::option::Option::Some(EPredictionType::Generic),
                "Hero" => ::std::option::Option::Some(EPredictionType::Hero),
                "Team" => ::std::option::Option::Some(EPredictionType::Team),
                "Player" => ::std::option::Option::Some(EPredictionType::Player),
                "Special" => ::std::option::Option::Some(EPredictionType::Special),
                "YesNo" => ::std::option::Option::Some(EPredictionType::YesNo),
                "QualifiersTeam" => ::std::option::Option::Some(EPredictionType::QualifiersTeam),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EPredictionType] = &[
            EPredictionType::Generic,
            EPredictionType::Hero,
            EPredictionType::Team,
            EPredictionType::Player,
            EPredictionType::Special,
            EPredictionType::YesNo,
            EPredictionType::QualifiersTeam,
        ];
    }

    impl ::std::default::Default for EPredictionType {
        fn default() -> Self {
            EPredictionType::Generic
        }
    }


    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgInGamePrediction.EResolutionType_t)
    pub enum EResolutionType_t {
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.EResolutionType_t.InvalidQuery)
        InvalidQuery = 0,
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.EResolutionType_t.FirstToPassQuery)
        FirstToPassQuery = 1,
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.EResolutionType_t.LastToPassQuery)
        LastToPassQuery = 2,
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.EResolutionType_t.LastRemainingQuery)
        LastRemainingQuery = 3,
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.EResolutionType_t.MaxToPassQuery)
        MaxToPassQuery = 4,
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.EResolutionType_t.MinToPassQuery)
        MinToPassQuery = 5,
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.EResolutionType_t.SumQuery)
        SumQuery = 6,
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.EResolutionType_t.MaxTeamSumToPassQuery)
        MaxTeamSumToPassQuery = 7,
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.EResolutionType_t.MinTeamSumToPassQuery)
        MinTeamSumToPassQuery = 8,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResolutionType_t {
        const NAME: &'static str = "EResolutionType_t";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResolutionType_t> {
            match value {
                0 => ::std::option::Option::Some(EResolutionType_t::InvalidQuery),
                1 => ::std::option::Option::Some(EResolutionType_t::FirstToPassQuery),
                2 => ::std::option::Option::Some(EResolutionType_t::LastToPassQuery),
                3 => ::std::option::Option::Some(EResolutionType_t::LastRemainingQuery),
                4 => ::std::option::Option::Some(EResolutionType_t::MaxToPassQuery),
                5 => ::std::option::Option::Some(EResolutionType_t::MinToPassQuery),
                6 => ::std::option::Option::Some(EResolutionType_t::SumQuery),
                7 => ::std::option::Option::Some(EResolutionType_t::MaxTeamSumToPassQuery),
                8 => ::std::option::Option::Some(EResolutionType_t::MinTeamSumToPassQuery),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResolutionType_t> {
            match str {
                "InvalidQuery" => ::std::option::Option::Some(EResolutionType_t::InvalidQuery),
                "FirstToPassQuery" => ::std::option::Option::Some(EResolutionType_t::FirstToPassQuery),
                "LastToPassQuery" => ::std::option::Option::Some(EResolutionType_t::LastToPassQuery),
                "LastRemainingQuery" => ::std::option::Option::Some(EResolutionType_t::LastRemainingQuery),
                "MaxToPassQuery" => ::std::option::Option::Some(EResolutionType_t::MaxToPassQuery),
                "MinToPassQuery" => ::std::option::Option::Some(EResolutionType_t::MinToPassQuery),
                "SumQuery" => ::std::option::Option::Some(EResolutionType_t::SumQuery),
                "MaxTeamSumToPassQuery" => ::std::option::Option::Some(EResolutionType_t::MaxTeamSumToPassQuery),
                "MinTeamSumToPassQuery" => ::std::option::Option::Some(EResolutionType_t::MinTeamSumToPassQuery),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResolutionType_t] = &[
            EResolutionType_t::InvalidQuery,
            EResolutionType_t::FirstToPassQuery,
            EResolutionType_t::LastToPassQuery,
            EResolutionType_t::LastRemainingQuery,
            EResolutionType_t::MaxToPassQuery,
            EResolutionType_t::MinToPassQuery,
            EResolutionType_t::SumQuery,
            EResolutionType_t::MaxTeamSumToPassQuery,
            EResolutionType_t::MinTeamSumToPassQuery,
        ];
    }

    impl ::std::default::Default for EResolutionType_t {
        fn default() -> Self {
            EResolutionType_t::InvalidQuery
        }
    }


    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgInGamePrediction.ERandomSelectionGroup_t)
    pub enum ERandomSelectionGroup_t {
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.ERandomSelectionGroup_t.EarlyGame)
        EarlyGame = 0,
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.ERandomSelectionGroup_t.MidGame)
        MidGame = 1,
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.ERandomSelectionGroup_t.LateGame)
        LateGame = 2,
        // @@protoc_insertion_point(enum_value:CMsgInGamePrediction.ERandomSelectionGroup_t.Count)
        Count = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for ERandomSelectionGroup_t {
        const NAME: &'static str = "ERandomSelectionGroup_t";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ERandomSelectionGroup_t> {
            match value {
                0 => ::std::option::Option::Some(ERandomSelectionGroup_t::EarlyGame),
                1 => ::std::option::Option::Some(ERandomSelectionGroup_t::MidGame),
                2 => ::std::option::Option::Some(ERandomSelectionGroup_t::LateGame),
                3 => ::std::option::Option::Some(ERandomSelectionGroup_t::Count),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ERandomSelectionGroup_t> {
            match str {
                "EarlyGame" => ::std::option::Option::Some(ERandomSelectionGroup_t::EarlyGame),
                "MidGame" => ::std::option::Option::Some(ERandomSelectionGroup_t::MidGame),
                "LateGame" => ::std::option::Option::Some(ERandomSelectionGroup_t::LateGame),
                "Count" => ::std::option::Option::Some(ERandomSelectionGroup_t::Count),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ERandomSelectionGroup_t] = &[
            ERandomSelectionGroup_t::EarlyGame,
            ERandomSelectionGroup_t::MidGame,
            ERandomSelectionGroup_t::LateGame,
            ERandomSelectionGroup_t::Count,
        ];
    }

    impl ::std::default::Default for ERandomSelectionGroup_t {
        fn default() -> Self {
            ERandomSelectionGroup_t::EarlyGame
        }
    }

}

// @@protoc_insertion_point(message:CMsgDOTASeasonPredictions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASeasonPredictions {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.predictions)
    pub predictions: ::std::vec::Vec<cmsg_dotaseason_predictions::Prediction>,
    // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.in_game_predictions)
    pub in_game_predictions: ::std::vec::Vec<CMsgInGamePrediction>,
    // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.in_game_prediction_count_per_game)
    pub in_game_prediction_count_per_game: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.in_game_prediction_voting_period_minutes)
    pub in_game_prediction_voting_period_minutes: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTASeasonPredictions.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASeasonPredictions {
    fn default() -> &'a CMsgDOTASeasonPredictions {
        <CMsgDOTASeasonPredictions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASeasonPredictions {
    pub fn new() -> CMsgDOTASeasonPredictions {
        ::std::default::Default::default()
    }

    // optional uint32 in_game_prediction_count_per_game = 3;

    pub fn in_game_prediction_count_per_game(&self) -> u32 {
        self.in_game_prediction_count_per_game.unwrap_or(0)
    }

    pub fn clear_in_game_prediction_count_per_game(&mut self) {
        self.in_game_prediction_count_per_game = ::std::option::Option::None;
    }

    pub fn has_in_game_prediction_count_per_game(&self) -> bool {
        self.in_game_prediction_count_per_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_game_prediction_count_per_game(&mut self, v: u32) {
        self.in_game_prediction_count_per_game = ::std::option::Option::Some(v);
    }

    // optional uint32 in_game_prediction_voting_period_minutes = 4;

    pub fn in_game_prediction_voting_period_minutes(&self) -> u32 {
        self.in_game_prediction_voting_period_minutes.unwrap_or(0)
    }

    pub fn clear_in_game_prediction_voting_period_minutes(&mut self) {
        self.in_game_prediction_voting_period_minutes = ::std::option::Option::None;
    }

    pub fn has_in_game_prediction_voting_period_minutes(&self) -> bool {
        self.in_game_prediction_voting_period_minutes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_game_prediction_voting_period_minutes(&mut self, v: u32) {
        self.in_game_prediction_voting_period_minutes = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTASeasonPredictions {
    const NAME: &'static str = "CMsgDOTASeasonPredictions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.predictions.push(is.read_message()?);
                },
                18 => {
                    self.in_game_predictions.push(is.read_message()?);
                },
                24 => {
                    self.in_game_prediction_count_per_game = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.in_game_prediction_voting_period_minutes = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.predictions {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.in_game_predictions {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.in_game_prediction_count_per_game {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.in_game_prediction_voting_period_minutes {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.predictions {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.in_game_predictions {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.in_game_prediction_count_per_game {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.in_game_prediction_voting_period_minutes {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASeasonPredictions {
        CMsgDOTASeasonPredictions::new()
    }

    fn clear(&mut self) {
        self.predictions.clear();
        self.in_game_predictions.clear();
        self.in_game_prediction_count_per_game = ::std::option::Option::None;
        self.in_game_prediction_voting_period_minutes = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASeasonPredictions {
        static instance: CMsgDOTASeasonPredictions = CMsgDOTASeasonPredictions {
            predictions: ::std::vec::Vec::new(),
            in_game_predictions: ::std::vec::Vec::new(),
            in_game_prediction_count_per_game: ::std::option::Option::None,
            in_game_prediction_voting_period_minutes: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTASeasonPredictions`
pub mod cmsg_dotaseason_predictions {
    // @@protoc_insertion_point(message:CMsgDOTASeasonPredictions.Prediction)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Prediction {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.Prediction.type)
        pub type_: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<prediction::EPredictionType>>,
        // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.Prediction.question)
        pub question: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.Prediction.choices)
        pub choices: ::std::vec::Vec<super::CMsgPredictionChoice>,
        // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.Prediction.selection_id)
        pub selection_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.Prediction.start_date)
        pub start_date: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.Prediction.lock_date)
        pub lock_date: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.Prediction.reward)
        pub reward: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.Prediction.answer_type)
        pub answer_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<prediction::EAnswerType>>,
        // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.Prediction.answer_id)
        pub answer_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.Prediction.answers)
        pub answers: ::std::vec::Vec<prediction::Answers>,
        // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.Prediction.query_name)
        pub query_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.Prediction.lock_on_selection_id)
        pub lock_on_selection_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.Prediction.lock_on_selection_value)
        pub lock_on_selection_value: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.Prediction.lock_on_selection_set)
        pub lock_on_selection_set: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.Prediction.use_answer_value_ranges)
        pub use_answer_value_ranges: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.Prediction.region)
        pub region: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeagueRegion>>,
        // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.Prediction.phases)
        pub phases: ::std::vec::Vec<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeaguePhase>>,
        // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.Prediction.reward_event)
        pub reward_event: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::EEvent>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTASeasonPredictions.Prediction.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Prediction {
        fn default() -> &'a Prediction {
            <Prediction as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Prediction {
        pub fn new() -> Prediction {
            ::std::default::Default::default()
        }

        // optional .CMsgDOTASeasonPredictions.Prediction.EPredictionType type = 1;

        pub fn type_(&self) -> prediction::EPredictionType {
            match self.type_ {
                Some(e) => e.enum_value_or(prediction::EPredictionType::Generic),
                None => prediction::EPredictionType::Generic,
            }
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: prediction::EPredictionType) {
            self.type_ = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional string question = 2;

        pub fn question(&self) -> &str {
            match self.question.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_question(&mut self) {
            self.question = ::std::option::Option::None;
        }

        pub fn has_question(&self) -> bool {
            self.question.is_some()
        }

        // Param is passed by value, moved
        pub fn set_question(&mut self, v: ::std::string::String) {
            self.question = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_question(&mut self) -> &mut ::std::string::String {
            if self.question.is_none() {
                self.question = ::std::option::Option::Some(::std::string::String::new());
            }
            self.question.as_mut().unwrap()
        }

        // Take field
        pub fn take_question(&mut self) -> ::std::string::String {
            self.question.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 selection_id = 4;

        pub fn selection_id(&self) -> u32 {
            self.selection_id.unwrap_or(0)
        }

        pub fn clear_selection_id(&mut self) {
            self.selection_id = ::std::option::Option::None;
        }

        pub fn has_selection_id(&self) -> bool {
            self.selection_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_selection_id(&mut self, v: u32) {
            self.selection_id = ::std::option::Option::Some(v);
        }

        // optional uint32 start_date = 5;

        pub fn start_date(&self) -> u32 {
            self.start_date.unwrap_or(0)
        }

        pub fn clear_start_date(&mut self) {
            self.start_date = ::std::option::Option::None;
        }

        pub fn has_start_date(&self) -> bool {
            self.start_date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_date(&mut self, v: u32) {
            self.start_date = ::std::option::Option::Some(v);
        }

        // optional uint32 lock_date = 6;

        pub fn lock_date(&self) -> u32 {
            self.lock_date.unwrap_or(0)
        }

        pub fn clear_lock_date(&mut self) {
            self.lock_date = ::std::option::Option::None;
        }

        pub fn has_lock_date(&self) -> bool {
            self.lock_date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lock_date(&mut self, v: u32) {
            self.lock_date = ::std::option::Option::Some(v);
        }

        // optional uint32 reward = 7;

        pub fn reward(&self) -> u32 {
            self.reward.unwrap_or(0)
        }

        pub fn clear_reward(&mut self) {
            self.reward = ::std::option::Option::None;
        }

        pub fn has_reward(&self) -> bool {
            self.reward.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reward(&mut self, v: u32) {
            self.reward = ::std::option::Option::Some(v);
        }

        // optional .CMsgDOTASeasonPredictions.Prediction.EAnswerType answer_type = 8;

        pub fn answer_type(&self) -> prediction::EAnswerType {
            match self.answer_type {
                Some(e) => e.enum_value_or(prediction::EAnswerType::SingleInt),
                None => prediction::EAnswerType::SingleInt,
            }
        }

        pub fn clear_answer_type(&mut self) {
            self.answer_type = ::std::option::Option::None;
        }

        pub fn has_answer_type(&self) -> bool {
            self.answer_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_answer_type(&mut self, v: prediction::EAnswerType) {
            self.answer_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 answer_id = 9;

        pub fn answer_id(&self) -> u32 {
            self.answer_id.unwrap_or(0)
        }

        pub fn clear_answer_id(&mut self) {
            self.answer_id = ::std::option::Option::None;
        }

        pub fn has_answer_id(&self) -> bool {
            self.answer_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_answer_id(&mut self, v: u32) {
            self.answer_id = ::std::option::Option::Some(v);
        }

        // optional string query_name = 11;

        pub fn query_name(&self) -> &str {
            match self.query_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_query_name(&mut self) {
            self.query_name = ::std::option::Option::None;
        }

        pub fn has_query_name(&self) -> bool {
            self.query_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_query_name(&mut self, v: ::std::string::String) {
            self.query_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_query_name(&mut self) -> &mut ::std::string::String {
            if self.query_name.is_none() {
                self.query_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.query_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_query_name(&mut self) -> ::std::string::String {
            self.query_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 lock_on_selection_id = 13;

        pub fn lock_on_selection_id(&self) -> u32 {
            self.lock_on_selection_id.unwrap_or(0)
        }

        pub fn clear_lock_on_selection_id(&mut self) {
            self.lock_on_selection_id = ::std::option::Option::None;
        }

        pub fn has_lock_on_selection_id(&self) -> bool {
            self.lock_on_selection_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lock_on_selection_id(&mut self, v: u32) {
            self.lock_on_selection_id = ::std::option::Option::Some(v);
        }

        // optional uint32 lock_on_selection_value = 14;

        pub fn lock_on_selection_value(&self) -> u32 {
            self.lock_on_selection_value.unwrap_or(0)
        }

        pub fn clear_lock_on_selection_value(&mut self) {
            self.lock_on_selection_value = ::std::option::Option::None;
        }

        pub fn has_lock_on_selection_value(&self) -> bool {
            self.lock_on_selection_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lock_on_selection_value(&mut self, v: u32) {
            self.lock_on_selection_value = ::std::option::Option::Some(v);
        }

        // optional bool lock_on_selection_set = 15;

        pub fn lock_on_selection_set(&self) -> bool {
            self.lock_on_selection_set.unwrap_or(false)
        }

        pub fn clear_lock_on_selection_set(&mut self) {
            self.lock_on_selection_set = ::std::option::Option::None;
        }

        pub fn has_lock_on_selection_set(&self) -> bool {
            self.lock_on_selection_set.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lock_on_selection_set(&mut self, v: bool) {
            self.lock_on_selection_set = ::std::option::Option::Some(v);
        }

        // optional bool use_answer_value_ranges = 16;

        pub fn use_answer_value_ranges(&self) -> bool {
            self.use_answer_value_ranges.unwrap_or(false)
        }

        pub fn clear_use_answer_value_ranges(&mut self) {
            self.use_answer_value_ranges = ::std::option::Option::None;
        }

        pub fn has_use_answer_value_ranges(&self) -> bool {
            self.use_answer_value_ranges.is_some()
        }

        // Param is passed by value, moved
        pub fn set_use_answer_value_ranges(&mut self, v: bool) {
            self.use_answer_value_ranges = ::std::option::Option::Some(v);
        }

        // optional .ELeagueRegion region = 17;

        pub fn region(&self) -> super::super::dota_shared_enums::ELeagueRegion {
            match self.region {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET),
                None => super::super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET,
            }
        }

        pub fn clear_region(&mut self) {
            self.region = ::std::option::Option::None;
        }

        pub fn has_region(&self) -> bool {
            self.region.is_some()
        }

        // Param is passed by value, moved
        pub fn set_region(&mut self, v: super::super::dota_shared_enums::ELeagueRegion) {
            self.region = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional .EEvent reward_event = 19;

        pub fn reward_event(&self) -> super::super::dota_shared_enums::EEvent {
            match self.reward_event {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::EEvent::EVENT_ID_NONE),
                None => super::super::dota_shared_enums::EEvent::EVENT_ID_NONE,
            }
        }

        pub fn clear_reward_event(&mut self) {
            self.reward_event = ::std::option::Option::None;
        }

        pub fn has_reward_event(&self) -> bool {
            self.reward_event.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reward_event(&mut self, v: super::super::dota_shared_enums::EEvent) {
            self.reward_event = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Prediction {
        const NAME: &'static str = "Prediction";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    18 => {
                        self.question = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.choices.push(is.read_message()?);
                    },
                    32 => {
                        self.selection_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.start_date = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.lock_date = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.reward = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.answer_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    72 => {
                        self.answer_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    82 => {
                        self.answers.push(is.read_message()?);
                    },
                    90 => {
                        self.query_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    104 => {
                        self.lock_on_selection_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.lock_on_selection_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    120 => {
                        self.lock_on_selection_set = ::std::option::Option::Some(is.read_bool()?);
                    },
                    128 => {
                        self.use_answer_value_ranges = ::std::option::Option::Some(is.read_bool()?);
                    },
                    136 => {
                        self.region = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    144 => {
                        self.phases.push(is.read_enum_or_unknown()?);
                    },
                    146 => {
                        ::steam_vent_proto_common::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.phases)?
                    },
                    152 => {
                        self.reward_event = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.question.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            for value in &self.choices {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.selection_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.start_date {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.lock_date {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.reward {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.answer_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v.value());
            }
            if let Some(v) = self.answer_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            for value in &self.answers {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.query_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(11, &v);
            }
            if let Some(v) = self.lock_on_selection_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.lock_on_selection_value {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
            }
            if let Some(v) = self.lock_on_selection_set {
                my_size += 1 + 1;
            }
            if let Some(v) = self.use_answer_value_ranges {
                my_size += 2 + 1;
            }
            if let Some(v) = self.region {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(17, v.value());
            }
            for value in &self.phases {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(18, value.value());
            };
            if let Some(v) = self.reward_event {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(19, v.value());
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.question.as_ref() {
                os.write_string(2, v)?;
            }
            for v in &self.choices {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            if let Some(v) = self.selection_id {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.start_date {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.lock_date {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.reward {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.answer_type {
                os.write_enum(8, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.answer_id {
                os.write_uint32(9, v)?;
            }
            for v in &self.answers {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
            };
            if let Some(v) = self.query_name.as_ref() {
                os.write_string(11, v)?;
            }
            if let Some(v) = self.lock_on_selection_id {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.lock_on_selection_value {
                os.write_uint32(14, v)?;
            }
            if let Some(v) = self.lock_on_selection_set {
                os.write_bool(15, v)?;
            }
            if let Some(v) = self.use_answer_value_ranges {
                os.write_bool(16, v)?;
            }
            if let Some(v) = self.region {
                os.write_enum(17, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            for v in &self.phases {
                os.write_enum(18, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(v))?;
            };
            if let Some(v) = self.reward_event {
                os.write_enum(19, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Prediction {
            Prediction::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.question = ::std::option::Option::None;
            self.choices.clear();
            self.selection_id = ::std::option::Option::None;
            self.start_date = ::std::option::Option::None;
            self.lock_date = ::std::option::Option::None;
            self.reward = ::std::option::Option::None;
            self.answer_type = ::std::option::Option::None;
            self.answer_id = ::std::option::Option::None;
            self.answers.clear();
            self.query_name = ::std::option::Option::None;
            self.lock_on_selection_id = ::std::option::Option::None;
            self.lock_on_selection_value = ::std::option::Option::None;
            self.lock_on_selection_set = ::std::option::Option::None;
            self.use_answer_value_ranges = ::std::option::Option::None;
            self.region = ::std::option::Option::None;
            self.phases.clear();
            self.reward_event = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Prediction {
            static instance: Prediction = Prediction {
                type_: ::std::option::Option::None,
                question: ::std::option::Option::None,
                choices: ::std::vec::Vec::new(),
                selection_id: ::std::option::Option::None,
                start_date: ::std::option::Option::None,
                lock_date: ::std::option::Option::None,
                reward: ::std::option::Option::None,
                answer_type: ::std::option::Option::None,
                answer_id: ::std::option::Option::None,
                answers: ::std::vec::Vec::new(),
                query_name: ::std::option::Option::None,
                lock_on_selection_id: ::std::option::Option::None,
                lock_on_selection_value: ::std::option::Option::None,
                lock_on_selection_set: ::std::option::Option::None,
                use_answer_value_ranges: ::std::option::Option::None,
                region: ::std::option::Option::None,
                phases: ::std::vec::Vec::new(),
                reward_event: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Prediction`
    pub mod prediction {
        // @@protoc_insertion_point(message:CMsgDOTASeasonPredictions.Prediction.Answers)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Answers {
            // message fields
            // @@protoc_insertion_point(field:CMsgDOTASeasonPredictions.Prediction.Answers.answer_id)
            pub answer_id: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgDOTASeasonPredictions.Prediction.Answers.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Answers {
            fn default() -> &'a Answers {
                <Answers as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl Answers {
            pub fn new() -> Answers {
                ::std::default::Default::default()
            }

            // optional uint32 answer_id = 1;

            pub fn answer_id(&self) -> u32 {
                self.answer_id.unwrap_or(0)
            }

            pub fn clear_answer_id(&mut self) {
                self.answer_id = ::std::option::Option::None;
            }

            pub fn has_answer_id(&self) -> bool {
                self.answer_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_answer_id(&mut self, v: u32) {
                self.answer_id = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for Answers {
            const NAME: &'static str = "Answers";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.answer_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.answer_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.answer_id {
                    os.write_uint32(1, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Answers {
                Answers::new()
            }

            fn clear(&mut self) {
                self.answer_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Answers {
                static instance: Answers = Answers {
                    answer_id: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:CMsgDOTASeasonPredictions.Prediction.EPredictionType)
        pub enum EPredictionType {
            // @@protoc_insertion_point(enum_value:CMsgDOTASeasonPredictions.Prediction.EPredictionType.Generic)
            Generic = 0,
            // @@protoc_insertion_point(enum_value:CMsgDOTASeasonPredictions.Prediction.EPredictionType.Hero)
            Hero = 1,
            // @@protoc_insertion_point(enum_value:CMsgDOTASeasonPredictions.Prediction.EPredictionType.Team)
            Team = 2,
            // @@protoc_insertion_point(enum_value:CMsgDOTASeasonPredictions.Prediction.EPredictionType.Player)
            Player = 3,
            // @@protoc_insertion_point(enum_value:CMsgDOTASeasonPredictions.Prediction.EPredictionType.Special)
            Special = 4,
            // @@protoc_insertion_point(enum_value:CMsgDOTASeasonPredictions.Prediction.EPredictionType.YesNo)
            YesNo = 5,
            // @@protoc_insertion_point(enum_value:CMsgDOTASeasonPredictions.Prediction.EPredictionType.QualifiersTeam)
            QualifiersTeam = 6,
            // @@protoc_insertion_point(enum_value:CMsgDOTASeasonPredictions.Prediction.EPredictionType.LastChanceTeam)
            LastChanceTeam = 7,
        }

        impl ::steam_vent_proto_common::protobuf::Enum for EPredictionType {
            const NAME: &'static str = "EPredictionType";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<EPredictionType> {
                match value {
                    0 => ::std::option::Option::Some(EPredictionType::Generic),
                    1 => ::std::option::Option::Some(EPredictionType::Hero),
                    2 => ::std::option::Option::Some(EPredictionType::Team),
                    3 => ::std::option::Option::Some(EPredictionType::Player),
                    4 => ::std::option::Option::Some(EPredictionType::Special),
                    5 => ::std::option::Option::Some(EPredictionType::YesNo),
                    6 => ::std::option::Option::Some(EPredictionType::QualifiersTeam),
                    7 => ::std::option::Option::Some(EPredictionType::LastChanceTeam),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<EPredictionType> {
                match str {
                    "Generic" => ::std::option::Option::Some(EPredictionType::Generic),
                    "Hero" => ::std::option::Option::Some(EPredictionType::Hero),
                    "Team" => ::std::option::Option::Some(EPredictionType::Team),
                    "Player" => ::std::option::Option::Some(EPredictionType::Player),
                    "Special" => ::std::option::Option::Some(EPredictionType::Special),
                    "YesNo" => ::std::option::Option::Some(EPredictionType::YesNo),
                    "QualifiersTeam" => ::std::option::Option::Some(EPredictionType::QualifiersTeam),
                    "LastChanceTeam" => ::std::option::Option::Some(EPredictionType::LastChanceTeam),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [EPredictionType] = &[
                EPredictionType::Generic,
                EPredictionType::Hero,
                EPredictionType::Team,
                EPredictionType::Player,
                EPredictionType::Special,
                EPredictionType::YesNo,
                EPredictionType::QualifiersTeam,
                EPredictionType::LastChanceTeam,
            ];
        }

        impl ::std::default::Default for EPredictionType {
            fn default() -> Self {
                EPredictionType::Generic
            }
        }


        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:CMsgDOTASeasonPredictions.Prediction.EAnswerType)
        pub enum EAnswerType {
            // @@protoc_insertion_point(enum_value:CMsgDOTASeasonPredictions.Prediction.EAnswerType.SingleInt)
            SingleInt = 0,
            // @@protoc_insertion_point(enum_value:CMsgDOTASeasonPredictions.Prediction.EAnswerType.SingleFloat)
            SingleFloat = 1,
            // @@protoc_insertion_point(enum_value:CMsgDOTASeasonPredictions.Prediction.EAnswerType.MultipleInt)
            MultipleInt = 2,
            // @@protoc_insertion_point(enum_value:CMsgDOTASeasonPredictions.Prediction.EAnswerType.MultipleFloat)
            MultipleFloat = 3,
            // @@protoc_insertion_point(enum_value:CMsgDOTASeasonPredictions.Prediction.EAnswerType.AnswerTeam)
            AnswerTeam = 4,
            // @@protoc_insertion_point(enum_value:CMsgDOTASeasonPredictions.Prediction.EAnswerType.SingleTime)
            SingleTime = 5,
            // @@protoc_insertion_point(enum_value:CMsgDOTASeasonPredictions.Prediction.EAnswerType.MultipleTime)
            MultipleTime = 6,
            // @@protoc_insertion_point(enum_value:CMsgDOTASeasonPredictions.Prediction.EAnswerType.NoAnswer)
            NoAnswer = 7,
        }

        impl ::steam_vent_proto_common::protobuf::Enum for EAnswerType {
            const NAME: &'static str = "EAnswerType";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<EAnswerType> {
                match value {
                    0 => ::std::option::Option::Some(EAnswerType::SingleInt),
                    1 => ::std::option::Option::Some(EAnswerType::SingleFloat),
                    2 => ::std::option::Option::Some(EAnswerType::MultipleInt),
                    3 => ::std::option::Option::Some(EAnswerType::MultipleFloat),
                    4 => ::std::option::Option::Some(EAnswerType::AnswerTeam),
                    5 => ::std::option::Option::Some(EAnswerType::SingleTime),
                    6 => ::std::option::Option::Some(EAnswerType::MultipleTime),
                    7 => ::std::option::Option::Some(EAnswerType::NoAnswer),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<EAnswerType> {
                match str {
                    "SingleInt" => ::std::option::Option::Some(EAnswerType::SingleInt),
                    "SingleFloat" => ::std::option::Option::Some(EAnswerType::SingleFloat),
                    "MultipleInt" => ::std::option::Option::Some(EAnswerType::MultipleInt),
                    "MultipleFloat" => ::std::option::Option::Some(EAnswerType::MultipleFloat),
                    "AnswerTeam" => ::std::option::Option::Some(EAnswerType::AnswerTeam),
                    "SingleTime" => ::std::option::Option::Some(EAnswerType::SingleTime),
                    "MultipleTime" => ::std::option::Option::Some(EAnswerType::MultipleTime),
                    "NoAnswer" => ::std::option::Option::Some(EAnswerType::NoAnswer),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [EAnswerType] = &[
                EAnswerType::SingleInt,
                EAnswerType::SingleFloat,
                EAnswerType::MultipleInt,
                EAnswerType::MultipleFloat,
                EAnswerType::AnswerTeam,
                EAnswerType::SingleTime,
                EAnswerType::MultipleTime,
                EAnswerType::NoAnswer,
            ];
        }

        impl ::std::default::Default for EAnswerType {
            fn default() -> Self {
                EAnswerType::SingleInt
            }
        }

    }
}

// @@protoc_insertion_point(message:CMsgAvailablePredictions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAvailablePredictions {
    // message fields
    // @@protoc_insertion_point(field:CMsgAvailablePredictions.match_predictions)
    pub match_predictions: ::std::vec::Vec<cmsg_available_predictions::MatchPrediction>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAvailablePredictions.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAvailablePredictions {
    fn default() -> &'a CMsgAvailablePredictions {
        <CMsgAvailablePredictions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgAvailablePredictions {
    pub fn new() -> CMsgAvailablePredictions {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgAvailablePredictions {
    const NAME: &'static str = "CMsgAvailablePredictions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.match_predictions.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.match_predictions {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.match_predictions {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAvailablePredictions {
        CMsgAvailablePredictions::new()
    }

    fn clear(&mut self) {
        self.match_predictions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAvailablePredictions {
        static instance: CMsgAvailablePredictions = CMsgAvailablePredictions {
            match_predictions: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgAvailablePredictions`
pub mod cmsg_available_predictions {
    // @@protoc_insertion_point(message:CMsgAvailablePredictions.MatchPrediction)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MatchPrediction {
        // message fields
        // @@protoc_insertion_point(field:CMsgAvailablePredictions.MatchPrediction.match_id)
        pub match_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgAvailablePredictions.MatchPrediction.predictions)
        pub predictions: ::std::vec::Vec<super::CMsgInGamePrediction>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgAvailablePredictions.MatchPrediction.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MatchPrediction {
        fn default() -> &'a MatchPrediction {
            <MatchPrediction as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl MatchPrediction {
        pub fn new() -> MatchPrediction {
            ::std::default::Default::default()
        }

        // optional uint64 match_id = 1;

        pub fn match_id(&self) -> u64 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u64) {
            self.match_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for MatchPrediction {
        const NAME: &'static str = "MatchPrediction";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.predictions.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.match_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            for value in &self.predictions {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.match_id {
                os.write_uint64(1, v)?;
            }
            for v in &self.predictions {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MatchPrediction {
            MatchPrediction::new()
        }

        fn clear(&mut self) {
            self.match_id = ::std::option::Option::None;
            self.predictions.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MatchPrediction {
            static instance: MatchPrediction = MatchPrediction {
                match_id: ::std::option::Option::None,
                predictions: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgLeagueWatchedGames)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLeagueWatchedGames {
    // message fields
    // @@protoc_insertion_point(field:CMsgLeagueWatchedGames.leagues)
    pub leagues: ::std::vec::Vec<cmsg_league_watched_games::League>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLeagueWatchedGames.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLeagueWatchedGames {
    fn default() -> &'a CMsgLeagueWatchedGames {
        <CMsgLeagueWatchedGames as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLeagueWatchedGames {
    pub fn new() -> CMsgLeagueWatchedGames {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLeagueWatchedGames {
    const NAME: &'static str = "CMsgLeagueWatchedGames";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.leagues.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.leagues {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.leagues {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLeagueWatchedGames {
        CMsgLeagueWatchedGames::new()
    }

    fn clear(&mut self) {
        self.leagues.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLeagueWatchedGames {
        static instance: CMsgLeagueWatchedGames = CMsgLeagueWatchedGames {
            leagues: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgLeagueWatchedGames`
pub mod cmsg_league_watched_games {
    // @@protoc_insertion_point(message:CMsgLeagueWatchedGames.Series)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Series {
        // message fields
        // @@protoc_insertion_point(field:CMsgLeagueWatchedGames.Series.node_id)
        pub node_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgLeagueWatchedGames.Series.game)
        pub game: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgLeagueWatchedGames.Series.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Series {
        fn default() -> &'a Series {
            <Series as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Series {
        pub fn new() -> Series {
            ::std::default::Default::default()
        }

        // optional uint32 node_id = 1;

        pub fn node_id(&self) -> u32 {
            self.node_id.unwrap_or(0)
        }

        pub fn clear_node_id(&mut self) {
            self.node_id = ::std::option::Option::None;
        }

        pub fn has_node_id(&self) -> bool {
            self.node_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_node_id(&mut self, v: u32) {
            self.node_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Series {
        const NAME: &'static str = "Series";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.node_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        is.read_repeated_packed_uint32_into(&mut self.game)?;
                    },
                    16 => {
                        self.game.push(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.node_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.game {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.node_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.game {
                os.write_uint32(2, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Series {
            Series::new()
        }

        fn clear(&mut self) {
            self.node_id = ::std::option::Option::None;
            self.game.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Series {
            static instance: Series = Series {
                node_id: ::std::option::Option::None,
                game: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgLeagueWatchedGames.League)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct League {
        // message fields
        // @@protoc_insertion_point(field:CMsgLeagueWatchedGames.League.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgLeagueWatchedGames.League.series)
        pub series: ::std::vec::Vec<Series>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgLeagueWatchedGames.League.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a League {
        fn default() -> &'a League {
            <League as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl League {
        pub fn new() -> League {
            ::std::default::Default::default()
        }

        // optional uint32 league_id = 1;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for League {
        const NAME: &'static str = "League";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.series.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.league_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.series {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.league_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.series {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> League {
            League::new()
        }

        fn clear(&mut self) {
            self.league_id = ::std::option::Option::None;
            self.series.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static League {
            static instance: League = League {
                league_id: ::std::option::Option::None,
                series: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTAMatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAMatch {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAMatch.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.starttime)
    pub starttime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.players)
    pub players: ::std::vec::Vec<cmsg_dotamatch::Player>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.tower_status)
    pub tower_status: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.barracks_status)
    pub barracks_status: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.cluster)
    pub cluster: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.first_blood_time)
    pub first_blood_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.replay_salt)
    pub replay_salt: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.server_ip)
    pub server_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.server_port)
    pub server_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.lobby_type)
    pub lobby_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.human_players)
    pub human_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.average_skill)
    pub average_skill: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.game_balance)
    pub game_balance: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.radiant_team_id)
    pub radiant_team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.dire_team_id)
    pub dire_team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.leagueid)
    pub leagueid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.radiant_team_name)
    pub radiant_team_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.dire_team_name)
    pub dire_team_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.radiant_team_logo)
    pub radiant_team_logo: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.dire_team_logo)
    pub dire_team_logo: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.radiant_team_logo_url)
    pub radiant_team_logo_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.dire_team_logo_url)
    pub dire_team_logo_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.radiant_team_complete)
    pub radiant_team_complete: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.dire_team_complete)
    pub dire_team_complete: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.game_mode)
    pub game_mode: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GameMode>>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.picks_bans)
    pub picks_bans: ::std::vec::Vec<CMatchHeroSelectEvent>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.match_seq_num)
    pub match_seq_num: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.replay_state)
    pub replay_state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_dotamatch::ReplayState>>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.radiant_guild_id)
    pub radiant_guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.dire_guild_id)
    pub dire_guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.radiant_team_tag)
    pub radiant_team_tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.dire_team_tag)
    pub dire_team_tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.series_id)
    pub series_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.series_type)
    pub series_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.broadcaster_channels)
    pub broadcaster_channels: ::std::vec::Vec<cmsg_dotamatch::BroadcasterChannel>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.engine)
    pub engine: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.custom_game_data)
    pub custom_game_data: ::steam_vent_proto_common::protobuf::MessageField<cmsg_dotamatch::CustomGameData>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.match_flags)
    pub match_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.private_metadata_key)
    pub private_metadata_key: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.radiant_team_score)
    pub radiant_team_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.dire_team_score)
    pub dire_team_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.match_outcome)
    pub match_outcome: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EMatchOutcome>>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.tournament_id)
    pub tournament_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.tournament_round)
    pub tournament_round: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.pre_game_duration)
    pub pre_game_duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatch.coaches)
    pub coaches: ::std::vec::Vec<cmsg_dotamatch::Coach>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAMatch.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAMatch {
    fn default() -> &'a CMsgDOTAMatch {
        <CMsgDOTAMatch as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAMatch {
    pub fn new() -> CMsgDOTAMatch {
        ::std::default::Default::default()
    }

    // optional uint32 duration = 3;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional fixed32 starttime = 4;

    pub fn starttime(&self) -> u32 {
        self.starttime.unwrap_or(0)
    }

    pub fn clear_starttime(&mut self) {
        self.starttime = ::std::option::Option::None;
    }

    pub fn has_starttime(&self) -> bool {
        self.starttime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_starttime(&mut self, v: u32) {
        self.starttime = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 6;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 cluster = 10;

    pub fn cluster(&self) -> u32 {
        self.cluster.unwrap_or(0)
    }

    pub fn clear_cluster(&mut self) {
        self.cluster = ::std::option::Option::None;
    }

    pub fn has_cluster(&self) -> bool {
        self.cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster(&mut self, v: u32) {
        self.cluster = ::std::option::Option::Some(v);
    }

    // optional uint32 first_blood_time = 12;

    pub fn first_blood_time(&self) -> u32 {
        self.first_blood_time.unwrap_or(0)
    }

    pub fn clear_first_blood_time(&mut self) {
        self.first_blood_time = ::std::option::Option::None;
    }

    pub fn has_first_blood_time(&self) -> bool {
        self.first_blood_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood_time(&mut self, v: u32) {
        self.first_blood_time = ::std::option::Option::Some(v);
    }

    // optional fixed32 replay_salt = 13;

    pub fn replay_salt(&self) -> u32 {
        self.replay_salt.unwrap_or(0)
    }

    pub fn clear_replay_salt(&mut self) {
        self.replay_salt = ::std::option::Option::None;
    }

    pub fn has_replay_salt(&self) -> bool {
        self.replay_salt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_salt(&mut self, v: u32) {
        self.replay_salt = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_ip = 14;

    pub fn server_ip(&self) -> u32 {
        self.server_ip.unwrap_or(0)
    }

    pub fn clear_server_ip(&mut self) {
        self.server_ip = ::std::option::Option::None;
    }

    pub fn has_server_ip(&self) -> bool {
        self.server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ip(&mut self, v: u32) {
        self.server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 15;

    pub fn server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }

    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_type = 16;

    pub fn lobby_type(&self) -> u32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: u32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional uint32 human_players = 17;

    pub fn human_players(&self) -> u32 {
        self.human_players.unwrap_or(0)
    }

    pub fn clear_human_players(&mut self) {
        self.human_players = ::std::option::Option::None;
    }

    pub fn has_human_players(&self) -> bool {
        self.human_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_human_players(&mut self, v: u32) {
        self.human_players = ::std::option::Option::Some(v);
    }

    // optional uint32 average_skill = 18;

    pub fn average_skill(&self) -> u32 {
        self.average_skill.unwrap_or(0)
    }

    pub fn clear_average_skill(&mut self) {
        self.average_skill = ::std::option::Option::None;
    }

    pub fn has_average_skill(&self) -> bool {
        self.average_skill.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_skill(&mut self, v: u32) {
        self.average_skill = ::std::option::Option::Some(v);
    }

    // optional float game_balance = 19;

    pub fn game_balance(&self) -> f32 {
        self.game_balance.unwrap_or(0.)
    }

    pub fn clear_game_balance(&mut self) {
        self.game_balance = ::std::option::Option::None;
    }

    pub fn has_game_balance(&self) -> bool {
        self.game_balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_balance(&mut self, v: f32) {
        self.game_balance = ::std::option::Option::Some(v);
    }

    // optional uint32 radiant_team_id = 20;

    pub fn radiant_team_id(&self) -> u32 {
        self.radiant_team_id.unwrap_or(0)
    }

    pub fn clear_radiant_team_id(&mut self) {
        self.radiant_team_id = ::std::option::Option::None;
    }

    pub fn has_radiant_team_id(&self) -> bool {
        self.radiant_team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_team_id(&mut self, v: u32) {
        self.radiant_team_id = ::std::option::Option::Some(v);
    }

    // optional uint32 dire_team_id = 21;

    pub fn dire_team_id(&self) -> u32 {
        self.dire_team_id.unwrap_or(0)
    }

    pub fn clear_dire_team_id(&mut self) {
        self.dire_team_id = ::std::option::Option::None;
    }

    pub fn has_dire_team_id(&self) -> bool {
        self.dire_team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_team_id(&mut self, v: u32) {
        self.dire_team_id = ::std::option::Option::Some(v);
    }

    // optional uint32 leagueid = 22;

    pub fn leagueid(&self) -> u32 {
        self.leagueid.unwrap_or(0)
    }

    pub fn clear_leagueid(&mut self) {
        self.leagueid = ::std::option::Option::None;
    }

    pub fn has_leagueid(&self) -> bool {
        self.leagueid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leagueid(&mut self, v: u32) {
        self.leagueid = ::std::option::Option::Some(v);
    }

    // optional string radiant_team_name = 23;

    pub fn radiant_team_name(&self) -> &str {
        match self.radiant_team_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_radiant_team_name(&mut self) {
        self.radiant_team_name = ::std::option::Option::None;
    }

    pub fn has_radiant_team_name(&self) -> bool {
        self.radiant_team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_team_name(&mut self, v: ::std::string::String) {
        self.radiant_team_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_radiant_team_name(&mut self) -> &mut ::std::string::String {
        if self.radiant_team_name.is_none() {
            self.radiant_team_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.radiant_team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_radiant_team_name(&mut self) -> ::std::string::String {
        self.radiant_team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string dire_team_name = 24;

    pub fn dire_team_name(&self) -> &str {
        match self.dire_team_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_dire_team_name(&mut self) {
        self.dire_team_name = ::std::option::Option::None;
    }

    pub fn has_dire_team_name(&self) -> bool {
        self.dire_team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_team_name(&mut self, v: ::std::string::String) {
        self.dire_team_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dire_team_name(&mut self) -> &mut ::std::string::String {
        if self.dire_team_name.is_none() {
            self.dire_team_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.dire_team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_dire_team_name(&mut self) -> ::std::string::String {
        self.dire_team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 radiant_team_logo = 25;

    pub fn radiant_team_logo(&self) -> u64 {
        self.radiant_team_logo.unwrap_or(0)
    }

    pub fn clear_radiant_team_logo(&mut self) {
        self.radiant_team_logo = ::std::option::Option::None;
    }

    pub fn has_radiant_team_logo(&self) -> bool {
        self.radiant_team_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_team_logo(&mut self, v: u64) {
        self.radiant_team_logo = ::std::option::Option::Some(v);
    }

    // optional uint64 dire_team_logo = 26;

    pub fn dire_team_logo(&self) -> u64 {
        self.dire_team_logo.unwrap_or(0)
    }

    pub fn clear_dire_team_logo(&mut self) {
        self.dire_team_logo = ::std::option::Option::None;
    }

    pub fn has_dire_team_logo(&self) -> bool {
        self.dire_team_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_team_logo(&mut self, v: u64) {
        self.dire_team_logo = ::std::option::Option::Some(v);
    }

    // optional string radiant_team_logo_url = 54;

    pub fn radiant_team_logo_url(&self) -> &str {
        match self.radiant_team_logo_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_radiant_team_logo_url(&mut self) {
        self.radiant_team_logo_url = ::std::option::Option::None;
    }

    pub fn has_radiant_team_logo_url(&self) -> bool {
        self.radiant_team_logo_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_team_logo_url(&mut self, v: ::std::string::String) {
        self.radiant_team_logo_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_radiant_team_logo_url(&mut self) -> &mut ::std::string::String {
        if self.radiant_team_logo_url.is_none() {
            self.radiant_team_logo_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.radiant_team_logo_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_radiant_team_logo_url(&mut self) -> ::std::string::String {
        self.radiant_team_logo_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string dire_team_logo_url = 55;

    pub fn dire_team_logo_url(&self) -> &str {
        match self.dire_team_logo_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_dire_team_logo_url(&mut self) {
        self.dire_team_logo_url = ::std::option::Option::None;
    }

    pub fn has_dire_team_logo_url(&self) -> bool {
        self.dire_team_logo_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_team_logo_url(&mut self, v: ::std::string::String) {
        self.dire_team_logo_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dire_team_logo_url(&mut self) -> &mut ::std::string::String {
        if self.dire_team_logo_url.is_none() {
            self.dire_team_logo_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.dire_team_logo_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_dire_team_logo_url(&mut self) -> ::std::string::String {
        self.dire_team_logo_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 radiant_team_complete = 27;

    pub fn radiant_team_complete(&self) -> u32 {
        self.radiant_team_complete.unwrap_or(0)
    }

    pub fn clear_radiant_team_complete(&mut self) {
        self.radiant_team_complete = ::std::option::Option::None;
    }

    pub fn has_radiant_team_complete(&self) -> bool {
        self.radiant_team_complete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_team_complete(&mut self, v: u32) {
        self.radiant_team_complete = ::std::option::Option::Some(v);
    }

    // optional uint32 dire_team_complete = 28;

    pub fn dire_team_complete(&self) -> u32 {
        self.dire_team_complete.unwrap_or(0)
    }

    pub fn clear_dire_team_complete(&mut self) {
        self.dire_team_complete = ::std::option::Option::None;
    }

    pub fn has_dire_team_complete(&self) -> bool {
        self.dire_team_complete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_team_complete(&mut self, v: u32) {
        self.dire_team_complete = ::std::option::Option::Some(v);
    }

    // optional .DOTA_GameMode game_mode = 31;

    pub fn game_mode(&self) -> super::dota_shared_enums::DOTA_GameMode {
        match self.game_mode {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE),
            None => super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE,
        }
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: super::dota_shared_enums::DOTA_GameMode) {
        self.game_mode = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 match_seq_num = 33;

    pub fn match_seq_num(&self) -> u64 {
        self.match_seq_num.unwrap_or(0)
    }

    pub fn clear_match_seq_num(&mut self) {
        self.match_seq_num = ::std::option::Option::None;
    }

    pub fn has_match_seq_num(&self) -> bool {
        self.match_seq_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_seq_num(&mut self, v: u64) {
        self.match_seq_num = ::std::option::Option::Some(v);
    }

    // optional .CMsgDOTAMatch.ReplayState replay_state = 34;

    pub fn replay_state(&self) -> cmsg_dotamatch::ReplayState {
        match self.replay_state {
            Some(e) => e.enum_value_or(cmsg_dotamatch::ReplayState::REPLAY_AVAILABLE),
            None => cmsg_dotamatch::ReplayState::REPLAY_AVAILABLE,
        }
    }

    pub fn clear_replay_state(&mut self) {
        self.replay_state = ::std::option::Option::None;
    }

    pub fn has_replay_state(&self) -> bool {
        self.replay_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_state(&mut self, v: cmsg_dotamatch::ReplayState) {
        self.replay_state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 radiant_guild_id = 35;

    pub fn radiant_guild_id(&self) -> u32 {
        self.radiant_guild_id.unwrap_or(0)
    }

    pub fn clear_radiant_guild_id(&mut self) {
        self.radiant_guild_id = ::std::option::Option::None;
    }

    pub fn has_radiant_guild_id(&self) -> bool {
        self.radiant_guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_guild_id(&mut self, v: u32) {
        self.radiant_guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 dire_guild_id = 36;

    pub fn dire_guild_id(&self) -> u32 {
        self.dire_guild_id.unwrap_or(0)
    }

    pub fn clear_dire_guild_id(&mut self) {
        self.dire_guild_id = ::std::option::Option::None;
    }

    pub fn has_dire_guild_id(&self) -> bool {
        self.dire_guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_guild_id(&mut self, v: u32) {
        self.dire_guild_id = ::std::option::Option::Some(v);
    }

    // optional string radiant_team_tag = 37;

    pub fn radiant_team_tag(&self) -> &str {
        match self.radiant_team_tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_radiant_team_tag(&mut self) {
        self.radiant_team_tag = ::std::option::Option::None;
    }

    pub fn has_radiant_team_tag(&self) -> bool {
        self.radiant_team_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_team_tag(&mut self, v: ::std::string::String) {
        self.radiant_team_tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_radiant_team_tag(&mut self) -> &mut ::std::string::String {
        if self.radiant_team_tag.is_none() {
            self.radiant_team_tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.radiant_team_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_radiant_team_tag(&mut self) -> ::std::string::String {
        self.radiant_team_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string dire_team_tag = 38;

    pub fn dire_team_tag(&self) -> &str {
        match self.dire_team_tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_dire_team_tag(&mut self) {
        self.dire_team_tag = ::std::option::Option::None;
    }

    pub fn has_dire_team_tag(&self) -> bool {
        self.dire_team_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_team_tag(&mut self, v: ::std::string::String) {
        self.dire_team_tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dire_team_tag(&mut self) -> &mut ::std::string::String {
        if self.dire_team_tag.is_none() {
            self.dire_team_tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.dire_team_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_dire_team_tag(&mut self) -> ::std::string::String {
        self.dire_team_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 series_id = 39;

    pub fn series_id(&self) -> u32 {
        self.series_id.unwrap_or(0)
    }

    pub fn clear_series_id(&mut self) {
        self.series_id = ::std::option::Option::None;
    }

    pub fn has_series_id(&self) -> bool {
        self.series_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_id(&mut self, v: u32) {
        self.series_id = ::std::option::Option::Some(v);
    }

    // optional uint32 series_type = 40;

    pub fn series_type(&self) -> u32 {
        self.series_type.unwrap_or(0)
    }

    pub fn clear_series_type(&mut self) {
        self.series_type = ::std::option::Option::None;
    }

    pub fn has_series_type(&self) -> bool {
        self.series_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_type(&mut self, v: u32) {
        self.series_type = ::std::option::Option::Some(v);
    }

    // optional uint32 engine = 44;

    pub fn engine(&self) -> u32 {
        self.engine.unwrap_or(0)
    }

    pub fn clear_engine(&mut self) {
        self.engine = ::std::option::Option::None;
    }

    pub fn has_engine(&self) -> bool {
        self.engine.is_some()
    }

    // Param is passed by value, moved
    pub fn set_engine(&mut self, v: u32) {
        self.engine = ::std::option::Option::Some(v);
    }

    // optional uint32 match_flags = 46;

    pub fn match_flags(&self) -> u32 {
        self.match_flags.unwrap_or(0)
    }

    pub fn clear_match_flags(&mut self) {
        self.match_flags = ::std::option::Option::None;
    }

    pub fn has_match_flags(&self) -> bool {
        self.match_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_flags(&mut self, v: u32) {
        self.match_flags = ::std::option::Option::Some(v);
    }

    // optional fixed32 private_metadata_key = 47;

    pub fn private_metadata_key(&self) -> u32 {
        self.private_metadata_key.unwrap_or(0)
    }

    pub fn clear_private_metadata_key(&mut self) {
        self.private_metadata_key = ::std::option::Option::None;
    }

    pub fn has_private_metadata_key(&self) -> bool {
        self.private_metadata_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_private_metadata_key(&mut self, v: u32) {
        self.private_metadata_key = ::std::option::Option::Some(v);
    }

    // optional uint32 radiant_team_score = 48;

    pub fn radiant_team_score(&self) -> u32 {
        self.radiant_team_score.unwrap_or(0)
    }

    pub fn clear_radiant_team_score(&mut self) {
        self.radiant_team_score = ::std::option::Option::None;
    }

    pub fn has_radiant_team_score(&self) -> bool {
        self.radiant_team_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_team_score(&mut self, v: u32) {
        self.radiant_team_score = ::std::option::Option::Some(v);
    }

    // optional uint32 dire_team_score = 49;

    pub fn dire_team_score(&self) -> u32 {
        self.dire_team_score.unwrap_or(0)
    }

    pub fn clear_dire_team_score(&mut self) {
        self.dire_team_score = ::std::option::Option::None;
    }

    pub fn has_dire_team_score(&self) -> bool {
        self.dire_team_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_team_score(&mut self, v: u32) {
        self.dire_team_score = ::std::option::Option::Some(v);
    }

    // optional .EMatchOutcome match_outcome = 50;

    pub fn match_outcome(&self) -> super::dota_shared_enums::EMatchOutcome {
        match self.match_outcome {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EMatchOutcome::k_EMatchOutcome_Unknown),
            None => super::dota_shared_enums::EMatchOutcome::k_EMatchOutcome_Unknown,
        }
    }

    pub fn clear_match_outcome(&mut self) {
        self.match_outcome = ::std::option::Option::None;
    }

    pub fn has_match_outcome(&self) -> bool {
        self.match_outcome.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_outcome(&mut self, v: super::dota_shared_enums::EMatchOutcome) {
        self.match_outcome = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 tournament_id = 51;

    pub fn tournament_id(&self) -> u32 {
        self.tournament_id.unwrap_or(0)
    }

    pub fn clear_tournament_id(&mut self) {
        self.tournament_id = ::std::option::Option::None;
    }

    pub fn has_tournament_id(&self) -> bool {
        self.tournament_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_id(&mut self, v: u32) {
        self.tournament_id = ::std::option::Option::Some(v);
    }

    // optional uint32 tournament_round = 52;

    pub fn tournament_round(&self) -> u32 {
        self.tournament_round.unwrap_or(0)
    }

    pub fn clear_tournament_round(&mut self) {
        self.tournament_round = ::std::option::Option::None;
    }

    pub fn has_tournament_round(&self) -> bool {
        self.tournament_round.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_round(&mut self, v: u32) {
        self.tournament_round = ::std::option::Option::Some(v);
    }

    // optional uint32 pre_game_duration = 53;

    pub fn pre_game_duration(&self) -> u32 {
        self.pre_game_duration.unwrap_or(0)
    }

    pub fn clear_pre_game_duration(&mut self) {
        self.pre_game_duration = ::std::option::Option::None;
    }

    pub fn has_pre_game_duration(&self) -> bool {
        self.pre_game_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pre_game_duration(&mut self, v: u32) {
        self.pre_game_duration = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAMatch {
    const NAME: &'static str = "CMsgDOTAMatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.starttime = ::std::option::Option::Some(is.read_fixed32()?);
                },
                42 => {
                    self.players.push(is.read_message()?);
                },
                48 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.tower_status)?;
                },
                64 => {
                    self.tower_status.push(is.read_uint32()?);
                },
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.barracks_status)?;
                },
                72 => {
                    self.barracks_status.push(is.read_uint32()?);
                },
                80 => {
                    self.cluster = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.first_blood_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                109 => {
                    self.replay_salt = ::std::option::Option::Some(is.read_fixed32()?);
                },
                117 => {
                    self.server_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                120 => {
                    self.server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.human_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.average_skill = ::std::option::Option::Some(is.read_uint32()?);
                },
                157 => {
                    self.game_balance = ::std::option::Option::Some(is.read_float()?);
                },
                160 => {
                    self.radiant_team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.dire_team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.leagueid = ::std::option::Option::Some(is.read_uint32()?);
                },
                186 => {
                    self.radiant_team_name = ::std::option::Option::Some(is.read_string()?);
                },
                194 => {
                    self.dire_team_name = ::std::option::Option::Some(is.read_string()?);
                },
                200 => {
                    self.radiant_team_logo = ::std::option::Option::Some(is.read_uint64()?);
                },
                208 => {
                    self.dire_team_logo = ::std::option::Option::Some(is.read_uint64()?);
                },
                434 => {
                    self.radiant_team_logo_url = ::std::option::Option::Some(is.read_string()?);
                },
                442 => {
                    self.dire_team_logo_url = ::std::option::Option::Some(is.read_string()?);
                },
                216 => {
                    self.radiant_team_complete = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.dire_team_complete = ::std::option::Option::Some(is.read_uint32()?);
                },
                248 => {
                    self.game_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                258 => {
                    self.picks_bans.push(is.read_message()?);
                },
                264 => {
                    self.match_seq_num = ::std::option::Option::Some(is.read_uint64()?);
                },
                272 => {
                    self.replay_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                280 => {
                    self.radiant_guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                288 => {
                    self.dire_guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                298 => {
                    self.radiant_team_tag = ::std::option::Option::Some(is.read_string()?);
                },
                306 => {
                    self.dire_team_tag = ::std::option::Option::Some(is.read_string()?);
                },
                312 => {
                    self.series_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                320 => {
                    self.series_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                346 => {
                    self.broadcaster_channels.push(is.read_message()?);
                },
                352 => {
                    self.engine = ::std::option::Option::Some(is.read_uint32()?);
                },
                362 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.custom_game_data)?;
                },
                368 => {
                    self.match_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                381 => {
                    self.private_metadata_key = ::std::option::Option::Some(is.read_fixed32()?);
                },
                384 => {
                    self.radiant_team_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                392 => {
                    self.dire_team_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                400 => {
                    self.match_outcome = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                408 => {
                    self.tournament_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                416 => {
                    self.tournament_round = ::std::option::Option::Some(is.read_uint32()?);
                },
                424 => {
                    self.pre_game_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                458 => {
                    self.coaches.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.starttime {
            my_size += 1 + 4;
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(6, v);
        }
        for value in &self.tower_status {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, *value);
        };
        for value in &self.barracks_status {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, *value);
        };
        if let Some(v) = self.cluster {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.first_blood_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.replay_salt {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_port {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.human_players {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.average_skill {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.game_balance {
            my_size += 2 + 4;
        }
        if let Some(v) = self.radiant_team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.dire_team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.leagueid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.radiant_team_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(23, &v);
        }
        if let Some(v) = self.dire_team_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(24, &v);
        }
        if let Some(v) = self.radiant_team_logo {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(25, v);
        }
        if let Some(v) = self.dire_team_logo {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(26, v);
        }
        if let Some(v) = self.radiant_team_logo_url.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(54, &v);
        }
        if let Some(v) = self.dire_team_logo_url.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(55, &v);
        }
        if let Some(v) = self.radiant_team_complete {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.dire_team_complete {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(31, v.value());
        }
        for value in &self.picks_bans {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.match_seq_num {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(33, v);
        }
        if let Some(v) = self.replay_state {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(34, v.value());
        }
        if let Some(v) = self.radiant_guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(35, v);
        }
        if let Some(v) = self.dire_guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(36, v);
        }
        if let Some(v) = self.radiant_team_tag.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(37, &v);
        }
        if let Some(v) = self.dire_team_tag.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(38, &v);
        }
        if let Some(v) = self.series_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(39, v);
        }
        if let Some(v) = self.series_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(40, v);
        }
        for value in &self.broadcaster_channels {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.engine {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(44, v);
        }
        if let Some(v) = self.custom_game_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.match_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(46, v);
        }
        if let Some(v) = self.private_metadata_key {
            my_size += 2 + 4;
        }
        if let Some(v) = self.radiant_team_score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(48, v);
        }
        if let Some(v) = self.dire_team_score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(49, v);
        }
        if let Some(v) = self.match_outcome {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(50, v.value());
        }
        if let Some(v) = self.tournament_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(51, v);
        }
        if let Some(v) = self.tournament_round {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(52, v);
        }
        if let Some(v) = self.pre_game_duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(53, v);
        }
        for value in &self.coaches {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.duration {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.starttime {
            os.write_fixed32(4, v)?;
        }
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.match_id {
            os.write_uint64(6, v)?;
        }
        for v in &self.tower_status {
            os.write_uint32(8, *v)?;
        };
        for v in &self.barracks_status {
            os.write_uint32(9, *v)?;
        };
        if let Some(v) = self.cluster {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.first_blood_time {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.replay_salt {
            os.write_fixed32(13, v)?;
        }
        if let Some(v) = self.server_ip {
            os.write_fixed32(14, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.human_players {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.average_skill {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.game_balance {
            os.write_float(19, v)?;
        }
        if let Some(v) = self.radiant_team_id {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.dire_team_id {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.leagueid {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.radiant_team_name.as_ref() {
            os.write_string(23, v)?;
        }
        if let Some(v) = self.dire_team_name.as_ref() {
            os.write_string(24, v)?;
        }
        if let Some(v) = self.radiant_team_logo {
            os.write_uint64(25, v)?;
        }
        if let Some(v) = self.dire_team_logo {
            os.write_uint64(26, v)?;
        }
        if let Some(v) = self.radiant_team_logo_url.as_ref() {
            os.write_string(54, v)?;
        }
        if let Some(v) = self.dire_team_logo_url.as_ref() {
            os.write_string(55, v)?;
        }
        if let Some(v) = self.radiant_team_complete {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.dire_team_complete {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_enum(31, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.picks_bans {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
        };
        if let Some(v) = self.match_seq_num {
            os.write_uint64(33, v)?;
        }
        if let Some(v) = self.replay_state {
            os.write_enum(34, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.radiant_guild_id {
            os.write_uint32(35, v)?;
        }
        if let Some(v) = self.dire_guild_id {
            os.write_uint32(36, v)?;
        }
        if let Some(v) = self.radiant_team_tag.as_ref() {
            os.write_string(37, v)?;
        }
        if let Some(v) = self.dire_team_tag.as_ref() {
            os.write_string(38, v)?;
        }
        if let Some(v) = self.series_id {
            os.write_uint32(39, v)?;
        }
        if let Some(v) = self.series_type {
            os.write_uint32(40, v)?;
        }
        for v in &self.broadcaster_channels {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(43, v, os)?;
        };
        if let Some(v) = self.engine {
            os.write_uint32(44, v)?;
        }
        if let Some(v) = self.custom_game_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(45, v, os)?;
        }
        if let Some(v) = self.match_flags {
            os.write_uint32(46, v)?;
        }
        if let Some(v) = self.private_metadata_key {
            os.write_fixed32(47, v)?;
        }
        if let Some(v) = self.radiant_team_score {
            os.write_uint32(48, v)?;
        }
        if let Some(v) = self.dire_team_score {
            os.write_uint32(49, v)?;
        }
        if let Some(v) = self.match_outcome {
            os.write_enum(50, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.tournament_id {
            os.write_uint32(51, v)?;
        }
        if let Some(v) = self.tournament_round {
            os.write_uint32(52, v)?;
        }
        if let Some(v) = self.pre_game_duration {
            os.write_uint32(53, v)?;
        }
        for v in &self.coaches {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(57, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAMatch {
        CMsgDOTAMatch::new()
    }

    fn clear(&mut self) {
        self.duration = ::std::option::Option::None;
        self.starttime = ::std::option::Option::None;
        self.players.clear();
        self.match_id = ::std::option::Option::None;
        self.tower_status.clear();
        self.barracks_status.clear();
        self.cluster = ::std::option::Option::None;
        self.first_blood_time = ::std::option::Option::None;
        self.replay_salt = ::std::option::Option::None;
        self.server_ip = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.human_players = ::std::option::Option::None;
        self.average_skill = ::std::option::Option::None;
        self.game_balance = ::std::option::Option::None;
        self.radiant_team_id = ::std::option::Option::None;
        self.dire_team_id = ::std::option::Option::None;
        self.leagueid = ::std::option::Option::None;
        self.radiant_team_name = ::std::option::Option::None;
        self.dire_team_name = ::std::option::Option::None;
        self.radiant_team_logo = ::std::option::Option::None;
        self.dire_team_logo = ::std::option::Option::None;
        self.radiant_team_logo_url = ::std::option::Option::None;
        self.dire_team_logo_url = ::std::option::Option::None;
        self.radiant_team_complete = ::std::option::Option::None;
        self.dire_team_complete = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.picks_bans.clear();
        self.match_seq_num = ::std::option::Option::None;
        self.replay_state = ::std::option::Option::None;
        self.radiant_guild_id = ::std::option::Option::None;
        self.dire_guild_id = ::std::option::Option::None;
        self.radiant_team_tag = ::std::option::Option::None;
        self.dire_team_tag = ::std::option::Option::None;
        self.series_id = ::std::option::Option::None;
        self.series_type = ::std::option::Option::None;
        self.broadcaster_channels.clear();
        self.engine = ::std::option::Option::None;
        self.custom_game_data.clear();
        self.match_flags = ::std::option::Option::None;
        self.private_metadata_key = ::std::option::Option::None;
        self.radiant_team_score = ::std::option::Option::None;
        self.dire_team_score = ::std::option::Option::None;
        self.match_outcome = ::std::option::Option::None;
        self.tournament_id = ::std::option::Option::None;
        self.tournament_round = ::std::option::Option::None;
        self.pre_game_duration = ::std::option::Option::None;
        self.coaches.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAMatch {
        static instance: CMsgDOTAMatch = CMsgDOTAMatch {
            duration: ::std::option::Option::None,
            starttime: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            match_id: ::std::option::Option::None,
            tower_status: ::std::vec::Vec::new(),
            barracks_status: ::std::vec::Vec::new(),
            cluster: ::std::option::Option::None,
            first_blood_time: ::std::option::Option::None,
            replay_salt: ::std::option::Option::None,
            server_ip: ::std::option::Option::None,
            server_port: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            human_players: ::std::option::Option::None,
            average_skill: ::std::option::Option::None,
            game_balance: ::std::option::Option::None,
            radiant_team_id: ::std::option::Option::None,
            dire_team_id: ::std::option::Option::None,
            leagueid: ::std::option::Option::None,
            radiant_team_name: ::std::option::Option::None,
            dire_team_name: ::std::option::Option::None,
            radiant_team_logo: ::std::option::Option::None,
            dire_team_logo: ::std::option::Option::None,
            radiant_team_logo_url: ::std::option::Option::None,
            dire_team_logo_url: ::std::option::Option::None,
            radiant_team_complete: ::std::option::Option::None,
            dire_team_complete: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            picks_bans: ::std::vec::Vec::new(),
            match_seq_num: ::std::option::Option::None,
            replay_state: ::std::option::Option::None,
            radiant_guild_id: ::std::option::Option::None,
            dire_guild_id: ::std::option::Option::None,
            radiant_team_tag: ::std::option::Option::None,
            dire_team_tag: ::std::option::Option::None,
            series_id: ::std::option::Option::None,
            series_type: ::std::option::Option::None,
            broadcaster_channels: ::std::vec::Vec::new(),
            engine: ::std::option::Option::None,
            custom_game_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            match_flags: ::std::option::Option::None,
            private_metadata_key: ::std::option::Option::None,
            radiant_team_score: ::std::option::Option::None,
            dire_team_score: ::std::option::Option::None,
            match_outcome: ::std::option::Option::None,
            tournament_id: ::std::option::Option::None,
            tournament_round: ::std::option::Option::None,
            pre_game_duration: ::std::option::Option::None,
            coaches: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTAMatch`
pub mod cmsg_dotamatch {
    // @@protoc_insertion_point(message:CMsgDOTAMatch.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.player_slot)
        pub player_slot: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.item_0)
        pub item_0: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.item_1)
        pub item_1: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.item_2)
        pub item_2: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.item_3)
        pub item_3: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.item_4)
        pub item_4: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.item_5)
        pub item_5: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.item_6)
        pub item_6: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.item_7)
        pub item_7: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.item_8)
        pub item_8: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.item_9)
        pub item_9: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.expected_team_contribution)
        pub expected_team_contribution: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.scaled_metric)
        pub scaled_metric: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.previous_rank)
        pub previous_rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.rank_change)
        pub rank_change: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.mmr_type)
        pub mmr_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.kills)
        pub kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.deaths)
        pub deaths: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.assists)
        pub assists: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.leaver_status)
        pub leaver_status: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.gold)
        pub gold: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.last_hits)
        pub last_hits: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.denies)
        pub denies: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.gold_per_min)
        pub gold_per_min: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.xp_per_min)
        pub xp_per_min: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.gold_spent)
        pub gold_spent: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.hero_damage)
        pub hero_damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.tower_damage)
        pub tower_damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.hero_healing)
        pub hero_healing: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.level)
        pub level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.time_last_seen)
        pub time_last_seen: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.player_name)
        pub player_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.support_ability_value)
        pub support_ability_value: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.feeding_detected)
        pub feeding_detected: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.search_rank)
        pub search_rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.search_rank_uncertainty)
        pub search_rank_uncertainty: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.rank_uncertainty_change)
        pub rank_uncertainty_change: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.hero_play_count)
        pub hero_play_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.party_id)
        pub party_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.scaled_hero_damage)
        pub scaled_hero_damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.scaled_tower_damage)
        pub scaled_tower_damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.scaled_hero_healing)
        pub scaled_hero_healing: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.scaled_kills)
        pub scaled_kills: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.scaled_deaths)
        pub scaled_deaths: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.scaled_assists)
        pub scaled_assists: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.claimed_farm_gold)
        pub claimed_farm_gold: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.support_gold)
        pub support_gold: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.claimed_denies)
        pub claimed_denies: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.claimed_misses)
        pub claimed_misses: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.misses)
        pub misses: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.ability_upgrades)
        pub ability_upgrades: ::std::vec::Vec<super::CMatchPlayerAbilityUpgrade>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.additional_units_inventory)
        pub additional_units_inventory: ::std::vec::Vec<super::CMatchAdditionalUnitInventory>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.permanent_buffs)
        pub permanent_buffs: ::std::vec::Vec<super::CMatchPlayerPermanentBuff>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.pro_name)
        pub pro_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.real_name)
        pub real_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.custom_game_data)
        pub custom_game_data: ::steam_vent_proto_common::protobuf::MessageField<player::CustomGameData>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.active_plus_subscription)
        pub active_plus_subscription: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.net_worth)
        pub net_worth: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.bot_difficulty)
        pub bot_difficulty: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.hero_pick_order)
        pub hero_pick_order: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.hero_was_randomed)
        pub hero_was_randomed: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.hero_was_dota_plus_suggestion)
        pub hero_was_dota_plus_suggestion: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.hero_damage_received)
        pub hero_damage_received: ::std::vec::Vec<player::HeroDamageReceived>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.hero_damage_dealt)
        pub hero_damage_dealt: ::std::vec::Vec<player::HeroDamageReceived>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.seconds_dead)
        pub seconds_dead: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.gold_lost_to_death)
        pub gold_lost_to_death: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.lane_selection_flags)
        pub lane_selection_flags: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.bounty_runes)
        pub bounty_runes: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.outposts_captured)
        pub outposts_captured: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.team_number)
        pub team_number: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::DOTA_GC_TEAM>>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.team_slot)
        pub team_slot: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.selected_facet)
        pub selected_facet: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAMatch.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 player_slot = 2;

        pub fn player_slot(&self) -> u32 {
            self.player_slot.unwrap_or(0)
        }

        pub fn clear_player_slot(&mut self) {
            self.player_slot = ::std::option::Option::None;
        }

        pub fn has_player_slot(&self) -> bool {
            self.player_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_slot(&mut self, v: u32) {
            self.player_slot = ::std::option::Option::Some(v);
        }

        // optional int32 hero_id = 3;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional int32 item_0 = 4;

        pub fn item_0(&self) -> i32 {
            self.item_0.unwrap_or(-1i32)
        }

        pub fn clear_item_0(&mut self) {
            self.item_0 = ::std::option::Option::None;
        }

        pub fn has_item_0(&self) -> bool {
            self.item_0.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_0(&mut self, v: i32) {
            self.item_0 = ::std::option::Option::Some(v);
        }

        // optional int32 item_1 = 5;

        pub fn item_1(&self) -> i32 {
            self.item_1.unwrap_or(-1i32)
        }

        pub fn clear_item_1(&mut self) {
            self.item_1 = ::std::option::Option::None;
        }

        pub fn has_item_1(&self) -> bool {
            self.item_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_1(&mut self, v: i32) {
            self.item_1 = ::std::option::Option::Some(v);
        }

        // optional int32 item_2 = 6;

        pub fn item_2(&self) -> i32 {
            self.item_2.unwrap_or(-1i32)
        }

        pub fn clear_item_2(&mut self) {
            self.item_2 = ::std::option::Option::None;
        }

        pub fn has_item_2(&self) -> bool {
            self.item_2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_2(&mut self, v: i32) {
            self.item_2 = ::std::option::Option::Some(v);
        }

        // optional int32 item_3 = 7;

        pub fn item_3(&self) -> i32 {
            self.item_3.unwrap_or(-1i32)
        }

        pub fn clear_item_3(&mut self) {
            self.item_3 = ::std::option::Option::None;
        }

        pub fn has_item_3(&self) -> bool {
            self.item_3.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_3(&mut self, v: i32) {
            self.item_3 = ::std::option::Option::Some(v);
        }

        // optional int32 item_4 = 8;

        pub fn item_4(&self) -> i32 {
            self.item_4.unwrap_or(-1i32)
        }

        pub fn clear_item_4(&mut self) {
            self.item_4 = ::std::option::Option::None;
        }

        pub fn has_item_4(&self) -> bool {
            self.item_4.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_4(&mut self, v: i32) {
            self.item_4 = ::std::option::Option::Some(v);
        }

        // optional int32 item_5 = 9;

        pub fn item_5(&self) -> i32 {
            self.item_5.unwrap_or(-1i32)
        }

        pub fn clear_item_5(&mut self) {
            self.item_5 = ::std::option::Option::None;
        }

        pub fn has_item_5(&self) -> bool {
            self.item_5.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_5(&mut self, v: i32) {
            self.item_5 = ::std::option::Option::Some(v);
        }

        // optional int32 item_6 = 59;

        pub fn item_6(&self) -> i32 {
            self.item_6.unwrap_or(-1i32)
        }

        pub fn clear_item_6(&mut self) {
            self.item_6 = ::std::option::Option::None;
        }

        pub fn has_item_6(&self) -> bool {
            self.item_6.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_6(&mut self, v: i32) {
            self.item_6 = ::std::option::Option::Some(v);
        }

        // optional int32 item_7 = 60;

        pub fn item_7(&self) -> i32 {
            self.item_7.unwrap_or(-1i32)
        }

        pub fn clear_item_7(&mut self) {
            self.item_7 = ::std::option::Option::None;
        }

        pub fn has_item_7(&self) -> bool {
            self.item_7.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_7(&mut self, v: i32) {
            self.item_7 = ::std::option::Option::Some(v);
        }

        // optional int32 item_8 = 61;

        pub fn item_8(&self) -> i32 {
            self.item_8.unwrap_or(-1i32)
        }

        pub fn clear_item_8(&mut self) {
            self.item_8 = ::std::option::Option::None;
        }

        pub fn has_item_8(&self) -> bool {
            self.item_8.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_8(&mut self, v: i32) {
            self.item_8 = ::std::option::Option::Some(v);
        }

        // optional int32 item_9 = 76;

        pub fn item_9(&self) -> i32 {
            self.item_9.unwrap_or(-1i32)
        }

        pub fn clear_item_9(&mut self) {
            self.item_9 = ::std::option::Option::None;
        }

        pub fn has_item_9(&self) -> bool {
            self.item_9.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_9(&mut self, v: i32) {
            self.item_9 = ::std::option::Option::Some(v);
        }

        // optional float expected_team_contribution = 10;

        pub fn expected_team_contribution(&self) -> f32 {
            self.expected_team_contribution.unwrap_or(0.)
        }

        pub fn clear_expected_team_contribution(&mut self) {
            self.expected_team_contribution = ::std::option::Option::None;
        }

        pub fn has_expected_team_contribution(&self) -> bool {
            self.expected_team_contribution.is_some()
        }

        // Param is passed by value, moved
        pub fn set_expected_team_contribution(&mut self, v: f32) {
            self.expected_team_contribution = ::std::option::Option::Some(v);
        }

        // optional float scaled_metric = 11;

        pub fn scaled_metric(&self) -> f32 {
            self.scaled_metric.unwrap_or(0.)
        }

        pub fn clear_scaled_metric(&mut self) {
            self.scaled_metric = ::std::option::Option::None;
        }

        pub fn has_scaled_metric(&self) -> bool {
            self.scaled_metric.is_some()
        }

        // Param is passed by value, moved
        pub fn set_scaled_metric(&mut self, v: f32) {
            self.scaled_metric = ::std::option::Option::Some(v);
        }

        // optional uint32 previous_rank = 12;

        pub fn previous_rank(&self) -> u32 {
            self.previous_rank.unwrap_or(0)
        }

        pub fn clear_previous_rank(&mut self) {
            self.previous_rank = ::std::option::Option::None;
        }

        pub fn has_previous_rank(&self) -> bool {
            self.previous_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_previous_rank(&mut self, v: u32) {
            self.previous_rank = ::std::option::Option::Some(v);
        }

        // optional sint32 rank_change = 13;

        pub fn rank_change(&self) -> i32 {
            self.rank_change.unwrap_or(0)
        }

        pub fn clear_rank_change(&mut self) {
            self.rank_change = ::std::option::Option::None;
        }

        pub fn has_rank_change(&self) -> bool {
            self.rank_change.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_change(&mut self, v: i32) {
            self.rank_change = ::std::option::Option::Some(v);
        }

        // optional uint32 mmr_type = 74;

        pub fn mmr_type(&self) -> u32 {
            self.mmr_type.unwrap_or(0)
        }

        pub fn clear_mmr_type(&mut self) {
            self.mmr_type = ::std::option::Option::None;
        }

        pub fn has_mmr_type(&self) -> bool {
            self.mmr_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mmr_type(&mut self, v: u32) {
            self.mmr_type = ::std::option::Option::Some(v);
        }

        // optional uint32 kills = 14;

        pub fn kills(&self) -> u32 {
            self.kills.unwrap_or(0)
        }

        pub fn clear_kills(&mut self) {
            self.kills = ::std::option::Option::None;
        }

        pub fn has_kills(&self) -> bool {
            self.kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kills(&mut self, v: u32) {
            self.kills = ::std::option::Option::Some(v);
        }

        // optional uint32 deaths = 15;

        pub fn deaths(&self) -> u32 {
            self.deaths.unwrap_or(0)
        }

        pub fn clear_deaths(&mut self) {
            self.deaths = ::std::option::Option::None;
        }

        pub fn has_deaths(&self) -> bool {
            self.deaths.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deaths(&mut self, v: u32) {
            self.deaths = ::std::option::Option::Some(v);
        }

        // optional uint32 assists = 16;

        pub fn assists(&self) -> u32 {
            self.assists.unwrap_or(0)
        }

        pub fn clear_assists(&mut self) {
            self.assists = ::std::option::Option::None;
        }

        pub fn has_assists(&self) -> bool {
            self.assists.is_some()
        }

        // Param is passed by value, moved
        pub fn set_assists(&mut self, v: u32) {
            self.assists = ::std::option::Option::Some(v);
        }

        // optional uint32 leaver_status = 17;

        pub fn leaver_status(&self) -> u32 {
            self.leaver_status.unwrap_or(0)
        }

        pub fn clear_leaver_status(&mut self) {
            self.leaver_status = ::std::option::Option::None;
        }

        pub fn has_leaver_status(&self) -> bool {
            self.leaver_status.is_some()
        }

        // Param is passed by value, moved
        pub fn set_leaver_status(&mut self, v: u32) {
            self.leaver_status = ::std::option::Option::Some(v);
        }

        // optional uint32 gold = 18;

        pub fn gold(&self) -> u32 {
            self.gold.unwrap_or(0)
        }

        pub fn clear_gold(&mut self) {
            self.gold = ::std::option::Option::None;
        }

        pub fn has_gold(&self) -> bool {
            self.gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold(&mut self, v: u32) {
            self.gold = ::std::option::Option::Some(v);
        }

        // optional uint32 last_hits = 19;

        pub fn last_hits(&self) -> u32 {
            self.last_hits.unwrap_or(0)
        }

        pub fn clear_last_hits(&mut self) {
            self.last_hits = ::std::option::Option::None;
        }

        pub fn has_last_hits(&self) -> bool {
            self.last_hits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_hits(&mut self, v: u32) {
            self.last_hits = ::std::option::Option::Some(v);
        }

        // optional uint32 denies = 20;

        pub fn denies(&self) -> u32 {
            self.denies.unwrap_or(0)
        }

        pub fn clear_denies(&mut self) {
            self.denies = ::std::option::Option::None;
        }

        pub fn has_denies(&self) -> bool {
            self.denies.is_some()
        }

        // Param is passed by value, moved
        pub fn set_denies(&mut self, v: u32) {
            self.denies = ::std::option::Option::Some(v);
        }

        // optional uint32 gold_per_min = 21;

        pub fn gold_per_min(&self) -> u32 {
            self.gold_per_min.unwrap_or(0)
        }

        pub fn clear_gold_per_min(&mut self) {
            self.gold_per_min = ::std::option::Option::None;
        }

        pub fn has_gold_per_min(&self) -> bool {
            self.gold_per_min.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_per_min(&mut self, v: u32) {
            self.gold_per_min = ::std::option::Option::Some(v);
        }

        // optional uint32 xp_per_min = 22;

        pub fn xp_per_min(&self) -> u32 {
            self.xp_per_min.unwrap_or(0)
        }

        pub fn clear_xp_per_min(&mut self) {
            self.xp_per_min = ::std::option::Option::None;
        }

        pub fn has_xp_per_min(&self) -> bool {
            self.xp_per_min.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xp_per_min(&mut self, v: u32) {
            self.xp_per_min = ::std::option::Option::Some(v);
        }

        // optional uint32 gold_spent = 23;

        pub fn gold_spent(&self) -> u32 {
            self.gold_spent.unwrap_or(0)
        }

        pub fn clear_gold_spent(&mut self) {
            self.gold_spent = ::std::option::Option::None;
        }

        pub fn has_gold_spent(&self) -> bool {
            self.gold_spent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_spent(&mut self, v: u32) {
            self.gold_spent = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_damage = 24;

        pub fn hero_damage(&self) -> u32 {
            self.hero_damage.unwrap_or(0)
        }

        pub fn clear_hero_damage(&mut self) {
            self.hero_damage = ::std::option::Option::None;
        }

        pub fn has_hero_damage(&self) -> bool {
            self.hero_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_damage(&mut self, v: u32) {
            self.hero_damage = ::std::option::Option::Some(v);
        }

        // optional uint32 tower_damage = 25;

        pub fn tower_damage(&self) -> u32 {
            self.tower_damage.unwrap_or(0)
        }

        pub fn clear_tower_damage(&mut self) {
            self.tower_damage = ::std::option::Option::None;
        }

        pub fn has_tower_damage(&self) -> bool {
            self.tower_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tower_damage(&mut self, v: u32) {
            self.tower_damage = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_healing = 26;

        pub fn hero_healing(&self) -> u32 {
            self.hero_healing.unwrap_or(0)
        }

        pub fn clear_hero_healing(&mut self) {
            self.hero_healing = ::std::option::Option::None;
        }

        pub fn has_hero_healing(&self) -> bool {
            self.hero_healing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_healing(&mut self, v: u32) {
            self.hero_healing = ::std::option::Option::Some(v);
        }

        // optional uint32 level = 27;

        pub fn level(&self) -> u32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: u32) {
            self.level = ::std::option::Option::Some(v);
        }

        // optional uint32 time_last_seen = 28;

        pub fn time_last_seen(&self) -> u32 {
            self.time_last_seen.unwrap_or(0)
        }

        pub fn clear_time_last_seen(&mut self) {
            self.time_last_seen = ::std::option::Option::None;
        }

        pub fn has_time_last_seen(&self) -> bool {
            self.time_last_seen.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_last_seen(&mut self, v: u32) {
            self.time_last_seen = ::std::option::Option::Some(v);
        }

        // optional string player_name = 29;

        pub fn player_name(&self) -> &str {
            match self.player_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_player_name(&mut self) {
            self.player_name = ::std::option::Option::None;
        }

        pub fn has_player_name(&self) -> bool {
            self.player_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_name(&mut self, v: ::std::string::String) {
            self.player_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
            if self.player_name.is_none() {
                self.player_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.player_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_player_name(&mut self) -> ::std::string::String {
            self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 support_ability_value = 30;

        pub fn support_ability_value(&self) -> u32 {
            self.support_ability_value.unwrap_or(0)
        }

        pub fn clear_support_ability_value(&mut self) {
            self.support_ability_value = ::std::option::Option::None;
        }

        pub fn has_support_ability_value(&self) -> bool {
            self.support_ability_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_support_ability_value(&mut self, v: u32) {
            self.support_ability_value = ::std::option::Option::Some(v);
        }

        // optional bool feeding_detected = 32;

        pub fn feeding_detected(&self) -> bool {
            self.feeding_detected.unwrap_or(false)
        }

        pub fn clear_feeding_detected(&mut self) {
            self.feeding_detected = ::std::option::Option::None;
        }

        pub fn has_feeding_detected(&self) -> bool {
            self.feeding_detected.is_some()
        }

        // Param is passed by value, moved
        pub fn set_feeding_detected(&mut self, v: bool) {
            self.feeding_detected = ::std::option::Option::Some(v);
        }

        // optional uint32 search_rank = 34;

        pub fn search_rank(&self) -> u32 {
            self.search_rank.unwrap_or(0)
        }

        pub fn clear_search_rank(&mut self) {
            self.search_rank = ::std::option::Option::None;
        }

        pub fn has_search_rank(&self) -> bool {
            self.search_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_search_rank(&mut self, v: u32) {
            self.search_rank = ::std::option::Option::Some(v);
        }

        // optional uint32 search_rank_uncertainty = 35;

        pub fn search_rank_uncertainty(&self) -> u32 {
            self.search_rank_uncertainty.unwrap_or(0)
        }

        pub fn clear_search_rank_uncertainty(&mut self) {
            self.search_rank_uncertainty = ::std::option::Option::None;
        }

        pub fn has_search_rank_uncertainty(&self) -> bool {
            self.search_rank_uncertainty.is_some()
        }

        // Param is passed by value, moved
        pub fn set_search_rank_uncertainty(&mut self, v: u32) {
            self.search_rank_uncertainty = ::std::option::Option::Some(v);
        }

        // optional int32 rank_uncertainty_change = 36;

        pub fn rank_uncertainty_change(&self) -> i32 {
            self.rank_uncertainty_change.unwrap_or(0)
        }

        pub fn clear_rank_uncertainty_change(&mut self) {
            self.rank_uncertainty_change = ::std::option::Option::None;
        }

        pub fn has_rank_uncertainty_change(&self) -> bool {
            self.rank_uncertainty_change.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_uncertainty_change(&mut self, v: i32) {
            self.rank_uncertainty_change = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_play_count = 37;

        pub fn hero_play_count(&self) -> u32 {
            self.hero_play_count.unwrap_or(0)
        }

        pub fn clear_hero_play_count(&mut self) {
            self.hero_play_count = ::std::option::Option::None;
        }

        pub fn has_hero_play_count(&self) -> bool {
            self.hero_play_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_play_count(&mut self, v: u32) {
            self.hero_play_count = ::std::option::Option::Some(v);
        }

        // optional fixed64 party_id = 38;

        pub fn party_id(&self) -> u64 {
            self.party_id.unwrap_or(0)
        }

        pub fn clear_party_id(&mut self) {
            self.party_id = ::std::option::Option::None;
        }

        pub fn has_party_id(&self) -> bool {
            self.party_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_party_id(&mut self, v: u64) {
            self.party_id = ::std::option::Option::Some(v);
        }

        // optional uint32 scaled_hero_damage = 54;

        pub fn scaled_hero_damage(&self) -> u32 {
            self.scaled_hero_damage.unwrap_or(0)
        }

        pub fn clear_scaled_hero_damage(&mut self) {
            self.scaled_hero_damage = ::std::option::Option::None;
        }

        pub fn has_scaled_hero_damage(&self) -> bool {
            self.scaled_hero_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_scaled_hero_damage(&mut self, v: u32) {
            self.scaled_hero_damage = ::std::option::Option::Some(v);
        }

        // optional uint32 scaled_tower_damage = 55;

        pub fn scaled_tower_damage(&self) -> u32 {
            self.scaled_tower_damage.unwrap_or(0)
        }

        pub fn clear_scaled_tower_damage(&mut self) {
            self.scaled_tower_damage = ::std::option::Option::None;
        }

        pub fn has_scaled_tower_damage(&self) -> bool {
            self.scaled_tower_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_scaled_tower_damage(&mut self, v: u32) {
            self.scaled_tower_damage = ::std::option::Option::Some(v);
        }

        // optional uint32 scaled_hero_healing = 56;

        pub fn scaled_hero_healing(&self) -> u32 {
            self.scaled_hero_healing.unwrap_or(0)
        }

        pub fn clear_scaled_hero_healing(&mut self) {
            self.scaled_hero_healing = ::std::option::Option::None;
        }

        pub fn has_scaled_hero_healing(&self) -> bool {
            self.scaled_hero_healing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_scaled_hero_healing(&mut self, v: u32) {
            self.scaled_hero_healing = ::std::option::Option::Some(v);
        }

        // optional float scaled_kills = 39;

        pub fn scaled_kills(&self) -> f32 {
            self.scaled_kills.unwrap_or(0.)
        }

        pub fn clear_scaled_kills(&mut self) {
            self.scaled_kills = ::std::option::Option::None;
        }

        pub fn has_scaled_kills(&self) -> bool {
            self.scaled_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_scaled_kills(&mut self, v: f32) {
            self.scaled_kills = ::std::option::Option::Some(v);
        }

        // optional float scaled_deaths = 40;

        pub fn scaled_deaths(&self) -> f32 {
            self.scaled_deaths.unwrap_or(0.)
        }

        pub fn clear_scaled_deaths(&mut self) {
            self.scaled_deaths = ::std::option::Option::None;
        }

        pub fn has_scaled_deaths(&self) -> bool {
            self.scaled_deaths.is_some()
        }

        // Param is passed by value, moved
        pub fn set_scaled_deaths(&mut self, v: f32) {
            self.scaled_deaths = ::std::option::Option::Some(v);
        }

        // optional float scaled_assists = 41;

        pub fn scaled_assists(&self) -> f32 {
            self.scaled_assists.unwrap_or(0.)
        }

        pub fn clear_scaled_assists(&mut self) {
            self.scaled_assists = ::std::option::Option::None;
        }

        pub fn has_scaled_assists(&self) -> bool {
            self.scaled_assists.is_some()
        }

        // Param is passed by value, moved
        pub fn set_scaled_assists(&mut self, v: f32) {
            self.scaled_assists = ::std::option::Option::Some(v);
        }

        // optional uint32 claimed_farm_gold = 42;

        pub fn claimed_farm_gold(&self) -> u32 {
            self.claimed_farm_gold.unwrap_or(0)
        }

        pub fn clear_claimed_farm_gold(&mut self) {
            self.claimed_farm_gold = ::std::option::Option::None;
        }

        pub fn has_claimed_farm_gold(&self) -> bool {
            self.claimed_farm_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_claimed_farm_gold(&mut self, v: u32) {
            self.claimed_farm_gold = ::std::option::Option::Some(v);
        }

        // optional uint32 support_gold = 43;

        pub fn support_gold(&self) -> u32 {
            self.support_gold.unwrap_or(0)
        }

        pub fn clear_support_gold(&mut self) {
            self.support_gold = ::std::option::Option::None;
        }

        pub fn has_support_gold(&self) -> bool {
            self.support_gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_support_gold(&mut self, v: u32) {
            self.support_gold = ::std::option::Option::Some(v);
        }

        // optional uint32 claimed_denies = 44;

        pub fn claimed_denies(&self) -> u32 {
            self.claimed_denies.unwrap_or(0)
        }

        pub fn clear_claimed_denies(&mut self) {
            self.claimed_denies = ::std::option::Option::None;
        }

        pub fn has_claimed_denies(&self) -> bool {
            self.claimed_denies.is_some()
        }

        // Param is passed by value, moved
        pub fn set_claimed_denies(&mut self, v: u32) {
            self.claimed_denies = ::std::option::Option::Some(v);
        }

        // optional uint32 claimed_misses = 45;

        pub fn claimed_misses(&self) -> u32 {
            self.claimed_misses.unwrap_or(0)
        }

        pub fn clear_claimed_misses(&mut self) {
            self.claimed_misses = ::std::option::Option::None;
        }

        pub fn has_claimed_misses(&self) -> bool {
            self.claimed_misses.is_some()
        }

        // Param is passed by value, moved
        pub fn set_claimed_misses(&mut self, v: u32) {
            self.claimed_misses = ::std::option::Option::Some(v);
        }

        // optional uint32 misses = 46;

        pub fn misses(&self) -> u32 {
            self.misses.unwrap_or(0)
        }

        pub fn clear_misses(&mut self) {
            self.misses = ::std::option::Option::None;
        }

        pub fn has_misses(&self) -> bool {
            self.misses.is_some()
        }

        // Param is passed by value, moved
        pub fn set_misses(&mut self, v: u32) {
            self.misses = ::std::option::Option::Some(v);
        }

        // optional string pro_name = 72;

        pub fn pro_name(&self) -> &str {
            match self.pro_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_pro_name(&mut self) {
            self.pro_name = ::std::option::Option::None;
        }

        pub fn has_pro_name(&self) -> bool {
            self.pro_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pro_name(&mut self, v: ::std::string::String) {
            self.pro_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_pro_name(&mut self) -> &mut ::std::string::String {
            if self.pro_name.is_none() {
                self.pro_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.pro_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_pro_name(&mut self) -> ::std::string::String {
            self.pro_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string real_name = 73;

        pub fn real_name(&self) -> &str {
            match self.real_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_real_name(&mut self) {
            self.real_name = ::std::option::Option::None;
        }

        pub fn has_real_name(&self) -> bool {
            self.real_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_real_name(&mut self, v: ::std::string::String) {
            self.real_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_real_name(&mut self) -> &mut ::std::string::String {
            if self.real_name.is_none() {
                self.real_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.real_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_real_name(&mut self) -> ::std::string::String {
            self.real_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool active_plus_subscription = 51;

        pub fn active_plus_subscription(&self) -> bool {
            self.active_plus_subscription.unwrap_or(false)
        }

        pub fn clear_active_plus_subscription(&mut self) {
            self.active_plus_subscription = ::std::option::Option::None;
        }

        pub fn has_active_plus_subscription(&self) -> bool {
            self.active_plus_subscription.is_some()
        }

        // Param is passed by value, moved
        pub fn set_active_plus_subscription(&mut self, v: bool) {
            self.active_plus_subscription = ::std::option::Option::Some(v);
        }

        // optional uint32 net_worth = 52;

        pub fn net_worth(&self) -> u32 {
            self.net_worth.unwrap_or(0)
        }

        pub fn clear_net_worth(&mut self) {
            self.net_worth = ::std::option::Option::None;
        }

        pub fn has_net_worth(&self) -> bool {
            self.net_worth.is_some()
        }

        // Param is passed by value, moved
        pub fn set_net_worth(&mut self, v: u32) {
            self.net_worth = ::std::option::Option::Some(v);
        }

        // optional uint32 bot_difficulty = 58;

        pub fn bot_difficulty(&self) -> u32 {
            self.bot_difficulty.unwrap_or(0)
        }

        pub fn clear_bot_difficulty(&mut self) {
            self.bot_difficulty = ::std::option::Option::None;
        }

        pub fn has_bot_difficulty(&self) -> bool {
            self.bot_difficulty.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bot_difficulty(&mut self, v: u32) {
            self.bot_difficulty = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_pick_order = 63;

        pub fn hero_pick_order(&self) -> u32 {
            self.hero_pick_order.unwrap_or(0)
        }

        pub fn clear_hero_pick_order(&mut self) {
            self.hero_pick_order = ::std::option::Option::None;
        }

        pub fn has_hero_pick_order(&self) -> bool {
            self.hero_pick_order.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_pick_order(&mut self, v: u32) {
            self.hero_pick_order = ::std::option::Option::Some(v);
        }

        // optional bool hero_was_randomed = 64;

        pub fn hero_was_randomed(&self) -> bool {
            self.hero_was_randomed.unwrap_or(false)
        }

        pub fn clear_hero_was_randomed(&mut self) {
            self.hero_was_randomed = ::std::option::Option::None;
        }

        pub fn has_hero_was_randomed(&self) -> bool {
            self.hero_was_randomed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_was_randomed(&mut self, v: bool) {
            self.hero_was_randomed = ::std::option::Option::Some(v);
        }

        // optional bool hero_was_dota_plus_suggestion = 69;

        pub fn hero_was_dota_plus_suggestion(&self) -> bool {
            self.hero_was_dota_plus_suggestion.unwrap_or(false)
        }

        pub fn clear_hero_was_dota_plus_suggestion(&mut self) {
            self.hero_was_dota_plus_suggestion = ::std::option::Option::None;
        }

        pub fn has_hero_was_dota_plus_suggestion(&self) -> bool {
            self.hero_was_dota_plus_suggestion.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_was_dota_plus_suggestion(&mut self, v: bool) {
            self.hero_was_dota_plus_suggestion = ::std::option::Option::Some(v);
        }

        // optional uint32 seconds_dead = 70;

        pub fn seconds_dead(&self) -> u32 {
            self.seconds_dead.unwrap_or(0)
        }

        pub fn clear_seconds_dead(&mut self) {
            self.seconds_dead = ::std::option::Option::None;
        }

        pub fn has_seconds_dead(&self) -> bool {
            self.seconds_dead.is_some()
        }

        // Param is passed by value, moved
        pub fn set_seconds_dead(&mut self, v: u32) {
            self.seconds_dead = ::std::option::Option::Some(v);
        }

        // optional uint32 gold_lost_to_death = 71;

        pub fn gold_lost_to_death(&self) -> u32 {
            self.gold_lost_to_death.unwrap_or(0)
        }

        pub fn clear_gold_lost_to_death(&mut self) {
            self.gold_lost_to_death = ::std::option::Option::None;
        }

        pub fn has_gold_lost_to_death(&self) -> bool {
            self.gold_lost_to_death.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold_lost_to_death(&mut self, v: u32) {
            self.gold_lost_to_death = ::std::option::Option::Some(v);
        }

        // optional uint32 lane_selection_flags = 75;

        pub fn lane_selection_flags(&self) -> u32 {
            self.lane_selection_flags.unwrap_or(0)
        }

        pub fn clear_lane_selection_flags(&mut self) {
            self.lane_selection_flags = ::std::option::Option::None;
        }

        pub fn has_lane_selection_flags(&self) -> bool {
            self.lane_selection_flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lane_selection_flags(&mut self, v: u32) {
            self.lane_selection_flags = ::std::option::Option::Some(v);
        }

        // optional uint32 bounty_runes = 77;

        pub fn bounty_runes(&self) -> u32 {
            self.bounty_runes.unwrap_or(0)
        }

        pub fn clear_bounty_runes(&mut self) {
            self.bounty_runes = ::std::option::Option::None;
        }

        pub fn has_bounty_runes(&self) -> bool {
            self.bounty_runes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bounty_runes(&mut self, v: u32) {
            self.bounty_runes = ::std::option::Option::Some(v);
        }

        // optional uint32 outposts_captured = 78;

        pub fn outposts_captured(&self) -> u32 {
            self.outposts_captured.unwrap_or(0)
        }

        pub fn clear_outposts_captured(&mut self) {
            self.outposts_captured = ::std::option::Option::None;
        }

        pub fn has_outposts_captured(&self) -> bool {
            self.outposts_captured.is_some()
        }

        // Param is passed by value, moved
        pub fn set_outposts_captured(&mut self, v: u32) {
            self.outposts_captured = ::std::option::Option::Some(v);
        }

        // optional .DOTA_GC_TEAM team_number = 80;

        pub fn team_number(&self) -> super::super::dota_shared_enums::DOTA_GC_TEAM {
            match self.team_number {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
                None => super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
            }
        }

        pub fn clear_team_number(&mut self) {
            self.team_number = ::std::option::Option::None;
        }

        pub fn has_team_number(&self) -> bool {
            self.team_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_number(&mut self, v: super::super::dota_shared_enums::DOTA_GC_TEAM) {
            self.team_number = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 team_slot = 81;

        pub fn team_slot(&self) -> u32 {
            self.team_slot.unwrap_or(0)
        }

        pub fn clear_team_slot(&mut self) {
            self.team_slot = ::std::option::Option::None;
        }

        pub fn has_team_slot(&self) -> bool {
            self.team_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_slot(&mut self, v: u32) {
            self.team_slot = ::std::option::Option::Some(v);
        }

        // optional uint32 selected_facet = 82;

        pub fn selected_facet(&self) -> u32 {
            self.selected_facet.unwrap_or(0)
        }

        pub fn clear_selected_facet(&mut self) {
            self.selected_facet = ::std::option::Option::None;
        }

        pub fn has_selected_facet(&self) -> bool {
            self.selected_facet.is_some()
        }

        // Param is passed by value, moved
        pub fn set_selected_facet(&mut self, v: u32) {
            self.selected_facet = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.item_0 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.item_1 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.item_2 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.item_3 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.item_4 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    72 => {
                        self.item_5 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    472 => {
                        self.item_6 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    480 => {
                        self.item_7 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    488 => {
                        self.item_8 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    608 => {
                        self.item_9 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    85 => {
                        self.expected_team_contribution = ::std::option::Option::Some(is.read_float()?);
                    },
                    93 => {
                        self.scaled_metric = ::std::option::Option::Some(is.read_float()?);
                    },
                    96 => {
                        self.previous_rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.rank_change = ::std::option::Option::Some(is.read_sint32()?);
                    },
                    592 => {
                        self.mmr_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    120 => {
                        self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    128 => {
                        self.assists = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    136 => {
                        self.leaver_status = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    144 => {
                        self.gold = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    152 => {
                        self.last_hits = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    160 => {
                        self.denies = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    168 => {
                        self.gold_per_min = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    176 => {
                        self.xp_per_min = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    184 => {
                        self.gold_spent = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    192 => {
                        self.hero_damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    200 => {
                        self.tower_damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    208 => {
                        self.hero_healing = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    216 => {
                        self.level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    224 => {
                        self.time_last_seen = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    234 => {
                        self.player_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    240 => {
                        self.support_ability_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    256 => {
                        self.feeding_detected = ::std::option::Option::Some(is.read_bool()?);
                    },
                    272 => {
                        self.search_rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    280 => {
                        self.search_rank_uncertainty = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    288 => {
                        self.rank_uncertainty_change = ::std::option::Option::Some(is.read_int32()?);
                    },
                    296 => {
                        self.hero_play_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    305 => {
                        self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    432 => {
                        self.scaled_hero_damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    440 => {
                        self.scaled_tower_damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    448 => {
                        self.scaled_hero_healing = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    317 => {
                        self.scaled_kills = ::std::option::Option::Some(is.read_float()?);
                    },
                    325 => {
                        self.scaled_deaths = ::std::option::Option::Some(is.read_float()?);
                    },
                    333 => {
                        self.scaled_assists = ::std::option::Option::Some(is.read_float()?);
                    },
                    336 => {
                        self.claimed_farm_gold = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    344 => {
                        self.support_gold = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    352 => {
                        self.claimed_denies = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    360 => {
                        self.claimed_misses = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    368 => {
                        self.misses = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    378 => {
                        self.ability_upgrades.push(is.read_message()?);
                    },
                    386 => {
                        self.additional_units_inventory.push(is.read_message()?);
                    },
                    458 => {
                        self.permanent_buffs.push(is.read_message()?);
                    },
                    578 => {
                        self.pro_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    586 => {
                        self.real_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    402 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.custom_game_data)?;
                    },
                    408 => {
                        self.active_plus_subscription = ::std::option::Option::Some(is.read_bool()?);
                    },
                    416 => {
                        self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    464 => {
                        self.bot_difficulty = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    504 => {
                        self.hero_pick_order = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    512 => {
                        self.hero_was_randomed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    552 => {
                        self.hero_was_dota_plus_suggestion = ::std::option::Option::Some(is.read_bool()?);
                    },
                    538 => {
                        self.hero_damage_received.push(is.read_message()?);
                    },
                    634 => {
                        self.hero_damage_dealt.push(is.read_message()?);
                    },
                    560 => {
                        self.seconds_dead = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    568 => {
                        self.gold_lost_to_death = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    600 => {
                        self.lane_selection_flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    616 => {
                        self.bounty_runes = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    624 => {
                        self.outposts_captured = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    640 => {
                        self.team_number = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    648 => {
                        self.team_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    656 => {
                        self.selected_facet = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.player_slot {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.item_0 {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.item_1 {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.item_2 {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.item_3 {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.item_4 {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
            }
            if let Some(v) = self.item_5 {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, v);
            }
            if let Some(v) = self.item_6 {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(59, v);
            }
            if let Some(v) = self.item_7 {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(60, v);
            }
            if let Some(v) = self.item_8 {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(61, v);
            }
            if let Some(v) = self.item_9 {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(76, v);
            }
            if let Some(v) = self.expected_team_contribution {
                my_size += 1 + 4;
            }
            if let Some(v) = self.scaled_metric {
                my_size += 1 + 4;
            }
            if let Some(v) = self.previous_rank {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.rank_change {
                my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(13, v);
            }
            if let Some(v) = self.mmr_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(74, v);
            }
            if let Some(v) = self.kills {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
            }
            if let Some(v) = self.deaths {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
            }
            if let Some(v) = self.assists {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
            }
            if let Some(v) = self.leaver_status {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
            }
            if let Some(v) = self.gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
            }
            if let Some(v) = self.last_hits {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
            }
            if let Some(v) = self.denies {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
            }
            if let Some(v) = self.gold_per_min {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
            }
            if let Some(v) = self.xp_per_min {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
            }
            if let Some(v) = self.gold_spent {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, v);
            }
            if let Some(v) = self.hero_damage {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(24, v);
            }
            if let Some(v) = self.tower_damage {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(25, v);
            }
            if let Some(v) = self.hero_healing {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(26, v);
            }
            if let Some(v) = self.level {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(27, v);
            }
            if let Some(v) = self.time_last_seen {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(28, v);
            }
            if let Some(v) = self.player_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(29, &v);
            }
            if let Some(v) = self.support_ability_value {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(30, v);
            }
            if let Some(v) = self.feeding_detected {
                my_size += 2 + 1;
            }
            if let Some(v) = self.search_rank {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(34, v);
            }
            if let Some(v) = self.search_rank_uncertainty {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(35, v);
            }
            if let Some(v) = self.rank_uncertainty_change {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(36, v);
            }
            if let Some(v) = self.hero_play_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(37, v);
            }
            if let Some(v) = self.party_id {
                my_size += 2 + 8;
            }
            if let Some(v) = self.scaled_hero_damage {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(54, v);
            }
            if let Some(v) = self.scaled_tower_damage {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(55, v);
            }
            if let Some(v) = self.scaled_hero_healing {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(56, v);
            }
            if let Some(v) = self.scaled_kills {
                my_size += 2 + 4;
            }
            if let Some(v) = self.scaled_deaths {
                my_size += 2 + 4;
            }
            if let Some(v) = self.scaled_assists {
                my_size += 2 + 4;
            }
            if let Some(v) = self.claimed_farm_gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(42, v);
            }
            if let Some(v) = self.support_gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(43, v);
            }
            if let Some(v) = self.claimed_denies {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(44, v);
            }
            if let Some(v) = self.claimed_misses {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(45, v);
            }
            if let Some(v) = self.misses {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(46, v);
            }
            for value in &self.ability_upgrades {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.additional_units_inventory {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.permanent_buffs {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.pro_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(72, &v);
            }
            if let Some(v) = self.real_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(73, &v);
            }
            if let Some(v) = self.custom_game_data.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.active_plus_subscription {
                my_size += 2 + 1;
            }
            if let Some(v) = self.net_worth {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(52, v);
            }
            if let Some(v) = self.bot_difficulty {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(58, v);
            }
            if let Some(v) = self.hero_pick_order {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(63, v);
            }
            if let Some(v) = self.hero_was_randomed {
                my_size += 2 + 1;
            }
            if let Some(v) = self.hero_was_dota_plus_suggestion {
                my_size += 2 + 1;
            }
            for value in &self.hero_damage_received {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.hero_damage_dealt {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.seconds_dead {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(70, v);
            }
            if let Some(v) = self.gold_lost_to_death {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(71, v);
            }
            if let Some(v) = self.lane_selection_flags {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(75, v);
            }
            if let Some(v) = self.bounty_runes {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(77, v);
            }
            if let Some(v) = self.outposts_captured {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(78, v);
            }
            if let Some(v) = self.team_number {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(80, v.value());
            }
            if let Some(v) = self.team_slot {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(81, v);
            }
            if let Some(v) = self.selected_facet {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(82, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.player_slot {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.item_0 {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.item_1 {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.item_2 {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.item_3 {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.item_4 {
                os.write_int32(8, v)?;
            }
            if let Some(v) = self.item_5 {
                os.write_int32(9, v)?;
            }
            if let Some(v) = self.item_6 {
                os.write_int32(59, v)?;
            }
            if let Some(v) = self.item_7 {
                os.write_int32(60, v)?;
            }
            if let Some(v) = self.item_8 {
                os.write_int32(61, v)?;
            }
            if let Some(v) = self.item_9 {
                os.write_int32(76, v)?;
            }
            if let Some(v) = self.expected_team_contribution {
                os.write_float(10, v)?;
            }
            if let Some(v) = self.scaled_metric {
                os.write_float(11, v)?;
            }
            if let Some(v) = self.previous_rank {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.rank_change {
                os.write_sint32(13, v)?;
            }
            if let Some(v) = self.mmr_type {
                os.write_uint32(74, v)?;
            }
            if let Some(v) = self.kills {
                os.write_uint32(14, v)?;
            }
            if let Some(v) = self.deaths {
                os.write_uint32(15, v)?;
            }
            if let Some(v) = self.assists {
                os.write_uint32(16, v)?;
            }
            if let Some(v) = self.leaver_status {
                os.write_uint32(17, v)?;
            }
            if let Some(v) = self.gold {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.last_hits {
                os.write_uint32(19, v)?;
            }
            if let Some(v) = self.denies {
                os.write_uint32(20, v)?;
            }
            if let Some(v) = self.gold_per_min {
                os.write_uint32(21, v)?;
            }
            if let Some(v) = self.xp_per_min {
                os.write_uint32(22, v)?;
            }
            if let Some(v) = self.gold_spent {
                os.write_uint32(23, v)?;
            }
            if let Some(v) = self.hero_damage {
                os.write_uint32(24, v)?;
            }
            if let Some(v) = self.tower_damage {
                os.write_uint32(25, v)?;
            }
            if let Some(v) = self.hero_healing {
                os.write_uint32(26, v)?;
            }
            if let Some(v) = self.level {
                os.write_uint32(27, v)?;
            }
            if let Some(v) = self.time_last_seen {
                os.write_uint32(28, v)?;
            }
            if let Some(v) = self.player_name.as_ref() {
                os.write_string(29, v)?;
            }
            if let Some(v) = self.support_ability_value {
                os.write_uint32(30, v)?;
            }
            if let Some(v) = self.feeding_detected {
                os.write_bool(32, v)?;
            }
            if let Some(v) = self.search_rank {
                os.write_uint32(34, v)?;
            }
            if let Some(v) = self.search_rank_uncertainty {
                os.write_uint32(35, v)?;
            }
            if let Some(v) = self.rank_uncertainty_change {
                os.write_int32(36, v)?;
            }
            if let Some(v) = self.hero_play_count {
                os.write_uint32(37, v)?;
            }
            if let Some(v) = self.party_id {
                os.write_fixed64(38, v)?;
            }
            if let Some(v) = self.scaled_hero_damage {
                os.write_uint32(54, v)?;
            }
            if let Some(v) = self.scaled_tower_damage {
                os.write_uint32(55, v)?;
            }
            if let Some(v) = self.scaled_hero_healing {
                os.write_uint32(56, v)?;
            }
            if let Some(v) = self.scaled_kills {
                os.write_float(39, v)?;
            }
            if let Some(v) = self.scaled_deaths {
                os.write_float(40, v)?;
            }
            if let Some(v) = self.scaled_assists {
                os.write_float(41, v)?;
            }
            if let Some(v) = self.claimed_farm_gold {
                os.write_uint32(42, v)?;
            }
            if let Some(v) = self.support_gold {
                os.write_uint32(43, v)?;
            }
            if let Some(v) = self.claimed_denies {
                os.write_uint32(44, v)?;
            }
            if let Some(v) = self.claimed_misses {
                os.write_uint32(45, v)?;
            }
            if let Some(v) = self.misses {
                os.write_uint32(46, v)?;
            }
            for v in &self.ability_upgrades {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(47, v, os)?;
            };
            for v in &self.additional_units_inventory {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(48, v, os)?;
            };
            for v in &self.permanent_buffs {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(57, v, os)?;
            };
            if let Some(v) = self.pro_name.as_ref() {
                os.write_string(72, v)?;
            }
            if let Some(v) = self.real_name.as_ref() {
                os.write_string(73, v)?;
            }
            if let Some(v) = self.custom_game_data.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(50, v, os)?;
            }
            if let Some(v) = self.active_plus_subscription {
                os.write_bool(51, v)?;
            }
            if let Some(v) = self.net_worth {
                os.write_uint32(52, v)?;
            }
            if let Some(v) = self.bot_difficulty {
                os.write_uint32(58, v)?;
            }
            if let Some(v) = self.hero_pick_order {
                os.write_uint32(63, v)?;
            }
            if let Some(v) = self.hero_was_randomed {
                os.write_bool(64, v)?;
            }
            if let Some(v) = self.hero_was_dota_plus_suggestion {
                os.write_bool(69, v)?;
            }
            for v in &self.hero_damage_received {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(67, v, os)?;
            };
            for v in &self.hero_damage_dealt {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(79, v, os)?;
            };
            if let Some(v) = self.seconds_dead {
                os.write_uint32(70, v)?;
            }
            if let Some(v) = self.gold_lost_to_death {
                os.write_uint32(71, v)?;
            }
            if let Some(v) = self.lane_selection_flags {
                os.write_uint32(75, v)?;
            }
            if let Some(v) = self.bounty_runes {
                os.write_uint32(77, v)?;
            }
            if let Some(v) = self.outposts_captured {
                os.write_uint32(78, v)?;
            }
            if let Some(v) = self.team_number {
                os.write_enum(80, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.team_slot {
                os.write_uint32(81, v)?;
            }
            if let Some(v) = self.selected_facet {
                os.write_uint32(82, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.player_slot = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.item_0 = ::std::option::Option::None;
            self.item_1 = ::std::option::Option::None;
            self.item_2 = ::std::option::Option::None;
            self.item_3 = ::std::option::Option::None;
            self.item_4 = ::std::option::Option::None;
            self.item_5 = ::std::option::Option::None;
            self.item_6 = ::std::option::Option::None;
            self.item_7 = ::std::option::Option::None;
            self.item_8 = ::std::option::Option::None;
            self.item_9 = ::std::option::Option::None;
            self.expected_team_contribution = ::std::option::Option::None;
            self.scaled_metric = ::std::option::Option::None;
            self.previous_rank = ::std::option::Option::None;
            self.rank_change = ::std::option::Option::None;
            self.mmr_type = ::std::option::Option::None;
            self.kills = ::std::option::Option::None;
            self.deaths = ::std::option::Option::None;
            self.assists = ::std::option::Option::None;
            self.leaver_status = ::std::option::Option::None;
            self.gold = ::std::option::Option::None;
            self.last_hits = ::std::option::Option::None;
            self.denies = ::std::option::Option::None;
            self.gold_per_min = ::std::option::Option::None;
            self.xp_per_min = ::std::option::Option::None;
            self.gold_spent = ::std::option::Option::None;
            self.hero_damage = ::std::option::Option::None;
            self.tower_damage = ::std::option::Option::None;
            self.hero_healing = ::std::option::Option::None;
            self.level = ::std::option::Option::None;
            self.time_last_seen = ::std::option::Option::None;
            self.player_name = ::std::option::Option::None;
            self.support_ability_value = ::std::option::Option::None;
            self.feeding_detected = ::std::option::Option::None;
            self.search_rank = ::std::option::Option::None;
            self.search_rank_uncertainty = ::std::option::Option::None;
            self.rank_uncertainty_change = ::std::option::Option::None;
            self.hero_play_count = ::std::option::Option::None;
            self.party_id = ::std::option::Option::None;
            self.scaled_hero_damage = ::std::option::Option::None;
            self.scaled_tower_damage = ::std::option::Option::None;
            self.scaled_hero_healing = ::std::option::Option::None;
            self.scaled_kills = ::std::option::Option::None;
            self.scaled_deaths = ::std::option::Option::None;
            self.scaled_assists = ::std::option::Option::None;
            self.claimed_farm_gold = ::std::option::Option::None;
            self.support_gold = ::std::option::Option::None;
            self.claimed_denies = ::std::option::Option::None;
            self.claimed_misses = ::std::option::Option::None;
            self.misses = ::std::option::Option::None;
            self.ability_upgrades.clear();
            self.additional_units_inventory.clear();
            self.permanent_buffs.clear();
            self.pro_name = ::std::option::Option::None;
            self.real_name = ::std::option::Option::None;
            self.custom_game_data.clear();
            self.active_plus_subscription = ::std::option::Option::None;
            self.net_worth = ::std::option::Option::None;
            self.bot_difficulty = ::std::option::Option::None;
            self.hero_pick_order = ::std::option::Option::None;
            self.hero_was_randomed = ::std::option::Option::None;
            self.hero_was_dota_plus_suggestion = ::std::option::Option::None;
            self.hero_damage_received.clear();
            self.hero_damage_dealt.clear();
            self.seconds_dead = ::std::option::Option::None;
            self.gold_lost_to_death = ::std::option::Option::None;
            self.lane_selection_flags = ::std::option::Option::None;
            self.bounty_runes = ::std::option::Option::None;
            self.outposts_captured = ::std::option::Option::None;
            self.team_number = ::std::option::Option::None;
            self.team_slot = ::std::option::Option::None;
            self.selected_facet = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                player_slot: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                item_0: ::std::option::Option::None,
                item_1: ::std::option::Option::None,
                item_2: ::std::option::Option::None,
                item_3: ::std::option::Option::None,
                item_4: ::std::option::Option::None,
                item_5: ::std::option::Option::None,
                item_6: ::std::option::Option::None,
                item_7: ::std::option::Option::None,
                item_8: ::std::option::Option::None,
                item_9: ::std::option::Option::None,
                expected_team_contribution: ::std::option::Option::None,
                scaled_metric: ::std::option::Option::None,
                previous_rank: ::std::option::Option::None,
                rank_change: ::std::option::Option::None,
                mmr_type: ::std::option::Option::None,
                kills: ::std::option::Option::None,
                deaths: ::std::option::Option::None,
                assists: ::std::option::Option::None,
                leaver_status: ::std::option::Option::None,
                gold: ::std::option::Option::None,
                last_hits: ::std::option::Option::None,
                denies: ::std::option::Option::None,
                gold_per_min: ::std::option::Option::None,
                xp_per_min: ::std::option::Option::None,
                gold_spent: ::std::option::Option::None,
                hero_damage: ::std::option::Option::None,
                tower_damage: ::std::option::Option::None,
                hero_healing: ::std::option::Option::None,
                level: ::std::option::Option::None,
                time_last_seen: ::std::option::Option::None,
                player_name: ::std::option::Option::None,
                support_ability_value: ::std::option::Option::None,
                feeding_detected: ::std::option::Option::None,
                search_rank: ::std::option::Option::None,
                search_rank_uncertainty: ::std::option::Option::None,
                rank_uncertainty_change: ::std::option::Option::None,
                hero_play_count: ::std::option::Option::None,
                party_id: ::std::option::Option::None,
                scaled_hero_damage: ::std::option::Option::None,
                scaled_tower_damage: ::std::option::Option::None,
                scaled_hero_healing: ::std::option::Option::None,
                scaled_kills: ::std::option::Option::None,
                scaled_deaths: ::std::option::Option::None,
                scaled_assists: ::std::option::Option::None,
                claimed_farm_gold: ::std::option::Option::None,
                support_gold: ::std::option::Option::None,
                claimed_denies: ::std::option::Option::None,
                claimed_misses: ::std::option::Option::None,
                misses: ::std::option::Option::None,
                ability_upgrades: ::std::vec::Vec::new(),
                additional_units_inventory: ::std::vec::Vec::new(),
                permanent_buffs: ::std::vec::Vec::new(),
                pro_name: ::std::option::Option::None,
                real_name: ::std::option::Option::None,
                custom_game_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
                active_plus_subscription: ::std::option::Option::None,
                net_worth: ::std::option::Option::None,
                bot_difficulty: ::std::option::Option::None,
                hero_pick_order: ::std::option::Option::None,
                hero_was_randomed: ::std::option::Option::None,
                hero_was_dota_plus_suggestion: ::std::option::Option::None,
                hero_damage_received: ::std::vec::Vec::new(),
                hero_damage_dealt: ::std::vec::Vec::new(),
                seconds_dead: ::std::option::Option::None,
                gold_lost_to_death: ::std::option::Option::None,
                lane_selection_flags: ::std::option::Option::None,
                bounty_runes: ::std::option::Option::None,
                outposts_captured: ::std::option::Option::None,
                team_number: ::std::option::Option::None,
                team_slot: ::std::option::Option::None,
                selected_facet: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Player`
    pub mod player {
        // @@protoc_insertion_point(message:CMsgDOTAMatch.Player.CustomGameData)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CustomGameData {
            // message fields
            // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.CustomGameData.dota_team)
            pub dota_team: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.CustomGameData.winner)
            pub winner: ::std::option::Option<bool>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgDOTAMatch.Player.CustomGameData.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CustomGameData {
            fn default() -> &'a CustomGameData {
                <CustomGameData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl CustomGameData {
            pub fn new() -> CustomGameData {
                ::std::default::Default::default()
            }

            // optional uint32 dota_team = 1;

            pub fn dota_team(&self) -> u32 {
                self.dota_team.unwrap_or(0)
            }

            pub fn clear_dota_team(&mut self) {
                self.dota_team = ::std::option::Option::None;
            }

            pub fn has_dota_team(&self) -> bool {
                self.dota_team.is_some()
            }

            // Param is passed by value, moved
            pub fn set_dota_team(&mut self, v: u32) {
                self.dota_team = ::std::option::Option::Some(v);
            }

            // optional bool winner = 2;

            pub fn winner(&self) -> bool {
                self.winner.unwrap_or(false)
            }

            pub fn clear_winner(&mut self) {
                self.winner = ::std::option::Option::None;
            }

            pub fn has_winner(&self) -> bool {
                self.winner.is_some()
            }

            // Param is passed by value, moved
            pub fn set_winner(&mut self, v: bool) {
                self.winner = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for CustomGameData {
            const NAME: &'static str = "CustomGameData";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.dota_team = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.winner = ::std::option::Option::Some(is.read_bool()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.dota_team {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.winner {
                    my_size += 1 + 1;
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.dota_team {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.winner {
                    os.write_bool(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CustomGameData {
                CustomGameData::new()
            }

            fn clear(&mut self) {
                self.dota_team = ::std::option::Option::None;
                self.winner = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CustomGameData {
                static instance: CustomGameData = CustomGameData {
                    dota_team: ::std::option::Option::None,
                    winner: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CMsgDOTAMatch.Player.HeroDamageReceived)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct HeroDamageReceived {
            // message fields
            // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.HeroDamageReceived.pre_reduction)
            pub pre_reduction: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.HeroDamageReceived.post_reduction)
            pub post_reduction: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgDOTAMatch.Player.HeroDamageReceived.damage_type)
            pub damage_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<HeroDamageType>>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgDOTAMatch.Player.HeroDamageReceived.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a HeroDamageReceived {
            fn default() -> &'a HeroDamageReceived {
                <HeroDamageReceived as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl HeroDamageReceived {
            pub fn new() -> HeroDamageReceived {
                ::std::default::Default::default()
            }

            // optional uint32 pre_reduction = 1;

            pub fn pre_reduction(&self) -> u32 {
                self.pre_reduction.unwrap_or(0)
            }

            pub fn clear_pre_reduction(&mut self) {
                self.pre_reduction = ::std::option::Option::None;
            }

            pub fn has_pre_reduction(&self) -> bool {
                self.pre_reduction.is_some()
            }

            // Param is passed by value, moved
            pub fn set_pre_reduction(&mut self, v: u32) {
                self.pre_reduction = ::std::option::Option::Some(v);
            }

            // optional uint32 post_reduction = 2;

            pub fn post_reduction(&self) -> u32 {
                self.post_reduction.unwrap_or(0)
            }

            pub fn clear_post_reduction(&mut self) {
                self.post_reduction = ::std::option::Option::None;
            }

            pub fn has_post_reduction(&self) -> bool {
                self.post_reduction.is_some()
            }

            // Param is passed by value, moved
            pub fn set_post_reduction(&mut self, v: u32) {
                self.post_reduction = ::std::option::Option::Some(v);
            }

            // optional .CMsgDOTAMatch.Player.HeroDamageType damage_type = 3;

            pub fn damage_type(&self) -> HeroDamageType {
                match self.damage_type {
                    Some(e) => e.enum_value_or(HeroDamageType::HERO_DAMAGE_PHYSICAL),
                    None => HeroDamageType::HERO_DAMAGE_PHYSICAL,
                }
            }

            pub fn clear_damage_type(&mut self) {
                self.damage_type = ::std::option::Option::None;
            }

            pub fn has_damage_type(&self) -> bool {
                self.damage_type.is_some()
            }

            // Param is passed by value, moved
            pub fn set_damage_type(&mut self, v: HeroDamageType) {
                self.damage_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for HeroDamageReceived {
            const NAME: &'static str = "HeroDamageReceived";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.pre_reduction = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.post_reduction = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.damage_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.pre_reduction {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.post_reduction {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.damage_type {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.pre_reduction {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.post_reduction {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.damage_type {
                    os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> HeroDamageReceived {
                HeroDamageReceived::new()
            }

            fn clear(&mut self) {
                self.pre_reduction = ::std::option::Option::None;
                self.post_reduction = ::std::option::Option::None;
                self.damage_type = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static HeroDamageReceived {
                static instance: HeroDamageReceived = HeroDamageReceived {
                    pre_reduction: ::std::option::Option::None,
                    post_reduction: ::std::option::Option::None,
                    damage_type: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:CMsgDOTAMatch.Player.HeroDamageType)
        pub enum HeroDamageType {
            // @@protoc_insertion_point(enum_value:CMsgDOTAMatch.Player.HeroDamageType.HERO_DAMAGE_PHYSICAL)
            HERO_DAMAGE_PHYSICAL = 0,
            // @@protoc_insertion_point(enum_value:CMsgDOTAMatch.Player.HeroDamageType.HERO_DAMAGE_MAGICAL)
            HERO_DAMAGE_MAGICAL = 1,
            // @@protoc_insertion_point(enum_value:CMsgDOTAMatch.Player.HeroDamageType.HERO_DAMAGE_PURE)
            HERO_DAMAGE_PURE = 2,
        }

        impl ::steam_vent_proto_common::protobuf::Enum for HeroDamageType {
            const NAME: &'static str = "HeroDamageType";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<HeroDamageType> {
                match value {
                    0 => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_PHYSICAL),
                    1 => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_MAGICAL),
                    2 => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_PURE),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<HeroDamageType> {
                match str {
                    "HERO_DAMAGE_PHYSICAL" => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_PHYSICAL),
                    "HERO_DAMAGE_MAGICAL" => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_MAGICAL),
                    "HERO_DAMAGE_PURE" => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_PURE),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [HeroDamageType] = &[
                HeroDamageType::HERO_DAMAGE_PHYSICAL,
                HeroDamageType::HERO_DAMAGE_MAGICAL,
                HeroDamageType::HERO_DAMAGE_PURE,
            ];
        }

        impl ::std::default::Default for HeroDamageType {
            fn default() -> Self {
                HeroDamageType::HERO_DAMAGE_PHYSICAL
            }
        }

    }

    // @@protoc_insertion_point(message:CMsgDOTAMatch.BroadcasterInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BroadcasterInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAMatch.BroadcasterInfo.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.BroadcasterInfo.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAMatch.BroadcasterInfo.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BroadcasterInfo {
        fn default() -> &'a BroadcasterInfo {
            <BroadcasterInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl BroadcasterInfo {
        pub fn new() -> BroadcasterInfo {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for BroadcasterInfo {
        const NAME: &'static str = "BroadcasterInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BroadcasterInfo {
            BroadcasterInfo::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BroadcasterInfo {
            static instance: BroadcasterInfo = BroadcasterInfo {
                account_id: ::std::option::Option::None,
                name: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTAMatch.BroadcasterChannel)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BroadcasterChannel {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAMatch.BroadcasterChannel.country_code)
        pub country_code: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.BroadcasterChannel.description)
        pub description: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.BroadcasterChannel.broadcaster_infos)
        pub broadcaster_infos: ::std::vec::Vec<BroadcasterInfo>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.BroadcasterChannel.language_code)
        pub language_code: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAMatch.BroadcasterChannel.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BroadcasterChannel {
        fn default() -> &'a BroadcasterChannel {
            <BroadcasterChannel as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl BroadcasterChannel {
        pub fn new() -> BroadcasterChannel {
            ::std::default::Default::default()
        }

        // optional string country_code = 1;

        pub fn country_code(&self) -> &str {
            match self.country_code.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_country_code(&mut self) {
            self.country_code = ::std::option::Option::None;
        }

        pub fn has_country_code(&self) -> bool {
            self.country_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_country_code(&mut self, v: ::std::string::String) {
            self.country_code = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
            if self.country_code.is_none() {
                self.country_code = ::std::option::Option::Some(::std::string::String::new());
            }
            self.country_code.as_mut().unwrap()
        }

        // Take field
        pub fn take_country_code(&mut self) -> ::std::string::String {
            self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string description = 2;

        pub fn description(&self) -> &str {
            match self.description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_description(&mut self) {
            self.description = ::std::option::Option::None;
        }

        pub fn has_description(&self) -> bool {
            self.description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_description(&mut self, v: ::std::string::String) {
            self.description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_description(&mut self) -> &mut ::std::string::String {
            if self.description.is_none() {
                self.description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.description.as_mut().unwrap()
        }

        // Take field
        pub fn take_description(&mut self) -> ::std::string::String {
            self.description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string language_code = 4;

        pub fn language_code(&self) -> &str {
            match self.language_code.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_language_code(&mut self) {
            self.language_code = ::std::option::Option::None;
        }

        pub fn has_language_code(&self) -> bool {
            self.language_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_language_code(&mut self, v: ::std::string::String) {
            self.language_code = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_language_code(&mut self) -> &mut ::std::string::String {
            if self.language_code.is_none() {
                self.language_code = ::std::option::Option::Some(::std::string::String::new());
            }
            self.language_code.as_mut().unwrap()
        }

        // Take field
        pub fn take_language_code(&mut self) -> ::std::string::String {
            self.language_code.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for BroadcasterChannel {
        const NAME: &'static str = "BroadcasterChannel";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.country_code = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.description = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.broadcaster_infos.push(is.read_message()?);
                    },
                    34 => {
                        self.language_code = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.country_code.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.description.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            for value in &self.broadcaster_infos {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.language_code.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.country_code.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.description.as_ref() {
                os.write_string(2, v)?;
            }
            for v in &self.broadcaster_infos {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            if let Some(v) = self.language_code.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BroadcasterChannel {
            BroadcasterChannel::new()
        }

        fn clear(&mut self) {
            self.country_code = ::std::option::Option::None;
            self.description = ::std::option::Option::None;
            self.broadcaster_infos.clear();
            self.language_code = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BroadcasterChannel {
            static instance: BroadcasterChannel = BroadcasterChannel {
                country_code: ::std::option::Option::None,
                description: ::std::option::Option::None,
                broadcaster_infos: ::std::vec::Vec::new(),
                language_code: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTAMatch.Coach)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Coach {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Coach.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Coach.coach_name)
        pub coach_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Coach.coach_rating)
        pub coach_rating: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Coach.coach_team)
        pub coach_team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Coach.coach_party_id)
        pub coach_party_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.Coach.is_private_coach)
        pub is_private_coach: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAMatch.Coach.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Coach {
        fn default() -> &'a Coach {
            <Coach as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Coach {
        pub fn new() -> Coach {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional string coach_name = 2;

        pub fn coach_name(&self) -> &str {
            match self.coach_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_coach_name(&mut self) {
            self.coach_name = ::std::option::Option::None;
        }

        pub fn has_coach_name(&self) -> bool {
            self.coach_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_coach_name(&mut self, v: ::std::string::String) {
            self.coach_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_coach_name(&mut self) -> &mut ::std::string::String {
            if self.coach_name.is_none() {
                self.coach_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.coach_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_coach_name(&mut self) -> ::std::string::String {
            self.coach_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 coach_rating = 3;

        pub fn coach_rating(&self) -> u32 {
            self.coach_rating.unwrap_or(0)
        }

        pub fn clear_coach_rating(&mut self) {
            self.coach_rating = ::std::option::Option::None;
        }

        pub fn has_coach_rating(&self) -> bool {
            self.coach_rating.is_some()
        }

        // Param is passed by value, moved
        pub fn set_coach_rating(&mut self, v: u32) {
            self.coach_rating = ::std::option::Option::Some(v);
        }

        // optional uint32 coach_team = 4;

        pub fn coach_team(&self) -> u32 {
            self.coach_team.unwrap_or(0)
        }

        pub fn clear_coach_team(&mut self) {
            self.coach_team = ::std::option::Option::None;
        }

        pub fn has_coach_team(&self) -> bool {
            self.coach_team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_coach_team(&mut self, v: u32) {
            self.coach_team = ::std::option::Option::Some(v);
        }

        // optional uint64 coach_party_id = 5;

        pub fn coach_party_id(&self) -> u64 {
            self.coach_party_id.unwrap_or(0)
        }

        pub fn clear_coach_party_id(&mut self) {
            self.coach_party_id = ::std::option::Option::None;
        }

        pub fn has_coach_party_id(&self) -> bool {
            self.coach_party_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_coach_party_id(&mut self, v: u64) {
            self.coach_party_id = ::std::option::Option::Some(v);
        }

        // optional bool is_private_coach = 6;

        pub fn is_private_coach(&self) -> bool {
            self.is_private_coach.unwrap_or(false)
        }

        pub fn clear_is_private_coach(&mut self) {
            self.is_private_coach = ::std::option::Option::None;
        }

        pub fn has_is_private_coach(&self) -> bool {
            self.is_private_coach.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_private_coach(&mut self, v: bool) {
            self.is_private_coach = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Coach {
        const NAME: &'static str = "Coach";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.coach_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.coach_rating = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.coach_team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.coach_party_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    48 => {
                        self.is_private_coach = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.coach_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.coach_rating {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.coach_team {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.coach_party_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
            }
            if let Some(v) = self.is_private_coach {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.coach_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.coach_rating {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.coach_team {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.coach_party_id {
                os.write_uint64(5, v)?;
            }
            if let Some(v) = self.is_private_coach {
                os.write_bool(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Coach {
            Coach::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.coach_name = ::std::option::Option::None;
            self.coach_rating = ::std::option::Option::None;
            self.coach_team = ::std::option::Option::None;
            self.coach_party_id = ::std::option::Option::None;
            self.is_private_coach = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Coach {
            static instance: Coach = Coach {
                account_id: ::std::option::Option::None,
                coach_name: ::std::option::Option::None,
                coach_rating: ::std::option::Option::None,
                coach_team: ::std::option::Option::None,
                coach_party_id: ::std::option::Option::None,
                is_private_coach: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTAMatch.CustomGameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CustomGameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAMatch.CustomGameData.custom_game_id)
        pub custom_game_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTAMatch.CustomGameData.map_name)
        pub map_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAMatch.CustomGameData.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CustomGameData {
        fn default() -> &'a CustomGameData {
            <CustomGameData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CustomGameData {
        pub fn new() -> CustomGameData {
            ::std::default::Default::default()
        }

        // optional uint64 custom_game_id = 1;

        pub fn custom_game_id(&self) -> u64 {
            self.custom_game_id.unwrap_or(0)
        }

        pub fn clear_custom_game_id(&mut self) {
            self.custom_game_id = ::std::option::Option::None;
        }

        pub fn has_custom_game_id(&self) -> bool {
            self.custom_game_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_custom_game_id(&mut self, v: u64) {
            self.custom_game_id = ::std::option::Option::Some(v);
        }

        // optional string map_name = 2;

        pub fn map_name(&self) -> &str {
            match self.map_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_map_name(&mut self) {
            self.map_name = ::std::option::Option::None;
        }

        pub fn has_map_name(&self) -> bool {
            self.map_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_map_name(&mut self, v: ::std::string::String) {
            self.map_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
            if self.map_name.is_none() {
                self.map_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.map_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_map_name(&mut self) -> ::std::string::String {
            self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CustomGameData {
        const NAME: &'static str = "CustomGameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.map_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.custom_game_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.map_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.custom_game_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.map_name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CustomGameData {
            CustomGameData::new()
        }

        fn clear(&mut self) {
            self.custom_game_id = ::std::option::Option::None;
            self.map_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CustomGameData {
            static instance: CustomGameData = CustomGameData {
                custom_game_id: ::std::option::Option::None,
                map_name: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgDOTAMatch.ReplayState)
    pub enum ReplayState {
        // @@protoc_insertion_point(enum_value:CMsgDOTAMatch.ReplayState.REPLAY_AVAILABLE)
        REPLAY_AVAILABLE = 0,
        // @@protoc_insertion_point(enum_value:CMsgDOTAMatch.ReplayState.REPLAY_NOT_RECORDED)
        REPLAY_NOT_RECORDED = 1,
        // @@protoc_insertion_point(enum_value:CMsgDOTAMatch.ReplayState.REPLAY_EXPIRED)
        REPLAY_EXPIRED = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for ReplayState {
        const NAME: &'static str = "ReplayState";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ReplayState> {
            match value {
                0 => ::std::option::Option::Some(ReplayState::REPLAY_AVAILABLE),
                1 => ::std::option::Option::Some(ReplayState::REPLAY_NOT_RECORDED),
                2 => ::std::option::Option::Some(ReplayState::REPLAY_EXPIRED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ReplayState> {
            match str {
                "REPLAY_AVAILABLE" => ::std::option::Option::Some(ReplayState::REPLAY_AVAILABLE),
                "REPLAY_NOT_RECORDED" => ::std::option::Option::Some(ReplayState::REPLAY_NOT_RECORDED),
                "REPLAY_EXPIRED" => ::std::option::Option::Some(ReplayState::REPLAY_EXPIRED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ReplayState] = &[
            ReplayState::REPLAY_AVAILABLE,
            ReplayState::REPLAY_NOT_RECORDED,
            ReplayState::REPLAY_EXPIRED,
        ];
    }

    impl ::std::default::Default for ReplayState {
        fn default() -> Self {
            ReplayState::REPLAY_AVAILABLE
        }
    }

}

// @@protoc_insertion_point(message:CMsgPlayerCard)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerCard {
    // message fields
    // @@protoc_insertion_point(field:CMsgPlayerCard.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerCard.stat_modifier)
    pub stat_modifier: ::std::vec::Vec<cmsg_player_card::StatModifier>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPlayerCard.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerCard {
    fn default() -> &'a CMsgPlayerCard {
        <CMsgPlayerCard as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerCard {
    pub fn new() -> CMsgPlayerCard {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPlayerCard {
    const NAME: &'static str = "CMsgPlayerCard";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.stat_modifier.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.stat_modifier {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.stat_modifier {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerCard {
        CMsgPlayerCard::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.stat_modifier.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerCard {
        static instance: CMsgPlayerCard = CMsgPlayerCard {
            account_id: ::std::option::Option::None,
            stat_modifier: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgPlayerCard`
pub mod cmsg_player_card {
    // @@protoc_insertion_point(message:CMsgPlayerCard.StatModifier)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StatModifier {
        // message fields
        // @@protoc_insertion_point(field:CMsgPlayerCard.StatModifier.stat)
        pub stat: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgPlayerCard.StatModifier.value)
        pub value: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgPlayerCard.StatModifier.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StatModifier {
        fn default() -> &'a StatModifier {
            <StatModifier as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl StatModifier {
        pub fn new() -> StatModifier {
            ::std::default::Default::default()
        }

        // optional uint32 stat = 1;

        pub fn stat(&self) -> u32 {
            self.stat.unwrap_or(0)
        }

        pub fn clear_stat(&mut self) {
            self.stat = ::std::option::Option::None;
        }

        pub fn has_stat(&self) -> bool {
            self.stat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat(&mut self, v: u32) {
            self.stat = ::std::option::Option::Some(v);
        }

        // optional uint32 value = 2;

        pub fn value(&self) -> u32 {
            self.value.unwrap_or(0)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: u32) {
            self.value = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for StatModifier {
        const NAME: &'static str = "StatModifier";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.stat = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.stat {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.value {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.stat {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.value {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StatModifier {
            StatModifier::new()
        }

        fn clear(&mut self) {
            self.stat = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StatModifier {
            static instance: StatModifier = StatModifier {
                stat: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTAFantasyPlayerStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAFantasyPlayerStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.player_account_id)
    pub player_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.match_completed)
    pub match_completed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.team_id)
    pub team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.league_id)
    pub league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.delay)
    pub delay: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.series_id)
    pub series_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.series_type)
    pub series_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.kills)
    pub kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.deaths)
    pub deaths: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.cs)
    pub cs: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.gpm)
    pub gpm: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.tower_kills)
    pub tower_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.roshan_kills)
    pub roshan_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.teamfight_participation)
    pub teamfight_participation: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.wards_placed)
    pub wards_placed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.camps_stacked)
    pub camps_stacked: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.runes_grabbed)
    pub runes_grabbed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.first_blood)
    pub first_blood: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.stuns)
    pub stuns: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.smokes)
    pub smokes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.neutral_tokens)
    pub neutral_tokens: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.watchers)
    pub watchers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.lotuses)
    pub lotuses: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.tormentors)
    pub tormentors: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.courier_kills)
    pub courier_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerStats.title_stats)
    pub title_stats: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAFantasyPlayerStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAFantasyPlayerStats {
    fn default() -> &'a CMsgDOTAFantasyPlayerStats {
        <CMsgDOTAFantasyPlayerStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAFantasyPlayerStats {
    pub fn new() -> CMsgDOTAFantasyPlayerStats {
        ::std::default::Default::default()
    }

    // optional uint32 player_account_id = 1;

    pub fn player_account_id(&self) -> u32 {
        self.player_account_id.unwrap_or(0)
    }

    pub fn clear_player_account_id(&mut self) {
        self.player_account_id = ::std::option::Option::None;
    }

    pub fn has_player_account_id(&self) -> bool {
        self.player_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_account_id(&mut self, v: u32) {
        self.player_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional bool match_completed = 3;

    pub fn match_completed(&self) -> bool {
        self.match_completed.unwrap_or(false)
    }

    pub fn clear_match_completed(&mut self) {
        self.match_completed = ::std::option::Option::None;
    }

    pub fn has_match_completed(&self) -> bool {
        self.match_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_completed(&mut self, v: bool) {
        self.match_completed = ::std::option::Option::Some(v);
    }

    // optional uint32 team_id = 4;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 5;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional uint32 delay = 6;

    pub fn delay(&self) -> u32 {
        self.delay.unwrap_or(0)
    }

    pub fn clear_delay(&mut self) {
        self.delay = ::std::option::Option::None;
    }

    pub fn has_delay(&self) -> bool {
        self.delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay(&mut self, v: u32) {
        self.delay = ::std::option::Option::Some(v);
    }

    // optional uint32 series_id = 7;

    pub fn series_id(&self) -> u32 {
        self.series_id.unwrap_or(0)
    }

    pub fn clear_series_id(&mut self) {
        self.series_id = ::std::option::Option::None;
    }

    pub fn has_series_id(&self) -> bool {
        self.series_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_id(&mut self, v: u32) {
        self.series_id = ::std::option::Option::Some(v);
    }

    // optional uint32 series_type = 8;

    pub fn series_type(&self) -> u32 {
        self.series_type.unwrap_or(0)
    }

    pub fn clear_series_type(&mut self) {
        self.series_type = ::std::option::Option::None;
    }

    pub fn has_series_type(&self) -> bool {
        self.series_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_type(&mut self, v: u32) {
        self.series_type = ::std::option::Option::Some(v);
    }

    // optional uint32 kills = 10;

    pub fn kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional uint32 deaths = 11;

    pub fn deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 cs = 12;

    pub fn cs(&self) -> u32 {
        self.cs.unwrap_or(0)
    }

    pub fn clear_cs(&mut self) {
        self.cs = ::std::option::Option::None;
    }

    pub fn has_cs(&self) -> bool {
        self.cs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cs(&mut self, v: u32) {
        self.cs = ::std::option::Option::Some(v);
    }

    // optional float gpm = 13;

    pub fn gpm(&self) -> f32 {
        self.gpm.unwrap_or(0.)
    }

    pub fn clear_gpm(&mut self) {
        self.gpm = ::std::option::Option::None;
    }

    pub fn has_gpm(&self) -> bool {
        self.gpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpm(&mut self, v: f32) {
        self.gpm = ::std::option::Option::Some(v);
    }

    // optional uint32 tower_kills = 14;

    pub fn tower_kills(&self) -> u32 {
        self.tower_kills.unwrap_or(0)
    }

    pub fn clear_tower_kills(&mut self) {
        self.tower_kills = ::std::option::Option::None;
    }

    pub fn has_tower_kills(&self) -> bool {
        self.tower_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tower_kills(&mut self, v: u32) {
        self.tower_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 roshan_kills = 15;

    pub fn roshan_kills(&self) -> u32 {
        self.roshan_kills.unwrap_or(0)
    }

    pub fn clear_roshan_kills(&mut self) {
        self.roshan_kills = ::std::option::Option::None;
    }

    pub fn has_roshan_kills(&self) -> bool {
        self.roshan_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roshan_kills(&mut self, v: u32) {
        self.roshan_kills = ::std::option::Option::Some(v);
    }

    // optional float teamfight_participation = 16;

    pub fn teamfight_participation(&self) -> f32 {
        self.teamfight_participation.unwrap_or(0.)
    }

    pub fn clear_teamfight_participation(&mut self) {
        self.teamfight_participation = ::std::option::Option::None;
    }

    pub fn has_teamfight_participation(&self) -> bool {
        self.teamfight_participation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teamfight_participation(&mut self, v: f32) {
        self.teamfight_participation = ::std::option::Option::Some(v);
    }

    // optional uint32 wards_placed = 17;

    pub fn wards_placed(&self) -> u32 {
        self.wards_placed.unwrap_or(0)
    }

    pub fn clear_wards_placed(&mut self) {
        self.wards_placed = ::std::option::Option::None;
    }

    pub fn has_wards_placed(&self) -> bool {
        self.wards_placed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wards_placed(&mut self, v: u32) {
        self.wards_placed = ::std::option::Option::Some(v);
    }

    // optional uint32 camps_stacked = 18;

    pub fn camps_stacked(&self) -> u32 {
        self.camps_stacked.unwrap_or(0)
    }

    pub fn clear_camps_stacked(&mut self) {
        self.camps_stacked = ::std::option::Option::None;
    }

    pub fn has_camps_stacked(&self) -> bool {
        self.camps_stacked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camps_stacked(&mut self, v: u32) {
        self.camps_stacked = ::std::option::Option::Some(v);
    }

    // optional uint32 runes_grabbed = 19;

    pub fn runes_grabbed(&self) -> u32 {
        self.runes_grabbed.unwrap_or(0)
    }

    pub fn clear_runes_grabbed(&mut self) {
        self.runes_grabbed = ::std::option::Option::None;
    }

    pub fn has_runes_grabbed(&self) -> bool {
        self.runes_grabbed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runes_grabbed(&mut self, v: u32) {
        self.runes_grabbed = ::std::option::Option::Some(v);
    }

    // optional uint32 first_blood = 20;

    pub fn first_blood(&self) -> u32 {
        self.first_blood.unwrap_or(0)
    }

    pub fn clear_first_blood(&mut self) {
        self.first_blood = ::std::option::Option::None;
    }

    pub fn has_first_blood(&self) -> bool {
        self.first_blood.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood(&mut self, v: u32) {
        self.first_blood = ::std::option::Option::Some(v);
    }

    // optional float stuns = 21;

    pub fn stuns(&self) -> f32 {
        self.stuns.unwrap_or(0.)
    }

    pub fn clear_stuns(&mut self) {
        self.stuns = ::std::option::Option::None;
    }

    pub fn has_stuns(&self) -> bool {
        self.stuns.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stuns(&mut self, v: f32) {
        self.stuns = ::std::option::Option::Some(v);
    }

    // optional uint32 smokes = 22;

    pub fn smokes(&self) -> u32 {
        self.smokes.unwrap_or(0)
    }

    pub fn clear_smokes(&mut self) {
        self.smokes = ::std::option::Option::None;
    }

    pub fn has_smokes(&self) -> bool {
        self.smokes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_smokes(&mut self, v: u32) {
        self.smokes = ::std::option::Option::Some(v);
    }

    // optional uint32 neutral_tokens = 23;

    pub fn neutral_tokens(&self) -> u32 {
        self.neutral_tokens.unwrap_or(0)
    }

    pub fn clear_neutral_tokens(&mut self) {
        self.neutral_tokens = ::std::option::Option::None;
    }

    pub fn has_neutral_tokens(&self) -> bool {
        self.neutral_tokens.is_some()
    }

    // Param is passed by value, moved
    pub fn set_neutral_tokens(&mut self, v: u32) {
        self.neutral_tokens = ::std::option::Option::Some(v);
    }

    // optional uint32 watchers = 24;

    pub fn watchers(&self) -> u32 {
        self.watchers.unwrap_or(0)
    }

    pub fn clear_watchers(&mut self) {
        self.watchers = ::std::option::Option::None;
    }

    pub fn has_watchers(&self) -> bool {
        self.watchers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watchers(&mut self, v: u32) {
        self.watchers = ::std::option::Option::Some(v);
    }

    // optional uint32 lotuses = 25;

    pub fn lotuses(&self) -> u32 {
        self.lotuses.unwrap_or(0)
    }

    pub fn clear_lotuses(&mut self) {
        self.lotuses = ::std::option::Option::None;
    }

    pub fn has_lotuses(&self) -> bool {
        self.lotuses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lotuses(&mut self, v: u32) {
        self.lotuses = ::std::option::Option::Some(v);
    }

    // optional uint32 tormentors = 26;

    pub fn tormentors(&self) -> u32 {
        self.tormentors.unwrap_or(0)
    }

    pub fn clear_tormentors(&mut self) {
        self.tormentors = ::std::option::Option::None;
    }

    pub fn has_tormentors(&self) -> bool {
        self.tormentors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tormentors(&mut self, v: u32) {
        self.tormentors = ::std::option::Option::Some(v);
    }

    // optional uint32 courier_kills = 27;

    pub fn courier_kills(&self) -> u32 {
        self.courier_kills.unwrap_or(0)
    }

    pub fn clear_courier_kills(&mut self) {
        self.courier_kills = ::std::option::Option::None;
    }

    pub fn has_courier_kills(&self) -> bool {
        self.courier_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_courier_kills(&mut self, v: u32) {
        self.courier_kills = ::std::option::Option::Some(v);
    }

    // optional fixed64 title_stats = 28;

    pub fn title_stats(&self) -> u64 {
        self.title_stats.unwrap_or(0)
    }

    pub fn clear_title_stats(&mut self) {
        self.title_stats = ::std::option::Option::None;
    }

    pub fn has_title_stats(&self) -> bool {
        self.title_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title_stats(&mut self, v: u64) {
        self.title_stats = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAFantasyPlayerStats {
    const NAME: &'static str = "CMsgDOTAFantasyPlayerStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.match_completed = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.delay = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.series_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.series_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.cs = ::std::option::Option::Some(is.read_uint32()?);
                },
                109 => {
                    self.gpm = ::std::option::Option::Some(is.read_float()?);
                },
                112 => {
                    self.tower_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.roshan_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                133 => {
                    self.teamfight_participation = ::std::option::Option::Some(is.read_float()?);
                },
                136 => {
                    self.wards_placed = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.camps_stacked = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.runes_grabbed = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.first_blood = ::std::option::Option::Some(is.read_uint32()?);
                },
                173 => {
                    self.stuns = ::std::option::Option::Some(is.read_float()?);
                },
                176 => {
                    self.smokes = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.neutral_tokens = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.watchers = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.lotuses = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.tormentors = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.courier_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                225 => {
                    self.title_stats = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.match_completed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.league_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.delay {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.series_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.series_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.deaths {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.cs {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.gpm {
            my_size += 1 + 4;
        }
        if let Some(v) = self.tower_kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.roshan_kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.teamfight_participation {
            my_size += 2 + 4;
        }
        if let Some(v) = self.wards_placed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.camps_stacked {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.runes_grabbed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.first_blood {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.stuns {
            my_size += 2 + 4;
        }
        if let Some(v) = self.smokes {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.neutral_tokens {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.watchers {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.lotuses {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.tormentors {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.courier_kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.title_stats {
            my_size += 2 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.match_completed {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.delay {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.series_id {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.series_type {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.cs {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.gpm {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.tower_kills {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.roshan_kills {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.teamfight_participation {
            os.write_float(16, v)?;
        }
        if let Some(v) = self.wards_placed {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.camps_stacked {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.runes_grabbed {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.first_blood {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.stuns {
            os.write_float(21, v)?;
        }
        if let Some(v) = self.smokes {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.neutral_tokens {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.watchers {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.lotuses {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.tormentors {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.courier_kills {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.title_stats {
            os.write_fixed64(28, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAFantasyPlayerStats {
        CMsgDOTAFantasyPlayerStats::new()
    }

    fn clear(&mut self) {
        self.player_account_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.match_completed = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.delay = ::std::option::Option::None;
        self.series_id = ::std::option::Option::None;
        self.series_type = ::std::option::Option::None;
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.cs = ::std::option::Option::None;
        self.gpm = ::std::option::Option::None;
        self.tower_kills = ::std::option::Option::None;
        self.roshan_kills = ::std::option::Option::None;
        self.teamfight_participation = ::std::option::Option::None;
        self.wards_placed = ::std::option::Option::None;
        self.camps_stacked = ::std::option::Option::None;
        self.runes_grabbed = ::std::option::Option::None;
        self.first_blood = ::std::option::Option::None;
        self.stuns = ::std::option::Option::None;
        self.smokes = ::std::option::Option::None;
        self.neutral_tokens = ::std::option::Option::None;
        self.watchers = ::std::option::Option::None;
        self.lotuses = ::std::option::Option::None;
        self.tormentors = ::std::option::Option::None;
        self.courier_kills = ::std::option::Option::None;
        self.title_stats = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAFantasyPlayerStats {
        static instance: CMsgDOTAFantasyPlayerStats = CMsgDOTAFantasyPlayerStats {
            player_account_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            match_completed: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            league_id: ::std::option::Option::None,
            delay: ::std::option::Option::None,
            series_id: ::std::option::Option::None,
            series_type: ::std::option::Option::None,
            kills: ::std::option::Option::None,
            deaths: ::std::option::Option::None,
            cs: ::std::option::Option::None,
            gpm: ::std::option::Option::None,
            tower_kills: ::std::option::Option::None,
            roshan_kills: ::std::option::Option::None,
            teamfight_participation: ::std::option::Option::None,
            wards_placed: ::std::option::Option::None,
            camps_stacked: ::std::option::Option::None,
            runes_grabbed: ::std::option::Option::None,
            first_blood: ::std::option::Option::None,
            stuns: ::std::option::Option::None,
            smokes: ::std::option::Option::None,
            neutral_tokens: ::std::option::Option::None,
            watchers: ::std::option::Option::None,
            lotuses: ::std::option::Option::None,
            tormentors: ::std::option::Option::None,
            courier_kills: ::std::option::Option::None,
            title_stats: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAFantasyPlayerMatchStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAFantasyPlayerMatchStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAFantasyPlayerMatchStats.matches)
    pub matches: ::std::vec::Vec<CMsgDOTAFantasyPlayerStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAFantasyPlayerMatchStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAFantasyPlayerMatchStats {
    fn default() -> &'a CMsgDOTAFantasyPlayerMatchStats {
        <CMsgDOTAFantasyPlayerMatchStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAFantasyPlayerMatchStats {
    pub fn new() -> CMsgDOTAFantasyPlayerMatchStats {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAFantasyPlayerMatchStats {
    const NAME: &'static str = "CMsgDOTAFantasyPlayerMatchStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.matches.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.matches {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAFantasyPlayerMatchStats {
        CMsgDOTAFantasyPlayerMatchStats::new()
    }

    fn clear(&mut self) {
        self.matches.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAFantasyPlayerMatchStats {
        static instance: CMsgDOTAFantasyPlayerMatchStats = CMsgDOTAFantasyPlayerMatchStats {
            matches: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTABotDebugInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTABotDebugInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.bots)
    pub bots: ::std::vec::Vec<cmsg_dotabot_debug_info::Bot>,
    // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.desire_push_lane_top)
    pub desire_push_lane_top: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.desire_push_lane_mid)
    pub desire_push_lane_mid: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.desire_push_lane_bot)
    pub desire_push_lane_bot: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.desire_defend_lane_top)
    pub desire_defend_lane_top: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.desire_defend_lane_mid)
    pub desire_defend_lane_mid: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.desire_defend_lane_bot)
    pub desire_defend_lane_bot: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.desire_farm_lane_top)
    pub desire_farm_lane_top: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.desire_farm_lane_mid)
    pub desire_farm_lane_mid: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.desire_farm_lane_bot)
    pub desire_farm_lane_bot: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.desire_farm_roshan)
    pub desire_farm_roshan: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.execution_time)
    pub execution_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.rune_status)
    pub rune_status: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTABotDebugInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTABotDebugInfo {
    fn default() -> &'a CMsgDOTABotDebugInfo {
        <CMsgDOTABotDebugInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTABotDebugInfo {
    pub fn new() -> CMsgDOTABotDebugInfo {
        ::std::default::Default::default()
    }

    // optional float desire_push_lane_top = 2;

    pub fn desire_push_lane_top(&self) -> f32 {
        self.desire_push_lane_top.unwrap_or(0.)
    }

    pub fn clear_desire_push_lane_top(&mut self) {
        self.desire_push_lane_top = ::std::option::Option::None;
    }

    pub fn has_desire_push_lane_top(&self) -> bool {
        self.desire_push_lane_top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_push_lane_top(&mut self, v: f32) {
        self.desire_push_lane_top = ::std::option::Option::Some(v);
    }

    // optional float desire_push_lane_mid = 3;

    pub fn desire_push_lane_mid(&self) -> f32 {
        self.desire_push_lane_mid.unwrap_or(0.)
    }

    pub fn clear_desire_push_lane_mid(&mut self) {
        self.desire_push_lane_mid = ::std::option::Option::None;
    }

    pub fn has_desire_push_lane_mid(&self) -> bool {
        self.desire_push_lane_mid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_push_lane_mid(&mut self, v: f32) {
        self.desire_push_lane_mid = ::std::option::Option::Some(v);
    }

    // optional float desire_push_lane_bot = 4;

    pub fn desire_push_lane_bot(&self) -> f32 {
        self.desire_push_lane_bot.unwrap_or(0.)
    }

    pub fn clear_desire_push_lane_bot(&mut self) {
        self.desire_push_lane_bot = ::std::option::Option::None;
    }

    pub fn has_desire_push_lane_bot(&self) -> bool {
        self.desire_push_lane_bot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_push_lane_bot(&mut self, v: f32) {
        self.desire_push_lane_bot = ::std::option::Option::Some(v);
    }

    // optional float desire_defend_lane_top = 5;

    pub fn desire_defend_lane_top(&self) -> f32 {
        self.desire_defend_lane_top.unwrap_or(0.)
    }

    pub fn clear_desire_defend_lane_top(&mut self) {
        self.desire_defend_lane_top = ::std::option::Option::None;
    }

    pub fn has_desire_defend_lane_top(&self) -> bool {
        self.desire_defend_lane_top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_defend_lane_top(&mut self, v: f32) {
        self.desire_defend_lane_top = ::std::option::Option::Some(v);
    }

    // optional float desire_defend_lane_mid = 6;

    pub fn desire_defend_lane_mid(&self) -> f32 {
        self.desire_defend_lane_mid.unwrap_or(0.)
    }

    pub fn clear_desire_defend_lane_mid(&mut self) {
        self.desire_defend_lane_mid = ::std::option::Option::None;
    }

    pub fn has_desire_defend_lane_mid(&self) -> bool {
        self.desire_defend_lane_mid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_defend_lane_mid(&mut self, v: f32) {
        self.desire_defend_lane_mid = ::std::option::Option::Some(v);
    }

    // optional float desire_defend_lane_bot = 7;

    pub fn desire_defend_lane_bot(&self) -> f32 {
        self.desire_defend_lane_bot.unwrap_or(0.)
    }

    pub fn clear_desire_defend_lane_bot(&mut self) {
        self.desire_defend_lane_bot = ::std::option::Option::None;
    }

    pub fn has_desire_defend_lane_bot(&self) -> bool {
        self.desire_defend_lane_bot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_defend_lane_bot(&mut self, v: f32) {
        self.desire_defend_lane_bot = ::std::option::Option::Some(v);
    }

    // optional float desire_farm_lane_top = 8;

    pub fn desire_farm_lane_top(&self) -> f32 {
        self.desire_farm_lane_top.unwrap_or(0.)
    }

    pub fn clear_desire_farm_lane_top(&mut self) {
        self.desire_farm_lane_top = ::std::option::Option::None;
    }

    pub fn has_desire_farm_lane_top(&self) -> bool {
        self.desire_farm_lane_top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_farm_lane_top(&mut self, v: f32) {
        self.desire_farm_lane_top = ::std::option::Option::Some(v);
    }

    // optional float desire_farm_lane_mid = 9;

    pub fn desire_farm_lane_mid(&self) -> f32 {
        self.desire_farm_lane_mid.unwrap_or(0.)
    }

    pub fn clear_desire_farm_lane_mid(&mut self) {
        self.desire_farm_lane_mid = ::std::option::Option::None;
    }

    pub fn has_desire_farm_lane_mid(&self) -> bool {
        self.desire_farm_lane_mid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_farm_lane_mid(&mut self, v: f32) {
        self.desire_farm_lane_mid = ::std::option::Option::Some(v);
    }

    // optional float desire_farm_lane_bot = 10;

    pub fn desire_farm_lane_bot(&self) -> f32 {
        self.desire_farm_lane_bot.unwrap_or(0.)
    }

    pub fn clear_desire_farm_lane_bot(&mut self) {
        self.desire_farm_lane_bot = ::std::option::Option::None;
    }

    pub fn has_desire_farm_lane_bot(&self) -> bool {
        self.desire_farm_lane_bot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_farm_lane_bot(&mut self, v: f32) {
        self.desire_farm_lane_bot = ::std::option::Option::Some(v);
    }

    // optional float desire_farm_roshan = 11;

    pub fn desire_farm_roshan(&self) -> f32 {
        self.desire_farm_roshan.unwrap_or(0.)
    }

    pub fn clear_desire_farm_roshan(&mut self) {
        self.desire_farm_roshan = ::std::option::Option::None;
    }

    pub fn has_desire_farm_roshan(&self) -> bool {
        self.desire_farm_roshan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desire_farm_roshan(&mut self, v: f32) {
        self.desire_farm_roshan = ::std::option::Option::Some(v);
    }

    // optional float execution_time = 12;

    pub fn execution_time(&self) -> f32 {
        self.execution_time.unwrap_or(0.)
    }

    pub fn clear_execution_time(&mut self) {
        self.execution_time = ::std::option::Option::None;
    }

    pub fn has_execution_time(&self) -> bool {
        self.execution_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_execution_time(&mut self, v: f32) {
        self.execution_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTABotDebugInfo {
    const NAME: &'static str = "CMsgDOTABotDebugInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bots.push(is.read_message()?);
                },
                21 => {
                    self.desire_push_lane_top = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.desire_push_lane_mid = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.desire_push_lane_bot = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.desire_defend_lane_top = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.desire_defend_lane_mid = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.desire_defend_lane_bot = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.desire_farm_lane_top = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.desire_farm_lane_mid = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.desire_farm_lane_bot = ::std::option::Option::Some(is.read_float()?);
                },
                93 => {
                    self.desire_farm_roshan = ::std::option::Option::Some(is.read_float()?);
                },
                101 => {
                    self.execution_time = ::std::option::Option::Some(is.read_float()?);
                },
                106 => {
                    is.read_repeated_packed_uint32_into(&mut self.rune_status)?;
                },
                104 => {
                    self.rune_status.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.bots {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.desire_push_lane_top {
            my_size += 1 + 4;
        }
        if let Some(v) = self.desire_push_lane_mid {
            my_size += 1 + 4;
        }
        if let Some(v) = self.desire_push_lane_bot {
            my_size += 1 + 4;
        }
        if let Some(v) = self.desire_defend_lane_top {
            my_size += 1 + 4;
        }
        if let Some(v) = self.desire_defend_lane_mid {
            my_size += 1 + 4;
        }
        if let Some(v) = self.desire_defend_lane_bot {
            my_size += 1 + 4;
        }
        if let Some(v) = self.desire_farm_lane_top {
            my_size += 1 + 4;
        }
        if let Some(v) = self.desire_farm_lane_mid {
            my_size += 1 + 4;
        }
        if let Some(v) = self.desire_farm_lane_bot {
            my_size += 1 + 4;
        }
        if let Some(v) = self.desire_farm_roshan {
            my_size += 1 + 4;
        }
        if let Some(v) = self.execution_time {
            my_size += 1 + 4;
        }
        for value in &self.rune_status {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.bots {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.desire_push_lane_top {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.desire_push_lane_mid {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.desire_push_lane_bot {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.desire_defend_lane_top {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.desire_defend_lane_mid {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.desire_defend_lane_bot {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.desire_farm_lane_top {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.desire_farm_lane_mid {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.desire_farm_lane_bot {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.desire_farm_roshan {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.execution_time {
            os.write_float(12, v)?;
        }
        for v in &self.rune_status {
            os.write_uint32(13, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTABotDebugInfo {
        CMsgDOTABotDebugInfo::new()
    }

    fn clear(&mut self) {
        self.bots.clear();
        self.desire_push_lane_top = ::std::option::Option::None;
        self.desire_push_lane_mid = ::std::option::Option::None;
        self.desire_push_lane_bot = ::std::option::Option::None;
        self.desire_defend_lane_top = ::std::option::Option::None;
        self.desire_defend_lane_mid = ::std::option::Option::None;
        self.desire_defend_lane_bot = ::std::option::Option::None;
        self.desire_farm_lane_top = ::std::option::Option::None;
        self.desire_farm_lane_mid = ::std::option::Option::None;
        self.desire_farm_lane_bot = ::std::option::Option::None;
        self.desire_farm_roshan = ::std::option::Option::None;
        self.execution_time = ::std::option::Option::None;
        self.rune_status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTABotDebugInfo {
        static instance: CMsgDOTABotDebugInfo = CMsgDOTABotDebugInfo {
            bots: ::std::vec::Vec::new(),
            desire_push_lane_top: ::std::option::Option::None,
            desire_push_lane_mid: ::std::option::Option::None,
            desire_push_lane_bot: ::std::option::Option::None,
            desire_defend_lane_top: ::std::option::Option::None,
            desire_defend_lane_mid: ::std::option::Option::None,
            desire_defend_lane_bot: ::std::option::Option::None,
            desire_farm_lane_top: ::std::option::Option::None,
            desire_farm_lane_mid: ::std::option::Option::None,
            desire_farm_lane_bot: ::std::option::Option::None,
            desire_farm_roshan: ::std::option::Option::None,
            execution_time: ::std::option::Option::None,
            rune_status: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTABotDebugInfo`
pub mod cmsg_dotabot_debug_info {
    // @@protoc_insertion_point(message:CMsgDOTABotDebugInfo.Bot)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Bot {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.Bot.player_owner_id)
        pub player_owner_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.Bot.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.Bot.difficulty)
        pub difficulty: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.Bot.power_current)
        pub power_current: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.Bot.power_max)
        pub power_max: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.Bot.move_target_x)
        pub move_target_x: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.Bot.move_target_y)
        pub move_target_y: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.Bot.move_target_z)
        pub move_target_z: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.Bot.active_mode_id)
        pub active_mode_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.Bot.execution_time)
        pub execution_time: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.Bot.modes)
        pub modes: ::std::vec::Vec<bot::Mode>,
        // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.Bot.action)
        pub action: ::steam_vent_proto_common::protobuf::MessageField<bot::Action>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTABotDebugInfo.Bot.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Bot {
        fn default() -> &'a Bot {
            <Bot as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Bot {
        pub fn new() -> Bot {
            ::std::default::Default::default()
        }

        // optional int32 player_owner_id = 1;

        pub fn player_owner_id(&self) -> i32 {
            self.player_owner_id.unwrap_or(-1i32)
        }

        pub fn clear_player_owner_id(&mut self) {
            self.player_owner_id = ::std::option::Option::None;
        }

        pub fn has_player_owner_id(&self) -> bool {
            self.player_owner_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_owner_id(&mut self, v: i32) {
            self.player_owner_id = ::std::option::Option::Some(v);
        }

        // optional int32 hero_id = 2;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 difficulty = 3;

        pub fn difficulty(&self) -> u32 {
            self.difficulty.unwrap_or(0)
        }

        pub fn clear_difficulty(&mut self) {
            self.difficulty = ::std::option::Option::None;
        }

        pub fn has_difficulty(&self) -> bool {
            self.difficulty.is_some()
        }

        // Param is passed by value, moved
        pub fn set_difficulty(&mut self, v: u32) {
            self.difficulty = ::std::option::Option::Some(v);
        }

        // optional uint32 power_current = 4;

        pub fn power_current(&self) -> u32 {
            self.power_current.unwrap_or(0)
        }

        pub fn clear_power_current(&mut self) {
            self.power_current = ::std::option::Option::None;
        }

        pub fn has_power_current(&self) -> bool {
            self.power_current.is_some()
        }

        // Param is passed by value, moved
        pub fn set_power_current(&mut self, v: u32) {
            self.power_current = ::std::option::Option::Some(v);
        }

        // optional uint32 power_max = 5;

        pub fn power_max(&self) -> u32 {
            self.power_max.unwrap_or(0)
        }

        pub fn clear_power_max(&mut self) {
            self.power_max = ::std::option::Option::None;
        }

        pub fn has_power_max(&self) -> bool {
            self.power_max.is_some()
        }

        // Param is passed by value, moved
        pub fn set_power_max(&mut self, v: u32) {
            self.power_max = ::std::option::Option::Some(v);
        }

        // optional uint32 move_target_x = 6;

        pub fn move_target_x(&self) -> u32 {
            self.move_target_x.unwrap_or(0)
        }

        pub fn clear_move_target_x(&mut self) {
            self.move_target_x = ::std::option::Option::None;
        }

        pub fn has_move_target_x(&self) -> bool {
            self.move_target_x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_move_target_x(&mut self, v: u32) {
            self.move_target_x = ::std::option::Option::Some(v);
        }

        // optional uint32 move_target_y = 7;

        pub fn move_target_y(&self) -> u32 {
            self.move_target_y.unwrap_or(0)
        }

        pub fn clear_move_target_y(&mut self) {
            self.move_target_y = ::std::option::Option::None;
        }

        pub fn has_move_target_y(&self) -> bool {
            self.move_target_y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_move_target_y(&mut self, v: u32) {
            self.move_target_y = ::std::option::Option::Some(v);
        }

        // optional uint32 move_target_z = 8;

        pub fn move_target_z(&self) -> u32 {
            self.move_target_z.unwrap_or(0)
        }

        pub fn clear_move_target_z(&mut self) {
            self.move_target_z = ::std::option::Option::None;
        }

        pub fn has_move_target_z(&self) -> bool {
            self.move_target_z.is_some()
        }

        // Param is passed by value, moved
        pub fn set_move_target_z(&mut self, v: u32) {
            self.move_target_z = ::std::option::Option::Some(v);
        }

        // optional uint32 active_mode_id = 9;

        pub fn active_mode_id(&self) -> u32 {
            self.active_mode_id.unwrap_or(0)
        }

        pub fn clear_active_mode_id(&mut self) {
            self.active_mode_id = ::std::option::Option::None;
        }

        pub fn has_active_mode_id(&self) -> bool {
            self.active_mode_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_active_mode_id(&mut self, v: u32) {
            self.active_mode_id = ::std::option::Option::Some(v);
        }

        // optional float execution_time = 10;

        pub fn execution_time(&self) -> f32 {
            self.execution_time.unwrap_or(0.)
        }

        pub fn clear_execution_time(&mut self) {
            self.execution_time = ::std::option::Option::None;
        }

        pub fn has_execution_time(&self) -> bool {
            self.execution_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_execution_time(&mut self, v: f32) {
            self.execution_time = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Bot {
        const NAME: &'static str = "Bot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_owner_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.difficulty = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.power_current = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.power_max = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.move_target_x = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.move_target_y = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.move_target_z = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.active_mode_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    85 => {
                        self.execution_time = ::std::option::Option::Some(is.read_float()?);
                    },
                    90 => {
                        self.modes.push(is.read_message()?);
                    },
                    98 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.action)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_owner_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.difficulty {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.power_current {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.power_max {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.move_target_x {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.move_target_y {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.move_target_z {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.active_mode_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.execution_time {
                my_size += 1 + 4;
            }
            for value in &self.modes {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.action.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.player_owner_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.difficulty {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.power_current {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.power_max {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.move_target_x {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.move_target_y {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.move_target_z {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.active_mode_id {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.execution_time {
                os.write_float(10, v)?;
            }
            for v in &self.modes {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
            };
            if let Some(v) = self.action.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Bot {
            Bot::new()
        }

        fn clear(&mut self) {
            self.player_owner_id = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.difficulty = ::std::option::Option::None;
            self.power_current = ::std::option::Option::None;
            self.power_max = ::std::option::Option::None;
            self.move_target_x = ::std::option::Option::None;
            self.move_target_y = ::std::option::Option::None;
            self.move_target_z = ::std::option::Option::None;
            self.active_mode_id = ::std::option::Option::None;
            self.execution_time = ::std::option::Option::None;
            self.modes.clear();
            self.action.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Bot {
            static instance: Bot = Bot {
                player_owner_id: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                difficulty: ::std::option::Option::None,
                power_current: ::std::option::Option::None,
                power_max: ::std::option::Option::None,
                move_target_x: ::std::option::Option::None,
                move_target_y: ::std::option::Option::None,
                move_target_z: ::std::option::Option::None,
                active_mode_id: ::std::option::Option::None,
                execution_time: ::std::option::Option::None,
                modes: ::std::vec::Vec::new(),
                action: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Bot`
    pub mod bot {
        // @@protoc_insertion_point(message:CMsgDOTABotDebugInfo.Bot.Mode)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Mode {
            // message fields
            // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.Bot.Mode.mode_id)
            pub mode_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.Bot.Mode.desire)
            pub desire: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.Bot.Mode.target_entity)
            pub target_entity: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.Bot.Mode.target_x)
            pub target_x: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.Bot.Mode.target_y)
            pub target_y: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.Bot.Mode.target_z)
            pub target_z: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgDOTABotDebugInfo.Bot.Mode.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Mode {
            fn default() -> &'a Mode {
                <Mode as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl Mode {
            pub fn new() -> Mode {
                ::std::default::Default::default()
            }

            // optional uint32 mode_id = 1;

            pub fn mode_id(&self) -> u32 {
                self.mode_id.unwrap_or(0)
            }

            pub fn clear_mode_id(&mut self) {
                self.mode_id = ::std::option::Option::None;
            }

            pub fn has_mode_id(&self) -> bool {
                self.mode_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_mode_id(&mut self, v: u32) {
                self.mode_id = ::std::option::Option::Some(v);
            }

            // optional float desire = 2;

            pub fn desire(&self) -> f32 {
                self.desire.unwrap_or(0.)
            }

            pub fn clear_desire(&mut self) {
                self.desire = ::std::option::Option::None;
            }

            pub fn has_desire(&self) -> bool {
                self.desire.is_some()
            }

            // Param is passed by value, moved
            pub fn set_desire(&mut self, v: f32) {
                self.desire = ::std::option::Option::Some(v);
            }

            // optional int32 target_entity = 3;

            pub fn target_entity(&self) -> i32 {
                self.target_entity.unwrap_or(-1i32)
            }

            pub fn clear_target_entity(&mut self) {
                self.target_entity = ::std::option::Option::None;
            }

            pub fn has_target_entity(&self) -> bool {
                self.target_entity.is_some()
            }

            // Param is passed by value, moved
            pub fn set_target_entity(&mut self, v: i32) {
                self.target_entity = ::std::option::Option::Some(v);
            }

            // optional uint32 target_x = 4;

            pub fn target_x(&self) -> u32 {
                self.target_x.unwrap_or(0)
            }

            pub fn clear_target_x(&mut self) {
                self.target_x = ::std::option::Option::None;
            }

            pub fn has_target_x(&self) -> bool {
                self.target_x.is_some()
            }

            // Param is passed by value, moved
            pub fn set_target_x(&mut self, v: u32) {
                self.target_x = ::std::option::Option::Some(v);
            }

            // optional uint32 target_y = 5;

            pub fn target_y(&self) -> u32 {
                self.target_y.unwrap_or(0)
            }

            pub fn clear_target_y(&mut self) {
                self.target_y = ::std::option::Option::None;
            }

            pub fn has_target_y(&self) -> bool {
                self.target_y.is_some()
            }

            // Param is passed by value, moved
            pub fn set_target_y(&mut self, v: u32) {
                self.target_y = ::std::option::Option::Some(v);
            }

            // optional uint32 target_z = 6;

            pub fn target_z(&self) -> u32 {
                self.target_z.unwrap_or(0)
            }

            pub fn clear_target_z(&mut self) {
                self.target_z = ::std::option::Option::None;
            }

            pub fn has_target_z(&self) -> bool {
                self.target_z.is_some()
            }

            // Param is passed by value, moved
            pub fn set_target_z(&mut self, v: u32) {
                self.target_z = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for Mode {
            const NAME: &'static str = "Mode";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.mode_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        21 => {
                            self.desire = ::std::option::Option::Some(is.read_float()?);
                        },
                        24 => {
                            self.target_entity = ::std::option::Option::Some(is.read_int32()?);
                        },
                        32 => {
                            self.target_x = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        40 => {
                            self.target_y = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        48 => {
                            self.target_z = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.mode_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.desire {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.target_entity {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
                }
                if let Some(v) = self.target_x {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
                }
                if let Some(v) = self.target_y {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
                }
                if let Some(v) = self.target_z {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.mode_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.desire {
                    os.write_float(2, v)?;
                }
                if let Some(v) = self.target_entity {
                    os.write_int32(3, v)?;
                }
                if let Some(v) = self.target_x {
                    os.write_uint32(4, v)?;
                }
                if let Some(v) = self.target_y {
                    os.write_uint32(5, v)?;
                }
                if let Some(v) = self.target_z {
                    os.write_uint32(6, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Mode {
                Mode::new()
            }

            fn clear(&mut self) {
                self.mode_id = ::std::option::Option::None;
                self.desire = ::std::option::Option::None;
                self.target_entity = ::std::option::Option::None;
                self.target_x = ::std::option::Option::None;
                self.target_y = ::std::option::Option::None;
                self.target_z = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Mode {
                static instance: Mode = Mode {
                    mode_id: ::std::option::Option::None,
                    desire: ::std::option::Option::None,
                    target_entity: ::std::option::Option::None,
                    target_x: ::std::option::Option::None,
                    target_y: ::std::option::Option::None,
                    target_z: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CMsgDOTABotDebugInfo.Bot.Action)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Action {
            // message fields
            // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.Bot.Action.action_id)
            pub action_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgDOTABotDebugInfo.Bot.Action.action_target)
            pub action_target: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgDOTABotDebugInfo.Bot.Action.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Action {
            fn default() -> &'a Action {
                <Action as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl Action {
            pub fn new() -> Action {
                ::std::default::Default::default()
            }

            // optional uint32 action_id = 1;

            pub fn action_id(&self) -> u32 {
                self.action_id.unwrap_or(0)
            }

            pub fn clear_action_id(&mut self) {
                self.action_id = ::std::option::Option::None;
            }

            pub fn has_action_id(&self) -> bool {
                self.action_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_action_id(&mut self, v: u32) {
                self.action_id = ::std::option::Option::Some(v);
            }

            // optional string action_target = 2;

            pub fn action_target(&self) -> &str {
                match self.action_target.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_action_target(&mut self) {
                self.action_target = ::std::option::Option::None;
            }

            pub fn has_action_target(&self) -> bool {
                self.action_target.is_some()
            }

            // Param is passed by value, moved
            pub fn set_action_target(&mut self, v: ::std::string::String) {
                self.action_target = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_action_target(&mut self) -> &mut ::std::string::String {
                if self.action_target.is_none() {
                    self.action_target = ::std::option::Option::Some(::std::string::String::new());
                }
                self.action_target.as_mut().unwrap()
            }

            // Take field
            pub fn take_action_target(&mut self) -> ::std::string::String {
                self.action_target.take().unwrap_or_else(|| ::std::string::String::new())
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for Action {
            const NAME: &'static str = "Action";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        18 => {
                            self.action_target = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.action_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.action_target.as_ref() {
                    my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.action_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.action_target.as_ref() {
                    os.write_string(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Action {
                Action::new()
            }

            fn clear(&mut self) {
                self.action_id = ::std::option::Option::None;
                self.action_target = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Action {
                static instance: Action = Action {
                    action_id: ::std::option::Option::None,
                    action_target: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }
}

// @@protoc_insertion_point(message:CMsgSuccessfulHero)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSuccessfulHero {
    // message fields
    // @@protoc_insertion_point(field:CMsgSuccessfulHero.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSuccessfulHero.win_percent)
    pub win_percent: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSuccessfulHero.longest_streak)
    pub longest_streak: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSuccessfulHero.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSuccessfulHero {
    fn default() -> &'a CMsgSuccessfulHero {
        <CMsgSuccessfulHero as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSuccessfulHero {
    pub fn new() -> CMsgSuccessfulHero {
        ::std::default::Default::default()
    }

    // optional int32 hero_id = 1;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional float win_percent = 2;

    pub fn win_percent(&self) -> f32 {
        self.win_percent.unwrap_or(0.)
    }

    pub fn clear_win_percent(&mut self) {
        self.win_percent = ::std::option::Option::None;
    }

    pub fn has_win_percent(&self) -> bool {
        self.win_percent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_win_percent(&mut self, v: f32) {
        self.win_percent = ::std::option::Option::Some(v);
    }

    // optional uint32 longest_streak = 3;

    pub fn longest_streak(&self) -> u32 {
        self.longest_streak.unwrap_or(0)
    }

    pub fn clear_longest_streak(&mut self) {
        self.longest_streak = ::std::option::Option::None;
    }

    pub fn has_longest_streak(&self) -> bool {
        self.longest_streak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_longest_streak(&mut self, v: u32) {
        self.longest_streak = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSuccessfulHero {
    const NAME: &'static str = "CMsgSuccessfulHero";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.win_percent = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.longest_streak = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.win_percent {
            my_size += 1 + 4;
        }
        if let Some(v) = self.longest_streak {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hero_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.win_percent {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.longest_streak {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSuccessfulHero {
        CMsgSuccessfulHero::new()
    }

    fn clear(&mut self) {
        self.hero_id = ::std::option::Option::None;
        self.win_percent = ::std::option::Option::None;
        self.longest_streak = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSuccessfulHero {
        static instance: CMsgSuccessfulHero = CMsgSuccessfulHero {
            hero_id: ::std::option::Option::None,
            win_percent: ::std::option::Option::None,
            longest_streak: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRecentMatchInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRecentMatchInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgRecentMatchInfo.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgRecentMatchInfo.game_mode)
    pub game_mode: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GameMode>>,
    // @@protoc_insertion_point(field:CMsgRecentMatchInfo.kills)
    pub kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRecentMatchInfo.deaths)
    pub deaths: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRecentMatchInfo.assists)
    pub assists: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRecentMatchInfo.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRecentMatchInfo.player_slot)
    pub player_slot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRecentMatchInfo.match_outcome)
    pub match_outcome: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EMatchOutcome>>,
    // @@protoc_insertion_point(field:CMsgRecentMatchInfo.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRecentMatchInfo.lobby_type)
    pub lobby_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRecentMatchInfo.team_number)
    pub team_number: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRecentMatchInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRecentMatchInfo {
    fn default() -> &'a CMsgRecentMatchInfo {
        <CMsgRecentMatchInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgRecentMatchInfo {
    pub fn new() -> CMsgRecentMatchInfo {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional .DOTA_GameMode game_mode = 2;

    pub fn game_mode(&self) -> super::dota_shared_enums::DOTA_GameMode {
        match self.game_mode {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE),
            None => super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE,
        }
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: super::dota_shared_enums::DOTA_GameMode) {
        self.game_mode = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 kills = 3;

    pub fn kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional uint32 deaths = 4;

    pub fn deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 assists = 5;

    pub fn assists(&self) -> u32 {
        self.assists.unwrap_or(0)
    }

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: u32) {
        self.assists = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 6;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional uint32 player_slot = 7;

    pub fn player_slot(&self) -> u32 {
        self.player_slot.unwrap_or(0)
    }

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: u32) {
        self.player_slot = ::std::option::Option::Some(v);
    }

    // optional .EMatchOutcome match_outcome = 8;

    pub fn match_outcome(&self) -> super::dota_shared_enums::EMatchOutcome {
        match self.match_outcome {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EMatchOutcome::k_EMatchOutcome_Unknown),
            None => super::dota_shared_enums::EMatchOutcome::k_EMatchOutcome_Unknown,
        }
    }

    pub fn clear_match_outcome(&mut self) {
        self.match_outcome = ::std::option::Option::None;
    }

    pub fn has_match_outcome(&self) -> bool {
        self.match_outcome.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_outcome(&mut self, v: super::dota_shared_enums::EMatchOutcome) {
        self.match_outcome = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 timestamp = 9;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_type = 10;

    pub fn lobby_type(&self) -> u32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: u32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional uint32 team_number = 11;

    pub fn team_number(&self) -> u32 {
        self.team_number.unwrap_or(0)
    }

    pub fn clear_team_number(&mut self) {
        self.team_number = ::std::option::Option::None;
    }

    pub fn has_team_number(&self) -> bool {
        self.team_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_number(&mut self, v: u32) {
        self.team_number = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgRecentMatchInfo {
    const NAME: &'static str = "CMsgRecentMatchInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.game_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.assists = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.match_outcome = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.team_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.deaths {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.assists {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.player_slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.match_outcome {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v.value());
        }
        if let Some(v) = self.timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.team_number {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.assists {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.player_slot {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.match_outcome {
            os.write_enum(8, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.team_number {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRecentMatchInfo {
        CMsgRecentMatchInfo::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.assists = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.player_slot = ::std::option::Option::None;
        self.match_outcome = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.team_number = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRecentMatchInfo {
        static instance: CMsgRecentMatchInfo = CMsgRecentMatchInfo {
            match_id: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            kills: ::std::option::Option::None,
            deaths: ::std::option::Option::None,
            assists: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            player_slot: ::std::option::Option::None,
            match_outcome: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            team_number: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMatchTips)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMatchTips {
    // message fields
    // @@protoc_insertion_point(field:CMsgMatchTips.tips)
    pub tips: ::std::vec::Vec<cmsg_match_tips::SingleTip>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMatchTips.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMatchTips {
    fn default() -> &'a CMsgMatchTips {
        <CMsgMatchTips as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgMatchTips {
    pub fn new() -> CMsgMatchTips {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgMatchTips {
    const NAME: &'static str = "CMsgMatchTips";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.tips.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.tips {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.tips {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMatchTips {
        CMsgMatchTips::new()
    }

    fn clear(&mut self) {
        self.tips.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMatchTips {
        static instance: CMsgMatchTips = CMsgMatchTips {
            tips: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgMatchTips`
pub mod cmsg_match_tips {
    // @@protoc_insertion_point(message:CMsgMatchTips.SingleTip)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SingleTip {
        // message fields
        // @@protoc_insertion_point(field:CMsgMatchTips.SingleTip.source_account_id)
        pub source_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgMatchTips.SingleTip.target_account_id)
        pub target_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgMatchTips.SingleTip.tip_amount)
        pub tip_amount: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgMatchTips.SingleTip.event_id)
        pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::EEvent>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgMatchTips.SingleTip.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SingleTip {
        fn default() -> &'a SingleTip {
            <SingleTip as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SingleTip {
        pub fn new() -> SingleTip {
            ::std::default::Default::default()
        }

        // optional uint32 source_account_id = 1;

        pub fn source_account_id(&self) -> u32 {
            self.source_account_id.unwrap_or(0)
        }

        pub fn clear_source_account_id(&mut self) {
            self.source_account_id = ::std::option::Option::None;
        }

        pub fn has_source_account_id(&self) -> bool {
            self.source_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_account_id(&mut self, v: u32) {
            self.source_account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 target_account_id = 2;

        pub fn target_account_id(&self) -> u32 {
            self.target_account_id.unwrap_or(0)
        }

        pub fn clear_target_account_id(&mut self) {
            self.target_account_id = ::std::option::Option::None;
        }

        pub fn has_target_account_id(&self) -> bool {
            self.target_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_target_account_id(&mut self, v: u32) {
            self.target_account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 tip_amount = 3;

        pub fn tip_amount(&self) -> u32 {
            self.tip_amount.unwrap_or(0)
        }

        pub fn clear_tip_amount(&mut self) {
            self.tip_amount = ::std::option::Option::None;
        }

        pub fn has_tip_amount(&self) -> bool {
            self.tip_amount.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tip_amount(&mut self, v: u32) {
            self.tip_amount = ::std::option::Option::Some(v);
        }

        // optional .EEvent event_id = 4;

        pub fn event_id(&self) -> super::super::dota_shared_enums::EEvent {
            match self.event_id {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::EEvent::EVENT_ID_NONE),
                None => super::super::dota_shared_enums::EEvent::EVENT_ID_NONE,
            }
        }

        pub fn clear_event_id(&mut self) {
            self.event_id = ::std::option::Option::None;
        }

        pub fn has_event_id(&self) -> bool {
            self.event_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_id(&mut self, v: super::super::dota_shared_enums::EEvent) {
            self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SingleTip {
        const NAME: &'static str = "SingleTip";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.source_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.tip_amount = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.source_account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.target_account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.tip_amount {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.event_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.source_account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.target_account_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.tip_amount {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.event_id {
                os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SingleTip {
            SingleTip::new()
        }

        fn clear(&mut self) {
            self.source_account_id = ::std::option::Option::None;
            self.target_account_id = ::std::option::Option::None;
            self.tip_amount = ::std::option::Option::None;
            self.event_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SingleTip {
            static instance: SingleTip = SingleTip {
                source_account_id: ::std::option::Option::None,
                target_account_id: ::std::option::Option::None,
                tip_amount: ::std::option::Option::None,
                event_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTAMatchMinimal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAMatchMinimal {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.game_mode)
    pub game_mode: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GameMode>>,
    // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.players)
    pub players: ::std::vec::Vec<cmsg_dotamatch_minimal::Player>,
    // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.tourney)
    pub tourney: ::steam_vent_proto_common::protobuf::MessageField<cmsg_dotamatch_minimal::Tourney>,
    // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.match_outcome)
    pub match_outcome: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EMatchOutcome>>,
    // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.radiant_score)
    pub radiant_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.dire_score)
    pub dire_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.lobby_type)
    pub lobby_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAMatchMinimal.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAMatchMinimal {
    fn default() -> &'a CMsgDOTAMatchMinimal {
        <CMsgDOTAMatchMinimal as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAMatchMinimal {
    pub fn new() -> CMsgDOTAMatchMinimal {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 start_time = 2;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 3;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional .DOTA_GameMode game_mode = 4;

    pub fn game_mode(&self) -> super::dota_shared_enums::DOTA_GameMode {
        match self.game_mode {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE),
            None => super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE,
        }
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: super::dota_shared_enums::DOTA_GameMode) {
        self.game_mode = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .EMatchOutcome match_outcome = 8;

    pub fn match_outcome(&self) -> super::dota_shared_enums::EMatchOutcome {
        match self.match_outcome {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EMatchOutcome::k_EMatchOutcome_Unknown),
            None => super::dota_shared_enums::EMatchOutcome::k_EMatchOutcome_Unknown,
        }
    }

    pub fn clear_match_outcome(&mut self) {
        self.match_outcome = ::std::option::Option::None;
    }

    pub fn has_match_outcome(&self) -> bool {
        self.match_outcome.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_outcome(&mut self, v: super::dota_shared_enums::EMatchOutcome) {
        self.match_outcome = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 radiant_score = 9;

    pub fn radiant_score(&self) -> u32 {
        self.radiant_score.unwrap_or(0)
    }

    pub fn clear_radiant_score(&mut self) {
        self.radiant_score = ::std::option::Option::None;
    }

    pub fn has_radiant_score(&self) -> bool {
        self.radiant_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_score(&mut self, v: u32) {
        self.radiant_score = ::std::option::Option::Some(v);
    }

    // optional uint32 dire_score = 10;

    pub fn dire_score(&self) -> u32 {
        self.dire_score.unwrap_or(0)
    }

    pub fn clear_dire_score(&mut self) {
        self.dire_score = ::std::option::Option::None;
    }

    pub fn has_dire_score(&self) -> bool {
        self.dire_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_score(&mut self, v: u32) {
        self.dire_score = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_type = 11;

    pub fn lobby_type(&self) -> u32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: u32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAMatchMinimal {
    const NAME: &'static str = "CMsgDOTAMatchMinimal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                21 => {
                    self.start_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.players.push(is.read_message()?);
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.tourney)?;
                },
                64 => {
                    self.match_outcome = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.radiant_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.dire_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.start_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.tourney.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.match_outcome {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v.value());
        }
        if let Some(v) = self.radiant_score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.dire_score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.tourney.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.match_outcome {
            os.write_enum(8, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.radiant_score {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.dire_score {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAMatchMinimal {
        CMsgDOTAMatchMinimal::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.players.clear();
        self.tourney.clear();
        self.match_outcome = ::std::option::Option::None;
        self.radiant_score = ::std::option::Option::None;
        self.dire_score = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAMatchMinimal {
        static instance: CMsgDOTAMatchMinimal = CMsgDOTAMatchMinimal {
            match_id: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            tourney: ::steam_vent_proto_common::protobuf::MessageField::none(),
            match_outcome: ::std::option::Option::None,
            radiant_score: ::std::option::Option::None,
            dire_score: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTAMatchMinimal`
pub mod cmsg_dotamatch_minimal {
    // @@protoc_insertion_point(message:CMsgDOTAMatchMinimal.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Player.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Player.kills)
        pub kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Player.deaths)
        pub deaths: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Player.assists)
        pub assists: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Player.items)
        pub items: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Player.player_slot)
        pub player_slot: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Player.pro_name)
        pub pro_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Player.level)
        pub level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Player.team_number)
        pub team_number: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::DOTA_GC_TEAM>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAMatchMinimal.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional int32 hero_id = 2;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 kills = 3;

        pub fn kills(&self) -> u32 {
            self.kills.unwrap_or(0)
        }

        pub fn clear_kills(&mut self) {
            self.kills = ::std::option::Option::None;
        }

        pub fn has_kills(&self) -> bool {
            self.kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kills(&mut self, v: u32) {
            self.kills = ::std::option::Option::Some(v);
        }

        // optional uint32 deaths = 4;

        pub fn deaths(&self) -> u32 {
            self.deaths.unwrap_or(0)
        }

        pub fn clear_deaths(&mut self) {
            self.deaths = ::std::option::Option::None;
        }

        pub fn has_deaths(&self) -> bool {
            self.deaths.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deaths(&mut self, v: u32) {
            self.deaths = ::std::option::Option::Some(v);
        }

        // optional uint32 assists = 5;

        pub fn assists(&self) -> u32 {
            self.assists.unwrap_or(0)
        }

        pub fn clear_assists(&mut self) {
            self.assists = ::std::option::Option::None;
        }

        pub fn has_assists(&self) -> bool {
            self.assists.is_some()
        }

        // Param is passed by value, moved
        pub fn set_assists(&mut self, v: u32) {
            self.assists = ::std::option::Option::Some(v);
        }

        // optional uint32 player_slot = 7;

        pub fn player_slot(&self) -> u32 {
            self.player_slot.unwrap_or(0)
        }

        pub fn clear_player_slot(&mut self) {
            self.player_slot = ::std::option::Option::None;
        }

        pub fn has_player_slot(&self) -> bool {
            self.player_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_slot(&mut self, v: u32) {
            self.player_slot = ::std::option::Option::Some(v);
        }

        // optional string pro_name = 8;

        pub fn pro_name(&self) -> &str {
            match self.pro_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_pro_name(&mut self) {
            self.pro_name = ::std::option::Option::None;
        }

        pub fn has_pro_name(&self) -> bool {
            self.pro_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pro_name(&mut self, v: ::std::string::String) {
            self.pro_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_pro_name(&mut self) -> &mut ::std::string::String {
            if self.pro_name.is_none() {
                self.pro_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.pro_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_pro_name(&mut self) -> ::std::string::String {
            self.pro_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 level = 9;

        pub fn level(&self) -> u32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: u32) {
            self.level = ::std::option::Option::Some(v);
        }

        // optional .DOTA_GC_TEAM team_number = 10;

        pub fn team_number(&self) -> super::super::dota_shared_enums::DOTA_GC_TEAM {
            match self.team_number {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
                None => super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
            }
        }

        pub fn clear_team_number(&mut self) {
            self.team_number = ::std::option::Option::None;
        }

        pub fn has_team_number(&self) -> bool {
            self.team_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_number(&mut self, v: super::super::dota_shared_enums::DOTA_GC_TEAM) {
            self.team_number = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.assists = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    50 => {
                        is.read_repeated_packed_int32_into(&mut self.items)?;
                    },
                    48 => {
                        self.items.push(is.read_int32()?);
                    },
                    56 => {
                        self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    66 => {
                        self.pro_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    72 => {
                        self.level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.team_number = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.kills {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.deaths {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.assists {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            for value in &self.items {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, *value);
            };
            if let Some(v) = self.player_slot {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.pro_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.level {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.team_number {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v.value());
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.kills {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.deaths {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.assists {
                os.write_uint32(5, v)?;
            }
            for v in &self.items {
                os.write_int32(6, *v)?;
            };
            if let Some(v) = self.player_slot {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.pro_name.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.level {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.team_number {
                os.write_enum(10, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.kills = ::std::option::Option::None;
            self.deaths = ::std::option::Option::None;
            self.assists = ::std::option::Option::None;
            self.items.clear();
            self.player_slot = ::std::option::Option::None;
            self.pro_name = ::std::option::Option::None;
            self.level = ::std::option::Option::None;
            self.team_number = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                kills: ::std::option::Option::None,
                deaths: ::std::option::Option::None,
                assists: ::std::option::Option::None,
                items: ::std::vec::Vec::new(),
                player_slot: ::std::option::Option::None,
                pro_name: ::std::option::Option::None,
                level: ::std::option::Option::None,
                team_number: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTAMatchMinimal.Tourney)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tourney {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Tourney.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Tourney.series_type)
        pub series_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Tourney.series_game)
        pub series_game: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Tourney.weekend_tourney_tournament_id)
        pub weekend_tourney_tournament_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Tourney.weekend_tourney_season_trophy_id)
        pub weekend_tourney_season_trophy_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Tourney.weekend_tourney_division)
        pub weekend_tourney_division: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Tourney.weekend_tourney_skill_level)
        pub weekend_tourney_skill_level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Tourney.radiant_team_id)
        pub radiant_team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Tourney.radiant_team_name)
        pub radiant_team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Tourney.radiant_team_logo)
        pub radiant_team_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Tourney.radiant_team_logo_url)
        pub radiant_team_logo_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Tourney.dire_team_id)
        pub dire_team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Tourney.dire_team_name)
        pub dire_team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Tourney.dire_team_logo)
        pub dire_team_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchMinimal.Tourney.dire_team_logo_url)
        pub dire_team_logo_url: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAMatchMinimal.Tourney.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tourney {
        fn default() -> &'a Tourney {
            <Tourney as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Tourney {
        pub fn new() -> Tourney {
            ::std::default::Default::default()
        }

        // optional uint32 league_id = 1;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }

        // optional uint32 series_type = 8;

        pub fn series_type(&self) -> u32 {
            self.series_type.unwrap_or(0)
        }

        pub fn clear_series_type(&mut self) {
            self.series_type = ::std::option::Option::None;
        }

        pub fn has_series_type(&self) -> bool {
            self.series_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_series_type(&mut self, v: u32) {
            self.series_type = ::std::option::Option::Some(v);
        }

        // optional uint32 series_game = 9;

        pub fn series_game(&self) -> u32 {
            self.series_game.unwrap_or(0)
        }

        pub fn clear_series_game(&mut self) {
            self.series_game = ::std::option::Option::None;
        }

        pub fn has_series_game(&self) -> bool {
            self.series_game.is_some()
        }

        // Param is passed by value, moved
        pub fn set_series_game(&mut self, v: u32) {
            self.series_game = ::std::option::Option::Some(v);
        }

        // optional uint32 weekend_tourney_tournament_id = 10;

        pub fn weekend_tourney_tournament_id(&self) -> u32 {
            self.weekend_tourney_tournament_id.unwrap_or(0)
        }

        pub fn clear_weekend_tourney_tournament_id(&mut self) {
            self.weekend_tourney_tournament_id = ::std::option::Option::None;
        }

        pub fn has_weekend_tourney_tournament_id(&self) -> bool {
            self.weekend_tourney_tournament_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_weekend_tourney_tournament_id(&mut self, v: u32) {
            self.weekend_tourney_tournament_id = ::std::option::Option::Some(v);
        }

        // optional uint32 weekend_tourney_season_trophy_id = 11;

        pub fn weekend_tourney_season_trophy_id(&self) -> u32 {
            self.weekend_tourney_season_trophy_id.unwrap_or(0)
        }

        pub fn clear_weekend_tourney_season_trophy_id(&mut self) {
            self.weekend_tourney_season_trophy_id = ::std::option::Option::None;
        }

        pub fn has_weekend_tourney_season_trophy_id(&self) -> bool {
            self.weekend_tourney_season_trophy_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_weekend_tourney_season_trophy_id(&mut self, v: u32) {
            self.weekend_tourney_season_trophy_id = ::std::option::Option::Some(v);
        }

        // optional uint32 weekend_tourney_division = 12;

        pub fn weekend_tourney_division(&self) -> u32 {
            self.weekend_tourney_division.unwrap_or(0)
        }

        pub fn clear_weekend_tourney_division(&mut self) {
            self.weekend_tourney_division = ::std::option::Option::None;
        }

        pub fn has_weekend_tourney_division(&self) -> bool {
            self.weekend_tourney_division.is_some()
        }

        // Param is passed by value, moved
        pub fn set_weekend_tourney_division(&mut self, v: u32) {
            self.weekend_tourney_division = ::std::option::Option::Some(v);
        }

        // optional uint32 weekend_tourney_skill_level = 13;

        pub fn weekend_tourney_skill_level(&self) -> u32 {
            self.weekend_tourney_skill_level.unwrap_or(0)
        }

        pub fn clear_weekend_tourney_skill_level(&mut self) {
            self.weekend_tourney_skill_level = ::std::option::Option::None;
        }

        pub fn has_weekend_tourney_skill_level(&self) -> bool {
            self.weekend_tourney_skill_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_weekend_tourney_skill_level(&mut self, v: u32) {
            self.weekend_tourney_skill_level = ::std::option::Option::Some(v);
        }

        // optional uint32 radiant_team_id = 2;

        pub fn radiant_team_id(&self) -> u32 {
            self.radiant_team_id.unwrap_or(0)
        }

        pub fn clear_radiant_team_id(&mut self) {
            self.radiant_team_id = ::std::option::Option::None;
        }

        pub fn has_radiant_team_id(&self) -> bool {
            self.radiant_team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_radiant_team_id(&mut self, v: u32) {
            self.radiant_team_id = ::std::option::Option::Some(v);
        }

        // optional string radiant_team_name = 3;

        pub fn radiant_team_name(&self) -> &str {
            match self.radiant_team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_radiant_team_name(&mut self) {
            self.radiant_team_name = ::std::option::Option::None;
        }

        pub fn has_radiant_team_name(&self) -> bool {
            self.radiant_team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_radiant_team_name(&mut self, v: ::std::string::String) {
            self.radiant_team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_radiant_team_name(&mut self) -> &mut ::std::string::String {
            if self.radiant_team_name.is_none() {
                self.radiant_team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.radiant_team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_radiant_team_name(&mut self) -> ::std::string::String {
            self.radiant_team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 radiant_team_logo = 4;

        pub fn radiant_team_logo(&self) -> u64 {
            self.radiant_team_logo.unwrap_or(0)
        }

        pub fn clear_radiant_team_logo(&mut self) {
            self.radiant_team_logo = ::std::option::Option::None;
        }

        pub fn has_radiant_team_logo(&self) -> bool {
            self.radiant_team_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_radiant_team_logo(&mut self, v: u64) {
            self.radiant_team_logo = ::std::option::Option::Some(v);
        }

        // optional string radiant_team_logo_url = 14;

        pub fn radiant_team_logo_url(&self) -> &str {
            match self.radiant_team_logo_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_radiant_team_logo_url(&mut self) {
            self.radiant_team_logo_url = ::std::option::Option::None;
        }

        pub fn has_radiant_team_logo_url(&self) -> bool {
            self.radiant_team_logo_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_radiant_team_logo_url(&mut self, v: ::std::string::String) {
            self.radiant_team_logo_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_radiant_team_logo_url(&mut self) -> &mut ::std::string::String {
            if self.radiant_team_logo_url.is_none() {
                self.radiant_team_logo_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.radiant_team_logo_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_radiant_team_logo_url(&mut self) -> ::std::string::String {
            self.radiant_team_logo_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 dire_team_id = 5;

        pub fn dire_team_id(&self) -> u32 {
            self.dire_team_id.unwrap_or(0)
        }

        pub fn clear_dire_team_id(&mut self) {
            self.dire_team_id = ::std::option::Option::None;
        }

        pub fn has_dire_team_id(&self) -> bool {
            self.dire_team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dire_team_id(&mut self, v: u32) {
            self.dire_team_id = ::std::option::Option::Some(v);
        }

        // optional string dire_team_name = 6;

        pub fn dire_team_name(&self) -> &str {
            match self.dire_team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_dire_team_name(&mut self) {
            self.dire_team_name = ::std::option::Option::None;
        }

        pub fn has_dire_team_name(&self) -> bool {
            self.dire_team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dire_team_name(&mut self, v: ::std::string::String) {
            self.dire_team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_dire_team_name(&mut self) -> &mut ::std::string::String {
            if self.dire_team_name.is_none() {
                self.dire_team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.dire_team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_dire_team_name(&mut self) -> ::std::string::String {
            self.dire_team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 dire_team_logo = 7;

        pub fn dire_team_logo(&self) -> u64 {
            self.dire_team_logo.unwrap_or(0)
        }

        pub fn clear_dire_team_logo(&mut self) {
            self.dire_team_logo = ::std::option::Option::None;
        }

        pub fn has_dire_team_logo(&self) -> bool {
            self.dire_team_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dire_team_logo(&mut self, v: u64) {
            self.dire_team_logo = ::std::option::Option::Some(v);
        }

        // optional string dire_team_logo_url = 15;

        pub fn dire_team_logo_url(&self) -> &str {
            match self.dire_team_logo_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_dire_team_logo_url(&mut self) {
            self.dire_team_logo_url = ::std::option::Option::None;
        }

        pub fn has_dire_team_logo_url(&self) -> bool {
            self.dire_team_logo_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dire_team_logo_url(&mut self, v: ::std::string::String) {
            self.dire_team_logo_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_dire_team_logo_url(&mut self) -> &mut ::std::string::String {
            if self.dire_team_logo_url.is_none() {
                self.dire_team_logo_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.dire_team_logo_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_dire_team_logo_url(&mut self) -> ::std::string::String {
            self.dire_team_logo_url.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Tourney {
        const NAME: &'static str = "Tourney";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.series_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.series_game = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.weekend_tourney_tournament_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.weekend_tourney_season_trophy_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.weekend_tourney_division = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.weekend_tourney_skill_level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.radiant_team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.radiant_team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    33 => {
                        self.radiant_team_logo = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    114 => {
                        self.radiant_team_logo_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.dire_team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    50 => {
                        self.dire_team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    57 => {
                        self.dire_team_logo = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    122 => {
                        self.dire_team_logo_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.league_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.series_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.series_game {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.weekend_tourney_tournament_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.weekend_tourney_season_trophy_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.weekend_tourney_division {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.weekend_tourney_skill_level {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.radiant_team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.radiant_team_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.radiant_team_logo {
                my_size += 1 + 8;
            }
            if let Some(v) = self.radiant_team_logo_url.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(14, &v);
            }
            if let Some(v) = self.dire_team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.dire_team_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
            }
            if let Some(v) = self.dire_team_logo {
                my_size += 1 + 8;
            }
            if let Some(v) = self.dire_team_logo_url.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(15, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.league_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.series_type {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.series_game {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.weekend_tourney_tournament_id {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.weekend_tourney_season_trophy_id {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.weekend_tourney_division {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.weekend_tourney_skill_level {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.radiant_team_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.radiant_team_name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.radiant_team_logo {
                os.write_fixed64(4, v)?;
            }
            if let Some(v) = self.radiant_team_logo_url.as_ref() {
                os.write_string(14, v)?;
            }
            if let Some(v) = self.dire_team_id {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.dire_team_name.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.dire_team_logo {
                os.write_fixed64(7, v)?;
            }
            if let Some(v) = self.dire_team_logo_url.as_ref() {
                os.write_string(15, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tourney {
            Tourney::new()
        }

        fn clear(&mut self) {
            self.league_id = ::std::option::Option::None;
            self.series_type = ::std::option::Option::None;
            self.series_game = ::std::option::Option::None;
            self.weekend_tourney_tournament_id = ::std::option::Option::None;
            self.weekend_tourney_season_trophy_id = ::std::option::Option::None;
            self.weekend_tourney_division = ::std::option::Option::None;
            self.weekend_tourney_skill_level = ::std::option::Option::None;
            self.radiant_team_id = ::std::option::Option::None;
            self.radiant_team_name = ::std::option::Option::None;
            self.radiant_team_logo = ::std::option::Option::None;
            self.radiant_team_logo_url = ::std::option::Option::None;
            self.dire_team_id = ::std::option::Option::None;
            self.dire_team_name = ::std::option::Option::None;
            self.dire_team_logo = ::std::option::Option::None;
            self.dire_team_logo_url = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tourney {
            static instance: Tourney = Tourney {
                league_id: ::std::option::Option::None,
                series_type: ::std::option::Option::None,
                series_game: ::std::option::Option::None,
                weekend_tourney_tournament_id: ::std::option::Option::None,
                weekend_tourney_season_trophy_id: ::std::option::Option::None,
                weekend_tourney_division: ::std::option::Option::None,
                weekend_tourney_skill_level: ::std::option::Option::None,
                radiant_team_id: ::std::option::Option::None,
                radiant_team_name: ::std::option::Option::None,
                radiant_team_logo: ::std::option::Option::None,
                radiant_team_logo_url: ::std::option::Option::None,
                dire_team_id: ::std::option::Option::None,
                dire_team_name: ::std::option::Option::None,
                dire_team_logo: ::std::option::Option::None,
                dire_team_logo_url: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgConsumableUsage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgConsumableUsage {
    // message fields
    // @@protoc_insertion_point(field:CMsgConsumableUsage.item_def)
    pub item_def: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgConsumableUsage.quantity_change)
    pub quantity_change: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgConsumableUsage.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgConsumableUsage {
    fn default() -> &'a CMsgConsumableUsage {
        <CMsgConsumableUsage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgConsumableUsage {
    pub fn new() -> CMsgConsumableUsage {
        ::std::default::Default::default()
    }

    // optional uint32 item_def = 1;

    pub fn item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    // optional int32 quantity_change = 2;

    pub fn quantity_change(&self) -> i32 {
        self.quantity_change.unwrap_or(0)
    }

    pub fn clear_quantity_change(&mut self) {
        self.quantity_change = ::std::option::Option::None;
    }

    pub fn has_quantity_change(&self) -> bool {
        self.quantity_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity_change(&mut self, v: i32) {
        self.quantity_change = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgConsumableUsage {
    const NAME: &'static str = "CMsgConsumableUsage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.quantity_change = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.quantity_change {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_def {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quantity_change {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgConsumableUsage {
        CMsgConsumableUsage::new()
    }

    fn clear(&mut self) {
        self.item_def = ::std::option::Option::None;
        self.quantity_change = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgConsumableUsage {
        static instance: CMsgConsumableUsage = CMsgConsumableUsage {
            item_def: ::std::option::Option::None,
            quantity_change: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMatchConsumableUsage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMatchConsumableUsage {
    // message fields
    // @@protoc_insertion_point(field:CMsgMatchConsumableUsage.player_consumables_used)
    pub player_consumables_used: ::std::vec::Vec<cmsg_match_consumable_usage::PlayerUsage>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMatchConsumableUsage.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMatchConsumableUsage {
    fn default() -> &'a CMsgMatchConsumableUsage {
        <CMsgMatchConsumableUsage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgMatchConsumableUsage {
    pub fn new() -> CMsgMatchConsumableUsage {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgMatchConsumableUsage {
    const NAME: &'static str = "CMsgMatchConsumableUsage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_consumables_used.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_consumables_used {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.player_consumables_used {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMatchConsumableUsage {
        CMsgMatchConsumableUsage::new()
    }

    fn clear(&mut self) {
        self.player_consumables_used.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMatchConsumableUsage {
        static instance: CMsgMatchConsumableUsage = CMsgMatchConsumableUsage {
            player_consumables_used: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgMatchConsumableUsage`
pub mod cmsg_match_consumable_usage {
    // @@protoc_insertion_point(message:CMsgMatchConsumableUsage.PlayerUsage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerUsage {
        // message fields
        // @@protoc_insertion_point(field:CMsgMatchConsumableUsage.PlayerUsage.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgMatchConsumableUsage.PlayerUsage.consumables_used)
        pub consumables_used: ::std::vec::Vec<super::CMsgConsumableUsage>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgMatchConsumableUsage.PlayerUsage.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerUsage {
        fn default() -> &'a PlayerUsage {
            <PlayerUsage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerUsage {
        pub fn new() -> PlayerUsage {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerUsage {
        const NAME: &'static str = "PlayerUsage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.consumables_used.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.consumables_used {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.consumables_used {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerUsage {
            PlayerUsage::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.consumables_used.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerUsage {
            static instance: PlayerUsage = PlayerUsage {
                account_id: ::std::option::Option::None,
                consumables_used: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgMatchEventActionGrants)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMatchEventActionGrants {
    // message fields
    // @@protoc_insertion_point(field:CMsgMatchEventActionGrants.player_grants)
    pub player_grants: ::std::vec::Vec<cmsg_match_event_action_grants::PlayerGrants>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMatchEventActionGrants.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMatchEventActionGrants {
    fn default() -> &'a CMsgMatchEventActionGrants {
        <CMsgMatchEventActionGrants as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgMatchEventActionGrants {
    pub fn new() -> CMsgMatchEventActionGrants {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgMatchEventActionGrants {
    const NAME: &'static str = "CMsgMatchEventActionGrants";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_grants.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_grants {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.player_grants {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMatchEventActionGrants {
        CMsgMatchEventActionGrants::new()
    }

    fn clear(&mut self) {
        self.player_grants.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMatchEventActionGrants {
        static instance: CMsgMatchEventActionGrants = CMsgMatchEventActionGrants {
            player_grants: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgMatchEventActionGrants`
pub mod cmsg_match_event_action_grants {
    // @@protoc_insertion_point(message:CMsgMatchEventActionGrants.PlayerGrants)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerGrants {
        // message fields
        // @@protoc_insertion_point(field:CMsgMatchEventActionGrants.PlayerGrants.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgMatchEventActionGrants.PlayerGrants.actions_granted)
        pub actions_granted: ::std::vec::Vec<super::super::dota_shared_enums::CMsgPendingEventAward>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgMatchEventActionGrants.PlayerGrants.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerGrants {
        fn default() -> &'a PlayerGrants {
            <PlayerGrants as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerGrants {
        pub fn new() -> PlayerGrants {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerGrants {
        const NAME: &'static str = "PlayerGrants";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.actions_granted.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.actions_granted {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.actions_granted {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerGrants {
            PlayerGrants::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.actions_granted.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerGrants {
            static instance: PlayerGrants = PlayerGrants {
                account_id: ::std::option::Option::None,
                actions_granted: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgCustomGameWhitelist)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCustomGameWhitelist {
    // message fields
    // @@protoc_insertion_point(field:CMsgCustomGameWhitelist.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCustomGameWhitelist.custom_games_whitelist)
    pub custom_games_whitelist: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgCustomGameWhitelist.disable_whitelist)
    pub disable_whitelist: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCustomGameWhitelist.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCustomGameWhitelist {
    fn default() -> &'a CMsgCustomGameWhitelist {
        <CMsgCustomGameWhitelist as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgCustomGameWhitelist {
    pub fn new() -> CMsgCustomGameWhitelist {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional bool disable_whitelist = 3;

    pub fn disable_whitelist(&self) -> bool {
        self.disable_whitelist.unwrap_or(false)
    }

    pub fn clear_disable_whitelist(&mut self) {
        self.disable_whitelist = ::std::option::Option::None;
    }

    pub fn has_disable_whitelist(&self) -> bool {
        self.disable_whitelist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_whitelist(&mut self, v: bool) {
        self.disable_whitelist = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgCustomGameWhitelist {
    const NAME: &'static str = "CMsgCustomGameWhitelist";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.custom_games_whitelist)?;
                },
                16 => {
                    self.custom_games_whitelist.push(is.read_uint64()?);
                },
                24 => {
                    self.disable_whitelist = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.custom_games_whitelist {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, *value);
        };
        if let Some(v) = self.disable_whitelist {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        for v in &self.custom_games_whitelist {
            os.write_uint64(2, *v)?;
        };
        if let Some(v) = self.disable_whitelist {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCustomGameWhitelist {
        CMsgCustomGameWhitelist::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.custom_games_whitelist.clear();
        self.disable_whitelist = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCustomGameWhitelist {
        static instance: CMsgCustomGameWhitelist = CMsgCustomGameWhitelist {
            version: ::std::option::Option::None,
            custom_games_whitelist: ::std::vec::Vec::new(),
            disable_whitelist: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgCustomGameWhitelistForEdit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCustomGameWhitelistForEdit {
    // message fields
    // @@protoc_insertion_point(field:CMsgCustomGameWhitelistForEdit.whitelist_entries)
    pub whitelist_entries: ::std::vec::Vec<cmsg_custom_game_whitelist_for_edit::WhitelistEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCustomGameWhitelistForEdit.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCustomGameWhitelistForEdit {
    fn default() -> &'a CMsgCustomGameWhitelistForEdit {
        <CMsgCustomGameWhitelistForEdit as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgCustomGameWhitelistForEdit {
    pub fn new() -> CMsgCustomGameWhitelistForEdit {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgCustomGameWhitelistForEdit {
    const NAME: &'static str = "CMsgCustomGameWhitelistForEdit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.whitelist_entries.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.whitelist_entries {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.whitelist_entries {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCustomGameWhitelistForEdit {
        CMsgCustomGameWhitelistForEdit::new()
    }

    fn clear(&mut self) {
        self.whitelist_entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCustomGameWhitelistForEdit {
        static instance: CMsgCustomGameWhitelistForEdit = CMsgCustomGameWhitelistForEdit {
            whitelist_entries: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgCustomGameWhitelistForEdit`
pub mod cmsg_custom_game_whitelist_for_edit {
    // @@protoc_insertion_point(message:CMsgCustomGameWhitelistForEdit.WhitelistEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WhitelistEntry {
        // message fields
        // @@protoc_insertion_point(field:CMsgCustomGameWhitelistForEdit.WhitelistEntry.custom_game_id)
        pub custom_game_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgCustomGameWhitelistForEdit.WhitelistEntry.whitelist_state)
        pub whitelist_state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::ECustomGameWhitelistState>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgCustomGameWhitelistForEdit.WhitelistEntry.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WhitelistEntry {
        fn default() -> &'a WhitelistEntry {
            <WhitelistEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl WhitelistEntry {
        pub fn new() -> WhitelistEntry {
            ::std::default::Default::default()
        }

        // optional uint64 custom_game_id = 1;

        pub fn custom_game_id(&self) -> u64 {
            self.custom_game_id.unwrap_or(0)
        }

        pub fn clear_custom_game_id(&mut self) {
            self.custom_game_id = ::std::option::Option::None;
        }

        pub fn has_custom_game_id(&self) -> bool {
            self.custom_game_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_custom_game_id(&mut self, v: u64) {
            self.custom_game_id = ::std::option::Option::Some(v);
        }

        // optional .ECustomGameWhitelistState whitelist_state = 2;

        pub fn whitelist_state(&self) -> super::ECustomGameWhitelistState {
            match self.whitelist_state {
                Some(e) => e.enum_value_or(super::ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_UNKNOWN),
                None => super::ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_UNKNOWN,
            }
        }

        pub fn clear_whitelist_state(&mut self) {
            self.whitelist_state = ::std::option::Option::None;
        }

        pub fn has_whitelist_state(&self) -> bool {
            self.whitelist_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_whitelist_state(&mut self, v: super::ECustomGameWhitelistState) {
            self.whitelist_state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for WhitelistEntry {
        const NAME: &'static str = "WhitelistEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.whitelist_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.custom_game_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.whitelist_state {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.custom_game_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.whitelist_state {
                os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WhitelistEntry {
            WhitelistEntry::new()
        }

        fn clear(&mut self) {
            self.custom_game_id = ::std::option::Option::None;
            self.whitelist_state = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WhitelistEntry {
            static instance: WhitelistEntry = WhitelistEntry {
                custom_game_id: ::std::option::Option::None,
                whitelist_state: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgPlayerRecentMatchInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerRecentMatchInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgPlayerRecentMatchInfo.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPlayerRecentMatchInfo.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerRecentMatchInfo.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerRecentMatchInfo.win)
    pub win: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPlayerRecentMatchInfo.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgPlayerRecentMatchInfo.kills)
    pub kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerRecentMatchInfo.deaths)
    pub deaths: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerRecentMatchInfo.assists)
    pub assists: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPlayerRecentMatchInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerRecentMatchInfo {
    fn default() -> &'a CMsgPlayerRecentMatchInfo {
        <CMsgPlayerRecentMatchInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerRecentMatchInfo {
    pub fn new() -> CMsgPlayerRecentMatchInfo {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 3;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool win = 4;

    pub fn win(&self) -> bool {
        self.win.unwrap_or(false)
    }

    pub fn clear_win(&mut self) {
        self.win = ::std::option::Option::None;
    }

    pub fn has_win(&self) -> bool {
        self.win.is_some()
    }

    // Param is passed by value, moved
    pub fn set_win(&mut self, v: bool) {
        self.win = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 5;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 kills = 6;

    pub fn kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional uint32 deaths = 7;

    pub fn deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 assists = 8;

    pub fn assists(&self) -> u32 {
        self.assists.unwrap_or(0)
    }

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: u32) {
        self.assists = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPlayerRecentMatchInfo {
    const NAME: &'static str = "CMsgPlayerRecentMatchInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.win = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.assists = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.win {
            my_size += 1 + 1;
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.deaths {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.assists {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.win {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.assists {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerRecentMatchInfo {
        CMsgPlayerRecentMatchInfo::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.win = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.assists = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerRecentMatchInfo {
        static instance: CMsgPlayerRecentMatchInfo = CMsgPlayerRecentMatchInfo {
            match_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            win: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            kills: ::std::option::Option::None,
            deaths: ::std::option::Option::None,
            assists: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPlayerMatchRecord)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerMatchRecord {
    // message fields
    // @@protoc_insertion_point(field:CMsgPlayerMatchRecord.wins)
    pub wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerMatchRecord.losses)
    pub losses: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPlayerMatchRecord.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerMatchRecord {
    fn default() -> &'a CMsgPlayerMatchRecord {
        <CMsgPlayerMatchRecord as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerMatchRecord {
    pub fn new() -> CMsgPlayerMatchRecord {
        ::std::default::Default::default()
    }

    // optional uint32 wins = 1;

    pub fn wins(&self) -> u32 {
        self.wins.unwrap_or(0)
    }

    pub fn clear_wins(&mut self) {
        self.wins = ::std::option::Option::None;
    }

    pub fn has_wins(&self) -> bool {
        self.wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wins(&mut self, v: u32) {
        self.wins = ::std::option::Option::Some(v);
    }

    // optional uint32 losses = 2;

    pub fn losses(&self) -> u32 {
        self.losses.unwrap_or(0)
    }

    pub fn clear_losses(&mut self) {
        self.losses = ::std::option::Option::None;
    }

    pub fn has_losses(&self) -> bool {
        self.losses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_losses(&mut self, v: u32) {
        self.losses = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPlayerMatchRecord {
    const NAME: &'static str = "CMsgPlayerMatchRecord";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.losses = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.wins {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.losses {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.wins {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.losses {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerMatchRecord {
        CMsgPlayerMatchRecord::new()
    }

    fn clear(&mut self) {
        self.wins = ::std::option::Option::None;
        self.losses = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerMatchRecord {
        static instance: CMsgPlayerMatchRecord = CMsgPlayerMatchRecord {
            wins: ::std::option::Option::None,
            losses: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPlayerRecentMatchOutcomes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerRecentMatchOutcomes {
    // message fields
    // @@protoc_insertion_point(field:CMsgPlayerRecentMatchOutcomes.outcomes)
    pub outcomes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerRecentMatchOutcomes.match_count)
    pub match_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPlayerRecentMatchOutcomes.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerRecentMatchOutcomes {
    fn default() -> &'a CMsgPlayerRecentMatchOutcomes {
        <CMsgPlayerRecentMatchOutcomes as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerRecentMatchOutcomes {
    pub fn new() -> CMsgPlayerRecentMatchOutcomes {
        ::std::default::Default::default()
    }

    // optional uint32 outcomes = 1;

    pub fn outcomes(&self) -> u32 {
        self.outcomes.unwrap_or(0)
    }

    pub fn clear_outcomes(&mut self) {
        self.outcomes = ::std::option::Option::None;
    }

    pub fn has_outcomes(&self) -> bool {
        self.outcomes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outcomes(&mut self, v: u32) {
        self.outcomes = ::std::option::Option::Some(v);
    }

    // optional uint32 match_count = 2;

    pub fn match_count(&self) -> u32 {
        self.match_count.unwrap_or(0)
    }

    pub fn clear_match_count(&mut self) {
        self.match_count = ::std::option::Option::None;
    }

    pub fn has_match_count(&self) -> bool {
        self.match_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_count(&mut self, v: u32) {
        self.match_count = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPlayerRecentMatchOutcomes {
    const NAME: &'static str = "CMsgPlayerRecentMatchOutcomes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.outcomes = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.match_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.outcomes {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.outcomes {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_count {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerRecentMatchOutcomes {
        CMsgPlayerRecentMatchOutcomes::new()
    }

    fn clear(&mut self) {
        self.outcomes = ::std::option::Option::None;
        self.match_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerRecentMatchOutcomes {
        static instance: CMsgPlayerRecentMatchOutcomes = CMsgPlayerRecentMatchOutcomes {
            outcomes: ::std::option::Option::None,
            match_count: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPlayerRecentCommends)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerRecentCommends {
    // message fields
    // @@protoc_insertion_point(field:CMsgPlayerRecentCommends.commends)
    pub commends: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerRecentCommends.match_count)
    pub match_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPlayerRecentCommends.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerRecentCommends {
    fn default() -> &'a CMsgPlayerRecentCommends {
        <CMsgPlayerRecentCommends as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerRecentCommends {
    pub fn new() -> CMsgPlayerRecentCommends {
        ::std::default::Default::default()
    }

    // optional uint32 commends = 1;

    pub fn commends(&self) -> u32 {
        self.commends.unwrap_or(0)
    }

    pub fn clear_commends(&mut self) {
        self.commends = ::std::option::Option::None;
    }

    pub fn has_commends(&self) -> bool {
        self.commends.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commends(&mut self, v: u32) {
        self.commends = ::std::option::Option::Some(v);
    }

    // optional uint32 match_count = 2;

    pub fn match_count(&self) -> u32 {
        self.match_count.unwrap_or(0)
    }

    pub fn clear_match_count(&mut self) {
        self.match_count = ::std::option::Option::None;
    }

    pub fn has_match_count(&self) -> bool {
        self.match_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_count(&mut self, v: u32) {
        self.match_count = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPlayerRecentCommends {
    const NAME: &'static str = "CMsgPlayerRecentCommends";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.commends = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.match_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.commends {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.commends {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_count {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerRecentCommends {
        CMsgPlayerRecentCommends::new()
    }

    fn clear(&mut self) {
        self.commends = ::std::option::Option::None;
        self.match_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerRecentCommends {
        static instance: CMsgPlayerRecentCommends = CMsgPlayerRecentCommends {
            commends: ::std::option::Option::None,
            match_count: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPlayerRecentAccomplishments)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerRecentAccomplishments {
    // message fields
    // @@protoc_insertion_point(field:CMsgPlayerRecentAccomplishments.recent_outcomes)
    pub recent_outcomes: ::steam_vent_proto_common::protobuf::MessageField<CMsgPlayerRecentMatchOutcomes>,
    // @@protoc_insertion_point(field:CMsgPlayerRecentAccomplishments.total_record)
    pub total_record: ::steam_vent_proto_common::protobuf::MessageField<CMsgPlayerMatchRecord>,
    // @@protoc_insertion_point(field:CMsgPlayerRecentAccomplishments.prediction_streak)
    pub prediction_streak: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerRecentAccomplishments.plus_prediction_streak)
    pub plus_prediction_streak: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerRecentAccomplishments.recent_commends)
    pub recent_commends: ::steam_vent_proto_common::protobuf::MessageField<CMsgPlayerRecentCommends>,
    // @@protoc_insertion_point(field:CMsgPlayerRecentAccomplishments.first_match_timestamp)
    pub first_match_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerRecentAccomplishments.last_match)
    pub last_match: ::steam_vent_proto_common::protobuf::MessageField<CMsgPlayerRecentMatchInfo>,
    // @@protoc_insertion_point(field:CMsgPlayerRecentAccomplishments.recent_mvps)
    pub recent_mvps: ::steam_vent_proto_common::protobuf::MessageField<CMsgPlayerRecentMatchOutcomes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPlayerRecentAccomplishments.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerRecentAccomplishments {
    fn default() -> &'a CMsgPlayerRecentAccomplishments {
        <CMsgPlayerRecentAccomplishments as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerRecentAccomplishments {
    pub fn new() -> CMsgPlayerRecentAccomplishments {
        ::std::default::Default::default()
    }

    // optional uint32 prediction_streak = 3;

    pub fn prediction_streak(&self) -> u32 {
        self.prediction_streak.unwrap_or(0)
    }

    pub fn clear_prediction_streak(&mut self) {
        self.prediction_streak = ::std::option::Option::None;
    }

    pub fn has_prediction_streak(&self) -> bool {
        self.prediction_streak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prediction_streak(&mut self, v: u32) {
        self.prediction_streak = ::std::option::Option::Some(v);
    }

    // optional uint32 plus_prediction_streak = 4;

    pub fn plus_prediction_streak(&self) -> u32 {
        self.plus_prediction_streak.unwrap_or(0)
    }

    pub fn clear_plus_prediction_streak(&mut self) {
        self.plus_prediction_streak = ::std::option::Option::None;
    }

    pub fn has_plus_prediction_streak(&self) -> bool {
        self.plus_prediction_streak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plus_prediction_streak(&mut self, v: u32) {
        self.plus_prediction_streak = ::std::option::Option::Some(v);
    }

    // optional uint32 first_match_timestamp = 6;

    pub fn first_match_timestamp(&self) -> u32 {
        self.first_match_timestamp.unwrap_or(0)
    }

    pub fn clear_first_match_timestamp(&mut self) {
        self.first_match_timestamp = ::std::option::Option::None;
    }

    pub fn has_first_match_timestamp(&self) -> bool {
        self.first_match_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_match_timestamp(&mut self, v: u32) {
        self.first_match_timestamp = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPlayerRecentAccomplishments {
    const NAME: &'static str = "CMsgPlayerRecentAccomplishments";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.recent_outcomes)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.total_record)?;
                },
                24 => {
                    self.prediction_streak = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.plus_prediction_streak = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.recent_commends)?;
                },
                48 => {
                    self.first_match_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.last_match)?;
                },
                66 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.recent_mvps)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.recent_outcomes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.total_record.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.prediction_streak {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.plus_prediction_streak {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.recent_commends.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.first_match_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.last_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.recent_mvps.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.recent_outcomes.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.total_record.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.prediction_streak {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.plus_prediction_streak {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.recent_commends.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.first_match_timestamp {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.last_match.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.recent_mvps.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerRecentAccomplishments {
        CMsgPlayerRecentAccomplishments::new()
    }

    fn clear(&mut self) {
        self.recent_outcomes.clear();
        self.total_record.clear();
        self.prediction_streak = ::std::option::Option::None;
        self.plus_prediction_streak = ::std::option::Option::None;
        self.recent_commends.clear();
        self.first_match_timestamp = ::std::option::Option::None;
        self.last_match.clear();
        self.recent_mvps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerRecentAccomplishments {
        static instance: CMsgPlayerRecentAccomplishments = CMsgPlayerRecentAccomplishments {
            recent_outcomes: ::steam_vent_proto_common::protobuf::MessageField::none(),
            total_record: ::steam_vent_proto_common::protobuf::MessageField::none(),
            prediction_streak: ::std::option::Option::None,
            plus_prediction_streak: ::std::option::Option::None,
            recent_commends: ::steam_vent_proto_common::protobuf::MessageField::none(),
            first_match_timestamp: ::std::option::Option::None,
            last_match: ::steam_vent_proto_common::protobuf::MessageField::none(),
            recent_mvps: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPlayerHeroRecentAccomplishments)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerHeroRecentAccomplishments {
    // message fields
    // @@protoc_insertion_point(field:CMsgPlayerHeroRecentAccomplishments.recent_outcomes)
    pub recent_outcomes: ::steam_vent_proto_common::protobuf::MessageField<CMsgPlayerRecentMatchOutcomes>,
    // @@protoc_insertion_point(field:CMsgPlayerHeroRecentAccomplishments.total_record)
    pub total_record: ::steam_vent_proto_common::protobuf::MessageField<CMsgPlayerMatchRecord>,
    // @@protoc_insertion_point(field:CMsgPlayerHeroRecentAccomplishments.last_match)
    pub last_match: ::steam_vent_proto_common::protobuf::MessageField<CMsgPlayerRecentMatchInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPlayerHeroRecentAccomplishments.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerHeroRecentAccomplishments {
    fn default() -> &'a CMsgPlayerHeroRecentAccomplishments {
        <CMsgPlayerHeroRecentAccomplishments as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerHeroRecentAccomplishments {
    pub fn new() -> CMsgPlayerHeroRecentAccomplishments {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPlayerHeroRecentAccomplishments {
    const NAME: &'static str = "CMsgPlayerHeroRecentAccomplishments";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.recent_outcomes)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.total_record)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.last_match)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.recent_outcomes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.total_record.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.last_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.recent_outcomes.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.total_record.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.last_match.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerHeroRecentAccomplishments {
        CMsgPlayerHeroRecentAccomplishments::new()
    }

    fn clear(&mut self) {
        self.recent_outcomes.clear();
        self.total_record.clear();
        self.last_match.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerHeroRecentAccomplishments {
        static instance: CMsgPlayerHeroRecentAccomplishments = CMsgPlayerHeroRecentAccomplishments {
            recent_outcomes: ::steam_vent_proto_common::protobuf::MessageField::none(),
            total_record: ::steam_vent_proto_common::protobuf::MessageField::none(),
            last_match: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRecentAccomplishments)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRecentAccomplishments {
    // message fields
    // @@protoc_insertion_point(field:CMsgRecentAccomplishments.player_accomplishments)
    pub player_accomplishments: ::steam_vent_proto_common::protobuf::MessageField<CMsgPlayerRecentAccomplishments>,
    // @@protoc_insertion_point(field:CMsgRecentAccomplishments.hero_accomplishments)
    pub hero_accomplishments: ::steam_vent_proto_common::protobuf::MessageField<CMsgPlayerHeroRecentAccomplishments>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRecentAccomplishments.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRecentAccomplishments {
    fn default() -> &'a CMsgRecentAccomplishments {
        <CMsgRecentAccomplishments as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgRecentAccomplishments {
    pub fn new() -> CMsgRecentAccomplishments {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgRecentAccomplishments {
    const NAME: &'static str = "CMsgRecentAccomplishments";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.player_accomplishments)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.hero_accomplishments)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_accomplishments.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.hero_accomplishments.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_accomplishments.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.hero_accomplishments.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRecentAccomplishments {
        CMsgRecentAccomplishments::new()
    }

    fn clear(&mut self) {
        self.player_accomplishments.clear();
        self.hero_accomplishments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRecentAccomplishments {
        static instance: CMsgRecentAccomplishments = CMsgRecentAccomplishments {
            player_accomplishments: ::steam_vent_proto_common::protobuf::MessageField::none(),
            hero_accomplishments: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCRequestPlayerRecentAccomplishments)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCRequestPlayerRecentAccomplishments {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCRequestPlayerRecentAccomplishments.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCRequestPlayerRecentAccomplishments.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCRequestPlayerRecentAccomplishments.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCRequestPlayerRecentAccomplishments {
    fn default() -> &'a CMsgServerToGCRequestPlayerRecentAccomplishments {
        <CMsgServerToGCRequestPlayerRecentAccomplishments as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCRequestPlayerRecentAccomplishments {
    pub fn new() -> CMsgServerToGCRequestPlayerRecentAccomplishments {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 2;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCRequestPlayerRecentAccomplishments {
    const NAME: &'static str = "CMsgServerToGCRequestPlayerRecentAccomplishments";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCRequestPlayerRecentAccomplishments {
        CMsgServerToGCRequestPlayerRecentAccomplishments::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCRequestPlayerRecentAccomplishments {
        static instance: CMsgServerToGCRequestPlayerRecentAccomplishments = CMsgServerToGCRequestPlayerRecentAccomplishments {
            account_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_server_to_gcrequest_player_recent_accomplishments_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.player_accomplishments)
    pub player_accomplishments: ::steam_vent_proto_common::protobuf::MessageField<CMsgRecentAccomplishments>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
    fn default() -> &'a CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
        <CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
    pub fn new() -> CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_server_to_gcrequest_player_recent_accomplishments_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_server_to_gcrequest_player_recent_accomplishments_response::EResponse::k_eInternalError),
            None => cmsg_server_to_gcrequest_player_recent_accomplishments_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_server_to_gcrequest_player_recent_accomplishments_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
    const NAME: &'static str = "CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.player_accomplishments)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.player_accomplishments.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.player_accomplishments.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
        CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.player_accomplishments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
        static instance: CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse = CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
            result: ::std::option::Option::None,
            player_accomplishments: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse`
pub mod cmsg_server_to_gcrequest_player_recent_accomplishments_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgArcanaVoteMatchVotes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgArcanaVoteMatchVotes {
    // message fields
    // @@protoc_insertion_point(field:CMsgArcanaVoteMatchVotes.match_id)
    pub match_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgArcanaVoteMatchVotes.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgArcanaVoteMatchVotes.vote_count)
    pub vote_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgArcanaVoteMatchVotes.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgArcanaVoteMatchVotes {
    fn default() -> &'a CMsgArcanaVoteMatchVotes {
        <CMsgArcanaVoteMatchVotes as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgArcanaVoteMatchVotes {
    pub fn new() -> CMsgArcanaVoteMatchVotes {
        ::std::default::Default::default()
    }

    // optional uint32 match_id = 1;

    pub fn match_id(&self) -> u32 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u32) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 2;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 vote_count = 3;

    pub fn vote_count(&self) -> u32 {
        self.vote_count.unwrap_or(0)
    }

    pub fn clear_vote_count(&mut self) {
        self.vote_count = ::std::option::Option::None;
    }

    pub fn has_vote_count(&self) -> bool {
        self.vote_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_count(&mut self, v: u32) {
        self.vote_count = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgArcanaVoteMatchVotes {
    const NAME: &'static str = "CMsgArcanaVoteMatchVotes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.vote_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.vote_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.vote_count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgArcanaVoteMatchVotes {
        CMsgArcanaVoteMatchVotes::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.vote_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgArcanaVoteMatchVotes {
        static instance: CMsgArcanaVoteMatchVotes = CMsgArcanaVoteMatchVotes {
            match_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            vote_count: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCtoGCAssociatedExploiterAccountInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCtoGCAssociatedExploiterAccountInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCtoGCAssociatedExploiterAccountInfo.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCtoGCAssociatedExploiterAccountInfo.num_matches_to_search)
    pub num_matches_to_search: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCtoGCAssociatedExploiterAccountInfo.min_shared_match_count)
    pub min_shared_match_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCtoGCAssociatedExploiterAccountInfo.num_additional_players)
    pub num_additional_players: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCtoGCAssociatedExploiterAccountInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCtoGCAssociatedExploiterAccountInfo {
    fn default() -> &'a CMsgGCtoGCAssociatedExploiterAccountInfo {
        <CMsgGCtoGCAssociatedExploiterAccountInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCtoGCAssociatedExploiterAccountInfo {
    pub fn new() -> CMsgGCtoGCAssociatedExploiterAccountInfo {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 num_matches_to_search = 2;

    pub fn num_matches_to_search(&self) -> u32 {
        self.num_matches_to_search.unwrap_or(0)
    }

    pub fn clear_num_matches_to_search(&mut self) {
        self.num_matches_to_search = ::std::option::Option::None;
    }

    pub fn has_num_matches_to_search(&self) -> bool {
        self.num_matches_to_search.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_matches_to_search(&mut self, v: u32) {
        self.num_matches_to_search = ::std::option::Option::Some(v);
    }

    // optional uint32 min_shared_match_count = 3;

    pub fn min_shared_match_count(&self) -> u32 {
        self.min_shared_match_count.unwrap_or(0)
    }

    pub fn clear_min_shared_match_count(&mut self) {
        self.min_shared_match_count = ::std::option::Option::None;
    }

    pub fn has_min_shared_match_count(&self) -> bool {
        self.min_shared_match_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_shared_match_count(&mut self, v: u32) {
        self.min_shared_match_count = ::std::option::Option::Some(v);
    }

    // optional uint32 num_additional_players = 4;

    pub fn num_additional_players(&self) -> u32 {
        self.num_additional_players.unwrap_or(0)
    }

    pub fn clear_num_additional_players(&mut self) {
        self.num_additional_players = ::std::option::Option::None;
    }

    pub fn has_num_additional_players(&self) -> bool {
        self.num_additional_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_additional_players(&mut self, v: u32) {
        self.num_additional_players = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCtoGCAssociatedExploiterAccountInfo {
    const NAME: &'static str = "CMsgGCtoGCAssociatedExploiterAccountInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.num_matches_to_search = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.min_shared_match_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.num_additional_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.num_matches_to_search {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.min_shared_match_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.num_additional_players {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_matches_to_search {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.min_shared_match_count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.num_additional_players {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCtoGCAssociatedExploiterAccountInfo {
        CMsgGCtoGCAssociatedExploiterAccountInfo::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.num_matches_to_search = ::std::option::Option::None;
        self.min_shared_match_count = ::std::option::Option::None;
        self.num_additional_players = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCtoGCAssociatedExploiterAccountInfo {
        static instance: CMsgGCtoGCAssociatedExploiterAccountInfo = CMsgGCtoGCAssociatedExploiterAccountInfo {
            account_id: ::std::option::Option::None,
            num_matches_to_search: ::std::option::Option::None,
            min_shared_match_count: ::std::option::Option::None,
            num_additional_players: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCtoGCAssociatedExploiterAccountInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCtoGCAssociatedExploiterAccountInfoResponse.accounts)
    pub accounts: ::std::vec::Vec<cmsg_gcto_gcassociated_exploiter_account_info_response::Account>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCtoGCAssociatedExploiterAccountInfoResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
    fn default() -> &'a CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
        <CMsgGCtoGCAssociatedExploiterAccountInfoResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
    pub fn new() -> CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
    const NAME: &'static str = "CMsgGCtoGCAssociatedExploiterAccountInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.accounts.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.accounts {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.accounts {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
        CMsgGCtoGCAssociatedExploiterAccountInfoResponse::new()
    }

    fn clear(&mut self) {
        self.accounts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
        static instance: CMsgGCtoGCAssociatedExploiterAccountInfoResponse = CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
            accounts: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCtoGCAssociatedExploiterAccountInfoResponse`
pub mod cmsg_gcto_gcassociated_exploiter_account_info_response {
    // @@protoc_insertion_point(message:CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Account {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account.num_common_matches)
        pub num_common_matches: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account.earliest_common_match)
        pub earliest_common_match: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account.latest_common_match)
        pub latest_common_match: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account.generation)
        pub generation: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account.persona)
        pub persona: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account.already_banned)
        pub already_banned: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Account {
        fn default() -> &'a Account {
            <Account as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Account {
        pub fn new() -> Account {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 num_common_matches = 2;

        pub fn num_common_matches(&self) -> u32 {
            self.num_common_matches.unwrap_or(0)
        }

        pub fn clear_num_common_matches(&mut self) {
            self.num_common_matches = ::std::option::Option::None;
        }

        pub fn has_num_common_matches(&self) -> bool {
            self.num_common_matches.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_common_matches(&mut self, v: u32) {
            self.num_common_matches = ::std::option::Option::Some(v);
        }

        // optional uint32 earliest_common_match = 3;

        pub fn earliest_common_match(&self) -> u32 {
            self.earliest_common_match.unwrap_or(0)
        }

        pub fn clear_earliest_common_match(&mut self) {
            self.earliest_common_match = ::std::option::Option::None;
        }

        pub fn has_earliest_common_match(&self) -> bool {
            self.earliest_common_match.is_some()
        }

        // Param is passed by value, moved
        pub fn set_earliest_common_match(&mut self, v: u32) {
            self.earliest_common_match = ::std::option::Option::Some(v);
        }

        // optional uint32 latest_common_match = 4;

        pub fn latest_common_match(&self) -> u32 {
            self.latest_common_match.unwrap_or(0)
        }

        pub fn clear_latest_common_match(&mut self) {
            self.latest_common_match = ::std::option::Option::None;
        }

        pub fn has_latest_common_match(&self) -> bool {
            self.latest_common_match.is_some()
        }

        // Param is passed by value, moved
        pub fn set_latest_common_match(&mut self, v: u32) {
            self.latest_common_match = ::std::option::Option::Some(v);
        }

        // optional uint32 generation = 5;

        pub fn generation(&self) -> u32 {
            self.generation.unwrap_or(0)
        }

        pub fn clear_generation(&mut self) {
            self.generation = ::std::option::Option::None;
        }

        pub fn has_generation(&self) -> bool {
            self.generation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_generation(&mut self, v: u32) {
            self.generation = ::std::option::Option::Some(v);
        }

        // optional string persona = 6;

        pub fn persona(&self) -> &str {
            match self.persona.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_persona(&mut self) {
            self.persona = ::std::option::Option::None;
        }

        pub fn has_persona(&self) -> bool {
            self.persona.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona(&mut self, v: ::std::string::String) {
            self.persona = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_persona(&mut self) -> &mut ::std::string::String {
            if self.persona.is_none() {
                self.persona = ::std::option::Option::Some(::std::string::String::new());
            }
            self.persona.as_mut().unwrap()
        }

        // Take field
        pub fn take_persona(&mut self) -> ::std::string::String {
            self.persona.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool already_banned = 7;

        pub fn already_banned(&self) -> bool {
            self.already_banned.unwrap_or(false)
        }

        pub fn clear_already_banned(&mut self) {
            self.already_banned = ::std::option::Option::None;
        }

        pub fn has_already_banned(&self) -> bool {
            self.already_banned.is_some()
        }

        // Param is passed by value, moved
        pub fn set_already_banned(&mut self, v: bool) {
            self.already_banned = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Account {
        const NAME: &'static str = "Account";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.num_common_matches = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.earliest_common_match = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.latest_common_match = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.generation = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    50 => {
                        self.persona = ::std::option::Option::Some(is.read_string()?);
                    },
                    56 => {
                        self.already_banned = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.num_common_matches {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.earliest_common_match {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.latest_common_match {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.generation {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.persona.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
            }
            if let Some(v) = self.already_banned {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.num_common_matches {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.earliest_common_match {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.latest_common_match {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.generation {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.persona.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.already_banned {
                os.write_bool(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Account {
            Account::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.num_common_matches = ::std::option::Option::None;
            self.earliest_common_match = ::std::option::Option::None;
            self.latest_common_match = ::std::option::Option::None;
            self.generation = ::std::option::Option::None;
            self.persona = ::std::option::Option::None;
            self.already_banned = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Account {
            static instance: Account = Account {
                account_id: ::std::option::Option::None,
                num_common_matches: ::std::option::Option::None,
                earliest_common_match: ::std::option::Option::None,
                latest_common_match: ::std::option::Option::None,
                generation: ::std::option::Option::None,
                persona: ::std::option::Option::None,
                already_banned: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgPullTabsData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPullTabsData {
    // message fields
    // @@protoc_insertion_point(field:CMsgPullTabsData.slots)
    pub slots: ::std::vec::Vec<cmsg_pull_tabs_data::Slot>,
    // @@protoc_insertion_point(field:CMsgPullTabsData.jackpots)
    pub jackpots: ::std::vec::Vec<cmsg_pull_tabs_data::Jackpot>,
    // @@protoc_insertion_point(field:CMsgPullTabsData.last_board)
    pub last_board: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPullTabsData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPullTabsData {
    fn default() -> &'a CMsgPullTabsData {
        <CMsgPullTabsData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPullTabsData {
    pub fn new() -> CMsgPullTabsData {
        ::std::default::Default::default()
    }

    // optional uint32 last_board = 3;

    pub fn last_board(&self) -> u32 {
        self.last_board.unwrap_or(0)
    }

    pub fn clear_last_board(&mut self) {
        self.last_board = ::std::option::Option::None;
    }

    pub fn has_last_board(&self) -> bool {
        self.last_board.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_board(&mut self, v: u32) {
        self.last_board = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPullTabsData {
    const NAME: &'static str = "CMsgPullTabsData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.slots.push(is.read_message()?);
                },
                18 => {
                    self.jackpots.push(is.read_message()?);
                },
                24 => {
                    self.last_board = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.slots {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.jackpots {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.last_board {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.slots {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.jackpots {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.last_board {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPullTabsData {
        CMsgPullTabsData::new()
    }

    fn clear(&mut self) {
        self.slots.clear();
        self.jackpots.clear();
        self.last_board = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPullTabsData {
        static instance: CMsgPullTabsData = CMsgPullTabsData {
            slots: ::std::vec::Vec::new(),
            jackpots: ::std::vec::Vec::new(),
            last_board: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgPullTabsData`
pub mod cmsg_pull_tabs_data {
    // @@protoc_insertion_point(message:CMsgPullTabsData.Slot)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Slot {
        // message fields
        // @@protoc_insertion_point(field:CMsgPullTabsData.Slot.event_id)
        pub event_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgPullTabsData.Slot.board_id)
        pub board_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgPullTabsData.Slot.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgPullTabsData.Slot.action_id)
        pub action_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgPullTabsData.Slot.redeemed)
        pub redeemed: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgPullTabsData.Slot.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Slot {
        fn default() -> &'a Slot {
            <Slot as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Slot {
        pub fn new() -> Slot {
            ::std::default::Default::default()
        }

        // optional uint32 event_id = 1;

        pub fn event_id(&self) -> u32 {
            self.event_id.unwrap_or(0)
        }

        pub fn clear_event_id(&mut self) {
            self.event_id = ::std::option::Option::None;
        }

        pub fn has_event_id(&self) -> bool {
            self.event_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_id(&mut self, v: u32) {
            self.event_id = ::std::option::Option::Some(v);
        }

        // optional uint32 board_id = 2;

        pub fn board_id(&self) -> u32 {
            self.board_id.unwrap_or(0)
        }

        pub fn clear_board_id(&mut self) {
            self.board_id = ::std::option::Option::None;
        }

        pub fn has_board_id(&self) -> bool {
            self.board_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_board_id(&mut self, v: u32) {
            self.board_id = ::std::option::Option::Some(v);
        }

        // optional int32 hero_id = 3;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 action_id = 4;

        pub fn action_id(&self) -> u32 {
            self.action_id.unwrap_or(0)
        }

        pub fn clear_action_id(&mut self) {
            self.action_id = ::std::option::Option::None;
        }

        pub fn has_action_id(&self) -> bool {
            self.action_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_action_id(&mut self, v: u32) {
            self.action_id = ::std::option::Option::Some(v);
        }

        // optional bool redeemed = 5;

        pub fn redeemed(&self) -> bool {
            self.redeemed.unwrap_or(false)
        }

        pub fn clear_redeemed(&mut self) {
            self.redeemed = ::std::option::Option::None;
        }

        pub fn has_redeemed(&self) -> bool {
            self.redeemed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_redeemed(&mut self, v: bool) {
            self.redeemed = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Slot {
        const NAME: &'static str = "Slot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.board_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.redeemed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.event_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.board_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.action_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.redeemed {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.event_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.board_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.action_id {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.redeemed {
                os.write_bool(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Slot {
            Slot::new()
        }

        fn clear(&mut self) {
            self.event_id = ::std::option::Option::None;
            self.board_id = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.action_id = ::std::option::Option::None;
            self.redeemed = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Slot {
            static instance: Slot = Slot {
                event_id: ::std::option::Option::None,
                board_id: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                action_id: ::std::option::Option::None,
                redeemed: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgPullTabsData.Jackpot)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Jackpot {
        // message fields
        // @@protoc_insertion_point(field:CMsgPullTabsData.Jackpot.board_id)
        pub board_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgPullTabsData.Jackpot.action_id)
        pub action_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgPullTabsData.Jackpot.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgPullTabsData.Jackpot.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Jackpot {
        fn default() -> &'a Jackpot {
            <Jackpot as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Jackpot {
        pub fn new() -> Jackpot {
            ::std::default::Default::default()
        }

        // optional uint32 board_id = 1;

        pub fn board_id(&self) -> u32 {
            self.board_id.unwrap_or(0)
        }

        pub fn clear_board_id(&mut self) {
            self.board_id = ::std::option::Option::None;
        }

        pub fn has_board_id(&self) -> bool {
            self.board_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_board_id(&mut self, v: u32) {
            self.board_id = ::std::option::Option::Some(v);
        }

        // optional uint32 action_id = 2;

        pub fn action_id(&self) -> u32 {
            self.action_id.unwrap_or(0)
        }

        pub fn clear_action_id(&mut self) {
            self.action_id = ::std::option::Option::None;
        }

        pub fn has_action_id(&self) -> bool {
            self.action_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_action_id(&mut self, v: u32) {
            self.action_id = ::std::option::Option::Some(v);
        }

        // optional int32 hero_id = 3;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Jackpot {
        const NAME: &'static str = "Jackpot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.board_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.board_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.action_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.board_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.action_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Jackpot {
            Jackpot::new()
        }

        fn clear(&mut self) {
            self.board_id = ::std::option::Option::None;
            self.action_id = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Jackpot {
            static instance: Jackpot = Jackpot {
                board_id: ::std::option::Option::None,
                action_id: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgUnderDraftData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgUnderDraftData {
    // message fields
    // @@protoc_insertion_point(field:CMsgUnderDraftData.bench_slots)
    pub bench_slots: ::std::vec::Vec<cmsg_under_draft_data::BenchSlot>,
    // @@protoc_insertion_point(field:CMsgUnderDraftData.shop_slots)
    pub shop_slots: ::std::vec::Vec<cmsg_under_draft_data::ShopSlot>,
    // @@protoc_insertion_point(field:CMsgUnderDraftData.gold)
    pub gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgUnderDraftData.total_gold)
    pub total_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgUnderDraftData.not_restorable)
    pub not_restorable: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUnderDraftData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUnderDraftData {
    fn default() -> &'a CMsgUnderDraftData {
        <CMsgUnderDraftData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgUnderDraftData {
    pub fn new() -> CMsgUnderDraftData {
        ::std::default::Default::default()
    }

    // optional uint32 gold = 3;

    pub fn gold(&self) -> u32 {
        self.gold.unwrap_or(0)
    }

    pub fn clear_gold(&mut self) {
        self.gold = ::std::option::Option::None;
    }

    pub fn has_gold(&self) -> bool {
        self.gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold(&mut self, v: u32) {
        self.gold = ::std::option::Option::Some(v);
    }

    // optional uint32 total_gold = 4;

    pub fn total_gold(&self) -> u32 {
        self.total_gold.unwrap_or(0)
    }

    pub fn clear_total_gold(&mut self) {
        self.total_gold = ::std::option::Option::None;
    }

    pub fn has_total_gold(&self) -> bool {
        self.total_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_gold(&mut self, v: u32) {
        self.total_gold = ::std::option::Option::Some(v);
    }

    // optional bool not_restorable = 5;

    pub fn not_restorable(&self) -> bool {
        self.not_restorable.unwrap_or(false)
    }

    pub fn clear_not_restorable(&mut self) {
        self.not_restorable = ::std::option::Option::None;
    }

    pub fn has_not_restorable(&self) -> bool {
        self.not_restorable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_not_restorable(&mut self, v: bool) {
        self.not_restorable = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgUnderDraftData {
    const NAME: &'static str = "CMsgUnderDraftData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bench_slots.push(is.read_message()?);
                },
                18 => {
                    self.shop_slots.push(is.read_message()?);
                },
                24 => {
                    self.gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.total_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.not_restorable = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.bench_slots {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.shop_slots {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.total_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.not_restorable {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.bench_slots {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.shop_slots {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.gold {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.total_gold {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.not_restorable {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUnderDraftData {
        CMsgUnderDraftData::new()
    }

    fn clear(&mut self) {
        self.bench_slots.clear();
        self.shop_slots.clear();
        self.gold = ::std::option::Option::None;
        self.total_gold = ::std::option::Option::None;
        self.not_restorable = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUnderDraftData {
        static instance: CMsgUnderDraftData = CMsgUnderDraftData {
            bench_slots: ::std::vec::Vec::new(),
            shop_slots: ::std::vec::Vec::new(),
            gold: ::std::option::Option::None,
            total_gold: ::std::option::Option::None,
            not_restorable: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgUnderDraftData`
pub mod cmsg_under_draft_data {
    // @@protoc_insertion_point(message:CMsgUnderDraftData.BenchSlot)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BenchSlot {
        // message fields
        // @@protoc_insertion_point(field:CMsgUnderDraftData.BenchSlot.slot_id)
        pub slot_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgUnderDraftData.BenchSlot.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgUnderDraftData.BenchSlot.stars)
        pub stars: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgUnderDraftData.BenchSlot.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BenchSlot {
        fn default() -> &'a BenchSlot {
            <BenchSlot as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl BenchSlot {
        pub fn new() -> BenchSlot {
            ::std::default::Default::default()
        }

        // optional uint32 slot_id = 1;

        pub fn slot_id(&self) -> u32 {
            self.slot_id.unwrap_or(0)
        }

        pub fn clear_slot_id(&mut self) {
            self.slot_id = ::std::option::Option::None;
        }

        pub fn has_slot_id(&self) -> bool {
            self.slot_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot_id(&mut self, v: u32) {
            self.slot_id = ::std::option::Option::Some(v);
        }

        // optional int32 hero_id = 2;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 stars = 3;

        pub fn stars(&self) -> u32 {
            self.stars.unwrap_or(0)
        }

        pub fn clear_stars(&mut self) {
            self.stars = ::std::option::Option::None;
        }

        pub fn has_stars(&self) -> bool {
            self.stars.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stars(&mut self, v: u32) {
            self.stars = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for BenchSlot {
        const NAME: &'static str = "BenchSlot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.stars = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.slot_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.stars {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.slot_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.stars {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BenchSlot {
            BenchSlot::new()
        }

        fn clear(&mut self) {
            self.slot_id = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.stars = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BenchSlot {
            static instance: BenchSlot = BenchSlot {
                slot_id: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                stars: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgUnderDraftData.ShopSlot)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ShopSlot {
        // message fields
        // @@protoc_insertion_point(field:CMsgUnderDraftData.ShopSlot.slot_id)
        pub slot_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgUnderDraftData.ShopSlot.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgUnderDraftData.ShopSlot.is_special_reward)
        pub is_special_reward: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgUnderDraftData.ShopSlot.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ShopSlot {
        fn default() -> &'a ShopSlot {
            <ShopSlot as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ShopSlot {
        pub fn new() -> ShopSlot {
            ::std::default::Default::default()
        }

        // optional uint32 slot_id = 1;

        pub fn slot_id(&self) -> u32 {
            self.slot_id.unwrap_or(0)
        }

        pub fn clear_slot_id(&mut self) {
            self.slot_id = ::std::option::Option::None;
        }

        pub fn has_slot_id(&self) -> bool {
            self.slot_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot_id(&mut self, v: u32) {
            self.slot_id = ::std::option::Option::Some(v);
        }

        // optional int32 hero_id = 2;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional bool is_special_reward = 3;

        pub fn is_special_reward(&self) -> bool {
            self.is_special_reward.unwrap_or(false)
        }

        pub fn clear_is_special_reward(&mut self) {
            self.is_special_reward = ::std::option::Option::None;
        }

        pub fn has_is_special_reward(&self) -> bool {
            self.is_special_reward.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_special_reward(&mut self, v: bool) {
            self.is_special_reward = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ShopSlot {
        const NAME: &'static str = "ShopSlot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.is_special_reward = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.slot_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.is_special_reward {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.slot_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.is_special_reward {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ShopSlot {
            ShopSlot::new()
        }

        fn clear(&mut self) {
            self.slot_id = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.is_special_reward = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ShopSlot {
            static instance: ShopSlot = ShopSlot {
                slot_id: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                is_special_reward: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgPlayerTitleData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerTitleData {
    // message fields
    // @@protoc_insertion_point(field:CMsgPlayerTitleData.title)
    pub title: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerTitleData.event_id)
    pub event_id: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerTitleData.active)
    pub active: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPlayerTitleData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerTitleData {
    fn default() -> &'a CMsgPlayerTitleData {
        <CMsgPlayerTitleData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerTitleData {
    pub fn new() -> CMsgPlayerTitleData {
        ::std::default::Default::default()
    }

    // optional uint32 active = 3;

    pub fn active(&self) -> u32 {
        self.active.unwrap_or(0)
    }

    pub fn clear_active(&mut self) {
        self.active = ::std::option::Option::None;
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: u32) {
        self.active = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPlayerTitleData {
    const NAME: &'static str = "CMsgPlayerTitleData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.title)?;
                },
                8 => {
                    self.title.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.event_id)?;
                },
                16 => {
                    self.event_id.push(is.read_uint32()?);
                },
                24 => {
                    self.active = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.title {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.active {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.title {
            os.write_uint32(1, *v)?;
        };
        for v in &self.event_id {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.active {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerTitleData {
        CMsgPlayerTitleData::new()
    }

    fn clear(&mut self) {
        self.title.clear();
        self.event_id.clear();
        self.active = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerTitleData {
        static instance: CMsgPlayerTitleData = CMsgPlayerTitleData {
            title: ::std::vec::Vec::new(),
            event_id: ::std::vec::Vec::new(),
            active: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTATriviaQuestion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTATriviaQuestion {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTATriviaQuestion.question_id)
    pub question_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTATriviaQuestion.category)
    pub category: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EDOTATriviaQuestionCategory>>,
    // @@protoc_insertion_point(field:CMsgDOTATriviaQuestion.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTATriviaQuestion.question_value)
    pub question_value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDOTATriviaQuestion.answer_values)
    pub answer_values: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDOTATriviaQuestion.correct_answer_index)
    pub correct_answer_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTATriviaQuestion.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTATriviaQuestion {
    fn default() -> &'a CMsgDOTATriviaQuestion {
        <CMsgDOTATriviaQuestion as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTATriviaQuestion {
    pub fn new() -> CMsgDOTATriviaQuestion {
        ::std::default::Default::default()
    }

    // optional uint32 question_id = 1;

    pub fn question_id(&self) -> u32 {
        self.question_id.unwrap_or(0)
    }

    pub fn clear_question_id(&mut self) {
        self.question_id = ::std::option::Option::None;
    }

    pub fn has_question_id(&self) -> bool {
        self.question_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_question_id(&mut self, v: u32) {
        self.question_id = ::std::option::Option::Some(v);
    }

    // optional .EDOTATriviaQuestionCategory category = 2;

    pub fn category(&self) -> EDOTATriviaQuestionCategory {
        match self.category {
            Some(e) => e.enum_value_or(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityIcon),
            None => EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityIcon,
        }
    }

    pub fn clear_category(&mut self) {
        self.category = ::std::option::Option::None;
    }

    pub fn has_category(&self) -> bool {
        self.category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category(&mut self, v: EDOTATriviaQuestionCategory) {
        self.category = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 timestamp = 3;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional string question_value = 4;

    pub fn question_value(&self) -> &str {
        match self.question_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_question_value(&mut self) {
        self.question_value = ::std::option::Option::None;
    }

    pub fn has_question_value(&self) -> bool {
        self.question_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_question_value(&mut self, v: ::std::string::String) {
        self.question_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_question_value(&mut self) -> &mut ::std::string::String {
        if self.question_value.is_none() {
            self.question_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.question_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_question_value(&mut self) -> ::std::string::String {
        self.question_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 correct_answer_index = 6;

    pub fn correct_answer_index(&self) -> u32 {
        self.correct_answer_index.unwrap_or(0)
    }

    pub fn clear_correct_answer_index(&mut self) {
        self.correct_answer_index = ::std::option::Option::None;
    }

    pub fn has_correct_answer_index(&self) -> bool {
        self.correct_answer_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_correct_answer_index(&mut self, v: u32) {
        self.correct_answer_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTATriviaQuestion {
    const NAME: &'static str = "CMsgDOTATriviaQuestion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.question_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.category = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.question_value = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.answer_values.push(is.read_string()?);
                },
                48 => {
                    self.correct_answer_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.question_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.category {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.question_value.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        for value in &self.answer_values {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &value);
        };
        if let Some(v) = self.correct_answer_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.question_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.category {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.question_value.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.answer_values {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.correct_answer_index {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTATriviaQuestion {
        CMsgDOTATriviaQuestion::new()
    }

    fn clear(&mut self) {
        self.question_id = ::std::option::Option::None;
        self.category = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.question_value = ::std::option::Option::None;
        self.answer_values.clear();
        self.correct_answer_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTATriviaQuestion {
        static instance: CMsgDOTATriviaQuestion = CMsgDOTATriviaQuestion {
            question_id: ::std::option::Option::None,
            category: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            question_value: ::std::option::Option::None,
            answer_values: ::std::vec::Vec::new(),
            correct_answer_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTATriviaQuestionAnswersSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTATriviaQuestionAnswersSummary {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTATriviaQuestionAnswersSummary.summary_available)
    pub summary_available: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTATriviaQuestionAnswersSummary.picked_count)
    pub picked_count: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTATriviaQuestionAnswersSummary.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTATriviaQuestionAnswersSummary {
    fn default() -> &'a CMsgDOTATriviaQuestionAnswersSummary {
        <CMsgDOTATriviaQuestionAnswersSummary as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTATriviaQuestionAnswersSummary {
    pub fn new() -> CMsgDOTATriviaQuestionAnswersSummary {
        ::std::default::Default::default()
    }

    // optional bool summary_available = 1;

    pub fn summary_available(&self) -> bool {
        self.summary_available.unwrap_or(false)
    }

    pub fn clear_summary_available(&mut self) {
        self.summary_available = ::std::option::Option::None;
    }

    pub fn has_summary_available(&self) -> bool {
        self.summary_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary_available(&mut self, v: bool) {
        self.summary_available = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTATriviaQuestionAnswersSummary {
    const NAME: &'static str = "CMsgDOTATriviaQuestionAnswersSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.summary_available = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.picked_count)?;
                },
                16 => {
                    self.picked_count.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.summary_available {
            my_size += 1 + 1;
        }
        for value in &self.picked_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.summary_available {
            os.write_bool(1, v)?;
        }
        for v in &self.picked_count {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTATriviaQuestionAnswersSummary {
        CMsgDOTATriviaQuestionAnswersSummary::new()
    }

    fn clear(&mut self) {
        self.summary_available = ::std::option::Option::None;
        self.picked_count.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTATriviaQuestionAnswersSummary {
        static instance: CMsgDOTATriviaQuestionAnswersSummary = CMsgDOTATriviaQuestionAnswersSummary {
            summary_available: ::std::option::Option::None,
            picked_count: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameDataSpecialValueBonus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameDataSpecialValueBonus {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameDataSpecialValueBonus.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameDataSpecialValueBonus.value)
    pub value: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameDataSpecialValueBonus.operation)
    pub operation: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameDataSpecialValueBonus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameDataSpecialValueBonus {
    fn default() -> &'a CMsgGameDataSpecialValueBonus {
        <CMsgGameDataSpecialValueBonus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameDataSpecialValueBonus {
    pub fn new() -> CMsgGameDataSpecialValueBonus {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float value = 2;

    pub fn value(&self) -> f32 {
        self.value.unwrap_or(0.)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional uint32 operation = 3;

    pub fn operation(&self) -> u32 {
        self.operation.unwrap_or(0)
    }

    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: u32) {
        self.operation = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameDataSpecialValueBonus {
    const NAME: &'static str = "CMsgGameDataSpecialValueBonus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                21 => {
                    self.value = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.operation = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value {
            my_size += 1 + 4;
        }
        if let Some(v) = self.operation {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.operation {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameDataSpecialValueBonus {
        CMsgGameDataSpecialValueBonus::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameDataSpecialValueBonus {
        static instance: CMsgGameDataSpecialValueBonus = CMsgGameDataSpecialValueBonus {
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            operation: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameDataSpecialValues)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameDataSpecialValues {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameDataSpecialValues.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameDataSpecialValues.values_float)
    pub values_float: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameDataSpecialValues.is_percentage)
    pub is_percentage: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameDataSpecialValues.heading_loc)
    pub heading_loc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameDataSpecialValues.bonuses)
    pub bonuses: ::std::vec::Vec<CMsgGameDataSpecialValueBonus>,
    // @@protoc_insertion_point(field:CMsgGameDataSpecialValues.values_shard)
    pub values_shard: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameDataSpecialValues.values_scepter)
    pub values_scepter: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameDataSpecialValues.facet_bonus)
    pub facet_bonus: ::steam_vent_proto_common::protobuf::MessageField<CMsgGameDataFacetAbilityBonus>,
    // @@protoc_insertion_point(field:CMsgGameDataSpecialValues.required_facet)
    pub required_facet: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameDataSpecialValues.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameDataSpecialValues {
    fn default() -> &'a CMsgGameDataSpecialValues {
        <CMsgGameDataSpecialValues as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameDataSpecialValues {
    pub fn new() -> CMsgGameDataSpecialValues {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_percentage = 4;

    pub fn is_percentage(&self) -> bool {
        self.is_percentage.unwrap_or(false)
    }

    pub fn clear_is_percentage(&mut self) {
        self.is_percentage = ::std::option::Option::None;
    }

    pub fn has_is_percentage(&self) -> bool {
        self.is_percentage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_percentage(&mut self, v: bool) {
        self.is_percentage = ::std::option::Option::Some(v);
    }

    // optional string heading_loc = 5;

    pub fn heading_loc(&self) -> &str {
        match self.heading_loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_heading_loc(&mut self) {
        self.heading_loc = ::std::option::Option::None;
    }

    pub fn has_heading_loc(&self) -> bool {
        self.heading_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heading_loc(&mut self, v: ::std::string::String) {
        self.heading_loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_heading_loc(&mut self) -> &mut ::std::string::String {
        if self.heading_loc.is_none() {
            self.heading_loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.heading_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_heading_loc(&mut self) -> ::std::string::String {
        self.heading_loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string required_facet = 10;

    pub fn required_facet(&self) -> &str {
        match self.required_facet.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_required_facet(&mut self) {
        self.required_facet = ::std::option::Option::None;
    }

    pub fn has_required_facet(&self) -> bool {
        self.required_facet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_facet(&mut self, v: ::std::string::String) {
        self.required_facet = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_required_facet(&mut self) -> &mut ::std::string::String {
        if self.required_facet.is_none() {
            self.required_facet = ::std::option::Option::Some(::std::string::String::new());
        }
        self.required_facet.as_mut().unwrap()
    }

    // Take field
    pub fn take_required_facet(&mut self) -> ::std::string::String {
        self.required_facet.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameDataSpecialValues {
    const NAME: &'static str = "CMsgGameDataSpecialValues";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    is.read_repeated_packed_float_into(&mut self.values_float)?;
                },
                21 => {
                    self.values_float.push(is.read_float()?);
                },
                32 => {
                    self.is_percentage = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.heading_loc = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.bonuses.push(is.read_message()?);
                },
                58 => {
                    is.read_repeated_packed_float_into(&mut self.values_shard)?;
                },
                61 => {
                    self.values_shard.push(is.read_float()?);
                },
                66 => {
                    is.read_repeated_packed_float_into(&mut self.values_scepter)?;
                },
                69 => {
                    self.values_scepter.push(is.read_float()?);
                },
                74 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.facet_bonus)?;
                },
                82 => {
                    self.required_facet = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += 5 * self.values_float.len() as u64;
        if let Some(v) = self.is_percentage {
            my_size += 1 + 1;
        }
        if let Some(v) = self.heading_loc.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        for value in &self.bonuses {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += 5 * self.values_shard.len() as u64;
        my_size += 5 * self.values_scepter.len() as u64;
        if let Some(v) = self.facet_bonus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.required_facet.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.values_float {
            os.write_float(2, *v)?;
        };
        if let Some(v) = self.is_percentage {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.heading_loc.as_ref() {
            os.write_string(5, v)?;
        }
        for v in &self.bonuses {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.values_shard {
            os.write_float(7, *v)?;
        };
        for v in &self.values_scepter {
            os.write_float(8, *v)?;
        };
        if let Some(v) = self.facet_bonus.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.required_facet.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameDataSpecialValues {
        CMsgGameDataSpecialValues::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.values_float.clear();
        self.is_percentage = ::std::option::Option::None;
        self.heading_loc = ::std::option::Option::None;
        self.bonuses.clear();
        self.values_shard.clear();
        self.values_scepter.clear();
        self.facet_bonus.clear();
        self.required_facet = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameDataSpecialValues {
        static instance: CMsgGameDataSpecialValues = CMsgGameDataSpecialValues {
            name: ::std::option::Option::None,
            values_float: ::std::vec::Vec::new(),
            is_percentage: ::std::option::Option::None,
            heading_loc: ::std::option::Option::None,
            bonuses: ::std::vec::Vec::new(),
            values_shard: ::std::vec::Vec::new(),
            values_scepter: ::std::vec::Vec::new(),
            facet_bonus: ::steam_vent_proto_common::protobuf::MessageField::none(),
            required_facet: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameDataFacetAbilityBonus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameDataFacetAbilityBonus {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameDataFacetAbilityBonus.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameDataFacetAbilityBonus.values)
    pub values: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameDataFacetAbilityBonus.operation)
    pub operation: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameDataFacetAbilityBonus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameDataFacetAbilityBonus {
    fn default() -> &'a CMsgGameDataFacetAbilityBonus {
        <CMsgGameDataFacetAbilityBonus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameDataFacetAbilityBonus {
    pub fn new() -> CMsgGameDataFacetAbilityBonus {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 operation = 3;

    pub fn operation(&self) -> u32 {
        self.operation.unwrap_or(0)
    }

    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: u32) {
        self.operation = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameDataFacetAbilityBonus {
    const NAME: &'static str = "CMsgGameDataFacetAbilityBonus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    is.read_repeated_packed_float_into(&mut self.values)?;
                },
                21 => {
                    self.values.push(is.read_float()?);
                },
                24 => {
                    self.operation = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += 5 * self.values.len() as u64;
        if let Some(v) = self.operation {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.values {
            os.write_float(2, *v)?;
        };
        if let Some(v) = self.operation {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameDataFacetAbilityBonus {
        CMsgGameDataFacetAbilityBonus::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.values.clear();
        self.operation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameDataFacetAbilityBonus {
        static instance: CMsgGameDataFacetAbilityBonus = CMsgGameDataFacetAbilityBonus {
            name: ::std::option::Option::None,
            values: ::std::vec::Vec::new(),
            operation: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameDataAbilityOrItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameDataAbilityOrItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.name_loc)
    pub name_loc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.desc_loc)
    pub desc_loc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.lore_loc)
    pub lore_loc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.notes_loc)
    pub notes_loc: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.shard_loc)
    pub shard_loc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.scepter_loc)
    pub scepter_loc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.facets_loc)
    pub facets_loc: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.type)
    pub type_: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.behavior)
    pub behavior: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.target_team)
    pub target_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.target_type)
    pub target_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.damage)
    pub damage: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.immunity)
    pub immunity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.dispellable)
    pub dispellable: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.max_level)
    pub max_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.cast_ranges)
    pub cast_ranges: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.cast_points)
    pub cast_points: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.channel_times)
    pub channel_times: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.cooldowns)
    pub cooldowns: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.durations)
    pub durations: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.damages)
    pub damages: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.mana_costs)
    pub mana_costs: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.gold_costs)
    pub gold_costs: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.health_costs)
    pub health_costs: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.special_values)
    pub special_values: ::std::vec::Vec<CMsgGameDataSpecialValues>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.is_item)
    pub is_item: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.ability_has_scepter)
    pub ability_has_scepter: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.ability_has_shard)
    pub ability_has_shard: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.ability_is_granted_by_scepter)
    pub ability_is_granted_by_scepter: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.ability_is_granted_by_shard)
    pub ability_is_granted_by_shard: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.ability_is_innate)
    pub ability_is_innate: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.item_cost)
    pub item_cost: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.item_initial_charges)
    pub item_initial_charges: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.item_neutral_tier)
    pub item_neutral_tier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.item_stock_max)
    pub item_stock_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.item_stock_time)
    pub item_stock_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItem.item_quality)
    pub item_quality: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameDataAbilityOrItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameDataAbilityOrItem {
    fn default() -> &'a CMsgGameDataAbilityOrItem {
        <CMsgGameDataAbilityOrItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameDataAbilityOrItem {
    pub fn new() -> CMsgGameDataAbilityOrItem {
        ::std::default::Default::default()
    }

    // optional int32 id = 1;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(-1i32)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name_loc = 5;

    pub fn name_loc(&self) -> &str {
        match self.name_loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name_loc(&mut self) {
        self.name_loc = ::std::option::Option::None;
    }

    pub fn has_name_loc(&self) -> bool {
        self.name_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_loc(&mut self, v: ::std::string::String) {
        self.name_loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_loc(&mut self) -> &mut ::std::string::String {
        if self.name_loc.is_none() {
            self.name_loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_loc(&mut self) -> ::std::string::String {
        self.name_loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string desc_loc = 6;

    pub fn desc_loc(&self) -> &str {
        match self.desc_loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_desc_loc(&mut self) {
        self.desc_loc = ::std::option::Option::None;
    }

    pub fn has_desc_loc(&self) -> bool {
        self.desc_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc_loc(&mut self, v: ::std::string::String) {
        self.desc_loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc_loc(&mut self) -> &mut ::std::string::String {
        if self.desc_loc.is_none() {
            self.desc_loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.desc_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc_loc(&mut self) -> ::std::string::String {
        self.desc_loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string lore_loc = 7;

    pub fn lore_loc(&self) -> &str {
        match self.lore_loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lore_loc(&mut self) {
        self.lore_loc = ::std::option::Option::None;
    }

    pub fn has_lore_loc(&self) -> bool {
        self.lore_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lore_loc(&mut self, v: ::std::string::String) {
        self.lore_loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lore_loc(&mut self) -> &mut ::std::string::String {
        if self.lore_loc.is_none() {
            self.lore_loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lore_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_lore_loc(&mut self) -> ::std::string::String {
        self.lore_loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string shard_loc = 9;

    pub fn shard_loc(&self) -> &str {
        match self.shard_loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_shard_loc(&mut self) {
        self.shard_loc = ::std::option::Option::None;
    }

    pub fn has_shard_loc(&self) -> bool {
        self.shard_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shard_loc(&mut self, v: ::std::string::String) {
        self.shard_loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shard_loc(&mut self) -> &mut ::std::string::String {
        if self.shard_loc.is_none() {
            self.shard_loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.shard_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_shard_loc(&mut self) -> ::std::string::String {
        self.shard_loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string scepter_loc = 10;

    pub fn scepter_loc(&self) -> &str {
        match self.scepter_loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_scepter_loc(&mut self) {
        self.scepter_loc = ::std::option::Option::None;
    }

    pub fn has_scepter_loc(&self) -> bool {
        self.scepter_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scepter_loc(&mut self, v: ::std::string::String) {
        self.scepter_loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scepter_loc(&mut self) -> &mut ::std::string::String {
        if self.scepter_loc.is_none() {
            self.scepter_loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.scepter_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_scepter_loc(&mut self) -> ::std::string::String {
        self.scepter_loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 type = 20;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional uint64 behavior = 21;

    pub fn behavior(&self) -> u64 {
        self.behavior.unwrap_or(0)
    }

    pub fn clear_behavior(&mut self) {
        self.behavior = ::std::option::Option::None;
    }

    pub fn has_behavior(&self) -> bool {
        self.behavior.is_some()
    }

    // Param is passed by value, moved
    pub fn set_behavior(&mut self, v: u64) {
        self.behavior = ::std::option::Option::Some(v);
    }

    // optional uint32 target_team = 22;

    pub fn target_team(&self) -> u32 {
        self.target_team.unwrap_or(0)
    }

    pub fn clear_target_team(&mut self) {
        self.target_team = ::std::option::Option::None;
    }

    pub fn has_target_team(&self) -> bool {
        self.target_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_team(&mut self, v: u32) {
        self.target_team = ::std::option::Option::Some(v);
    }

    // optional uint32 target_type = 23;

    pub fn target_type(&self) -> u32 {
        self.target_type.unwrap_or(0)
    }

    pub fn clear_target_type(&mut self) {
        self.target_type = ::std::option::Option::None;
    }

    pub fn has_target_type(&self) -> bool {
        self.target_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_type(&mut self, v: u32) {
        self.target_type = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 24;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 damage = 25;

    pub fn damage(&self) -> u32 {
        self.damage.unwrap_or(0)
    }

    pub fn clear_damage(&mut self) {
        self.damage = ::std::option::Option::None;
    }

    pub fn has_damage(&self) -> bool {
        self.damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage(&mut self, v: u32) {
        self.damage = ::std::option::Option::Some(v);
    }

    // optional uint32 immunity = 26;

    pub fn immunity(&self) -> u32 {
        self.immunity.unwrap_or(0)
    }

    pub fn clear_immunity(&mut self) {
        self.immunity = ::std::option::Option::None;
    }

    pub fn has_immunity(&self) -> bool {
        self.immunity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_immunity(&mut self, v: u32) {
        self.immunity = ::std::option::Option::Some(v);
    }

    // optional uint32 dispellable = 27;

    pub fn dispellable(&self) -> u32 {
        self.dispellable.unwrap_or(0)
    }

    pub fn clear_dispellable(&mut self) {
        self.dispellable = ::std::option::Option::None;
    }

    pub fn has_dispellable(&self) -> bool {
        self.dispellable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dispellable(&mut self, v: u32) {
        self.dispellable = ::std::option::Option::Some(v);
    }

    // optional uint32 max_level = 28;

    pub fn max_level(&self) -> u32 {
        self.max_level.unwrap_or(0)
    }

    pub fn clear_max_level(&mut self) {
        self.max_level = ::std::option::Option::None;
    }

    pub fn has_max_level(&self) -> bool {
        self.max_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_level(&mut self, v: u32) {
        self.max_level = ::std::option::Option::Some(v);
    }

    // optional bool is_item = 50;

    pub fn is_item(&self) -> bool {
        self.is_item.unwrap_or(false)
    }

    pub fn clear_is_item(&mut self) {
        self.is_item = ::std::option::Option::None;
    }

    pub fn has_is_item(&self) -> bool {
        self.is_item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_item(&mut self, v: bool) {
        self.is_item = ::std::option::Option::Some(v);
    }

    // optional bool ability_has_scepter = 60;

    pub fn ability_has_scepter(&self) -> bool {
        self.ability_has_scepter.unwrap_or(false)
    }

    pub fn clear_ability_has_scepter(&mut self) {
        self.ability_has_scepter = ::std::option::Option::None;
    }

    pub fn has_ability_has_scepter(&self) -> bool {
        self.ability_has_scepter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_has_scepter(&mut self, v: bool) {
        self.ability_has_scepter = ::std::option::Option::Some(v);
    }

    // optional bool ability_has_shard = 61;

    pub fn ability_has_shard(&self) -> bool {
        self.ability_has_shard.unwrap_or(false)
    }

    pub fn clear_ability_has_shard(&mut self) {
        self.ability_has_shard = ::std::option::Option::None;
    }

    pub fn has_ability_has_shard(&self) -> bool {
        self.ability_has_shard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_has_shard(&mut self, v: bool) {
        self.ability_has_shard = ::std::option::Option::Some(v);
    }

    // optional bool ability_is_granted_by_scepter = 62;

    pub fn ability_is_granted_by_scepter(&self) -> bool {
        self.ability_is_granted_by_scepter.unwrap_or(false)
    }

    pub fn clear_ability_is_granted_by_scepter(&mut self) {
        self.ability_is_granted_by_scepter = ::std::option::Option::None;
    }

    pub fn has_ability_is_granted_by_scepter(&self) -> bool {
        self.ability_is_granted_by_scepter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_is_granted_by_scepter(&mut self, v: bool) {
        self.ability_is_granted_by_scepter = ::std::option::Option::Some(v);
    }

    // optional bool ability_is_granted_by_shard = 63;

    pub fn ability_is_granted_by_shard(&self) -> bool {
        self.ability_is_granted_by_shard.unwrap_or(false)
    }

    pub fn clear_ability_is_granted_by_shard(&mut self) {
        self.ability_is_granted_by_shard = ::std::option::Option::None;
    }

    pub fn has_ability_is_granted_by_shard(&self) -> bool {
        self.ability_is_granted_by_shard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_is_granted_by_shard(&mut self, v: bool) {
        self.ability_is_granted_by_shard = ::std::option::Option::Some(v);
    }

    // optional bool ability_is_innate = 64;

    pub fn ability_is_innate(&self) -> bool {
        self.ability_is_innate.unwrap_or(false)
    }

    pub fn clear_ability_is_innate(&mut self) {
        self.ability_is_innate = ::std::option::Option::None;
    }

    pub fn has_ability_is_innate(&self) -> bool {
        self.ability_is_innate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_is_innate(&mut self, v: bool) {
        self.ability_is_innate = ::std::option::Option::Some(v);
    }

    // optional uint32 item_cost = 70;

    pub fn item_cost(&self) -> u32 {
        self.item_cost.unwrap_or(0)
    }

    pub fn clear_item_cost(&mut self) {
        self.item_cost = ::std::option::Option::None;
    }

    pub fn has_item_cost(&self) -> bool {
        self.item_cost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_cost(&mut self, v: u32) {
        self.item_cost = ::std::option::Option::Some(v);
    }

    // optional uint32 item_initial_charges = 71;

    pub fn item_initial_charges(&self) -> u32 {
        self.item_initial_charges.unwrap_or(0)
    }

    pub fn clear_item_initial_charges(&mut self) {
        self.item_initial_charges = ::std::option::Option::None;
    }

    pub fn has_item_initial_charges(&self) -> bool {
        self.item_initial_charges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_initial_charges(&mut self, v: u32) {
        self.item_initial_charges = ::std::option::Option::Some(v);
    }

    // optional uint32 item_neutral_tier = 72;

    pub fn item_neutral_tier(&self) -> u32 {
        self.item_neutral_tier.unwrap_or(0)
    }

    pub fn clear_item_neutral_tier(&mut self) {
        self.item_neutral_tier = ::std::option::Option::None;
    }

    pub fn has_item_neutral_tier(&self) -> bool {
        self.item_neutral_tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_neutral_tier(&mut self, v: u32) {
        self.item_neutral_tier = ::std::option::Option::Some(v);
    }

    // optional uint32 item_stock_max = 73;

    pub fn item_stock_max(&self) -> u32 {
        self.item_stock_max.unwrap_or(0)
    }

    pub fn clear_item_stock_max(&mut self) {
        self.item_stock_max = ::std::option::Option::None;
    }

    pub fn has_item_stock_max(&self) -> bool {
        self.item_stock_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_stock_max(&mut self, v: u32) {
        self.item_stock_max = ::std::option::Option::Some(v);
    }

    // optional float item_stock_time = 74;

    pub fn item_stock_time(&self) -> f32 {
        self.item_stock_time.unwrap_or(0.)
    }

    pub fn clear_item_stock_time(&mut self) {
        self.item_stock_time = ::std::option::Option::None;
    }

    pub fn has_item_stock_time(&self) -> bool {
        self.item_stock_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_stock_time(&mut self, v: f32) {
        self.item_stock_time = ::std::option::Option::Some(v);
    }

    // optional uint32 item_quality = 85;

    pub fn item_quality(&self) -> u32 {
        self.item_quality.unwrap_or(0)
    }

    pub fn clear_item_quality(&mut self) {
        self.item_quality = ::std::option::Option::None;
    }

    pub fn has_item_quality(&self) -> bool {
        self.item_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality(&mut self, v: u32) {
        self.item_quality = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameDataAbilityOrItem {
    const NAME: &'static str = "CMsgGameDataAbilityOrItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.name_loc = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.desc_loc = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.lore_loc = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.notes_loc.push(is.read_string()?);
                },
                74 => {
                    self.shard_loc = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.scepter_loc = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.facets_loc.push(is.read_string()?);
                },
                160 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.behavior = ::std::option::Option::Some(is.read_uint64()?);
                },
                176 => {
                    self.target_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.target_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.damage = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.immunity = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.dispellable = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.max_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                242 => {
                    is.read_repeated_packed_uint32_into(&mut self.cast_ranges)?;
                },
                240 => {
                    self.cast_ranges.push(is.read_uint32()?);
                },
                250 => {
                    is.read_repeated_packed_float_into(&mut self.cast_points)?;
                },
                253 => {
                    self.cast_points.push(is.read_float()?);
                },
                258 => {
                    is.read_repeated_packed_float_into(&mut self.channel_times)?;
                },
                261 => {
                    self.channel_times.push(is.read_float()?);
                },
                266 => {
                    is.read_repeated_packed_float_into(&mut self.cooldowns)?;
                },
                269 => {
                    self.cooldowns.push(is.read_float()?);
                },
                274 => {
                    is.read_repeated_packed_float_into(&mut self.durations)?;
                },
                277 => {
                    self.durations.push(is.read_float()?);
                },
                282 => {
                    is.read_repeated_packed_uint32_into(&mut self.damages)?;
                },
                280 => {
                    self.damages.push(is.read_uint32()?);
                },
                290 => {
                    is.read_repeated_packed_uint32_into(&mut self.mana_costs)?;
                },
                288 => {
                    self.mana_costs.push(is.read_uint32()?);
                },
                298 => {
                    is.read_repeated_packed_uint32_into(&mut self.gold_costs)?;
                },
                296 => {
                    self.gold_costs.push(is.read_uint32()?);
                },
                306 => {
                    is.read_repeated_packed_uint32_into(&mut self.health_costs)?;
                },
                304 => {
                    self.health_costs.push(is.read_uint32()?);
                },
                322 => {
                    self.special_values.push(is.read_message()?);
                },
                400 => {
                    self.is_item = ::std::option::Option::Some(is.read_bool()?);
                },
                480 => {
                    self.ability_has_scepter = ::std::option::Option::Some(is.read_bool()?);
                },
                488 => {
                    self.ability_has_shard = ::std::option::Option::Some(is.read_bool()?);
                },
                496 => {
                    self.ability_is_granted_by_scepter = ::std::option::Option::Some(is.read_bool()?);
                },
                504 => {
                    self.ability_is_granted_by_shard = ::std::option::Option::Some(is.read_bool()?);
                },
                512 => {
                    self.ability_is_innate = ::std::option::Option::Some(is.read_bool()?);
                },
                560 => {
                    self.item_cost = ::std::option::Option::Some(is.read_uint32()?);
                },
                568 => {
                    self.item_initial_charges = ::std::option::Option::Some(is.read_uint32()?);
                },
                576 => {
                    self.item_neutral_tier = ::std::option::Option::Some(is.read_uint32()?);
                },
                584 => {
                    self.item_stock_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                597 => {
                    self.item_stock_time = ::std::option::Option::Some(is.read_float()?);
                },
                680 => {
                    self.item_quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.name_loc.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.desc_loc.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.lore_loc.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
        }
        for value in &self.notes_loc {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(8, &value);
        };
        if let Some(v) = self.shard_loc.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.scepter_loc.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &v);
        }
        for value in &self.facets_loc {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(11, &value);
        };
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.behavior {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(21, v);
        }
        if let Some(v) = self.target_team {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.target_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.damage {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.immunity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.dispellable {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.max_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(28, v);
        }
        for value in &self.cast_ranges {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(30, *value);
        };
        my_size += 6 * self.cast_points.len() as u64;
        my_size += 6 * self.channel_times.len() as u64;
        my_size += 6 * self.cooldowns.len() as u64;
        my_size += 6 * self.durations.len() as u64;
        for value in &self.damages {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(35, *value);
        };
        for value in &self.mana_costs {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(36, *value);
        };
        for value in &self.gold_costs {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(37, *value);
        };
        for value in &self.health_costs {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(38, *value);
        };
        for value in &self.special_values {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_item {
            my_size += 2 + 1;
        }
        if let Some(v) = self.ability_has_scepter {
            my_size += 2 + 1;
        }
        if let Some(v) = self.ability_has_shard {
            my_size += 2 + 1;
        }
        if let Some(v) = self.ability_is_granted_by_scepter {
            my_size += 2 + 1;
        }
        if let Some(v) = self.ability_is_granted_by_shard {
            my_size += 2 + 1;
        }
        if let Some(v) = self.ability_is_innate {
            my_size += 2 + 1;
        }
        if let Some(v) = self.item_cost {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(70, v);
        }
        if let Some(v) = self.item_initial_charges {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(71, v);
        }
        if let Some(v) = self.item_neutral_tier {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(72, v);
        }
        if let Some(v) = self.item_stock_max {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(73, v);
        }
        if let Some(v) = self.item_stock_time {
            my_size += 2 + 4;
        }
        if let Some(v) = self.item_quality {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(85, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name_loc.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.desc_loc.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.lore_loc.as_ref() {
            os.write_string(7, v)?;
        }
        for v in &self.notes_loc {
            os.write_string(8, &v)?;
        };
        if let Some(v) = self.shard_loc.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.scepter_loc.as_ref() {
            os.write_string(10, v)?;
        }
        for v in &self.facets_loc {
            os.write_string(11, &v)?;
        };
        if let Some(v) = self.type_ {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.behavior {
            os.write_uint64(21, v)?;
        }
        if let Some(v) = self.target_team {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.target_type {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.damage {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.immunity {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.dispellable {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.max_level {
            os.write_uint32(28, v)?;
        }
        for v in &self.cast_ranges {
            os.write_uint32(30, *v)?;
        };
        for v in &self.cast_points {
            os.write_float(31, *v)?;
        };
        for v in &self.channel_times {
            os.write_float(32, *v)?;
        };
        for v in &self.cooldowns {
            os.write_float(33, *v)?;
        };
        for v in &self.durations {
            os.write_float(34, *v)?;
        };
        for v in &self.damages {
            os.write_uint32(35, *v)?;
        };
        for v in &self.mana_costs {
            os.write_uint32(36, *v)?;
        };
        for v in &self.gold_costs {
            os.write_uint32(37, *v)?;
        };
        for v in &self.health_costs {
            os.write_uint32(38, *v)?;
        };
        for v in &self.special_values {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
        };
        if let Some(v) = self.is_item {
            os.write_bool(50, v)?;
        }
        if let Some(v) = self.ability_has_scepter {
            os.write_bool(60, v)?;
        }
        if let Some(v) = self.ability_has_shard {
            os.write_bool(61, v)?;
        }
        if let Some(v) = self.ability_is_granted_by_scepter {
            os.write_bool(62, v)?;
        }
        if let Some(v) = self.ability_is_granted_by_shard {
            os.write_bool(63, v)?;
        }
        if let Some(v) = self.ability_is_innate {
            os.write_bool(64, v)?;
        }
        if let Some(v) = self.item_cost {
            os.write_uint32(70, v)?;
        }
        if let Some(v) = self.item_initial_charges {
            os.write_uint32(71, v)?;
        }
        if let Some(v) = self.item_neutral_tier {
            os.write_uint32(72, v)?;
        }
        if let Some(v) = self.item_stock_max {
            os.write_uint32(73, v)?;
        }
        if let Some(v) = self.item_stock_time {
            os.write_float(74, v)?;
        }
        if let Some(v) = self.item_quality {
            os.write_uint32(85, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameDataAbilityOrItem {
        CMsgGameDataAbilityOrItem::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.name_loc = ::std::option::Option::None;
        self.desc_loc = ::std::option::Option::None;
        self.lore_loc = ::std::option::Option::None;
        self.notes_loc.clear();
        self.shard_loc = ::std::option::Option::None;
        self.scepter_loc = ::std::option::Option::None;
        self.facets_loc.clear();
        self.type_ = ::std::option::Option::None;
        self.behavior = ::std::option::Option::None;
        self.target_team = ::std::option::Option::None;
        self.target_type = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.damage = ::std::option::Option::None;
        self.immunity = ::std::option::Option::None;
        self.dispellable = ::std::option::Option::None;
        self.max_level = ::std::option::Option::None;
        self.cast_ranges.clear();
        self.cast_points.clear();
        self.channel_times.clear();
        self.cooldowns.clear();
        self.durations.clear();
        self.damages.clear();
        self.mana_costs.clear();
        self.gold_costs.clear();
        self.health_costs.clear();
        self.special_values.clear();
        self.is_item = ::std::option::Option::None;
        self.ability_has_scepter = ::std::option::Option::None;
        self.ability_has_shard = ::std::option::Option::None;
        self.ability_is_granted_by_scepter = ::std::option::Option::None;
        self.ability_is_granted_by_shard = ::std::option::Option::None;
        self.ability_is_innate = ::std::option::Option::None;
        self.item_cost = ::std::option::Option::None;
        self.item_initial_charges = ::std::option::Option::None;
        self.item_neutral_tier = ::std::option::Option::None;
        self.item_stock_max = ::std::option::Option::None;
        self.item_stock_time = ::std::option::Option::None;
        self.item_quality = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameDataAbilityOrItem {
        static instance: CMsgGameDataAbilityOrItem = CMsgGameDataAbilityOrItem {
            id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            name_loc: ::std::option::Option::None,
            desc_loc: ::std::option::Option::None,
            lore_loc: ::std::option::Option::None,
            notes_loc: ::std::vec::Vec::new(),
            shard_loc: ::std::option::Option::None,
            scepter_loc: ::std::option::Option::None,
            facets_loc: ::std::vec::Vec::new(),
            type_: ::std::option::Option::None,
            behavior: ::std::option::Option::None,
            target_team: ::std::option::Option::None,
            target_type: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            damage: ::std::option::Option::None,
            immunity: ::std::option::Option::None,
            dispellable: ::std::option::Option::None,
            max_level: ::std::option::Option::None,
            cast_ranges: ::std::vec::Vec::new(),
            cast_points: ::std::vec::Vec::new(),
            channel_times: ::std::vec::Vec::new(),
            cooldowns: ::std::vec::Vec::new(),
            durations: ::std::vec::Vec::new(),
            damages: ::std::vec::Vec::new(),
            mana_costs: ::std::vec::Vec::new(),
            gold_costs: ::std::vec::Vec::new(),
            health_costs: ::std::vec::Vec::new(),
            special_values: ::std::vec::Vec::new(),
            is_item: ::std::option::Option::None,
            ability_has_scepter: ::std::option::Option::None,
            ability_has_shard: ::std::option::Option::None,
            ability_is_granted_by_scepter: ::std::option::Option::None,
            ability_is_granted_by_shard: ::std::option::Option::None,
            ability_is_innate: ::std::option::Option::None,
            item_cost: ::std::option::Option::None,
            item_initial_charges: ::std::option::Option::None,
            item_neutral_tier: ::std::option::Option::None,
            item_stock_max: ::std::option::Option::None,
            item_stock_time: ::std::option::Option::None,
            item_quality: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameDataAbilityOrItemList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameDataAbilityOrItemList {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameDataAbilityOrItemList.abilities)
    pub abilities: ::std::vec::Vec<CMsgGameDataAbilityOrItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameDataAbilityOrItemList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameDataAbilityOrItemList {
    fn default() -> &'a CMsgGameDataAbilityOrItemList {
        <CMsgGameDataAbilityOrItemList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameDataAbilityOrItemList {
    pub fn new() -> CMsgGameDataAbilityOrItemList {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameDataAbilityOrItemList {
    const NAME: &'static str = "CMsgGameDataAbilityOrItemList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.abilities.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.abilities {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.abilities {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameDataAbilityOrItemList {
        CMsgGameDataAbilityOrItemList::new()
    }

    fn clear(&mut self) {
        self.abilities.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameDataAbilityOrItemList {
        static instance: CMsgGameDataAbilityOrItemList = CMsgGameDataAbilityOrItemList {
            abilities: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameDataHero)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameDataHero {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameDataHero.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.order_id)
    pub order_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.name_loc)
    pub name_loc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.bio_loc)
    pub bio_loc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.hype_loc)
    pub hype_loc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.npe_desc_loc)
    pub npe_desc_loc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.facets)
    pub facets: ::std::vec::Vec<cmsg_game_data_hero::Facet>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.str_base)
    pub str_base: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.str_gain)
    pub str_gain: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.agi_base)
    pub agi_base: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.agi_gain)
    pub agi_gain: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.int_base)
    pub int_base: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.int_gain)
    pub int_gain: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.primary_attr)
    pub primary_attr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.complexity)
    pub complexity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.attack_capability)
    pub attack_capability: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.role_levels)
    pub role_levels: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.damage_min)
    pub damage_min: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.damage_max)
    pub damage_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.attack_rate)
    pub attack_rate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.attack_range)
    pub attack_range: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.projectile_speed)
    pub projectile_speed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.armor)
    pub armor: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.magic_resistance)
    pub magic_resistance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.movement_speed)
    pub movement_speed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.turn_rate)
    pub turn_rate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.sight_range_day)
    pub sight_range_day: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.sight_range_night)
    pub sight_range_night: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.max_health)
    pub max_health: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.health_regen)
    pub health_regen: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.max_mana)
    pub max_mana: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.mana_regen)
    pub mana_regen: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.abilities)
    pub abilities: ::std::vec::Vec<CMsgGameDataAbilityOrItem>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.talents)
    pub talents: ::std::vec::Vec<CMsgGameDataAbilityOrItem>,
    // @@protoc_insertion_point(field:CMsgGameDataHero.facet_abilities)
    pub facet_abilities: ::std::vec::Vec<CMsgGameDataAbilityOrItemList>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameDataHero.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameDataHero {
    fn default() -> &'a CMsgGameDataHero {
        <CMsgGameDataHero as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameDataHero {
    pub fn new() -> CMsgGameDataHero {
        ::std::default::Default::default()
    }

    // optional int32 id = 1;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 order_id = 3;

    pub fn order_id(&self) -> u32 {
        self.order_id.unwrap_or(0)
    }

    pub fn clear_order_id(&mut self) {
        self.order_id = ::std::option::Option::None;
    }

    pub fn has_order_id(&self) -> bool {
        self.order_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_id(&mut self, v: u32) {
        self.order_id = ::std::option::Option::Some(v);
    }

    // optional string name_loc = 5;

    pub fn name_loc(&self) -> &str {
        match self.name_loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name_loc(&mut self) {
        self.name_loc = ::std::option::Option::None;
    }

    pub fn has_name_loc(&self) -> bool {
        self.name_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_loc(&mut self, v: ::std::string::String) {
        self.name_loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_loc(&mut self) -> &mut ::std::string::String {
        if self.name_loc.is_none() {
            self.name_loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_loc(&mut self) -> ::std::string::String {
        self.name_loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string bio_loc = 6;

    pub fn bio_loc(&self) -> &str {
        match self.bio_loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bio_loc(&mut self) {
        self.bio_loc = ::std::option::Option::None;
    }

    pub fn has_bio_loc(&self) -> bool {
        self.bio_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bio_loc(&mut self, v: ::std::string::String) {
        self.bio_loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bio_loc(&mut self) -> &mut ::std::string::String {
        if self.bio_loc.is_none() {
            self.bio_loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bio_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_bio_loc(&mut self) -> ::std::string::String {
        self.bio_loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string hype_loc = 7;

    pub fn hype_loc(&self) -> &str {
        match self.hype_loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hype_loc(&mut self) {
        self.hype_loc = ::std::option::Option::None;
    }

    pub fn has_hype_loc(&self) -> bool {
        self.hype_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hype_loc(&mut self, v: ::std::string::String) {
        self.hype_loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hype_loc(&mut self) -> &mut ::std::string::String {
        if self.hype_loc.is_none() {
            self.hype_loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hype_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_hype_loc(&mut self) -> ::std::string::String {
        self.hype_loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string npe_desc_loc = 8;

    pub fn npe_desc_loc(&self) -> &str {
        match self.npe_desc_loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_npe_desc_loc(&mut self) {
        self.npe_desc_loc = ::std::option::Option::None;
    }

    pub fn has_npe_desc_loc(&self) -> bool {
        self.npe_desc_loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_npe_desc_loc(&mut self, v: ::std::string::String) {
        self.npe_desc_loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_npe_desc_loc(&mut self) -> &mut ::std::string::String {
        if self.npe_desc_loc.is_none() {
            self.npe_desc_loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.npe_desc_loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_npe_desc_loc(&mut self) -> ::std::string::String {
        self.npe_desc_loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 str_base = 10;

    pub fn str_base(&self) -> u32 {
        self.str_base.unwrap_or(0)
    }

    pub fn clear_str_base(&mut self) {
        self.str_base = ::std::option::Option::None;
    }

    pub fn has_str_base(&self) -> bool {
        self.str_base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_str_base(&mut self, v: u32) {
        self.str_base = ::std::option::Option::Some(v);
    }

    // optional float str_gain = 11;

    pub fn str_gain(&self) -> f32 {
        self.str_gain.unwrap_or(0.)
    }

    pub fn clear_str_gain(&mut self) {
        self.str_gain = ::std::option::Option::None;
    }

    pub fn has_str_gain(&self) -> bool {
        self.str_gain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_str_gain(&mut self, v: f32) {
        self.str_gain = ::std::option::Option::Some(v);
    }

    // optional uint32 agi_base = 12;

    pub fn agi_base(&self) -> u32 {
        self.agi_base.unwrap_or(0)
    }

    pub fn clear_agi_base(&mut self) {
        self.agi_base = ::std::option::Option::None;
    }

    pub fn has_agi_base(&self) -> bool {
        self.agi_base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agi_base(&mut self, v: u32) {
        self.agi_base = ::std::option::Option::Some(v);
    }

    // optional float agi_gain = 13;

    pub fn agi_gain(&self) -> f32 {
        self.agi_gain.unwrap_or(0.)
    }

    pub fn clear_agi_gain(&mut self) {
        self.agi_gain = ::std::option::Option::None;
    }

    pub fn has_agi_gain(&self) -> bool {
        self.agi_gain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agi_gain(&mut self, v: f32) {
        self.agi_gain = ::std::option::Option::Some(v);
    }

    // optional uint32 int_base = 14;

    pub fn int_base(&self) -> u32 {
        self.int_base.unwrap_or(0)
    }

    pub fn clear_int_base(&mut self) {
        self.int_base = ::std::option::Option::None;
    }

    pub fn has_int_base(&self) -> bool {
        self.int_base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_base(&mut self, v: u32) {
        self.int_base = ::std::option::Option::Some(v);
    }

    // optional float int_gain = 15;

    pub fn int_gain(&self) -> f32 {
        self.int_gain.unwrap_or(0.)
    }

    pub fn clear_int_gain(&mut self) {
        self.int_gain = ::std::option::Option::None;
    }

    pub fn has_int_gain(&self) -> bool {
        self.int_gain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_gain(&mut self, v: f32) {
        self.int_gain = ::std::option::Option::Some(v);
    }

    // optional uint32 primary_attr = 20;

    pub fn primary_attr(&self) -> u32 {
        self.primary_attr.unwrap_or(0)
    }

    pub fn clear_primary_attr(&mut self) {
        self.primary_attr = ::std::option::Option::None;
    }

    pub fn has_primary_attr(&self) -> bool {
        self.primary_attr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_attr(&mut self, v: u32) {
        self.primary_attr = ::std::option::Option::Some(v);
    }

    // optional uint32 complexity = 21;

    pub fn complexity(&self) -> u32 {
        self.complexity.unwrap_or(0)
    }

    pub fn clear_complexity(&mut self) {
        self.complexity = ::std::option::Option::None;
    }

    pub fn has_complexity(&self) -> bool {
        self.complexity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_complexity(&mut self, v: u32) {
        self.complexity = ::std::option::Option::Some(v);
    }

    // optional uint32 attack_capability = 22;

    pub fn attack_capability(&self) -> u32 {
        self.attack_capability.unwrap_or(0)
    }

    pub fn clear_attack_capability(&mut self) {
        self.attack_capability = ::std::option::Option::None;
    }

    pub fn has_attack_capability(&self) -> bool {
        self.attack_capability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attack_capability(&mut self, v: u32) {
        self.attack_capability = ::std::option::Option::Some(v);
    }

    // optional int32 damage_min = 24;

    pub fn damage_min(&self) -> i32 {
        self.damage_min.unwrap_or(0)
    }

    pub fn clear_damage_min(&mut self) {
        self.damage_min = ::std::option::Option::None;
    }

    pub fn has_damage_min(&self) -> bool {
        self.damage_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_min(&mut self, v: i32) {
        self.damage_min = ::std::option::Option::Some(v);
    }

    // optional int32 damage_max = 25;

    pub fn damage_max(&self) -> i32 {
        self.damage_max.unwrap_or(0)
    }

    pub fn clear_damage_max(&mut self) {
        self.damage_max = ::std::option::Option::None;
    }

    pub fn has_damage_max(&self) -> bool {
        self.damage_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_max(&mut self, v: i32) {
        self.damage_max = ::std::option::Option::Some(v);
    }

    // optional float attack_rate = 26;

    pub fn attack_rate(&self) -> f32 {
        self.attack_rate.unwrap_or(0.)
    }

    pub fn clear_attack_rate(&mut self) {
        self.attack_rate = ::std::option::Option::None;
    }

    pub fn has_attack_rate(&self) -> bool {
        self.attack_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attack_rate(&mut self, v: f32) {
        self.attack_rate = ::std::option::Option::Some(v);
    }

    // optional uint32 attack_range = 27;

    pub fn attack_range(&self) -> u32 {
        self.attack_range.unwrap_or(0)
    }

    pub fn clear_attack_range(&mut self) {
        self.attack_range = ::std::option::Option::None;
    }

    pub fn has_attack_range(&self) -> bool {
        self.attack_range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attack_range(&mut self, v: u32) {
        self.attack_range = ::std::option::Option::Some(v);
    }

    // optional uint32 projectile_speed = 28;

    pub fn projectile_speed(&self) -> u32 {
        self.projectile_speed.unwrap_or(0)
    }

    pub fn clear_projectile_speed(&mut self) {
        self.projectile_speed = ::std::option::Option::None;
    }

    pub fn has_projectile_speed(&self) -> bool {
        self.projectile_speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_projectile_speed(&mut self, v: u32) {
        self.projectile_speed = ::std::option::Option::Some(v);
    }

    // optional float armor = 29;

    pub fn armor(&self) -> f32 {
        self.armor.unwrap_or(0.)
    }

    pub fn clear_armor(&mut self) {
        self.armor = ::std::option::Option::None;
    }

    pub fn has_armor(&self) -> bool {
        self.armor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_armor(&mut self, v: f32) {
        self.armor = ::std::option::Option::Some(v);
    }

    // optional uint32 magic_resistance = 30;

    pub fn magic_resistance(&self) -> u32 {
        self.magic_resistance.unwrap_or(0)
    }

    pub fn clear_magic_resistance(&mut self) {
        self.magic_resistance = ::std::option::Option::None;
    }

    pub fn has_magic_resistance(&self) -> bool {
        self.magic_resistance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_magic_resistance(&mut self, v: u32) {
        self.magic_resistance = ::std::option::Option::Some(v);
    }

    // optional uint32 movement_speed = 31;

    pub fn movement_speed(&self) -> u32 {
        self.movement_speed.unwrap_or(0)
    }

    pub fn clear_movement_speed(&mut self) {
        self.movement_speed = ::std::option::Option::None;
    }

    pub fn has_movement_speed(&self) -> bool {
        self.movement_speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_movement_speed(&mut self, v: u32) {
        self.movement_speed = ::std::option::Option::Some(v);
    }

    // optional float turn_rate = 32;

    pub fn turn_rate(&self) -> f32 {
        self.turn_rate.unwrap_or(0.)
    }

    pub fn clear_turn_rate(&mut self) {
        self.turn_rate = ::std::option::Option::None;
    }

    pub fn has_turn_rate(&self) -> bool {
        self.turn_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_turn_rate(&mut self, v: f32) {
        self.turn_rate = ::std::option::Option::Some(v);
    }

    // optional uint32 sight_range_day = 33;

    pub fn sight_range_day(&self) -> u32 {
        self.sight_range_day.unwrap_or(0)
    }

    pub fn clear_sight_range_day(&mut self) {
        self.sight_range_day = ::std::option::Option::None;
    }

    pub fn has_sight_range_day(&self) -> bool {
        self.sight_range_day.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sight_range_day(&mut self, v: u32) {
        self.sight_range_day = ::std::option::Option::Some(v);
    }

    // optional uint32 sight_range_night = 34;

    pub fn sight_range_night(&self) -> u32 {
        self.sight_range_night.unwrap_or(0)
    }

    pub fn clear_sight_range_night(&mut self) {
        self.sight_range_night = ::std::option::Option::None;
    }

    pub fn has_sight_range_night(&self) -> bool {
        self.sight_range_night.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sight_range_night(&mut self, v: u32) {
        self.sight_range_night = ::std::option::Option::Some(v);
    }

    // optional uint32 max_health = 35;

    pub fn max_health(&self) -> u32 {
        self.max_health.unwrap_or(0)
    }

    pub fn clear_max_health(&mut self) {
        self.max_health = ::std::option::Option::None;
    }

    pub fn has_max_health(&self) -> bool {
        self.max_health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_health(&mut self, v: u32) {
        self.max_health = ::std::option::Option::Some(v);
    }

    // optional float health_regen = 36;

    pub fn health_regen(&self) -> f32 {
        self.health_regen.unwrap_or(0.)
    }

    pub fn clear_health_regen(&mut self) {
        self.health_regen = ::std::option::Option::None;
    }

    pub fn has_health_regen(&self) -> bool {
        self.health_regen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health_regen(&mut self, v: f32) {
        self.health_regen = ::std::option::Option::Some(v);
    }

    // optional uint32 max_mana = 37;

    pub fn max_mana(&self) -> u32 {
        self.max_mana.unwrap_or(0)
    }

    pub fn clear_max_mana(&mut self) {
        self.max_mana = ::std::option::Option::None;
    }

    pub fn has_max_mana(&self) -> bool {
        self.max_mana.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_mana(&mut self, v: u32) {
        self.max_mana = ::std::option::Option::Some(v);
    }

    // optional float mana_regen = 38;

    pub fn mana_regen(&self) -> f32 {
        self.mana_regen.unwrap_or(0.)
    }

    pub fn clear_mana_regen(&mut self) {
        self.mana_regen = ::std::option::Option::None;
    }

    pub fn has_mana_regen(&self) -> bool {
        self.mana_regen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mana_regen(&mut self, v: f32) {
        self.mana_regen = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameDataHero {
    const NAME: &'static str = "CMsgGameDataHero";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.order_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.name_loc = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.bio_loc = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.hype_loc = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.npe_desc_loc = ::std::option::Option::Some(is.read_string()?);
                },
                346 => {
                    self.facets.push(is.read_message()?);
                },
                80 => {
                    self.str_base = ::std::option::Option::Some(is.read_uint32()?);
                },
                93 => {
                    self.str_gain = ::std::option::Option::Some(is.read_float()?);
                },
                96 => {
                    self.agi_base = ::std::option::Option::Some(is.read_uint32()?);
                },
                109 => {
                    self.agi_gain = ::std::option::Option::Some(is.read_float()?);
                },
                112 => {
                    self.int_base = ::std::option::Option::Some(is.read_uint32()?);
                },
                125 => {
                    self.int_gain = ::std::option::Option::Some(is.read_float()?);
                },
                160 => {
                    self.primary_attr = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.complexity = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.attack_capability = ::std::option::Option::Some(is.read_uint32()?);
                },
                186 => {
                    is.read_repeated_packed_uint32_into(&mut self.role_levels)?;
                },
                184 => {
                    self.role_levels.push(is.read_uint32()?);
                },
                192 => {
                    self.damage_min = ::std::option::Option::Some(is.read_int32()?);
                },
                200 => {
                    self.damage_max = ::std::option::Option::Some(is.read_int32()?);
                },
                213 => {
                    self.attack_rate = ::std::option::Option::Some(is.read_float()?);
                },
                216 => {
                    self.attack_range = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.projectile_speed = ::std::option::Option::Some(is.read_uint32()?);
                },
                237 => {
                    self.armor = ::std::option::Option::Some(is.read_float()?);
                },
                240 => {
                    self.magic_resistance = ::std::option::Option::Some(is.read_uint32()?);
                },
                248 => {
                    self.movement_speed = ::std::option::Option::Some(is.read_uint32()?);
                },
                261 => {
                    self.turn_rate = ::std::option::Option::Some(is.read_float()?);
                },
                264 => {
                    self.sight_range_day = ::std::option::Option::Some(is.read_uint32()?);
                },
                272 => {
                    self.sight_range_night = ::std::option::Option::Some(is.read_uint32()?);
                },
                280 => {
                    self.max_health = ::std::option::Option::Some(is.read_uint32()?);
                },
                293 => {
                    self.health_regen = ::std::option::Option::Some(is.read_float()?);
                },
                296 => {
                    self.max_mana = ::std::option::Option::Some(is.read_uint32()?);
                },
                309 => {
                    self.mana_regen = ::std::option::Option::Some(is.read_float()?);
                },
                322 => {
                    self.abilities.push(is.read_message()?);
                },
                330 => {
                    self.talents.push(is.read_message()?);
                },
                338 => {
                    self.facet_abilities.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.order_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.name_loc.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.bio_loc.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.hype_loc.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.npe_desc_loc.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(8, &v);
        }
        for value in &self.facets {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.str_base {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.str_gain {
            my_size += 1 + 4;
        }
        if let Some(v) = self.agi_base {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.agi_gain {
            my_size += 1 + 4;
        }
        if let Some(v) = self.int_base {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.int_gain {
            my_size += 1 + 4;
        }
        if let Some(v) = self.primary_attr {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.complexity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.attack_capability {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
        }
        for value in &self.role_levels {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, *value);
        };
        if let Some(v) = self.damage_min {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(24, v);
        }
        if let Some(v) = self.damage_max {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(25, v);
        }
        if let Some(v) = self.attack_rate {
            my_size += 2 + 4;
        }
        if let Some(v) = self.attack_range {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.projectile_speed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.armor {
            my_size += 2 + 4;
        }
        if let Some(v) = self.magic_resistance {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(30, v);
        }
        if let Some(v) = self.movement_speed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(31, v);
        }
        if let Some(v) = self.turn_rate {
            my_size += 2 + 4;
        }
        if let Some(v) = self.sight_range_day {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(33, v);
        }
        if let Some(v) = self.sight_range_night {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(34, v);
        }
        if let Some(v) = self.max_health {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(35, v);
        }
        if let Some(v) = self.health_regen {
            my_size += 2 + 4;
        }
        if let Some(v) = self.max_mana {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(37, v);
        }
        if let Some(v) = self.mana_regen {
            my_size += 2 + 4;
        }
        for value in &self.abilities {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.talents {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.facet_abilities {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.order_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.name_loc.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.bio_loc.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.hype_loc.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.npe_desc_loc.as_ref() {
            os.write_string(8, v)?;
        }
        for v in &self.facets {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(43, v, os)?;
        };
        if let Some(v) = self.str_base {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.str_gain {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.agi_base {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.agi_gain {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.int_base {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.int_gain {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.primary_attr {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.complexity {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.attack_capability {
            os.write_uint32(22, v)?;
        }
        for v in &self.role_levels {
            os.write_uint32(23, *v)?;
        };
        if let Some(v) = self.damage_min {
            os.write_int32(24, v)?;
        }
        if let Some(v) = self.damage_max {
            os.write_int32(25, v)?;
        }
        if let Some(v) = self.attack_rate {
            os.write_float(26, v)?;
        }
        if let Some(v) = self.attack_range {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.projectile_speed {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.armor {
            os.write_float(29, v)?;
        }
        if let Some(v) = self.magic_resistance {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.movement_speed {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.turn_rate {
            os.write_float(32, v)?;
        }
        if let Some(v) = self.sight_range_day {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.sight_range_night {
            os.write_uint32(34, v)?;
        }
        if let Some(v) = self.max_health {
            os.write_uint32(35, v)?;
        }
        if let Some(v) = self.health_regen {
            os.write_float(36, v)?;
        }
        if let Some(v) = self.max_mana {
            os.write_uint32(37, v)?;
        }
        if let Some(v) = self.mana_regen {
            os.write_float(38, v)?;
        }
        for v in &self.abilities {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
        };
        for v in &self.talents {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(41, v, os)?;
        };
        for v in &self.facet_abilities {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(42, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameDataHero {
        CMsgGameDataHero::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.order_id = ::std::option::Option::None;
        self.name_loc = ::std::option::Option::None;
        self.bio_loc = ::std::option::Option::None;
        self.hype_loc = ::std::option::Option::None;
        self.npe_desc_loc = ::std::option::Option::None;
        self.facets.clear();
        self.str_base = ::std::option::Option::None;
        self.str_gain = ::std::option::Option::None;
        self.agi_base = ::std::option::Option::None;
        self.agi_gain = ::std::option::Option::None;
        self.int_base = ::std::option::Option::None;
        self.int_gain = ::std::option::Option::None;
        self.primary_attr = ::std::option::Option::None;
        self.complexity = ::std::option::Option::None;
        self.attack_capability = ::std::option::Option::None;
        self.role_levels.clear();
        self.damage_min = ::std::option::Option::None;
        self.damage_max = ::std::option::Option::None;
        self.attack_rate = ::std::option::Option::None;
        self.attack_range = ::std::option::Option::None;
        self.projectile_speed = ::std::option::Option::None;
        self.armor = ::std::option::Option::None;
        self.magic_resistance = ::std::option::Option::None;
        self.movement_speed = ::std::option::Option::None;
        self.turn_rate = ::std::option::Option::None;
        self.sight_range_day = ::std::option::Option::None;
        self.sight_range_night = ::std::option::Option::None;
        self.max_health = ::std::option::Option::None;
        self.health_regen = ::std::option::Option::None;
        self.max_mana = ::std::option::Option::None;
        self.mana_regen = ::std::option::Option::None;
        self.abilities.clear();
        self.talents.clear();
        self.facet_abilities.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameDataHero {
        static instance: CMsgGameDataHero = CMsgGameDataHero {
            id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            order_id: ::std::option::Option::None,
            name_loc: ::std::option::Option::None,
            bio_loc: ::std::option::Option::None,
            hype_loc: ::std::option::Option::None,
            npe_desc_loc: ::std::option::Option::None,
            facets: ::std::vec::Vec::new(),
            str_base: ::std::option::Option::None,
            str_gain: ::std::option::Option::None,
            agi_base: ::std::option::Option::None,
            agi_gain: ::std::option::Option::None,
            int_base: ::std::option::Option::None,
            int_gain: ::std::option::Option::None,
            primary_attr: ::std::option::Option::None,
            complexity: ::std::option::Option::None,
            attack_capability: ::std::option::Option::None,
            role_levels: ::std::vec::Vec::new(),
            damage_min: ::std::option::Option::None,
            damage_max: ::std::option::Option::None,
            attack_rate: ::std::option::Option::None,
            attack_range: ::std::option::Option::None,
            projectile_speed: ::std::option::Option::None,
            armor: ::std::option::Option::None,
            magic_resistance: ::std::option::Option::None,
            movement_speed: ::std::option::Option::None,
            turn_rate: ::std::option::Option::None,
            sight_range_day: ::std::option::Option::None,
            sight_range_night: ::std::option::Option::None,
            max_health: ::std::option::Option::None,
            health_regen: ::std::option::Option::None,
            max_mana: ::std::option::Option::None,
            mana_regen: ::std::option::Option::None,
            abilities: ::std::vec::Vec::new(),
            talents: ::std::vec::Vec::new(),
            facet_abilities: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGameDataHero`
pub mod cmsg_game_data_hero {
    // @@protoc_insertion_point(message:CMsgGameDataHero.Facet)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Facet {
        // message fields
        // @@protoc_insertion_point(field:CMsgGameDataHero.Facet.color)
        pub color: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameDataHero.Facet.title_loc)
        pub title_loc: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGameDataHero.Facet.description_loc)
        pub description_loc: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGameDataHero.Facet.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGameDataHero.Facet.icon)
        pub icon: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGameDataHero.Facet.gradient_id)
        pub gradient_id: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGameDataHero.Facet.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Facet {
        fn default() -> &'a Facet {
            <Facet as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Facet {
        pub fn new() -> Facet {
            ::std::default::Default::default()
        }

        // optional uint32 color = 1;

        pub fn color(&self) -> u32 {
            self.color.unwrap_or(0)
        }

        pub fn clear_color(&mut self) {
            self.color = ::std::option::Option::None;
        }

        pub fn has_color(&self) -> bool {
            self.color.is_some()
        }

        // Param is passed by value, moved
        pub fn set_color(&mut self, v: u32) {
            self.color = ::std::option::Option::Some(v);
        }

        // optional string title_loc = 2;

        pub fn title_loc(&self) -> &str {
            match self.title_loc.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_title_loc(&mut self) {
            self.title_loc = ::std::option::Option::None;
        }

        pub fn has_title_loc(&self) -> bool {
            self.title_loc.is_some()
        }

        // Param is passed by value, moved
        pub fn set_title_loc(&mut self, v: ::std::string::String) {
            self.title_loc = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_title_loc(&mut self) -> &mut ::std::string::String {
            if self.title_loc.is_none() {
                self.title_loc = ::std::option::Option::Some(::std::string::String::new());
            }
            self.title_loc.as_mut().unwrap()
        }

        // Take field
        pub fn take_title_loc(&mut self) -> ::std::string::String {
            self.title_loc.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string description_loc = 3;

        pub fn description_loc(&self) -> &str {
            match self.description_loc.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_description_loc(&mut self) {
            self.description_loc = ::std::option::Option::None;
        }

        pub fn has_description_loc(&self) -> bool {
            self.description_loc.is_some()
        }

        // Param is passed by value, moved
        pub fn set_description_loc(&mut self, v: ::std::string::String) {
            self.description_loc = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_description_loc(&mut self) -> &mut ::std::string::String {
            if self.description_loc.is_none() {
                self.description_loc = ::std::option::Option::Some(::std::string::String::new());
            }
            self.description_loc.as_mut().unwrap()
        }

        // Take field
        pub fn take_description_loc(&mut self) -> ::std::string::String {
            self.description_loc.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string name = 4;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string icon = 5;

        pub fn icon(&self) -> &str {
            match self.icon.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_icon(&mut self) {
            self.icon = ::std::option::Option::None;
        }

        pub fn has_icon(&self) -> bool {
            self.icon.is_some()
        }

        // Param is passed by value, moved
        pub fn set_icon(&mut self, v: ::std::string::String) {
            self.icon = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_icon(&mut self) -> &mut ::std::string::String {
            if self.icon.is_none() {
                self.icon = ::std::option::Option::Some(::std::string::String::new());
            }
            self.icon.as_mut().unwrap()
        }

        // Take field
        pub fn take_icon(&mut self) -> ::std::string::String {
            self.icon.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 gradient_id = 6;

        pub fn gradient_id(&self) -> i32 {
            self.gradient_id.unwrap_or(0)
        }

        pub fn clear_gradient_id(&mut self) {
            self.gradient_id = ::std::option::Option::None;
        }

        pub fn has_gradient_id(&self) -> bool {
            self.gradient_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gradient_id(&mut self, v: i32) {
            self.gradient_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Facet {
        const NAME: &'static str = "Facet";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.color = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.title_loc = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.description_loc = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.icon = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.gradient_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.color {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.title_loc.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.description_loc.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.icon.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.gradient_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.color {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.title_loc.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.description_loc.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.icon.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.gradient_id {
                os.write_int32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Facet {
            Facet::new()
        }

        fn clear(&mut self) {
            self.color = ::std::option::Option::None;
            self.title_loc = ::std::option::Option::None;
            self.description_loc = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.icon = ::std::option::Option::None;
            self.gradient_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Facet {
            static instance: Facet = Facet {
                color: ::std::option::Option::None,
                title_loc: ::std::option::Option::None,
                description_loc: ::std::option::Option::None,
                name: ::std::option::Option::None,
                icon: ::std::option::Option::None,
                gradient_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGameDataAbilities)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameDataAbilities {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameDataAbilities.abilities)
    pub abilities: ::std::vec::Vec<CMsgGameDataAbilityOrItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameDataAbilities.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameDataAbilities {
    fn default() -> &'a CMsgGameDataAbilities {
        <CMsgGameDataAbilities as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameDataAbilities {
    pub fn new() -> CMsgGameDataAbilities {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameDataAbilities {
    const NAME: &'static str = "CMsgGameDataAbilities";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.abilities.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.abilities {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.abilities {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameDataAbilities {
        CMsgGameDataAbilities::new()
    }

    fn clear(&mut self) {
        self.abilities.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameDataAbilities {
        static instance: CMsgGameDataAbilities = CMsgGameDataAbilities {
            abilities: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameDataItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameDataItems {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameDataItems.items)
    pub items: ::std::vec::Vec<CMsgGameDataAbilityOrItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameDataItems.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameDataItems {
    fn default() -> &'a CMsgGameDataItems {
        <CMsgGameDataItems as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameDataItems {
    pub fn new() -> CMsgGameDataItems {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameDataItems {
    const NAME: &'static str = "CMsgGameDataItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.items {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameDataItems {
        CMsgGameDataItems::new()
    }

    fn clear(&mut self) {
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameDataItems {
        static instance: CMsgGameDataItems = CMsgGameDataItems {
            items: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameDataHeroes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameDataHeroes {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameDataHeroes.heroes)
    pub heroes: ::std::vec::Vec<CMsgGameDataHero>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameDataHeroes.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameDataHeroes {
    fn default() -> &'a CMsgGameDataHeroes {
        <CMsgGameDataHeroes as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameDataHeroes {
    pub fn new() -> CMsgGameDataHeroes {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameDataHeroes {
    const NAME: &'static str = "CMsgGameDataHeroes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.heroes.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.heroes {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.heroes {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameDataHeroes {
        CMsgGameDataHeroes::new()
    }

    fn clear(&mut self) {
        self.heroes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameDataHeroes {
        static instance: CMsgGameDataHeroes = CMsgGameDataHeroes {
            heroes: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameDataHeroList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameDataHeroList {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameDataHeroList.heroes)
    pub heroes: ::std::vec::Vec<cmsg_game_data_hero_list::HeroInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameDataHeroList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameDataHeroList {
    fn default() -> &'a CMsgGameDataHeroList {
        <CMsgGameDataHeroList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameDataHeroList {
    pub fn new() -> CMsgGameDataHeroList {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameDataHeroList {
    const NAME: &'static str = "CMsgGameDataHeroList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.heroes.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.heroes {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.heroes {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameDataHeroList {
        CMsgGameDataHeroList::new()
    }

    fn clear(&mut self) {
        self.heroes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameDataHeroList {
        static instance: CMsgGameDataHeroList = CMsgGameDataHeroList {
            heroes: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGameDataHeroList`
pub mod cmsg_game_data_hero_list {
    // @@protoc_insertion_point(message:CMsgGameDataHeroList.HeroInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct HeroInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgGameDataHeroList.HeroInfo.id)
        pub id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGameDataHeroList.HeroInfo.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGameDataHeroList.HeroInfo.name_loc)
        pub name_loc: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGameDataHeroList.HeroInfo.name_english_loc)
        pub name_english_loc: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGameDataHeroList.HeroInfo.primary_attr)
        pub primary_attr: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameDataHeroList.HeroInfo.complexity)
        pub complexity: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGameDataHeroList.HeroInfo.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HeroInfo {
        fn default() -> &'a HeroInfo {
            <HeroInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl HeroInfo {
        pub fn new() -> HeroInfo {
            ::std::default::Default::default()
        }

        // optional int32 id = 1;

        pub fn id(&self) -> i32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: i32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string name_loc = 3;

        pub fn name_loc(&self) -> &str {
            match self.name_loc.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name_loc(&mut self) {
            self.name_loc = ::std::option::Option::None;
        }

        pub fn has_name_loc(&self) -> bool {
            self.name_loc.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name_loc(&mut self, v: ::std::string::String) {
            self.name_loc = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name_loc(&mut self) -> &mut ::std::string::String {
            if self.name_loc.is_none() {
                self.name_loc = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name_loc.as_mut().unwrap()
        }

        // Take field
        pub fn take_name_loc(&mut self) -> ::std::string::String {
            self.name_loc.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string name_english_loc = 4;

        pub fn name_english_loc(&self) -> &str {
            match self.name_english_loc.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name_english_loc(&mut self) {
            self.name_english_loc = ::std::option::Option::None;
        }

        pub fn has_name_english_loc(&self) -> bool {
            self.name_english_loc.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name_english_loc(&mut self, v: ::std::string::String) {
            self.name_english_loc = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name_english_loc(&mut self) -> &mut ::std::string::String {
            if self.name_english_loc.is_none() {
                self.name_english_loc = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name_english_loc.as_mut().unwrap()
        }

        // Take field
        pub fn take_name_english_loc(&mut self) -> ::std::string::String {
            self.name_english_loc.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 primary_attr = 5;

        pub fn primary_attr(&self) -> u32 {
            self.primary_attr.unwrap_or(0)
        }

        pub fn clear_primary_attr(&mut self) {
            self.primary_attr = ::std::option::Option::None;
        }

        pub fn has_primary_attr(&self) -> bool {
            self.primary_attr.is_some()
        }

        // Param is passed by value, moved
        pub fn set_primary_attr(&mut self, v: u32) {
            self.primary_attr = ::std::option::Option::Some(v);
        }

        // optional uint32 complexity = 6;

        pub fn complexity(&self) -> u32 {
            self.complexity.unwrap_or(0)
        }

        pub fn clear_complexity(&mut self) {
            self.complexity = ::std::option::Option::None;
        }

        pub fn has_complexity(&self) -> bool {
            self.complexity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_complexity(&mut self, v: u32) {
            self.complexity = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for HeroInfo {
        const NAME: &'static str = "HeroInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.name_loc = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.name_english_loc = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.primary_attr = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.complexity = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.name_loc.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.name_english_loc.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.primary_attr {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.complexity {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.name_loc.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.name_english_loc.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.primary_attr {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.complexity {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HeroInfo {
            HeroInfo::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.name_loc = ::std::option::Option::None;
            self.name_english_loc = ::std::option::Option::None;
            self.primary_attr = ::std::option::Option::None;
            self.complexity = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HeroInfo {
            static instance: HeroInfo = HeroInfo {
                id: ::std::option::Option::None,
                name: ::std::option::Option::None,
                name_loc: ::std::option::Option::None,
                name_english_loc: ::std::option::Option::None,
                primary_attr: ::std::option::Option::None,
                complexity: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGameDataItemAbilityList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameDataItemAbilityList {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameDataItemAbilityList.itemabilities)
    pub itemabilities: ::std::vec::Vec<cmsg_game_data_item_ability_list::ItemAbilityInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameDataItemAbilityList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameDataItemAbilityList {
    fn default() -> &'a CMsgGameDataItemAbilityList {
        <CMsgGameDataItemAbilityList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameDataItemAbilityList {
    pub fn new() -> CMsgGameDataItemAbilityList {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameDataItemAbilityList {
    const NAME: &'static str = "CMsgGameDataItemAbilityList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.itemabilities.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.itemabilities {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.itemabilities {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameDataItemAbilityList {
        CMsgGameDataItemAbilityList::new()
    }

    fn clear(&mut self) {
        self.itemabilities.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameDataItemAbilityList {
        static instance: CMsgGameDataItemAbilityList = CMsgGameDataItemAbilityList {
            itemabilities: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGameDataItemAbilityList`
pub mod cmsg_game_data_item_ability_list {
    // @@protoc_insertion_point(message:CMsgGameDataItemAbilityList.ItemAbilityInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemAbilityInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgGameDataItemAbilityList.ItemAbilityInfo.id)
        pub id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGameDataItemAbilityList.ItemAbilityInfo.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGameDataItemAbilityList.ItemAbilityInfo.name_loc)
        pub name_loc: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGameDataItemAbilityList.ItemAbilityInfo.name_english_loc)
        pub name_english_loc: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGameDataItemAbilityList.ItemAbilityInfo.neutral_item_tier)
        pub neutral_item_tier: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGameDataItemAbilityList.ItemAbilityInfo.is_pregame_suggested)
        pub is_pregame_suggested: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgGameDataItemAbilityList.ItemAbilityInfo.is_earlygame_suggested)
        pub is_earlygame_suggested: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgGameDataItemAbilityList.ItemAbilityInfo.is_lategame_suggested)
        pub is_lategame_suggested: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGameDataItemAbilityList.ItemAbilityInfo.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemAbilityInfo {
        fn default() -> &'a ItemAbilityInfo {
            <ItemAbilityInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ItemAbilityInfo {
        pub fn new() -> ItemAbilityInfo {
            ::std::default::Default::default()
        }

        // optional int32 id = 1;

        pub fn id(&self) -> i32 {
            self.id.unwrap_or(-1i32)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: i32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string name_loc = 3;

        pub fn name_loc(&self) -> &str {
            match self.name_loc.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name_loc(&mut self) {
            self.name_loc = ::std::option::Option::None;
        }

        pub fn has_name_loc(&self) -> bool {
            self.name_loc.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name_loc(&mut self, v: ::std::string::String) {
            self.name_loc = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name_loc(&mut self) -> &mut ::std::string::String {
            if self.name_loc.is_none() {
                self.name_loc = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name_loc.as_mut().unwrap()
        }

        // Take field
        pub fn take_name_loc(&mut self) -> ::std::string::String {
            self.name_loc.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string name_english_loc = 4;

        pub fn name_english_loc(&self) -> &str {
            match self.name_english_loc.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name_english_loc(&mut self) {
            self.name_english_loc = ::std::option::Option::None;
        }

        pub fn has_name_english_loc(&self) -> bool {
            self.name_english_loc.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name_english_loc(&mut self, v: ::std::string::String) {
            self.name_english_loc = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name_english_loc(&mut self) -> &mut ::std::string::String {
            if self.name_english_loc.is_none() {
                self.name_english_loc = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name_english_loc.as_mut().unwrap()
        }

        // Take field
        pub fn take_name_english_loc(&mut self) -> ::std::string::String {
            self.name_english_loc.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 neutral_item_tier = 5;

        pub fn neutral_item_tier(&self) -> i32 {
            self.neutral_item_tier.unwrap_or(0)
        }

        pub fn clear_neutral_item_tier(&mut self) {
            self.neutral_item_tier = ::std::option::Option::None;
        }

        pub fn has_neutral_item_tier(&self) -> bool {
            self.neutral_item_tier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_neutral_item_tier(&mut self, v: i32) {
            self.neutral_item_tier = ::std::option::Option::Some(v);
        }

        // optional bool is_pregame_suggested = 6;

        pub fn is_pregame_suggested(&self) -> bool {
            self.is_pregame_suggested.unwrap_or(false)
        }

        pub fn clear_is_pregame_suggested(&mut self) {
            self.is_pregame_suggested = ::std::option::Option::None;
        }

        pub fn has_is_pregame_suggested(&self) -> bool {
            self.is_pregame_suggested.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_pregame_suggested(&mut self, v: bool) {
            self.is_pregame_suggested = ::std::option::Option::Some(v);
        }

        // optional bool is_earlygame_suggested = 7;

        pub fn is_earlygame_suggested(&self) -> bool {
            self.is_earlygame_suggested.unwrap_or(false)
        }

        pub fn clear_is_earlygame_suggested(&mut self) {
            self.is_earlygame_suggested = ::std::option::Option::None;
        }

        pub fn has_is_earlygame_suggested(&self) -> bool {
            self.is_earlygame_suggested.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_earlygame_suggested(&mut self, v: bool) {
            self.is_earlygame_suggested = ::std::option::Option::Some(v);
        }

        // optional bool is_lategame_suggested = 8;

        pub fn is_lategame_suggested(&self) -> bool {
            self.is_lategame_suggested.unwrap_or(false)
        }

        pub fn clear_is_lategame_suggested(&mut self) {
            self.is_lategame_suggested = ::std::option::Option::None;
        }

        pub fn has_is_lategame_suggested(&self) -> bool {
            self.is_lategame_suggested.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_lategame_suggested(&mut self, v: bool) {
            self.is_lategame_suggested = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ItemAbilityInfo {
        const NAME: &'static str = "ItemAbilityInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.name_loc = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.name_english_loc = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.neutral_item_tier = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.is_pregame_suggested = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.is_earlygame_suggested = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.is_lategame_suggested = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.name_loc.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.name_english_loc.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.neutral_item_tier {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.is_pregame_suggested {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_earlygame_suggested {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_lategame_suggested {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.name_loc.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.name_english_loc.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.neutral_item_tier {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.is_pregame_suggested {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.is_earlygame_suggested {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.is_lategame_suggested {
                os.write_bool(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemAbilityInfo {
            ItemAbilityInfo::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.name_loc = ::std::option::Option::None;
            self.name_english_loc = ::std::option::Option::None;
            self.neutral_item_tier = ::std::option::Option::None;
            self.is_pregame_suggested = ::std::option::Option::None;
            self.is_earlygame_suggested = ::std::option::Option::None;
            self.is_lategame_suggested = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemAbilityInfo {
            static instance: ItemAbilityInfo = ItemAbilityInfo {
                id: ::std::option::Option::None,
                name: ::std::option::Option::None,
                name_loc: ::std::option::Option::None,
                name_english_loc: ::std::option::Option::None,
                neutral_item_tier: ::std::option::Option::None,
                is_pregame_suggested: ::std::option::Option::None,
                is_earlygame_suggested: ::std::option::Option::None,
                is_lategame_suggested: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgLobbyAbilityDraftData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyAbilityDraftData {
    // message fields
    // @@protoc_insertion_point(field:CMsgLobbyAbilityDraftData.shuffle_draft_order)
    pub shuffle_draft_order: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLobbyAbilityDraftData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyAbilityDraftData {
    fn default() -> &'a CMsgLobbyAbilityDraftData {
        <CMsgLobbyAbilityDraftData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyAbilityDraftData {
    pub fn new() -> CMsgLobbyAbilityDraftData {
        ::std::default::Default::default()
    }

    // optional bool shuffle_draft_order = 1;

    pub fn shuffle_draft_order(&self) -> bool {
        self.shuffle_draft_order.unwrap_or(false)
    }

    pub fn clear_shuffle_draft_order(&mut self) {
        self.shuffle_draft_order = ::std::option::Option::None;
    }

    pub fn has_shuffle_draft_order(&self) -> bool {
        self.shuffle_draft_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shuffle_draft_order(&mut self, v: bool) {
        self.shuffle_draft_order = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLobbyAbilityDraftData {
    const NAME: &'static str = "CMsgLobbyAbilityDraftData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.shuffle_draft_order = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.shuffle_draft_order {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.shuffle_draft_order {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyAbilityDraftData {
        CMsgLobbyAbilityDraftData::new()
    }

    fn clear(&mut self) {
        self.shuffle_draft_order = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyAbilityDraftData {
        static instance: CMsgLobbyAbilityDraftData = CMsgLobbyAbilityDraftData {
            shuffle_draft_order: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOEconItemDropRateBonus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOEconItemDropRateBonus {
    // message fields
    // @@protoc_insertion_point(field:CSOEconItemDropRateBonus.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemDropRateBonus.expiration_date)
    pub expiration_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemDropRateBonus.bonus)
    pub bonus: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CSOEconItemDropRateBonus.bonus_count)
    pub bonus_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemDropRateBonus.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOEconItemDropRateBonus.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemDropRateBonus.seconds_left)
    pub seconds_left: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemDropRateBonus.booster_type)
    pub booster_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconItemDropRateBonus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItemDropRateBonus {
    fn default() -> &'a CSOEconItemDropRateBonus {
        <CSOEconItemDropRateBonus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemDropRateBonus {
    pub fn new() -> CSOEconItemDropRateBonus {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 expiration_date = 2;

    pub fn expiration_date(&self) -> u32 {
        self.expiration_date.unwrap_or(0)
    }

    pub fn clear_expiration_date(&mut self) {
        self.expiration_date = ::std::option::Option::None;
    }

    pub fn has_expiration_date(&self) -> bool {
        self.expiration_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_date(&mut self, v: u32) {
        self.expiration_date = ::std::option::Option::Some(v);
    }

    // optional float bonus = 3;

    pub fn bonus(&self) -> f32 {
        self.bonus.unwrap_or(0.)
    }

    pub fn clear_bonus(&mut self) {
        self.bonus = ::std::option::Option::None;
    }

    pub fn has_bonus(&self) -> bool {
        self.bonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus(&mut self, v: f32) {
        self.bonus = ::std::option::Option::Some(v);
    }

    // optional uint32 bonus_count = 4;

    pub fn bonus_count(&self) -> u32 {
        self.bonus_count.unwrap_or(0)
    }

    pub fn clear_bonus_count(&mut self) {
        self.bonus_count = ::std::option::Option::None;
    }

    pub fn has_bonus_count(&self) -> bool {
        self.bonus_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_count(&mut self, v: u32) {
        self.bonus_count = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 5;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 6;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_left = 7;

    pub fn seconds_left(&self) -> u32 {
        self.seconds_left.unwrap_or(0)
    }

    pub fn clear_seconds_left(&mut self) {
        self.seconds_left = ::std::option::Option::None;
    }

    pub fn has_seconds_left(&self) -> bool {
        self.seconds_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_left(&mut self, v: u32) {
        self.seconds_left = ::std::option::Option::Some(v);
    }

    // optional uint32 booster_type = 8;

    pub fn booster_type(&self) -> u32 {
        self.booster_type.unwrap_or(0)
    }

    pub fn clear_booster_type(&mut self) {
        self.booster_type = ::std::option::Option::None;
    }

    pub fn has_booster_type(&self) -> bool {
        self.booster_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_booster_type(&mut self, v: u32) {
        self.booster_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOEconItemDropRateBonus {
    const NAME: &'static str = "CSOEconItemDropRateBonus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.expiration_date = ::std::option::Option::Some(is.read_fixed32()?);
                },
                29 => {
                    self.bonus = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.bonus_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.seconds_left = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.booster_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.expiration_date {
            my_size += 1 + 4;
        }
        if let Some(v) = self.bonus {
            my_size += 1 + 4;
        }
        if let Some(v) = self.bonus_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.seconds_left {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.booster_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.expiration_date {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.bonus {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.bonus_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.seconds_left {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.booster_type {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItemDropRateBonus {
        CSOEconItemDropRateBonus::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.expiration_date = ::std::option::Option::None;
        self.bonus = ::std::option::Option::None;
        self.bonus_count = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.seconds_left = ::std::option::Option::None;
        self.booster_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItemDropRateBonus {
        static instance: CSOEconItemDropRateBonus = CSOEconItemDropRateBonus {
            account_id: ::std::option::Option::None,
            expiration_date: ::std::option::Option::None,
            bonus: ::std::option::Option::None,
            bonus_count: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            def_index: ::std::option::Option::None,
            seconds_left: ::std::option::Option::None,
            booster_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOEconItemTournamentPassport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOEconItemTournamentPassport {
    // message fields
    // @@protoc_insertion_point(field:CSOEconItemTournamentPassport.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemTournamentPassport.league_id)
    pub league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemTournamentPassport.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOEconItemTournamentPassport.original_purchaser_id)
    pub original_purchaser_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemTournamentPassport.passports_bought)
    pub passports_bought: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemTournamentPassport.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemTournamentPassport.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemTournamentPassport.reward_flags)
    pub reward_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconItemTournamentPassport.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItemTournamentPassport {
    fn default() -> &'a CSOEconItemTournamentPassport {
        <CSOEconItemTournamentPassport as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemTournamentPassport {
    pub fn new() -> CSOEconItemTournamentPassport {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 2;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 3;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 original_purchaser_id = 4;

    pub fn original_purchaser_id(&self) -> u32 {
        self.original_purchaser_id.unwrap_or(0)
    }

    pub fn clear_original_purchaser_id(&mut self) {
        self.original_purchaser_id = ::std::option::Option::None;
    }

    pub fn has_original_purchaser_id(&self) -> bool {
        self.original_purchaser_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_purchaser_id(&mut self, v: u32) {
        self.original_purchaser_id = ::std::option::Option::Some(v);
    }

    // optional uint32 passports_bought = 5;

    pub fn passports_bought(&self) -> u32 {
        self.passports_bought.unwrap_or(0)
    }

    pub fn clear_passports_bought(&mut self) {
        self.passports_bought = ::std::option::Option::None;
    }

    pub fn has_passports_bought(&self) -> bool {
        self.passports_bought.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passports_bought(&mut self, v: u32) {
        self.passports_bought = ::std::option::Option::Some(v);
    }

    // optional uint32 version = 6;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 7;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 reward_flags = 8;

    pub fn reward_flags(&self) -> u32 {
        self.reward_flags.unwrap_or(0)
    }

    pub fn clear_reward_flags(&mut self) {
        self.reward_flags = ::std::option::Option::None;
    }

    pub fn has_reward_flags(&self) -> bool {
        self.reward_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_flags(&mut self, v: u32) {
        self.reward_flags = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOEconItemTournamentPassport {
    const NAME: &'static str = "CSOEconItemTournamentPassport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.original_purchaser_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.passports_bought = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.reward_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.league_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.original_purchaser_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.passports_bought {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.reward_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.original_purchaser_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.passports_bought {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.version {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.reward_flags {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItemTournamentPassport {
        CSOEconItemTournamentPassport::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.original_purchaser_id = ::std::option::Option::None;
        self.passports_bought = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.reward_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItemTournamentPassport {
        static instance: CSOEconItemTournamentPassport = CSOEconItemTournamentPassport {
            account_id: ::std::option::Option::None,
            league_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            original_purchaser_id: ::std::option::Option::None,
            passports_bought: ::std::option::Option::None,
            version: ::std::option::Option::None,
            def_index: ::std::option::Option::None,
            reward_flags: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgStickerbookSticker)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStickerbookSticker {
    // message fields
    // @@protoc_insertion_point(field:CMsgStickerbookSticker.item_def_id)
    pub item_def_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStickerbookSticker.sticker_num)
    pub sticker_num: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStickerbookSticker.quality)
    pub quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStickerbookSticker.position_x)
    pub position_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgStickerbookSticker.position_y)
    pub position_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgStickerbookSticker.position_z)
    pub position_z: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgStickerbookSticker.rotation)
    pub rotation: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgStickerbookSticker.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgStickerbookSticker.source_item_id)
    pub source_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgStickerbookSticker.depth_bias)
    pub depth_bias: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStickerbookSticker.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStickerbookSticker {
    fn default() -> &'a CMsgStickerbookSticker {
        <CMsgStickerbookSticker as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgStickerbookSticker {
    pub fn new() -> CMsgStickerbookSticker {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_id = 1;

    pub fn item_def_id(&self) -> u32 {
        self.item_def_id.unwrap_or(0)
    }

    pub fn clear_item_def_id(&mut self) {
        self.item_def_id = ::std::option::Option::None;
    }

    pub fn has_item_def_id(&self) -> bool {
        self.item_def_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_id(&mut self, v: u32) {
        self.item_def_id = ::std::option::Option::Some(v);
    }

    // optional uint32 sticker_num = 2;

    pub fn sticker_num(&self) -> u32 {
        self.sticker_num.unwrap_or(0)
    }

    pub fn clear_sticker_num(&mut self) {
        self.sticker_num = ::std::option::Option::None;
    }

    pub fn has_sticker_num(&self) -> bool {
        self.sticker_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sticker_num(&mut self, v: u32) {
        self.sticker_num = ::std::option::Option::Some(v);
    }

    // optional uint32 quality = 3;

    pub fn quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional float position_x = 4;

    pub fn position_x(&self) -> f32 {
        self.position_x.unwrap_or(0.)
    }

    pub fn clear_position_x(&mut self) {
        self.position_x = ::std::option::Option::None;
    }

    pub fn has_position_x(&self) -> bool {
        self.position_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_x(&mut self, v: f32) {
        self.position_x = ::std::option::Option::Some(v);
    }

    // optional float position_y = 5;

    pub fn position_y(&self) -> f32 {
        self.position_y.unwrap_or(0.)
    }

    pub fn clear_position_y(&mut self) {
        self.position_y = ::std::option::Option::None;
    }

    pub fn has_position_y(&self) -> bool {
        self.position_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_y(&mut self, v: f32) {
        self.position_y = ::std::option::Option::Some(v);
    }

    // optional float position_z = 8;

    pub fn position_z(&self) -> f32 {
        self.position_z.unwrap_or(0.)
    }

    pub fn clear_position_z(&mut self) {
        self.position_z = ::std::option::Option::None;
    }

    pub fn has_position_z(&self) -> bool {
        self.position_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_z(&mut self, v: f32) {
        self.position_z = ::std::option::Option::Some(v);
    }

    // optional float rotation = 6;

    pub fn rotation(&self) -> f32 {
        self.rotation.unwrap_or(0.)
    }

    pub fn clear_rotation(&mut self) {
        self.rotation = ::std::option::Option::None;
    }

    pub fn has_rotation(&self) -> bool {
        self.rotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rotation(&mut self, v: f32) {
        self.rotation = ::std::option::Option::Some(v);
    }

    // optional float scale = 7;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional uint64 source_item_id = 9;

    pub fn source_item_id(&self) -> u64 {
        self.source_item_id.unwrap_or(0)
    }

    pub fn clear_source_item_id(&mut self) {
        self.source_item_id = ::std::option::Option::None;
    }

    pub fn has_source_item_id(&self) -> bool {
        self.source_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_item_id(&mut self, v: u64) {
        self.source_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 depth_bias = 10;

    pub fn depth_bias(&self) -> u32 {
        self.depth_bias.unwrap_or(0)
    }

    pub fn clear_depth_bias(&mut self) {
        self.depth_bias = ::std::option::Option::None;
    }

    pub fn has_depth_bias(&self) -> bool {
        self.depth_bias.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depth_bias(&mut self, v: u32) {
        self.depth_bias = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgStickerbookSticker {
    const NAME: &'static str = "CMsgStickerbookSticker";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.sticker_num = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.position_x = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.position_y = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.position_z = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.rotation = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                72 => {
                    self.source_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                80 => {
                    self.depth_bias = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.sticker_num {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.quality {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.position_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.position_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.position_z {
            my_size += 1 + 4;
        }
        if let Some(v) = self.rotation {
            my_size += 1 + 4;
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.source_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.depth_bias {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_def_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.sticker_num {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.position_x {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.position_y {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.position_z {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.rotation {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.scale {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.source_item_id {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.depth_bias {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStickerbookSticker {
        CMsgStickerbookSticker::new()
    }

    fn clear(&mut self) {
        self.item_def_id = ::std::option::Option::None;
        self.sticker_num = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.position_x = ::std::option::Option::None;
        self.position_y = ::std::option::Option::None;
        self.position_z = ::std::option::Option::None;
        self.rotation = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.source_item_id = ::std::option::Option::None;
        self.depth_bias = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStickerbookSticker {
        static instance: CMsgStickerbookSticker = CMsgStickerbookSticker {
            item_def_id: ::std::option::Option::None,
            sticker_num: ::std::option::Option::None,
            quality: ::std::option::Option::None,
            position_x: ::std::option::Option::None,
            position_y: ::std::option::Option::None,
            position_z: ::std::option::Option::None,
            rotation: ::std::option::Option::None,
            scale: ::std::option::Option::None,
            source_item_id: ::std::option::Option::None,
            depth_bias: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgStickerbookPage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStickerbookPage {
    // message fields
    // @@protoc_insertion_point(field:CMsgStickerbookPage.page_num)
    pub page_num: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStickerbookPage.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgStickerbookPage.team_id)
    pub team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStickerbookPage.stickers)
    pub stickers: ::std::vec::Vec<CMsgStickerbookSticker>,
    // @@protoc_insertion_point(field:CMsgStickerbookPage.page_type)
    pub page_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EStickerbookPageType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStickerbookPage.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStickerbookPage {
    fn default() -> &'a CMsgStickerbookPage {
        <CMsgStickerbookPage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgStickerbookPage {
    pub fn new() -> CMsgStickerbookPage {
        ::std::default::Default::default()
    }

    // optional uint32 page_num = 1;

    pub fn page_num(&self) -> u32 {
        self.page_num.unwrap_or(0)
    }

    pub fn clear_page_num(&mut self) {
        self.page_num = ::std::option::Option::None;
    }

    pub fn has_page_num(&self) -> bool {
        self.page_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_num(&mut self, v: u32) {
        self.page_num = ::std::option::Option::Some(v);
    }

    // optional .EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 team_id = 3;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional .EStickerbookPageType page_type = 5;

    pub fn page_type(&self) -> EStickerbookPageType {
        match self.page_type {
            Some(e) => e.enum_value_or(EStickerbookPageType::STICKER_PAGE_GENERIC),
            None => EStickerbookPageType::STICKER_PAGE_GENERIC,
        }
    }

    pub fn clear_page_type(&mut self) {
        self.page_type = ::std::option::Option::None;
    }

    pub fn has_page_type(&self) -> bool {
        self.page_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_type(&mut self, v: EStickerbookPageType) {
        self.page_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgStickerbookPage {
    const NAME: &'static str = "CMsgStickerbookPage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.page_num = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.stickers.push(is.read_message()?);
                },
                40 => {
                    self.page_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.page_num {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.stickers {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.page_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.page_num {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(3, v)?;
        }
        for v in &self.stickers {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.page_type {
            os.write_enum(5, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStickerbookPage {
        CMsgStickerbookPage::new()
    }

    fn clear(&mut self) {
        self.page_num = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.stickers.clear();
        self.page_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStickerbookPage {
        static instance: CMsgStickerbookPage = CMsgStickerbookPage {
            page_num: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            stickers: ::std::vec::Vec::new(),
            page_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgStickerbookTeamPageOrderSequence)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStickerbookTeamPageOrderSequence {
    // message fields
    // @@protoc_insertion_point(field:CMsgStickerbookTeamPageOrderSequence.page_numbers)
    pub page_numbers: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStickerbookTeamPageOrderSequence.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStickerbookTeamPageOrderSequence {
    fn default() -> &'a CMsgStickerbookTeamPageOrderSequence {
        <CMsgStickerbookTeamPageOrderSequence as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgStickerbookTeamPageOrderSequence {
    pub fn new() -> CMsgStickerbookTeamPageOrderSequence {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgStickerbookTeamPageOrderSequence {
    const NAME: &'static str = "CMsgStickerbookTeamPageOrderSequence";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.page_numbers)?;
                },
                8 => {
                    self.page_numbers.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.page_numbers {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.page_numbers {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStickerbookTeamPageOrderSequence {
        CMsgStickerbookTeamPageOrderSequence::new()
    }

    fn clear(&mut self) {
        self.page_numbers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStickerbookTeamPageOrderSequence {
        static instance: CMsgStickerbookTeamPageOrderSequence = CMsgStickerbookTeamPageOrderSequence {
            page_numbers: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgStickerbook)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStickerbook {
    // message fields
    // @@protoc_insertion_point(field:CMsgStickerbook.pages)
    pub pages: ::std::vec::Vec<CMsgStickerbookPage>,
    // @@protoc_insertion_point(field:CMsgStickerbook.team_page_order_sequence)
    pub team_page_order_sequence: ::steam_vent_proto_common::protobuf::MessageField<CMsgStickerbookTeamPageOrderSequence>,
    // @@protoc_insertion_point(field:CMsgStickerbook.favorite_page_num)
    pub favorite_page_num: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStickerbook.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStickerbook {
    fn default() -> &'a CMsgStickerbook {
        <CMsgStickerbook as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgStickerbook {
    pub fn new() -> CMsgStickerbook {
        ::std::default::Default::default()
    }

    // optional uint32 favorite_page_num = 3;

    pub fn favorite_page_num(&self) -> u32 {
        self.favorite_page_num.unwrap_or(0)
    }

    pub fn clear_favorite_page_num(&mut self) {
        self.favorite_page_num = ::std::option::Option::None;
    }

    pub fn has_favorite_page_num(&self) -> bool {
        self.favorite_page_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite_page_num(&mut self, v: u32) {
        self.favorite_page_num = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgStickerbook {
    const NAME: &'static str = "CMsgStickerbook";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pages.push(is.read_message()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.team_page_order_sequence)?;
                },
                24 => {
                    self.favorite_page_num = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.pages {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.team_page_order_sequence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.favorite_page_num {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.pages {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.team_page_order_sequence.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.favorite_page_num {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStickerbook {
        CMsgStickerbook::new()
    }

    fn clear(&mut self) {
        self.pages.clear();
        self.team_page_order_sequence.clear();
        self.favorite_page_num = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStickerbook {
        static instance: CMsgStickerbook = CMsgStickerbook {
            pages: ::std::vec::Vec::new(),
            team_page_order_sequence: ::steam_vent_proto_common::protobuf::MessageField::none(),
            favorite_page_num: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgStickerHero)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStickerHero {
    // message fields
    // @@protoc_insertion_point(field:CMsgStickerHero.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgStickerHero.item_def_id)
    pub item_def_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStickerHero.quality)
    pub quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStickerHero.source_item_id)
    pub source_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStickerHero.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStickerHero {
    fn default() -> &'a CMsgStickerHero {
        <CMsgStickerHero as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgStickerHero {
    pub fn new() -> CMsgStickerHero {
        ::std::default::Default::default()
    }

    // optional int32 hero_id = 1;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 item_def_id = 2;

    pub fn item_def_id(&self) -> u32 {
        self.item_def_id.unwrap_or(0)
    }

    pub fn clear_item_def_id(&mut self) {
        self.item_def_id = ::std::option::Option::None;
    }

    pub fn has_item_def_id(&self) -> bool {
        self.item_def_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_id(&mut self, v: u32) {
        self.item_def_id = ::std::option::Option::Some(v);
    }

    // optional uint32 quality = 3;

    pub fn quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional uint64 source_item_id = 4;

    pub fn source_item_id(&self) -> u64 {
        self.source_item_id.unwrap_or(0)
    }

    pub fn clear_source_item_id(&mut self) {
        self.source_item_id = ::std::option::Option::None;
    }

    pub fn has_source_item_id(&self) -> bool {
        self.source_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_item_id(&mut self, v: u64) {
        self.source_item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgStickerHero {
    const NAME: &'static str = "CMsgStickerHero";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.item_def_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.source_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.item_def_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.quality {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.source_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hero_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.item_def_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.source_item_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStickerHero {
        CMsgStickerHero::new()
    }

    fn clear(&mut self) {
        self.hero_id = ::std::option::Option::None;
        self.item_def_id = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.source_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStickerHero {
        static instance: CMsgStickerHero = CMsgStickerHero {
            hero_id: ::std::option::Option::None,
            item_def_id: ::std::option::Option::None,
            quality: ::std::option::Option::None,
            source_item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgStickerHeroes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStickerHeroes {
    // message fields
    // @@protoc_insertion_point(field:CMsgStickerHeroes.heroes)
    pub heroes: ::std::vec::Vec<CMsgStickerHero>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStickerHeroes.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStickerHeroes {
    fn default() -> &'a CMsgStickerHeroes {
        <CMsgStickerHeroes as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgStickerHeroes {
    pub fn new() -> CMsgStickerHeroes {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgStickerHeroes {
    const NAME: &'static str = "CMsgStickerHeroes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.heroes.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.heroes {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.heroes {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStickerHeroes {
        CMsgStickerHeroes::new()
    }

    fn clear(&mut self) {
        self.heroes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStickerHeroes {
        static instance: CMsgStickerHeroes = CMsgStickerHeroes {
            heroes: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgHeroRoleStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHeroRoleStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgHeroRoleStats.lane_selection_flags)
    pub lane_selection_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHeroRoleStats.match_count)
    pub match_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHeroRoleStats.win_count)
    pub win_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHeroRoleStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHeroRoleStats {
    fn default() -> &'a CMsgHeroRoleStats {
        <CMsgHeroRoleStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgHeroRoleStats {
    pub fn new() -> CMsgHeroRoleStats {
        ::std::default::Default::default()
    }

    // optional uint32 lane_selection_flags = 1;

    pub fn lane_selection_flags(&self) -> u32 {
        self.lane_selection_flags.unwrap_or(0)
    }

    pub fn clear_lane_selection_flags(&mut self) {
        self.lane_selection_flags = ::std::option::Option::None;
    }

    pub fn has_lane_selection_flags(&self) -> bool {
        self.lane_selection_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane_selection_flags(&mut self, v: u32) {
        self.lane_selection_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 match_count = 2;

    pub fn match_count(&self) -> u32 {
        self.match_count.unwrap_or(0)
    }

    pub fn clear_match_count(&mut self) {
        self.match_count = ::std::option::Option::None;
    }

    pub fn has_match_count(&self) -> bool {
        self.match_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_count(&mut self, v: u32) {
        self.match_count = ::std::option::Option::Some(v);
    }

    // optional uint32 win_count = 3;

    pub fn win_count(&self) -> u32 {
        self.win_count.unwrap_or(0)
    }

    pub fn clear_win_count(&mut self) {
        self.win_count = ::std::option::Option::None;
    }

    pub fn has_win_count(&self) -> bool {
        self.win_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_win_count(&mut self, v: u32) {
        self.win_count = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgHeroRoleStats {
    const NAME: &'static str = "CMsgHeroRoleStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lane_selection_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.match_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.win_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lane_selection_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.win_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.lane_selection_flags {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.win_count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHeroRoleStats {
        CMsgHeroRoleStats::new()
    }

    fn clear(&mut self) {
        self.lane_selection_flags = ::std::option::Option::None;
        self.match_count = ::std::option::Option::None;
        self.win_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHeroRoleStats {
        static instance: CMsgHeroRoleStats = CMsgHeroRoleStats {
            lane_selection_flags: ::std::option::Option::None,
            match_count: ::std::option::Option::None,
            win_count: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgHeroRoleHeroStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHeroRoleHeroStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgHeroRoleHeroStats.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgHeroRoleHeroStats.role_stats)
    pub role_stats: ::std::vec::Vec<CMsgHeroRoleStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHeroRoleHeroStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHeroRoleHeroStats {
    fn default() -> &'a CMsgHeroRoleHeroStats {
        <CMsgHeroRoleHeroStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgHeroRoleHeroStats {
    pub fn new() -> CMsgHeroRoleHeroStats {
        ::std::default::Default::default()
    }

    // optional int32 hero_id = 1;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgHeroRoleHeroStats {
    const NAME: &'static str = "CMsgHeroRoleHeroStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.role_stats.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        for value in &self.role_stats {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hero_id {
            os.write_int32(1, v)?;
        }
        for v in &self.role_stats {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHeroRoleHeroStats {
        CMsgHeroRoleHeroStats::new()
    }

    fn clear(&mut self) {
        self.hero_id = ::std::option::Option::None;
        self.role_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHeroRoleHeroStats {
        static instance: CMsgHeroRoleHeroStats = CMsgHeroRoleHeroStats {
            hero_id: ::std::option::Option::None,
            role_stats: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgHeroRoleRankStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHeroRoleRankStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgHeroRoleRankStats.rank_tier)
    pub rank_tier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHeroRoleRankStats.hero_stats)
    pub hero_stats: ::std::vec::Vec<CMsgHeroRoleHeroStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHeroRoleRankStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHeroRoleRankStats {
    fn default() -> &'a CMsgHeroRoleRankStats {
        <CMsgHeroRoleRankStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgHeroRoleRankStats {
    pub fn new() -> CMsgHeroRoleRankStats {
        ::std::default::Default::default()
    }

    // optional uint32 rank_tier = 1;

    pub fn rank_tier(&self) -> u32 {
        self.rank_tier.unwrap_or(0)
    }

    pub fn clear_rank_tier(&mut self) {
        self.rank_tier = ::std::option::Option::None;
    }

    pub fn has_rank_tier(&self) -> bool {
        self.rank_tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_tier(&mut self, v: u32) {
        self.rank_tier = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgHeroRoleRankStats {
    const NAME: &'static str = "CMsgHeroRoleRankStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rank_tier = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.hero_stats.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rank_tier {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.hero_stats {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.rank_tier {
            os.write_uint32(1, v)?;
        }
        for v in &self.hero_stats {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHeroRoleRankStats {
        CMsgHeroRoleRankStats::new()
    }

    fn clear(&mut self) {
        self.rank_tier = ::std::option::Option::None;
        self.hero_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHeroRoleRankStats {
        static instance: CMsgHeroRoleRankStats = CMsgHeroRoleRankStats {
            rank_tier: ::std::option::Option::None,
            hero_stats: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgHeroRoleAllRanksStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHeroRoleAllRanksStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgHeroRoleAllRanksStats.start_timestamp)
    pub start_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHeroRoleAllRanksStats.end_timestamp)
    pub end_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHeroRoleAllRanksStats.rank_stats)
    pub rank_stats: ::std::vec::Vec<CMsgHeroRoleRankStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHeroRoleAllRanksStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHeroRoleAllRanksStats {
    fn default() -> &'a CMsgHeroRoleAllRanksStats {
        <CMsgHeroRoleAllRanksStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgHeroRoleAllRanksStats {
    pub fn new() -> CMsgHeroRoleAllRanksStats {
        ::std::default::Default::default()
    }

    // optional uint32 start_timestamp = 1;

    pub fn start_timestamp(&self) -> u32 {
        self.start_timestamp.unwrap_or(0)
    }

    pub fn clear_start_timestamp(&mut self) {
        self.start_timestamp = ::std::option::Option::None;
    }

    pub fn has_start_timestamp(&self) -> bool {
        self.start_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_timestamp(&mut self, v: u32) {
        self.start_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 end_timestamp = 2;

    pub fn end_timestamp(&self) -> u32 {
        self.end_timestamp.unwrap_or(0)
    }

    pub fn clear_end_timestamp(&mut self) {
        self.end_timestamp = ::std::option::Option::None;
    }

    pub fn has_end_timestamp(&self) -> bool {
        self.end_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_timestamp(&mut self, v: u32) {
        self.end_timestamp = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgHeroRoleAllRanksStats {
    const NAME: &'static str = "CMsgHeroRoleAllRanksStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.end_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.rank_stats.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.end_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.rank_stats {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.start_timestamp {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.end_timestamp {
            os.write_uint32(2, v)?;
        }
        for v in &self.rank_stats {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHeroRoleAllRanksStats {
        CMsgHeroRoleAllRanksStats::new()
    }

    fn clear(&mut self) {
        self.start_timestamp = ::std::option::Option::None;
        self.end_timestamp = ::std::option::Option::None;
        self.rank_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHeroRoleAllRanksStats {
        static instance: CMsgHeroRoleAllRanksStats = CMsgHeroRoleAllRanksStats {
            start_timestamp: ::std::option::Option::None,
            end_timestamp: ::std::option::Option::None,
            rank_stats: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMapStatsSnapshot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMapStatsSnapshot {
    // message fields
    // @@protoc_insertion_point(field:CMsgMapStatsSnapshot.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMapStatsSnapshot.lotuses_gained)
    pub lotuses_gained: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgMapStatsSnapshot.wisdom_runes_gained)
    pub wisdom_runes_gained: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgMapStatsSnapshot.roshan_kills_day)
    pub roshan_kills_day: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgMapStatsSnapshot.roshan_kills_night)
    pub roshan_kills_night: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgMapStatsSnapshot.portals_used)
    pub portals_used: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgMapStatsSnapshot.watchers_taken)
    pub watchers_taken: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgMapStatsSnapshot.tormentor_kills)
    pub tormentor_kills: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgMapStatsSnapshot.outposts_captured)
    pub outposts_captured: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgMapStatsSnapshot.shield_runes_gained)
    pub shield_runes_gained: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMapStatsSnapshot.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMapStatsSnapshot {
    fn default() -> &'a CMsgMapStatsSnapshot {
        <CMsgMapStatsSnapshot as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgMapStatsSnapshot {
    pub fn new() -> CMsgMapStatsSnapshot {
        ::std::default::Default::default()
    }

    // optional uint32 timestamp = 1;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint64 lotuses_gained = 2;

    pub fn lotuses_gained(&self) -> u64 {
        self.lotuses_gained.unwrap_or(0)
    }

    pub fn clear_lotuses_gained(&mut self) {
        self.lotuses_gained = ::std::option::Option::None;
    }

    pub fn has_lotuses_gained(&self) -> bool {
        self.lotuses_gained.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lotuses_gained(&mut self, v: u64) {
        self.lotuses_gained = ::std::option::Option::Some(v);
    }

    // optional uint64 wisdom_runes_gained = 3;

    pub fn wisdom_runes_gained(&self) -> u64 {
        self.wisdom_runes_gained.unwrap_or(0)
    }

    pub fn clear_wisdom_runes_gained(&mut self) {
        self.wisdom_runes_gained = ::std::option::Option::None;
    }

    pub fn has_wisdom_runes_gained(&self) -> bool {
        self.wisdom_runes_gained.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wisdom_runes_gained(&mut self, v: u64) {
        self.wisdom_runes_gained = ::std::option::Option::Some(v);
    }

    // optional uint64 roshan_kills_day = 4;

    pub fn roshan_kills_day(&self) -> u64 {
        self.roshan_kills_day.unwrap_or(0)
    }

    pub fn clear_roshan_kills_day(&mut self) {
        self.roshan_kills_day = ::std::option::Option::None;
    }

    pub fn has_roshan_kills_day(&self) -> bool {
        self.roshan_kills_day.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roshan_kills_day(&mut self, v: u64) {
        self.roshan_kills_day = ::std::option::Option::Some(v);
    }

    // optional uint64 roshan_kills_night = 5;

    pub fn roshan_kills_night(&self) -> u64 {
        self.roshan_kills_night.unwrap_or(0)
    }

    pub fn clear_roshan_kills_night(&mut self) {
        self.roshan_kills_night = ::std::option::Option::None;
    }

    pub fn has_roshan_kills_night(&self) -> bool {
        self.roshan_kills_night.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roshan_kills_night(&mut self, v: u64) {
        self.roshan_kills_night = ::std::option::Option::Some(v);
    }

    // optional uint64 portals_used = 6;

    pub fn portals_used(&self) -> u64 {
        self.portals_used.unwrap_or(0)
    }

    pub fn clear_portals_used(&mut self) {
        self.portals_used = ::std::option::Option::None;
    }

    pub fn has_portals_used(&self) -> bool {
        self.portals_used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portals_used(&mut self, v: u64) {
        self.portals_used = ::std::option::Option::Some(v);
    }

    // optional uint64 watchers_taken = 7;

    pub fn watchers_taken(&self) -> u64 {
        self.watchers_taken.unwrap_or(0)
    }

    pub fn clear_watchers_taken(&mut self) {
        self.watchers_taken = ::std::option::Option::None;
    }

    pub fn has_watchers_taken(&self) -> bool {
        self.watchers_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watchers_taken(&mut self, v: u64) {
        self.watchers_taken = ::std::option::Option::Some(v);
    }

    // optional uint64 tormentor_kills = 8;

    pub fn tormentor_kills(&self) -> u64 {
        self.tormentor_kills.unwrap_or(0)
    }

    pub fn clear_tormentor_kills(&mut self) {
        self.tormentor_kills = ::std::option::Option::None;
    }

    pub fn has_tormentor_kills(&self) -> bool {
        self.tormentor_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tormentor_kills(&mut self, v: u64) {
        self.tormentor_kills = ::std::option::Option::Some(v);
    }

    // optional uint64 outposts_captured = 9;

    pub fn outposts_captured(&self) -> u64 {
        self.outposts_captured.unwrap_or(0)
    }

    pub fn clear_outposts_captured(&mut self) {
        self.outposts_captured = ::std::option::Option::None;
    }

    pub fn has_outposts_captured(&self) -> bool {
        self.outposts_captured.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outposts_captured(&mut self, v: u64) {
        self.outposts_captured = ::std::option::Option::Some(v);
    }

    // optional uint64 shield_runes_gained = 10;

    pub fn shield_runes_gained(&self) -> u64 {
        self.shield_runes_gained.unwrap_or(0)
    }

    pub fn clear_shield_runes_gained(&mut self) {
        self.shield_runes_gained = ::std::option::Option::None;
    }

    pub fn has_shield_runes_gained(&self) -> bool {
        self.shield_runes_gained.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shield_runes_gained(&mut self, v: u64) {
        self.shield_runes_gained = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgMapStatsSnapshot {
    const NAME: &'static str = "CMsgMapStatsSnapshot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.lotuses_gained = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.wisdom_runes_gained = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.roshan_kills_day = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.roshan_kills_night = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.portals_used = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.watchers_taken = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.tormentor_kills = ::std::option::Option::Some(is.read_uint64()?);
                },
                72 => {
                    self.outposts_captured = ::std::option::Option::Some(is.read_uint64()?);
                },
                80 => {
                    self.shield_runes_gained = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.lotuses_gained {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.wisdom_runes_gained {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.roshan_kills_day {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.roshan_kills_night {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.portals_used {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.watchers_taken {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.tormentor_kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(8, v);
        }
        if let Some(v) = self.outposts_captured {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.shield_runes_gained {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(10, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.timestamp {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.lotuses_gained {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.wisdom_runes_gained {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.roshan_kills_day {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.roshan_kills_night {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.portals_used {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.watchers_taken {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.tormentor_kills {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.outposts_captured {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.shield_runes_gained {
            os.write_uint64(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMapStatsSnapshot {
        CMsgMapStatsSnapshot::new()
    }

    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.lotuses_gained = ::std::option::Option::None;
        self.wisdom_runes_gained = ::std::option::Option::None;
        self.roshan_kills_day = ::std::option::Option::None;
        self.roshan_kills_night = ::std::option::Option::None;
        self.portals_used = ::std::option::Option::None;
        self.watchers_taken = ::std::option::Option::None;
        self.tormentor_kills = ::std::option::Option::None;
        self.outposts_captured = ::std::option::Option::None;
        self.shield_runes_gained = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMapStatsSnapshot {
        static instance: CMsgMapStatsSnapshot = CMsgMapStatsSnapshot {
            timestamp: ::std::option::Option::None,
            lotuses_gained: ::std::option::Option::None,
            wisdom_runes_gained: ::std::option::Option::None,
            roshan_kills_day: ::std::option::Option::None,
            roshan_kills_night: ::std::option::Option::None,
            portals_used: ::std::option::Option::None,
            watchers_taken: ::std::option::Option::None,
            tormentor_kills: ::std::option::Option::None,
            outposts_captured: ::std::option::Option::None,
            shield_runes_gained: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGlobalMapStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGlobalMapStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgGlobalMapStats.current)
    pub current: ::steam_vent_proto_common::protobuf::MessageField<CMsgMapStatsSnapshot>,
    // @@protoc_insertion_point(field:CMsgGlobalMapStats.window_start)
    pub window_start: ::steam_vent_proto_common::protobuf::MessageField<CMsgMapStatsSnapshot>,
    // @@protoc_insertion_point(field:CMsgGlobalMapStats.window_end)
    pub window_end: ::steam_vent_proto_common::protobuf::MessageField<CMsgMapStatsSnapshot>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGlobalMapStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGlobalMapStats {
    fn default() -> &'a CMsgGlobalMapStats {
        <CMsgGlobalMapStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGlobalMapStats {
    pub fn new() -> CMsgGlobalMapStats {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGlobalMapStats {
    const NAME: &'static str = "CMsgGlobalMapStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.current)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.window_start)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.window_end)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.current.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.window_start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.window_end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.current.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.window_start.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.window_end.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGlobalMapStats {
        CMsgGlobalMapStats::new()
    }

    fn clear(&mut self) {
        self.current.clear();
        self.window_start.clear();
        self.window_end.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGlobalMapStats {
        static instance: CMsgGlobalMapStats = CMsgGlobalMapStats {
            current: ::steam_vent_proto_common::protobuf::MessageField::none(),
            window_start: ::steam_vent_proto_common::protobuf::MessageField::none(),
            window_end: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTrackedStat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTrackedStat {
    // message fields
    // @@protoc_insertion_point(field:CMsgTrackedStat.tracked_stat_id)
    pub tracked_stat_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTrackedStat.tracked_stat_value)
    pub tracked_stat_value: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTrackedStat.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTrackedStat {
    fn default() -> &'a CMsgTrackedStat {
        <CMsgTrackedStat as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTrackedStat {
    pub fn new() -> CMsgTrackedStat {
        ::std::default::Default::default()
    }

    // optional uint32 tracked_stat_id = 1;

    pub fn tracked_stat_id(&self) -> u32 {
        self.tracked_stat_id.unwrap_or(0)
    }

    pub fn clear_tracked_stat_id(&mut self) {
        self.tracked_stat_id = ::std::option::Option::None;
    }

    pub fn has_tracked_stat_id(&self) -> bool {
        self.tracked_stat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tracked_stat_id(&mut self, v: u32) {
        self.tracked_stat_id = ::std::option::Option::Some(v);
    }

    // optional int32 tracked_stat_value = 2;

    pub fn tracked_stat_value(&self) -> i32 {
        self.tracked_stat_value.unwrap_or(0)
    }

    pub fn clear_tracked_stat_value(&mut self) {
        self.tracked_stat_value = ::std::option::Option::None;
    }

    pub fn has_tracked_stat_value(&self) -> bool {
        self.tracked_stat_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tracked_stat_value(&mut self, v: i32) {
        self.tracked_stat_value = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTrackedStat {
    const NAME: &'static str = "CMsgTrackedStat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tracked_stat_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.tracked_stat_value = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tracked_stat_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.tracked_stat_value {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.tracked_stat_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.tracked_stat_value {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTrackedStat {
        CMsgTrackedStat::new()
    }

    fn clear(&mut self) {
        self.tracked_stat_id = ::std::option::Option::None;
        self.tracked_stat_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTrackedStat {
        static instance: CMsgTrackedStat = CMsgTrackedStat {
            tracked_stat_id: ::std::option::Option::None,
            tracked_stat_value: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAClaimEventActionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAClaimEventActionResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAClaimEventActionResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_dotaclaim_event_action_response::ResultCode>>,
    // @@protoc_insertion_point(field:CMsgDOTAClaimEventActionResponse.reward_results)
    pub reward_results: ::std::vec::Vec<cmsg_dotaclaim_event_action_response::GrantedRewardData>,
    // @@protoc_insertion_point(field:CMsgDOTAClaimEventActionResponse.action_id)
    pub action_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAClaimEventActionResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAClaimEventActionResponse {
    fn default() -> &'a CMsgDOTAClaimEventActionResponse {
        <CMsgDOTAClaimEventActionResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAClaimEventActionResponse {
    pub fn new() -> CMsgDOTAClaimEventActionResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgDOTAClaimEventActionResponse.ResultCode result = 1;

    pub fn result(&self) -> cmsg_dotaclaim_event_action_response::ResultCode {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_dotaclaim_event_action_response::ResultCode::Success),
            None => cmsg_dotaclaim_event_action_response::ResultCode::Success,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_dotaclaim_event_action_response::ResultCode) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 action_id = 3;

    pub fn action_id(&self) -> u32 {
        self.action_id.unwrap_or(0)
    }

    pub fn clear_action_id(&mut self) {
        self.action_id = ::std::option::Option::None;
    }

    pub fn has_action_id(&self) -> bool {
        self.action_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_id(&mut self, v: u32) {
        self.action_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAClaimEventActionResponse {
    const NAME: &'static str = "CMsgDOTAClaimEventActionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.reward_results.push(is.read_message()?);
                },
                24 => {
                    self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.reward_results {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.action_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.reward_results {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.action_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAClaimEventActionResponse {
        CMsgDOTAClaimEventActionResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.reward_results.clear();
        self.action_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAClaimEventActionResponse {
        static instance: CMsgDOTAClaimEventActionResponse = CMsgDOTAClaimEventActionResponse {
            result: ::std::option::Option::None,
            reward_results: ::std::vec::Vec::new(),
            action_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTAClaimEventActionResponse`
pub mod cmsg_dotaclaim_event_action_response {
    // @@protoc_insertion_point(message:CMsgDOTAClaimEventActionResponse.MysteryItemRewardData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MysteryItemRewardData {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAClaimEventActionResponse.MysteryItemRewardData.item_def)
        pub item_def: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAClaimEventActionResponse.MysteryItemRewardData.item_category)
        pub item_category: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAClaimEventActionResponse.MysteryItemRewardData.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MysteryItemRewardData {
        fn default() -> &'a MysteryItemRewardData {
            <MysteryItemRewardData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl MysteryItemRewardData {
        pub fn new() -> MysteryItemRewardData {
            ::std::default::Default::default()
        }

        // optional uint32 item_def = 1;

        pub fn item_def(&self) -> u32 {
            self.item_def.unwrap_or(0)
        }

        pub fn clear_item_def(&mut self) {
            self.item_def = ::std::option::Option::None;
        }

        pub fn has_item_def(&self) -> bool {
            self.item_def.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_def(&mut self, v: u32) {
            self.item_def = ::std::option::Option::Some(v);
        }

        // optional uint32 item_category = 2;

        pub fn item_category(&self) -> u32 {
            self.item_category.unwrap_or(0)
        }

        pub fn clear_item_category(&mut self) {
            self.item_category = ::std::option::Option::None;
        }

        pub fn has_item_category(&self) -> bool {
            self.item_category.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_category(&mut self, v: u32) {
            self.item_category = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for MysteryItemRewardData {
        const NAME: &'static str = "MysteryItemRewardData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.item_category = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_def {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.item_category {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item_def {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.item_category {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MysteryItemRewardData {
            MysteryItemRewardData::new()
        }

        fn clear(&mut self) {
            self.item_def = ::std::option::Option::None;
            self.item_category = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MysteryItemRewardData {
            static instance: MysteryItemRewardData = MysteryItemRewardData {
                item_def: ::std::option::Option::None,
                item_category: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTAClaimEventActionResponse.LootListRewardData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LootListRewardData {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAClaimEventActionResponse.LootListRewardData.item_def)
        pub item_def: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAClaimEventActionResponse.LootListRewardData.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LootListRewardData {
        fn default() -> &'a LootListRewardData {
            <LootListRewardData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl LootListRewardData {
        pub fn new() -> LootListRewardData {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for LootListRewardData {
        const NAME: &'static str = "LootListRewardData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_uint32_into(&mut self.item_def)?;
                    },
                    8 => {
                        self.item_def.push(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.item_def {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            for v in &self.item_def {
                os.write_uint32(1, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LootListRewardData {
            LootListRewardData::new()
        }

        fn clear(&mut self) {
            self.item_def.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LootListRewardData {
            static instance: LootListRewardData = LootListRewardData {
                item_def: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTAClaimEventActionResponse.ActionListRewardData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ActionListRewardData {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAClaimEventActionResponse.ActionListRewardData.action_id)
        pub action_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAClaimEventActionResponse.ActionListRewardData.result_reward_data)
        pub result_reward_data: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAClaimEventActionResponse.ActionListRewardData.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ActionListRewardData {
        fn default() -> &'a ActionListRewardData {
            <ActionListRewardData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ActionListRewardData {
        pub fn new() -> ActionListRewardData {
            ::std::default::Default::default()
        }

        // optional uint32 action_id = 1;

        pub fn action_id(&self) -> u32 {
            self.action_id.unwrap_or(0)
        }

        pub fn clear_action_id(&mut self) {
            self.action_id = ::std::option::Option::None;
        }

        pub fn has_action_id(&self) -> bool {
            self.action_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_action_id(&mut self, v: u32) {
            self.action_id = ::std::option::Option::Some(v);
        }

        // optional bytes result_reward_data = 2;

        pub fn result_reward_data(&self) -> &[u8] {
            match self.result_reward_data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_result_reward_data(&mut self) {
            self.result_reward_data = ::std::option::Option::None;
        }

        pub fn has_result_reward_data(&self) -> bool {
            self.result_reward_data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_result_reward_data(&mut self, v: ::std::vec::Vec<u8>) {
            self.result_reward_data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_result_reward_data(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.result_reward_data.is_none() {
                self.result_reward_data = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.result_reward_data.as_mut().unwrap()
        }

        // Take field
        pub fn take_result_reward_data(&mut self) -> ::std::vec::Vec<u8> {
            self.result_reward_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ActionListRewardData {
        const NAME: &'static str = "ActionListRewardData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.result_reward_data = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.action_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.result_reward_data.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.action_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.result_reward_data.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ActionListRewardData {
            ActionListRewardData::new()
        }

        fn clear(&mut self) {
            self.action_id = ::std::option::Option::None;
            self.result_reward_data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ActionListRewardData {
            static instance: ActionListRewardData = ActionListRewardData {
                action_id: ::std::option::Option::None,
                result_reward_data: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTAClaimEventActionResponse.OverworldTokenRewardData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct OverworldTokenRewardData {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAClaimEventActionResponse.OverworldTokenRewardData.tokens)
        pub tokens: ::std::vec::Vec<overworld_token_reward_data::TokenQuantity>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAClaimEventActionResponse.OverworldTokenRewardData.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a OverworldTokenRewardData {
        fn default() -> &'a OverworldTokenRewardData {
            <OverworldTokenRewardData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl OverworldTokenRewardData {
        pub fn new() -> OverworldTokenRewardData {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for OverworldTokenRewardData {
        const NAME: &'static str = "OverworldTokenRewardData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.tokens.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.tokens {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            for v in &self.tokens {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> OverworldTokenRewardData {
            OverworldTokenRewardData::new()
        }

        fn clear(&mut self) {
            self.tokens.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static OverworldTokenRewardData {
            static instance: OverworldTokenRewardData = OverworldTokenRewardData {
                tokens: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `OverworldTokenRewardData`
    pub mod overworld_token_reward_data {
        // @@protoc_insertion_point(message:CMsgDOTAClaimEventActionResponse.OverworldTokenRewardData.TokenQuantity)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct TokenQuantity {
            // message fields
            // @@protoc_insertion_point(field:CMsgDOTAClaimEventActionResponse.OverworldTokenRewardData.TokenQuantity.token_id)
            pub token_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgDOTAClaimEventActionResponse.OverworldTokenRewardData.TokenQuantity.token_count)
            pub token_count: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgDOTAClaimEventActionResponse.OverworldTokenRewardData.TokenQuantity.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a TokenQuantity {
            fn default() -> &'a TokenQuantity {
                <TokenQuantity as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl TokenQuantity {
            pub fn new() -> TokenQuantity {
                ::std::default::Default::default()
            }

            // optional uint32 token_id = 1;

            pub fn token_id(&self) -> u32 {
                self.token_id.unwrap_or(0)
            }

            pub fn clear_token_id(&mut self) {
                self.token_id = ::std::option::Option::None;
            }

            pub fn has_token_id(&self) -> bool {
                self.token_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_token_id(&mut self, v: u32) {
                self.token_id = ::std::option::Option::Some(v);
            }

            // optional uint32 token_count = 2;

            pub fn token_count(&self) -> u32 {
                self.token_count.unwrap_or(0)
            }

            pub fn clear_token_count(&mut self) {
                self.token_count = ::std::option::Option::None;
            }

            pub fn has_token_count(&self) -> bool {
                self.token_count.is_some()
            }

            // Param is passed by value, moved
            pub fn set_token_count(&mut self, v: u32) {
                self.token_count = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for TokenQuantity {
            const NAME: &'static str = "TokenQuantity";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.token_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.token_count = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.token_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.token_count {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.token_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.token_count {
                    os.write_uint32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> TokenQuantity {
                TokenQuantity::new()
            }

            fn clear(&mut self) {
                self.token_id = ::std::option::Option::None;
                self.token_count = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static TokenQuantity {
                static instance: TokenQuantity = TokenQuantity {
                    token_id: ::std::option::Option::None,
                    token_count: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTAClaimEventActionResponse.GrantedRewardData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GrantedRewardData {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAClaimEventActionResponse.GrantedRewardData.grant_index)
        pub grant_index: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAClaimEventActionResponse.GrantedRewardData.score_index)
        pub score_index: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAClaimEventActionResponse.GrantedRewardData.reward_index)
        pub reward_index: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAClaimEventActionResponse.GrantedRewardData.reward_data)
        pub reward_data: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgDOTAClaimEventActionResponse.GrantedRewardData.action_id)
        pub action_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAClaimEventActionResponse.GrantedRewardData.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GrantedRewardData {
        fn default() -> &'a GrantedRewardData {
            <GrantedRewardData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl GrantedRewardData {
        pub fn new() -> GrantedRewardData {
            ::std::default::Default::default()
        }

        // optional uint32 grant_index = 1;

        pub fn grant_index(&self) -> u32 {
            self.grant_index.unwrap_or(0)
        }

        pub fn clear_grant_index(&mut self) {
            self.grant_index = ::std::option::Option::None;
        }

        pub fn has_grant_index(&self) -> bool {
            self.grant_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_grant_index(&mut self, v: u32) {
            self.grant_index = ::std::option::Option::Some(v);
        }

        // optional uint32 score_index = 2;

        pub fn score_index(&self) -> u32 {
            self.score_index.unwrap_or(0)
        }

        pub fn clear_score_index(&mut self) {
            self.score_index = ::std::option::Option::None;
        }

        pub fn has_score_index(&self) -> bool {
            self.score_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score_index(&mut self, v: u32) {
            self.score_index = ::std::option::Option::Some(v);
        }

        // optional uint32 reward_index = 3;

        pub fn reward_index(&self) -> u32 {
            self.reward_index.unwrap_or(0)
        }

        pub fn clear_reward_index(&mut self) {
            self.reward_index = ::std::option::Option::None;
        }

        pub fn has_reward_index(&self) -> bool {
            self.reward_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reward_index(&mut self, v: u32) {
            self.reward_index = ::std::option::Option::Some(v);
        }

        // optional bytes reward_data = 4;

        pub fn reward_data(&self) -> &[u8] {
            match self.reward_data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_reward_data(&mut self) {
            self.reward_data = ::std::option::Option::None;
        }

        pub fn has_reward_data(&self) -> bool {
            self.reward_data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reward_data(&mut self, v: ::std::vec::Vec<u8>) {
            self.reward_data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_reward_data(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.reward_data.is_none() {
                self.reward_data = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.reward_data.as_mut().unwrap()
        }

        // Take field
        pub fn take_reward_data(&mut self) -> ::std::vec::Vec<u8> {
            self.reward_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint32 action_id = 5;

        pub fn action_id(&self) -> u32 {
            self.action_id.unwrap_or(0)
        }

        pub fn clear_action_id(&mut self) {
            self.action_id = ::std::option::Option::None;
        }

        pub fn has_action_id(&self) -> bool {
            self.action_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_action_id(&mut self, v: u32) {
            self.action_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for GrantedRewardData {
        const NAME: &'static str = "GrantedRewardData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.grant_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.score_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.reward_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.reward_data = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    40 => {
                        self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.grant_index {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.score_index {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.reward_index {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.reward_data.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(4, &v);
            }
            if let Some(v) = self.action_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.grant_index {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.score_index {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.reward_index {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.reward_data.as_ref() {
                os.write_bytes(4, v)?;
            }
            if let Some(v) = self.action_id {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GrantedRewardData {
            GrantedRewardData::new()
        }

        fn clear(&mut self) {
            self.grant_index = ::std::option::Option::None;
            self.score_index = ::std::option::Option::None;
            self.reward_index = ::std::option::Option::None;
            self.reward_data = ::std::option::Option::None;
            self.action_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GrantedRewardData {
            static instance: GrantedRewardData = GrantedRewardData {
                grant_index: ::std::option::Option::None,
                score_index: ::std::option::Option::None,
                reward_index: ::std::option::Option::None,
                reward_data: ::std::option::Option::None,
                action_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgDOTAClaimEventActionResponse.ResultCode)
    pub enum ResultCode {
        // @@protoc_insertion_point(enum_value:CMsgDOTAClaimEventActionResponse.ResultCode.Success)
        Success = 0,
        // @@protoc_insertion_point(enum_value:CMsgDOTAClaimEventActionResponse.ResultCode.InvalidEvent)
        InvalidEvent = 1,
        // @@protoc_insertion_point(enum_value:CMsgDOTAClaimEventActionResponse.ResultCode.EventNotActive)
        EventNotActive = 2,
        // @@protoc_insertion_point(enum_value:CMsgDOTAClaimEventActionResponse.ResultCode.InvalidAction)
        InvalidAction = 3,
        // @@protoc_insertion_point(enum_value:CMsgDOTAClaimEventActionResponse.ResultCode.ServerError)
        ServerError = 4,
        // @@protoc_insertion_point(enum_value:CMsgDOTAClaimEventActionResponse.ResultCode.InsufficientPoints)
        InsufficientPoints = 5,
        // @@protoc_insertion_point(enum_value:CMsgDOTAClaimEventActionResponse.ResultCode.InsufficentLevel)
        InsufficentLevel = 6,
        // @@protoc_insertion_point(enum_value:CMsgDOTAClaimEventActionResponse.ResultCode.AlreadyClaimed)
        AlreadyClaimed = 7,
        // @@protoc_insertion_point(enum_value:CMsgDOTAClaimEventActionResponse.ResultCode.SDOLockFailure)
        SDOLockFailure = 8,
        // @@protoc_insertion_point(enum_value:CMsgDOTAClaimEventActionResponse.ResultCode.SDOLoadFailure)
        SDOLoadFailure = 9,
        // @@protoc_insertion_point(enum_value:CMsgDOTAClaimEventActionResponse.ResultCode.EventNotOwned)
        EventNotOwned = 10,
        // @@protoc_insertion_point(enum_value:CMsgDOTAClaimEventActionResponse.ResultCode.Timeout)
        Timeout = 11,
        // @@protoc_insertion_point(enum_value:CMsgDOTAClaimEventActionResponse.ResultCode.RequiresPlusSubscription)
        RequiresPlusSubscription = 12,
        // @@protoc_insertion_point(enum_value:CMsgDOTAClaimEventActionResponse.ResultCode.InvalidItem)
        InvalidItem = 13,
        // @@protoc_insertion_point(enum_value:CMsgDOTAClaimEventActionResponse.ResultCode.AsyncRewards)
        AsyncRewards = 14,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for ResultCode {
        const NAME: &'static str = "ResultCode";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ResultCode> {
            match value {
                0 => ::std::option::Option::Some(ResultCode::Success),
                1 => ::std::option::Option::Some(ResultCode::InvalidEvent),
                2 => ::std::option::Option::Some(ResultCode::EventNotActive),
                3 => ::std::option::Option::Some(ResultCode::InvalidAction),
                4 => ::std::option::Option::Some(ResultCode::ServerError),
                5 => ::std::option::Option::Some(ResultCode::InsufficientPoints),
                6 => ::std::option::Option::Some(ResultCode::InsufficentLevel),
                7 => ::std::option::Option::Some(ResultCode::AlreadyClaimed),
                8 => ::std::option::Option::Some(ResultCode::SDOLockFailure),
                9 => ::std::option::Option::Some(ResultCode::SDOLoadFailure),
                10 => ::std::option::Option::Some(ResultCode::EventNotOwned),
                11 => ::std::option::Option::Some(ResultCode::Timeout),
                12 => ::std::option::Option::Some(ResultCode::RequiresPlusSubscription),
                13 => ::std::option::Option::Some(ResultCode::InvalidItem),
                14 => ::std::option::Option::Some(ResultCode::AsyncRewards),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ResultCode> {
            match str {
                "Success" => ::std::option::Option::Some(ResultCode::Success),
                "InvalidEvent" => ::std::option::Option::Some(ResultCode::InvalidEvent),
                "EventNotActive" => ::std::option::Option::Some(ResultCode::EventNotActive),
                "InvalidAction" => ::std::option::Option::Some(ResultCode::InvalidAction),
                "ServerError" => ::std::option::Option::Some(ResultCode::ServerError),
                "InsufficientPoints" => ::std::option::Option::Some(ResultCode::InsufficientPoints),
                "InsufficentLevel" => ::std::option::Option::Some(ResultCode::InsufficentLevel),
                "AlreadyClaimed" => ::std::option::Option::Some(ResultCode::AlreadyClaimed),
                "SDOLockFailure" => ::std::option::Option::Some(ResultCode::SDOLockFailure),
                "SDOLoadFailure" => ::std::option::Option::Some(ResultCode::SDOLoadFailure),
                "EventNotOwned" => ::std::option::Option::Some(ResultCode::EventNotOwned),
                "Timeout" => ::std::option::Option::Some(ResultCode::Timeout),
                "RequiresPlusSubscription" => ::std::option::Option::Some(ResultCode::RequiresPlusSubscription),
                "InvalidItem" => ::std::option::Option::Some(ResultCode::InvalidItem),
                "AsyncRewards" => ::std::option::Option::Some(ResultCode::AsyncRewards),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ResultCode] = &[
            ResultCode::Success,
            ResultCode::InvalidEvent,
            ResultCode::EventNotActive,
            ResultCode::InvalidAction,
            ResultCode::ServerError,
            ResultCode::InsufficientPoints,
            ResultCode::InsufficentLevel,
            ResultCode::AlreadyClaimed,
            ResultCode::SDOLockFailure,
            ResultCode::SDOLoadFailure,
            ResultCode::EventNotOwned,
            ResultCode::Timeout,
            ResultCode::RequiresPlusSubscription,
            ResultCode::InvalidItem,
            ResultCode::AsyncRewards,
        ];
    }

    impl ::std::default::Default for ResultCode {
        fn default() -> Self {
            ResultCode::Success
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCDotaLabsFeedback)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCDotaLabsFeedback {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCDotaLabsFeedback.language)
    pub language: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCDotaLabsFeedback.feedback_item)
    pub feedback_item: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCDotaLabsFeedback.feedback)
    pub feedback: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCDotaLabsFeedback.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCDotaLabsFeedback {
    fn default() -> &'a CMsgClientToGCDotaLabsFeedback {
        <CMsgClientToGCDotaLabsFeedback as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCDotaLabsFeedback {
    pub fn new() -> CMsgClientToGCDotaLabsFeedback {
        ::std::default::Default::default()
    }

    // optional uint32 language = 1;

    pub fn language(&self) -> u32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: u32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional uint32 feedback_item = 2;

    pub fn feedback_item(&self) -> u32 {
        self.feedback_item.unwrap_or(0)
    }

    pub fn clear_feedback_item(&mut self) {
        self.feedback_item = ::std::option::Option::None;
    }

    pub fn has_feedback_item(&self) -> bool {
        self.feedback_item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feedback_item(&mut self, v: u32) {
        self.feedback_item = ::std::option::Option::Some(v);
    }

    // optional string feedback = 3;

    pub fn feedback(&self) -> &str {
        match self.feedback.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_feedback(&mut self) {
        self.feedback = ::std::option::Option::None;
    }

    pub fn has_feedback(&self) -> bool {
        self.feedback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feedback(&mut self, v: ::std::string::String) {
        self.feedback = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feedback(&mut self) -> &mut ::std::string::String {
        if self.feedback.is_none() {
            self.feedback = ::std::option::Option::Some(::std::string::String::new());
        }
        self.feedback.as_mut().unwrap()
    }

    // Take field
    pub fn take_feedback(&mut self) -> ::std::string::String {
        self.feedback.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCDotaLabsFeedback {
    const NAME: &'static str = "CMsgClientToGCDotaLabsFeedback";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.language = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.feedback_item = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.feedback = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.language {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.feedback_item {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.feedback.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.language {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.feedback_item {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.feedback.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCDotaLabsFeedback {
        CMsgClientToGCDotaLabsFeedback::new()
    }

    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.feedback_item = ::std::option::Option::None;
        self.feedback = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCDotaLabsFeedback {
        static instance: CMsgClientToGCDotaLabsFeedback = CMsgClientToGCDotaLabsFeedback {
            language: ::std::option::Option::None,
            feedback_item: ::std::option::Option::None,
            feedback: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCDotaLabsFeedbackResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCDotaLabsFeedbackResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCDotaLabsFeedbackResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcdota_labs_feedback_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCDotaLabsFeedbackResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCDotaLabsFeedbackResponse {
    fn default() -> &'a CMsgClientToGCDotaLabsFeedbackResponse {
        <CMsgClientToGCDotaLabsFeedbackResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCDotaLabsFeedbackResponse {
    pub fn new() -> CMsgClientToGCDotaLabsFeedbackResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCDotaLabsFeedbackResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcdota_labs_feedback_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcdota_labs_feedback_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcdota_labs_feedback_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcdota_labs_feedback_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCDotaLabsFeedbackResponse {
    const NAME: &'static str = "CMsgClientToGCDotaLabsFeedbackResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCDotaLabsFeedbackResponse {
        CMsgClientToGCDotaLabsFeedbackResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCDotaLabsFeedbackResponse {
        static instance: CMsgClientToGCDotaLabsFeedbackResponse = CMsgClientToGCDotaLabsFeedbackResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCDotaLabsFeedbackResponse`
pub mod cmsg_client_to_gcdota_labs_feedback_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCDotaLabsFeedbackResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCDotaLabsFeedbackResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCDotaLabsFeedbackResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCDotaLabsFeedbackResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCDotaLabsFeedbackResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCDotaLabsFeedbackResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCDotaLabsFeedbackResponse.EResponse.k_eNotAllowed)
        k_eNotAllowed = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCDotaLabsFeedbackResponse.EResponse.k_eInvalidItem)
        k_eInvalidItem = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidItem),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNotAllowed" => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                "k_eInvalidItem" => ::std::option::Option::Some(EResponse::k_eInvalidItem),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNotAllowed,
            EResponse::k_eInvalidItem,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CDotaMsg_PredictionResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDotaMsg_PredictionResult {
    // message fields
    // @@protoc_insertion_point(field:CDotaMsg_PredictionResult.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDotaMsg_PredictionResult.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CDotaMsg_PredictionResult.correct)
    pub correct: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDotaMsg_PredictionResult.predictions)
    pub predictions: ::std::vec::Vec<cdota_msg_prediction_result::Prediction>,
    // special fields
    // @@protoc_insertion_point(special_field:CDotaMsg_PredictionResult.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDotaMsg_PredictionResult {
    fn default() -> &'a CDotaMsg_PredictionResult {
        <CDotaMsg_PredictionResult as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDotaMsg_PredictionResult {
    pub fn new() -> CDotaMsg_PredictionResult {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional bool correct = 3;

    pub fn correct(&self) -> bool {
        self.correct.unwrap_or(false)
    }

    pub fn clear_correct(&mut self) {
        self.correct = ::std::option::Option::None;
    }

    pub fn has_correct(&self) -> bool {
        self.correct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_correct(&mut self, v: bool) {
        self.correct = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDotaMsg_PredictionResult {
    const NAME: &'static str = "CDotaMsg_PredictionResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.correct = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.predictions.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.correct {
            my_size += 1 + 1;
        }
        for value in &self.predictions {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.correct {
            os.write_bool(3, v)?;
        }
        for v in &self.predictions {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDotaMsg_PredictionResult {
        CDotaMsg_PredictionResult::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.correct = ::std::option::Option::None;
        self.predictions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDotaMsg_PredictionResult {
        static instance: CDotaMsg_PredictionResult = CDotaMsg_PredictionResult {
            account_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            correct: ::std::option::Option::None,
            predictions: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CDotaMsg_PredictionResult`
pub mod cdota_msg_prediction_result {
    // @@protoc_insertion_point(message:CDotaMsg_PredictionResult.Prediction)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Prediction {
        // message fields
        // @@protoc_insertion_point(field:CDotaMsg_PredictionResult.Prediction.item_def)
        pub item_def: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDotaMsg_PredictionResult.Prediction.num_correct)
        pub num_correct: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDotaMsg_PredictionResult.Prediction.num_fails)
        pub num_fails: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CDotaMsg_PredictionResult.Prediction.result)
        pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<prediction::EResult>>,
        // @@protoc_insertion_point(field:CDotaMsg_PredictionResult.Prediction.granted_item_defs)
        pub granted_item_defs: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CDotaMsg_PredictionResult.Prediction.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Prediction {
        fn default() -> &'a Prediction {
            <Prediction as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Prediction {
        pub fn new() -> Prediction {
            ::std::default::Default::default()
        }

        // optional uint32 item_def = 1;

        pub fn item_def(&self) -> u32 {
            self.item_def.unwrap_or(0)
        }

        pub fn clear_item_def(&mut self) {
            self.item_def = ::std::option::Option::None;
        }

        pub fn has_item_def(&self) -> bool {
            self.item_def.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_def(&mut self, v: u32) {
            self.item_def = ::std::option::Option::Some(v);
        }

        // optional uint32 num_correct = 2;

        pub fn num_correct(&self) -> u32 {
            self.num_correct.unwrap_or(0)
        }

        pub fn clear_num_correct(&mut self) {
            self.num_correct = ::std::option::Option::None;
        }

        pub fn has_num_correct(&self) -> bool {
            self.num_correct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_correct(&mut self, v: u32) {
            self.num_correct = ::std::option::Option::Some(v);
        }

        // optional uint32 num_fails = 3;

        pub fn num_fails(&self) -> u32 {
            self.num_fails.unwrap_or(0)
        }

        pub fn clear_num_fails(&mut self) {
            self.num_fails = ::std::option::Option::None;
        }

        pub fn has_num_fails(&self) -> bool {
            self.num_fails.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_fails(&mut self, v: u32) {
            self.num_fails = ::std::option::Option::Some(v);
        }

        // optional .CDotaMsg_PredictionResult.Prediction.EResult result = 4;

        pub fn result(&self) -> prediction::EResult {
            match self.result {
                Some(e) => e.enum_value_or(prediction::EResult::k_eResult_ItemGranted),
                None => prediction::EResult::k_eResult_ItemGranted,
            }
        }

        pub fn clear_result(&mut self) {
            self.result = ::std::option::Option::None;
        }

        pub fn has_result(&self) -> bool {
            self.result.is_some()
        }

        // Param is passed by value, moved
        pub fn set_result(&mut self, v: prediction::EResult) {
            self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Prediction {
        const NAME: &'static str = "Prediction";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.num_correct = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.num_fails = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    50 => {
                        is.read_repeated_packed_uint32_into(&mut self.granted_item_defs)?;
                    },
                    48 => {
                        self.granted_item_defs.push(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_def {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.num_correct {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.num_fails {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.result {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
            }
            for value in &self.granted_item_defs {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, *value);
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item_def {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.num_correct {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.num_fails {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.result {
                os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            for v in &self.granted_item_defs {
                os.write_uint32(6, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Prediction {
            Prediction::new()
        }

        fn clear(&mut self) {
            self.item_def = ::std::option::Option::None;
            self.num_correct = ::std::option::Option::None;
            self.num_fails = ::std::option::Option::None;
            self.result = ::std::option::Option::None;
            self.granted_item_defs.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Prediction {
            static instance: Prediction = Prediction {
                item_def: ::std::option::Option::None,
                num_correct: ::std::option::Option::None,
                num_fails: ::std::option::Option::None,
                result: ::std::option::Option::None,
                granted_item_defs: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Prediction`
    pub mod prediction {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:CDotaMsg_PredictionResult.Prediction.EResult)
        pub enum EResult {
            // @@protoc_insertion_point(enum_value:CDotaMsg_PredictionResult.Prediction.EResult.k_eResult_ItemGranted)
            k_eResult_ItemGranted = 1,
            // @@protoc_insertion_point(enum_value:CDotaMsg_PredictionResult.Prediction.EResult.k_eResult_Destroyed)
            k_eResult_Destroyed = 2,
        }

        impl ::steam_vent_proto_common::protobuf::Enum for EResult {
            const NAME: &'static str = "EResult";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<EResult> {
                match value {
                    1 => ::std::option::Option::Some(EResult::k_eResult_ItemGranted),
                    2 => ::std::option::Option::Some(EResult::k_eResult_Destroyed),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<EResult> {
                match str {
                    "k_eResult_ItemGranted" => ::std::option::Option::Some(EResult::k_eResult_ItemGranted),
                    "k_eResult_Destroyed" => ::std::option::Option::Some(EResult::k_eResult_Destroyed),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [EResult] = &[
                EResult::k_eResult_ItemGranted,
                EResult::k_eResult_Destroyed,
            ];
        }

        // Note, `Default` is implemented although default value is not 0
        impl ::std::default::Default for EResult {
            fn default() -> Self {
                EResult::k_eResult_ItemGranted
            }
        }

    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESpecialPingValue)
pub enum ESpecialPingValue {
    // @@protoc_insertion_point(enum_value:ESpecialPingValue.k_ESpecialPingValue_NoData)
    k_ESpecialPingValue_NoData = 16382,
    // @@protoc_insertion_point(enum_value:ESpecialPingValue.k_ESpecialPingValue_Failed)
    k_ESpecialPingValue_Failed = 16383,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESpecialPingValue {
    const NAME: &'static str = "ESpecialPingValue";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESpecialPingValue> {
        match value {
            16382 => ::std::option::Option::Some(ESpecialPingValue::k_ESpecialPingValue_NoData),
            16383 => ::std::option::Option::Some(ESpecialPingValue::k_ESpecialPingValue_Failed),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESpecialPingValue> {
        match str {
            "k_ESpecialPingValue_NoData" => ::std::option::Option::Some(ESpecialPingValue::k_ESpecialPingValue_NoData),
            "k_ESpecialPingValue_Failed" => ::std::option::Option::Some(ESpecialPingValue::k_ESpecialPingValue_Failed),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESpecialPingValue] = &[
        ESpecialPingValue::k_ESpecialPingValue_NoData,
        ESpecialPingValue::k_ESpecialPingValue_Failed,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ESpecialPingValue {
    fn default() -> Self {
        ESpecialPingValue::k_ESpecialPingValue_NoData
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EDOTAGCSessionNeed)
pub enum EDOTAGCSessionNeed {
    // @@protoc_insertion_point(enum_value:EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_Unknown)
    k_EDOTAGCSessionNeed_Unknown = 0,
    // @@protoc_insertion_point(enum_value:EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserNoSessionNeeded)
    k_EDOTAGCSessionNeed_UserNoSessionNeeded = 100,
    // @@protoc_insertion_point(enum_value:EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInOnlineGame)
    k_EDOTAGCSessionNeed_UserInOnlineGame = 101,
    // @@protoc_insertion_point(enum_value:EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInLocalGame)
    k_EDOTAGCSessionNeed_UserInLocalGame = 102,
    // @@protoc_insertion_point(enum_value:EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUIWasConnected)
    k_EDOTAGCSessionNeed_UserInUIWasConnected = 103,
    // @@protoc_insertion_point(enum_value:EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUINeverConnected)
    k_EDOTAGCSessionNeed_UserInUINeverConnected = 104,
    // @@protoc_insertion_point(enum_value:EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserTutorials)
    k_EDOTAGCSessionNeed_UserTutorials = 105,
    // @@protoc_insertion_point(enum_value:EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle)
    k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle = 106,
    // @@protoc_insertion_point(enum_value:EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle)
    k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle = 107,
    // @@protoc_insertion_point(enum_value:EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerOnline)
    k_EDOTAGCSessionNeed_GameServerOnline = 200,
    // @@protoc_insertion_point(enum_value:EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerLocal)
    k_EDOTAGCSessionNeed_GameServerLocal = 201,
    // @@protoc_insertion_point(enum_value:EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerIdle)
    k_EDOTAGCSessionNeed_GameServerIdle = 202,
    // @@protoc_insertion_point(enum_value:EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerRelay)
    k_EDOTAGCSessionNeed_GameServerRelay = 203,
    // @@protoc_insertion_point(enum_value:EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerLocalUpload)
    k_EDOTAGCSessionNeed_GameServerLocalUpload = 204,
}

impl ::steam_vent_proto_common::protobuf::Enum for EDOTAGCSessionNeed {
    const NAME: &'static str = "EDOTAGCSessionNeed";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDOTAGCSessionNeed> {
        match value {
            0 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_Unknown),
            100 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserNoSessionNeeded),
            101 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInOnlineGame),
            102 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInLocalGame),
            103 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUIWasConnected),
            104 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUINeverConnected),
            105 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserTutorials),
            106 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle),
            107 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle),
            200 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerOnline),
            201 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerLocal),
            202 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerIdle),
            203 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerRelay),
            204 => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerLocalUpload),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDOTAGCSessionNeed> {
        match str {
            "k_EDOTAGCSessionNeed_Unknown" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_Unknown),
            "k_EDOTAGCSessionNeed_UserNoSessionNeeded" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserNoSessionNeeded),
            "k_EDOTAGCSessionNeed_UserInOnlineGame" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInOnlineGame),
            "k_EDOTAGCSessionNeed_UserInLocalGame" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInLocalGame),
            "k_EDOTAGCSessionNeed_UserInUIWasConnected" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUIWasConnected),
            "k_EDOTAGCSessionNeed_UserInUINeverConnected" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUINeverConnected),
            "k_EDOTAGCSessionNeed_UserTutorials" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserTutorials),
            "k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle),
            "k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle),
            "k_EDOTAGCSessionNeed_GameServerOnline" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerOnline),
            "k_EDOTAGCSessionNeed_GameServerLocal" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerLocal),
            "k_EDOTAGCSessionNeed_GameServerIdle" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerIdle),
            "k_EDOTAGCSessionNeed_GameServerRelay" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerRelay),
            "k_EDOTAGCSessionNeed_GameServerLocalUpload" => ::std::option::Option::Some(EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerLocalUpload),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDOTAGCSessionNeed] = &[
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_Unknown,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserNoSessionNeeded,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInOnlineGame,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInLocalGame,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUIWasConnected,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUINeverConnected,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserTutorials,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerOnline,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerLocal,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerIdle,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerRelay,
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_GameServerLocalUpload,
    ];
}

impl ::std::default::Default for EDOTAGCSessionNeed {
    fn default() -> Self {
        EDOTAGCSessionNeed::k_EDOTAGCSessionNeed_Unknown
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EDOTAMatchPlayerTimeCustomStat)
pub enum EDOTAMatchPlayerTimeCustomStat {
    // @@protoc_insertion_point(enum_value:EDOTAMatchPlayerTimeCustomStat.k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers)
    k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers = 1,
    // @@protoc_insertion_point(enum_value:EDOTAMatchPlayerTimeCustomStat.k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute)
    k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute = 2,
    // @@protoc_insertion_point(enum_value:EDOTAMatchPlayerTimeCustomStat.k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP)
    k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for EDOTAMatchPlayerTimeCustomStat {
    const NAME: &'static str = "EDOTAMatchPlayerTimeCustomStat";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDOTAMatchPlayerTimeCustomStat> {
        match value {
            1 => ::std::option::Option::Some(EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers),
            2 => ::std::option::Option::Some(EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute),
            3 => ::std::option::Option::Some(EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDOTAMatchPlayerTimeCustomStat> {
        match str {
            "k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers" => ::std::option::Option::Some(EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers),
            "k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute" => ::std::option::Option::Some(EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute),
            "k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP" => ::std::option::Option::Some(EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDOTAMatchPlayerTimeCustomStat] = &[
        EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers,
        EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute,
        EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EDOTAMatchPlayerTimeCustomStat {
    fn default() -> Self {
        EDOTAMatchPlayerTimeCustomStat::k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTA_TournamentEvents)
pub enum DOTA_TournamentEvents {
    // @@protoc_insertion_point(enum_value:DOTA_TournamentEvents.TE_FIRST_BLOOD)
    TE_FIRST_BLOOD = 0,
    // @@protoc_insertion_point(enum_value:DOTA_TournamentEvents.TE_GAME_END)
    TE_GAME_END = 1,
    // @@protoc_insertion_point(enum_value:DOTA_TournamentEvents.TE_MULTI_KILL)
    TE_MULTI_KILL = 2,
    // @@protoc_insertion_point(enum_value:DOTA_TournamentEvents.TE_HERO_DENY)
    TE_HERO_DENY = 3,
    // @@protoc_insertion_point(enum_value:DOTA_TournamentEvents.TE_AEGIS_DENY)
    TE_AEGIS_DENY = 4,
    // @@protoc_insertion_point(enum_value:DOTA_TournamentEvents.TE_AEGIS_STOLEN)
    TE_AEGIS_STOLEN = 5,
    // @@protoc_insertion_point(enum_value:DOTA_TournamentEvents.TE_GODLIKE)
    TE_GODLIKE = 6,
    // @@protoc_insertion_point(enum_value:DOTA_TournamentEvents.TE_COURIER_KILL)
    TE_COURIER_KILL = 7,
    // @@protoc_insertion_point(enum_value:DOTA_TournamentEvents.TE_ECHOSLAM)
    TE_ECHOSLAM = 8,
    // @@protoc_insertion_point(enum_value:DOTA_TournamentEvents.TE_RAPIER)
    TE_RAPIER = 9,
    // @@protoc_insertion_point(enum_value:DOTA_TournamentEvents.TE_EARLY_ROSHAN)
    TE_EARLY_ROSHAN = 10,
    // @@protoc_insertion_point(enum_value:DOTA_TournamentEvents.TE_BLACK_HOLE)
    TE_BLACK_HOLE = 11,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTA_TournamentEvents {
    const NAME: &'static str = "DOTA_TournamentEvents";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_TournamentEvents> {
        match value {
            0 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_FIRST_BLOOD),
            1 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_GAME_END),
            2 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_MULTI_KILL),
            3 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_HERO_DENY),
            4 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_AEGIS_DENY),
            5 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_AEGIS_STOLEN),
            6 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_GODLIKE),
            7 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_COURIER_KILL),
            8 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_ECHOSLAM),
            9 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_RAPIER),
            10 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_EARLY_ROSHAN),
            11 => ::std::option::Option::Some(DOTA_TournamentEvents::TE_BLACK_HOLE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_TournamentEvents> {
        match str {
            "TE_FIRST_BLOOD" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_FIRST_BLOOD),
            "TE_GAME_END" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_GAME_END),
            "TE_MULTI_KILL" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_MULTI_KILL),
            "TE_HERO_DENY" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_HERO_DENY),
            "TE_AEGIS_DENY" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_AEGIS_DENY),
            "TE_AEGIS_STOLEN" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_AEGIS_STOLEN),
            "TE_GODLIKE" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_GODLIKE),
            "TE_COURIER_KILL" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_COURIER_KILL),
            "TE_ECHOSLAM" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_ECHOSLAM),
            "TE_RAPIER" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_RAPIER),
            "TE_EARLY_ROSHAN" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_EARLY_ROSHAN),
            "TE_BLACK_HOLE" => ::std::option::Option::Some(DOTA_TournamentEvents::TE_BLACK_HOLE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_TournamentEvents] = &[
        DOTA_TournamentEvents::TE_FIRST_BLOOD,
        DOTA_TournamentEvents::TE_GAME_END,
        DOTA_TournamentEvents::TE_MULTI_KILL,
        DOTA_TournamentEvents::TE_HERO_DENY,
        DOTA_TournamentEvents::TE_AEGIS_DENY,
        DOTA_TournamentEvents::TE_AEGIS_STOLEN,
        DOTA_TournamentEvents::TE_GODLIKE,
        DOTA_TournamentEvents::TE_COURIER_KILL,
        DOTA_TournamentEvents::TE_ECHOSLAM,
        DOTA_TournamentEvents::TE_RAPIER,
        DOTA_TournamentEvents::TE_EARLY_ROSHAN,
        DOTA_TournamentEvents::TE_BLACK_HOLE,
    ];
}

impl ::std::default::Default for DOTA_TournamentEvents {
    fn default() -> Self {
        DOTA_TournamentEvents::TE_FIRST_BLOOD
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBroadcastTimelineEvent)
pub enum EBroadcastTimelineEvent {
    // @@protoc_insertion_point(enum_value:EBroadcastTimelineEvent.EBroadcastTimelineEvent_MatchStarted)
    EBroadcastTimelineEvent_MatchStarted = 1,
    // @@protoc_insertion_point(enum_value:EBroadcastTimelineEvent.EBroadcastTimelineEvent_GameStateChanged)
    EBroadcastTimelineEvent_GameStateChanged = 2,
    // @@protoc_insertion_point(enum_value:EBroadcastTimelineEvent.EBroadcastTimelineEvent_TowerDeath)
    EBroadcastTimelineEvent_TowerDeath = 3,
    // @@protoc_insertion_point(enum_value:EBroadcastTimelineEvent.EBroadcastTimelineEvent_BarracksDeath)
    EBroadcastTimelineEvent_BarracksDeath = 4,
    // @@protoc_insertion_point(enum_value:EBroadcastTimelineEvent.EBroadcastTimelineEvent_AncientDeath)
    EBroadcastTimelineEvent_AncientDeath = 5,
    // @@protoc_insertion_point(enum_value:EBroadcastTimelineEvent.EBroadcastTimelineEvent_RoshanDeath)
    EBroadcastTimelineEvent_RoshanDeath = 6,
    // @@protoc_insertion_point(enum_value:EBroadcastTimelineEvent.EBroadcastTimelineEvent_HeroDeath)
    EBroadcastTimelineEvent_HeroDeath = 7,
    // @@protoc_insertion_point(enum_value:EBroadcastTimelineEvent.EBroadcastTimelineEvent_TeamFight)
    EBroadcastTimelineEvent_TeamFight = 8,
    // @@protoc_insertion_point(enum_value:EBroadcastTimelineEvent.EBroadcastTimelineEvent_FirstBlood)
    EBroadcastTimelineEvent_FirstBlood = 9,
}

impl ::steam_vent_proto_common::protobuf::Enum for EBroadcastTimelineEvent {
    const NAME: &'static str = "EBroadcastTimelineEvent";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBroadcastTimelineEvent> {
        match value {
            1 => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_MatchStarted),
            2 => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_GameStateChanged),
            3 => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_TowerDeath),
            4 => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_BarracksDeath),
            5 => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_AncientDeath),
            6 => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_RoshanDeath),
            7 => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_HeroDeath),
            8 => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_TeamFight),
            9 => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_FirstBlood),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBroadcastTimelineEvent> {
        match str {
            "EBroadcastTimelineEvent_MatchStarted" => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_MatchStarted),
            "EBroadcastTimelineEvent_GameStateChanged" => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_GameStateChanged),
            "EBroadcastTimelineEvent_TowerDeath" => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_TowerDeath),
            "EBroadcastTimelineEvent_BarracksDeath" => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_BarracksDeath),
            "EBroadcastTimelineEvent_AncientDeath" => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_AncientDeath),
            "EBroadcastTimelineEvent_RoshanDeath" => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_RoshanDeath),
            "EBroadcastTimelineEvent_HeroDeath" => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_HeroDeath),
            "EBroadcastTimelineEvent_TeamFight" => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_TeamFight),
            "EBroadcastTimelineEvent_FirstBlood" => ::std::option::Option::Some(EBroadcastTimelineEvent::EBroadcastTimelineEvent_FirstBlood),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBroadcastTimelineEvent] = &[
        EBroadcastTimelineEvent::EBroadcastTimelineEvent_MatchStarted,
        EBroadcastTimelineEvent::EBroadcastTimelineEvent_GameStateChanged,
        EBroadcastTimelineEvent::EBroadcastTimelineEvent_TowerDeath,
        EBroadcastTimelineEvent::EBroadcastTimelineEvent_BarracksDeath,
        EBroadcastTimelineEvent::EBroadcastTimelineEvent_AncientDeath,
        EBroadcastTimelineEvent::EBroadcastTimelineEvent_RoshanDeath,
        EBroadcastTimelineEvent::EBroadcastTimelineEvent_HeroDeath,
        EBroadcastTimelineEvent::EBroadcastTimelineEvent_TeamFight,
        EBroadcastTimelineEvent::EBroadcastTimelineEvent_FirstBlood,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EBroadcastTimelineEvent {
    fn default() -> Self {
        EBroadcastTimelineEvent::EBroadcastTimelineEvent_MatchStarted
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECustomGameWhitelistState)
pub enum ECustomGameWhitelistState {
    // @@protoc_insertion_point(enum_value:ECustomGameWhitelistState.CUSTOM_GAME_WHITELIST_STATE_UNKNOWN)
    CUSTOM_GAME_WHITELIST_STATE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:ECustomGameWhitelistState.CUSTOM_GAME_WHITELIST_STATE_APPROVED)
    CUSTOM_GAME_WHITELIST_STATE_APPROVED = 1,
    // @@protoc_insertion_point(enum_value:ECustomGameWhitelistState.CUSTOM_GAME_WHITELIST_STATE_REJECTED)
    CUSTOM_GAME_WHITELIST_STATE_REJECTED = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for ECustomGameWhitelistState {
    const NAME: &'static str = "ECustomGameWhitelistState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECustomGameWhitelistState> {
        match value {
            0 => ::std::option::Option::Some(ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_UNKNOWN),
            1 => ::std::option::Option::Some(ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_APPROVED),
            2 => ::std::option::Option::Some(ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_REJECTED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECustomGameWhitelistState> {
        match str {
            "CUSTOM_GAME_WHITELIST_STATE_UNKNOWN" => ::std::option::Option::Some(ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_UNKNOWN),
            "CUSTOM_GAME_WHITELIST_STATE_APPROVED" => ::std::option::Option::Some(ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_APPROVED),
            "CUSTOM_GAME_WHITELIST_STATE_REJECTED" => ::std::option::Option::Some(ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_REJECTED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECustomGameWhitelistState] = &[
        ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_UNKNOWN,
        ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_APPROVED,
        ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_REJECTED,
    ];
}

impl ::std::default::Default for ECustomGameWhitelistState {
    fn default() -> Self {
        ECustomGameWhitelistState::CUSTOM_GAME_WHITELIST_STATE_UNKNOWN
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EDOTATriviaQuestionCategory)
pub enum EDOTATriviaQuestionCategory {
    // @@protoc_insertion_point(enum_value:EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityIcon)
    k_EDOTATriviaQuestionCategory_AbilityIcon = 0,
    // @@protoc_insertion_point(enum_value:EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityCooldown)
    k_EDOTATriviaQuestionCategory_AbilityCooldown = 1,
    // @@protoc_insertion_point(enum_value:EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroAttributes)
    k_EDOTATriviaQuestionCategory_HeroAttributes = 2,
    // @@protoc_insertion_point(enum_value:EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroMovementSpeed)
    k_EDOTATriviaQuestionCategory_HeroMovementSpeed = 3,
    // @@protoc_insertion_point(enum_value:EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_TalentTree)
    k_EDOTATriviaQuestionCategory_TalentTree = 4,
    // @@protoc_insertion_point(enum_value:EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroStats)
    k_EDOTATriviaQuestionCategory_HeroStats = 5,
    // @@protoc_insertion_point(enum_value:EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemPrice)
    k_EDOTATriviaQuestionCategory_ItemPrice = 6,
    // @@protoc_insertion_point(enum_value:EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilitySound)
    k_EDOTATriviaQuestionCategory_AbilitySound = 7,
    // @@protoc_insertion_point(enum_value:EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_InvokerSpells)
    k_EDOTATriviaQuestionCategory_InvokerSpells = 8,
    // @@protoc_insertion_point(enum_value:EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityManaCost)
    k_EDOTATriviaQuestionCategory_AbilityManaCost = 9,
    // @@protoc_insertion_point(enum_value:EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroAttackSound)
    k_EDOTATriviaQuestionCategory_HeroAttackSound = 10,
    // @@protoc_insertion_point(enum_value:EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityName)
    k_EDOTATriviaQuestionCategory_AbilityName = 11,
    // @@protoc_insertion_point(enum_value:EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemComponents)
    k_EDOTATriviaQuestionCategory_ItemComponents = 12,
    // @@protoc_insertion_point(enum_value:EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemLore)
    k_EDOTATriviaQuestionCategory_ItemLore = 13,
    // @@protoc_insertion_point(enum_value:EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemPassives)
    k_EDOTATriviaQuestionCategory_ItemPassives = 14,
    // @@protoc_insertion_point(enum_value:EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END)
    k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END = 15,
    // @@protoc_insertion_point(enum_value:EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START)
    k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START = 99,
    // @@protoc_insertion_point(enum_value:EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild)
    k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild = 100,
}

impl ::steam_vent_proto_common::protobuf::Enum for EDOTATriviaQuestionCategory {
    const NAME: &'static str = "EDOTATriviaQuestionCategory";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDOTATriviaQuestionCategory> {
        match value {
            0 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityIcon),
            1 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityCooldown),
            2 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroAttributes),
            3 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroMovementSpeed),
            4 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_TalentTree),
            5 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroStats),
            6 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemPrice),
            7 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilitySound),
            8 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_InvokerSpells),
            9 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityManaCost),
            10 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroAttackSound),
            11 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityName),
            12 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemComponents),
            13 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemLore),
            14 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemPassives),
            15 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END),
            99 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START),
            100 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDOTATriviaQuestionCategory> {
        match str {
            "k_EDOTATriviaQuestionCategory_AbilityIcon" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityIcon),
            "k_EDOTATriviaQuestionCategory_AbilityCooldown" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityCooldown),
            "k_EDOTATriviaQuestionCategory_HeroAttributes" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroAttributes),
            "k_EDOTATriviaQuestionCategory_HeroMovementSpeed" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroMovementSpeed),
            "k_EDOTATriviaQuestionCategory_TalentTree" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_TalentTree),
            "k_EDOTATriviaQuestionCategory_HeroStats" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroStats),
            "k_EDOTATriviaQuestionCategory_ItemPrice" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemPrice),
            "k_EDOTATriviaQuestionCategory_AbilitySound" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilitySound),
            "k_EDOTATriviaQuestionCategory_InvokerSpells" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_InvokerSpells),
            "k_EDOTATriviaQuestionCategory_AbilityManaCost" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityManaCost),
            "k_EDOTATriviaQuestionCategory_HeroAttackSound" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroAttackSound),
            "k_EDOTATriviaQuestionCategory_AbilityName" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityName),
            "k_EDOTATriviaQuestionCategory_ItemComponents" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemComponents),
            "k_EDOTATriviaQuestionCategory_ItemLore" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemLore),
            "k_EDOTATriviaQuestionCategory_ItemPassives" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemPassives),
            "k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END),
            "k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START),
            "k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild" => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDOTATriviaQuestionCategory] = &[
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityIcon,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityCooldown,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroAttributes,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroMovementSpeed,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_TalentTree,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroStats,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemPrice,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilitySound,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_InvokerSpells,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityManaCost,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroAttackSound,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityName,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemComponents,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemLore,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemPassives,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START,
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild,
    ];
}

impl ::std::default::Default for EDOTATriviaQuestionCategory {
    fn default() -> Self {
        EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityIcon
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EOverwatchConviction)
pub enum EOverwatchConviction {
    // @@protoc_insertion_point(enum_value:EOverwatchConviction.k_EOverwatchConviction_None)
    k_EOverwatchConviction_None = 0,
    // @@protoc_insertion_point(enum_value:EOverwatchConviction.k_EOverwatchConviction_NotGuilty)
    k_EOverwatchConviction_NotGuilty = 1,
    // @@protoc_insertion_point(enum_value:EOverwatchConviction.k_EOverwatchConviction_GuiltUnclear)
    k_EOverwatchConviction_GuiltUnclear = 2,
    // @@protoc_insertion_point(enum_value:EOverwatchConviction.k_EOverwatchConviction_Guilty)
    k_EOverwatchConviction_Guilty = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for EOverwatchConviction {
    const NAME: &'static str = "EOverwatchConviction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EOverwatchConviction> {
        match value {
            0 => ::std::option::Option::Some(EOverwatchConviction::k_EOverwatchConviction_None),
            1 => ::std::option::Option::Some(EOverwatchConviction::k_EOverwatchConviction_NotGuilty),
            2 => ::std::option::Option::Some(EOverwatchConviction::k_EOverwatchConviction_GuiltUnclear),
            3 => ::std::option::Option::Some(EOverwatchConviction::k_EOverwatchConviction_Guilty),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EOverwatchConviction> {
        match str {
            "k_EOverwatchConviction_None" => ::std::option::Option::Some(EOverwatchConviction::k_EOverwatchConviction_None),
            "k_EOverwatchConviction_NotGuilty" => ::std::option::Option::Some(EOverwatchConviction::k_EOverwatchConviction_NotGuilty),
            "k_EOverwatchConviction_GuiltUnclear" => ::std::option::Option::Some(EOverwatchConviction::k_EOverwatchConviction_GuiltUnclear),
            "k_EOverwatchConviction_Guilty" => ::std::option::Option::Some(EOverwatchConviction::k_EOverwatchConviction_Guilty),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EOverwatchConviction] = &[
        EOverwatchConviction::k_EOverwatchConviction_None,
        EOverwatchConviction::k_EOverwatchConviction_NotGuilty,
        EOverwatchConviction::k_EOverwatchConviction_GuiltUnclear,
        EOverwatchConviction::k_EOverwatchConviction_Guilty,
    ];
}

impl ::std::default::Default for EOverwatchConviction {
    fn default() -> Self {
        EOverwatchConviction::k_EOverwatchConviction_None
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EHeroRelicRarity)
pub enum EHeroRelicRarity {
    // @@protoc_insertion_point(enum_value:EHeroRelicRarity.HERO_RELIC_RARITY_INVALID)
    HERO_RELIC_RARITY_INVALID = -1,
    // @@protoc_insertion_point(enum_value:EHeroRelicRarity.HERO_RELIC_RARITY_COMMON)
    HERO_RELIC_RARITY_COMMON = 0,
    // @@protoc_insertion_point(enum_value:EHeroRelicRarity.HERO_RELIC_RARITY_RARE)
    HERO_RELIC_RARITY_RARE = 1,
}

impl ::steam_vent_proto_common::protobuf::Enum for EHeroRelicRarity {
    const NAME: &'static str = "EHeroRelicRarity";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EHeroRelicRarity> {
        match value {
            -1 => ::std::option::Option::Some(EHeroRelicRarity::HERO_RELIC_RARITY_INVALID),
            0 => ::std::option::Option::Some(EHeroRelicRarity::HERO_RELIC_RARITY_COMMON),
            1 => ::std::option::Option::Some(EHeroRelicRarity::HERO_RELIC_RARITY_RARE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EHeroRelicRarity> {
        match str {
            "HERO_RELIC_RARITY_INVALID" => ::std::option::Option::Some(EHeroRelicRarity::HERO_RELIC_RARITY_INVALID),
            "HERO_RELIC_RARITY_COMMON" => ::std::option::Option::Some(EHeroRelicRarity::HERO_RELIC_RARITY_COMMON),
            "HERO_RELIC_RARITY_RARE" => ::std::option::Option::Some(EHeroRelicRarity::HERO_RELIC_RARITY_RARE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EHeroRelicRarity] = &[
        EHeroRelicRarity::HERO_RELIC_RARITY_INVALID,
        EHeroRelicRarity::HERO_RELIC_RARITY_COMMON,
        EHeroRelicRarity::HERO_RELIC_RARITY_RARE,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EHeroRelicRarity {
    fn default() -> Self {
        EHeroRelicRarity::HERO_RELIC_RARITY_INVALID
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStickerbookAuditAction)
pub enum EStickerbookAuditAction {
    // @@protoc_insertion_point(enum_value:EStickerbookAuditAction.STICKERBOOK_AUDIT_CREATE_PAGE)
    STICKERBOOK_AUDIT_CREATE_PAGE = 0,
    // @@protoc_insertion_point(enum_value:EStickerbookAuditAction.STICKERBOOK_AUDIT_DELETE_PAGE)
    STICKERBOOK_AUDIT_DELETE_PAGE = 1,
    // @@protoc_insertion_point(enum_value:EStickerbookAuditAction.STICKERBOOK_AUDIT_STICK_STICKERS)
    STICKERBOOK_AUDIT_STICK_STICKERS = 2,
    // @@protoc_insertion_point(enum_value:EStickerbookAuditAction.STICKERBOOK_AUDIT_REPLACE_STICKERS)
    STICKERBOOK_AUDIT_REPLACE_STICKERS = 3,
    // @@protoc_insertion_point(enum_value:EStickerbookAuditAction.STICKERBOOK_AUDIT_HERO_STICKER)
    STICKERBOOK_AUDIT_HERO_STICKER = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for EStickerbookAuditAction {
    const NAME: &'static str = "EStickerbookAuditAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStickerbookAuditAction> {
        match value {
            0 => ::std::option::Option::Some(EStickerbookAuditAction::STICKERBOOK_AUDIT_CREATE_PAGE),
            1 => ::std::option::Option::Some(EStickerbookAuditAction::STICKERBOOK_AUDIT_DELETE_PAGE),
            2 => ::std::option::Option::Some(EStickerbookAuditAction::STICKERBOOK_AUDIT_STICK_STICKERS),
            3 => ::std::option::Option::Some(EStickerbookAuditAction::STICKERBOOK_AUDIT_REPLACE_STICKERS),
            4 => ::std::option::Option::Some(EStickerbookAuditAction::STICKERBOOK_AUDIT_HERO_STICKER),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStickerbookAuditAction> {
        match str {
            "STICKERBOOK_AUDIT_CREATE_PAGE" => ::std::option::Option::Some(EStickerbookAuditAction::STICKERBOOK_AUDIT_CREATE_PAGE),
            "STICKERBOOK_AUDIT_DELETE_PAGE" => ::std::option::Option::Some(EStickerbookAuditAction::STICKERBOOK_AUDIT_DELETE_PAGE),
            "STICKERBOOK_AUDIT_STICK_STICKERS" => ::std::option::Option::Some(EStickerbookAuditAction::STICKERBOOK_AUDIT_STICK_STICKERS),
            "STICKERBOOK_AUDIT_REPLACE_STICKERS" => ::std::option::Option::Some(EStickerbookAuditAction::STICKERBOOK_AUDIT_REPLACE_STICKERS),
            "STICKERBOOK_AUDIT_HERO_STICKER" => ::std::option::Option::Some(EStickerbookAuditAction::STICKERBOOK_AUDIT_HERO_STICKER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStickerbookAuditAction] = &[
        EStickerbookAuditAction::STICKERBOOK_AUDIT_CREATE_PAGE,
        EStickerbookAuditAction::STICKERBOOK_AUDIT_DELETE_PAGE,
        EStickerbookAuditAction::STICKERBOOK_AUDIT_STICK_STICKERS,
        EStickerbookAuditAction::STICKERBOOK_AUDIT_REPLACE_STICKERS,
        EStickerbookAuditAction::STICKERBOOK_AUDIT_HERO_STICKER,
    ];
}

impl ::std::default::Default for EStickerbookAuditAction {
    fn default() -> Self {
        EStickerbookAuditAction::STICKERBOOK_AUDIT_CREATE_PAGE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStickerbookPageType)
pub enum EStickerbookPageType {
    // @@protoc_insertion_point(enum_value:EStickerbookPageType.STICKER_PAGE_GENERIC)
    STICKER_PAGE_GENERIC = 0,
    // @@protoc_insertion_point(enum_value:EStickerbookPageType.STICKER_PAGE_TEAM)
    STICKER_PAGE_TEAM = 1,
    // @@protoc_insertion_point(enum_value:EStickerbookPageType.STICKER_PAGE_TALENT)
    STICKER_PAGE_TALENT = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for EStickerbookPageType {
    const NAME: &'static str = "EStickerbookPageType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStickerbookPageType> {
        match value {
            0 => ::std::option::Option::Some(EStickerbookPageType::STICKER_PAGE_GENERIC),
            1 => ::std::option::Option::Some(EStickerbookPageType::STICKER_PAGE_TEAM),
            2 => ::std::option::Option::Some(EStickerbookPageType::STICKER_PAGE_TALENT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStickerbookPageType> {
        match str {
            "STICKER_PAGE_GENERIC" => ::std::option::Option::Some(EStickerbookPageType::STICKER_PAGE_GENERIC),
            "STICKER_PAGE_TEAM" => ::std::option::Option::Some(EStickerbookPageType::STICKER_PAGE_TEAM),
            "STICKER_PAGE_TALENT" => ::std::option::Option::Some(EStickerbookPageType::STICKER_PAGE_TALENT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStickerbookPageType] = &[
        EStickerbookPageType::STICKER_PAGE_GENERIC,
        EStickerbookPageType::STICKER_PAGE_TEAM,
        EStickerbookPageType::STICKER_PAGE_TALENT,
    ];
}

impl ::std::default::Default for EStickerbookPageType {
    fn default() -> Self {
        EStickerbookPageType::STICKER_PAGE_GENERIC
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ENewBloomGiftingResponse)
pub enum ENewBloomGiftingResponse {
    // @@protoc_insertion_point(enum_value:ENewBloomGiftingResponse.kENewBloomGifting_Success)
    kENewBloomGifting_Success = 0,
    // @@protoc_insertion_point(enum_value:ENewBloomGiftingResponse.kENewBloomGifting_UnknownFailure)
    kENewBloomGifting_UnknownFailure = 1,
    // @@protoc_insertion_point(enum_value:ENewBloomGiftingResponse.kENewBloomGifting_MalformedRequest)
    kENewBloomGifting_MalformedRequest = 2,
    // @@protoc_insertion_point(enum_value:ENewBloomGiftingResponse.kENewBloomGifting_FeatureDisabled)
    kENewBloomGifting_FeatureDisabled = 3,
    // @@protoc_insertion_point(enum_value:ENewBloomGiftingResponse.kENewBloomGifting_ItemNotFound)
    kENewBloomGifting_ItemNotFound = 4,
    // @@protoc_insertion_point(enum_value:ENewBloomGiftingResponse.kENewBloomGifting_PlayerNotAllowedToGiveGifts)
    kENewBloomGifting_PlayerNotAllowedToGiveGifts = 5,
    // @@protoc_insertion_point(enum_value:ENewBloomGiftingResponse.kENewBloomGifting_TargetNotAllowedToReceiveGifts)
    kENewBloomGifting_TargetNotAllowedToReceiveGifts = 6,
    // @@protoc_insertion_point(enum_value:ENewBloomGiftingResponse.kENewBloomGifting_ServerNotAuthorized)
    kENewBloomGifting_ServerNotAuthorized = 100,
    // @@protoc_insertion_point(enum_value:ENewBloomGiftingResponse.kENewBloomGifting_PlayerNotInLobby)
    kENewBloomGifting_PlayerNotInLobby = 101,
    // @@protoc_insertion_point(enum_value:ENewBloomGiftingResponse.kENewBloomGifting_TargetNotInLobby)
    kENewBloomGifting_TargetNotInLobby = 102,
    // @@protoc_insertion_point(enum_value:ENewBloomGiftingResponse.kENewBloomGifting_LobbyNotEligible)
    kENewBloomGifting_LobbyNotEligible = 103,
    // @@protoc_insertion_point(enum_value:ENewBloomGiftingResponse.kENewBloomGifting_TargetNotFriend)
    kENewBloomGifting_TargetNotFriend = 200,
    // @@protoc_insertion_point(enum_value:ENewBloomGiftingResponse.kENewBloomGifting_TargetFriendDurationTooShort)
    kENewBloomGifting_TargetFriendDurationTooShort = 201,
}

impl ::steam_vent_proto_common::protobuf::Enum for ENewBloomGiftingResponse {
    const NAME: &'static str = "ENewBloomGiftingResponse";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ENewBloomGiftingResponse> {
        match value {
            0 => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_Success),
            1 => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_UnknownFailure),
            2 => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_MalformedRequest),
            3 => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_FeatureDisabled),
            4 => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_ItemNotFound),
            5 => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_PlayerNotAllowedToGiveGifts),
            6 => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_TargetNotAllowedToReceiveGifts),
            100 => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_ServerNotAuthorized),
            101 => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_PlayerNotInLobby),
            102 => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_TargetNotInLobby),
            103 => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_LobbyNotEligible),
            200 => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_TargetNotFriend),
            201 => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_TargetFriendDurationTooShort),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ENewBloomGiftingResponse> {
        match str {
            "kENewBloomGifting_Success" => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_Success),
            "kENewBloomGifting_UnknownFailure" => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_UnknownFailure),
            "kENewBloomGifting_MalformedRequest" => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_MalformedRequest),
            "kENewBloomGifting_FeatureDisabled" => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_FeatureDisabled),
            "kENewBloomGifting_ItemNotFound" => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_ItemNotFound),
            "kENewBloomGifting_PlayerNotAllowedToGiveGifts" => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_PlayerNotAllowedToGiveGifts),
            "kENewBloomGifting_TargetNotAllowedToReceiveGifts" => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_TargetNotAllowedToReceiveGifts),
            "kENewBloomGifting_ServerNotAuthorized" => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_ServerNotAuthorized),
            "kENewBloomGifting_PlayerNotInLobby" => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_PlayerNotInLobby),
            "kENewBloomGifting_TargetNotInLobby" => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_TargetNotInLobby),
            "kENewBloomGifting_LobbyNotEligible" => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_LobbyNotEligible),
            "kENewBloomGifting_TargetNotFriend" => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_TargetNotFriend),
            "kENewBloomGifting_TargetFriendDurationTooShort" => ::std::option::Option::Some(ENewBloomGiftingResponse::kENewBloomGifting_TargetFriendDurationTooShort),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ENewBloomGiftingResponse] = &[
        ENewBloomGiftingResponse::kENewBloomGifting_Success,
        ENewBloomGiftingResponse::kENewBloomGifting_UnknownFailure,
        ENewBloomGiftingResponse::kENewBloomGifting_MalformedRequest,
        ENewBloomGiftingResponse::kENewBloomGifting_FeatureDisabled,
        ENewBloomGiftingResponse::kENewBloomGifting_ItemNotFound,
        ENewBloomGiftingResponse::kENewBloomGifting_PlayerNotAllowedToGiveGifts,
        ENewBloomGiftingResponse::kENewBloomGifting_TargetNotAllowedToReceiveGifts,
        ENewBloomGiftingResponse::kENewBloomGifting_ServerNotAuthorized,
        ENewBloomGiftingResponse::kENewBloomGifting_PlayerNotInLobby,
        ENewBloomGiftingResponse::kENewBloomGifting_TargetNotInLobby,
        ENewBloomGiftingResponse::kENewBloomGifting_LobbyNotEligible,
        ENewBloomGiftingResponse::kENewBloomGifting_TargetNotFriend,
        ENewBloomGiftingResponse::kENewBloomGifting_TargetFriendDurationTooShort,
    ];
}

impl ::std::default::Default for ENewBloomGiftingResponse {
    fn default() -> Self {
        ENewBloomGiftingResponse::kENewBloomGifting_Success
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::steammessages::*;
#[allow(unused_imports)]
use crate::gcsdk_gcmessages::*;
#[allow(unused_imports)]
use crate::dota_shared_enums::*;
impl ::steam_vent_proto_common::RpcMessage for CSODOTAGameAccountClient {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSODOTAGameAccountPlus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSODOTAChatWheel {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLobbyFeaturedGamemodeProgress {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgLobbyFeaturedGamemodeProgress {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgLobbyFeaturedGamemodeProgress;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgBattleCupVictory {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLobbyBattleCupVictoryList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTABroadcastNotification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CProtoItemHeroStatue {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMatchPlayerAbilityUpgrade {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMatchPlayerTimedCustomStat {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMatchPlayerTimedStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMatchTeamTimedStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMatchAdditionalUnitInventory {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMatchPlayerPermanentBuff {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMatchHeroSelectEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMatchClip {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CPartySearchClientParty {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAHasItemQuery {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAHasItemResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCGetPlayerCardItemInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCGetPlayerCardItemInfo {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCGetPlayerCardItemInfo;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCGetPlayerCardItemInfoResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCGetPlayerCardItemInfoResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCGetPlayerCardItemInfoResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CSODOTAMapLocationState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLeagueAdminList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgLeagueAdminList {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCLeagueAdminList;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAProfileCard {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSODOTAPlayerChallenge {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRerollPlayerChallenge {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRerollPlayerChallenge {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRerollPlayerChallenge;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCRerollPlayerChallengeResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCRerollPlayerChallengeResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCRerollPlayerChallengeResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCTopCustomGamesList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCTopCustomGamesList {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCTopCustomGamesList;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTARealtimeGameStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTARealtimeGameStatsTerse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTABroadcastTimelineEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientMatchGroupsVersion {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientMatchGroupsVersion {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientMatchGroupsVersion;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTASDOHeroStatsHistory {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPredictionChoice {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgInGamePrediction {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTASeasonPredictions {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgAvailablePredictions {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLeagueWatchedGames {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAMatch {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPlayerCard {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAFantasyPlayerStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAFantasyPlayerMatchStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTABotDebugInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSuccessfulHero {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgRecentMatchInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgMatchTips {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAMatchMinimal {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgConsumableUsage {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgMatchConsumableUsage {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgMatchEventActionGrants {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgCustomGameWhitelist {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgCustomGameWhitelistForEdit {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPlayerRecentMatchInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPlayerMatchRecord {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPlayerRecentMatchOutcomes {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPlayerRecentCommends {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPlayerRecentAccomplishments {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPlayerHeroRecentAccomplishments {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgRecentAccomplishments {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgServerToGCRequestPlayerRecentAccomplishments {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgServerToGCRequestPlayerRecentAccomplishments {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCRequestPlayerRecentAccomplishments;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCRequestPlayerRecentAccomplishmentsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgArcanaVoteMatchVotes {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCtoGCAssociatedExploiterAccountInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCtoGCAssociatedExploiterAccountInfo {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCtoGCAssociatedExploiterAccountInfo;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCtoGCAssociatedExploiterAccountInfoResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPullTabsData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgUnderDraftData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPlayerTitleData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTATriviaQuestion {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTATriviaQuestionAnswersSummary {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameDataSpecialValueBonus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameDataSpecialValues {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameDataFacetAbilityBonus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameDataAbilityOrItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameDataAbilityOrItemList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameDataHero {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameDataAbilities {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameDataItems {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameDataHeroes {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameDataHeroList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameDataItemAbilityList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLobbyAbilityDraftData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOEconItemDropRateBonus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOEconItemTournamentPassport {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgStickerbookSticker {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgStickerbookPage {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgStickerbookTeamPageOrderSequence {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgStickerbook {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgStickerHero {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgStickerHeroes {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgHeroRoleStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgHeroRoleHeroStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgHeroRoleRankStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgHeroRoleAllRanksStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgMapStatsSnapshot {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGlobalMapStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTrackedStat {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAClaimEventActionResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgDOTAClaimEventActionResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgDOTAClaimEventActionResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCDotaLabsFeedback {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCDotaLabsFeedback {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCDotaLabsFeedback;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCDotaLabsFeedbackResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCDotaLabsFeedbackResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCDotaLabsFeedbackResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CDotaMsg_PredictionResult {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
