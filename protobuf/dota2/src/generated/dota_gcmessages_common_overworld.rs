// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_common_overworld.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CMsgOverworldTokenCount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOverworldTokenCount {
    // message fields
    // @@protoc_insertion_point(field:CMsgOverworldTokenCount.token_id)
    pub token_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgOverworldTokenCount.token_count)
    pub token_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOverworldTokenCount.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOverworldTokenCount {
    fn default() -> &'a CMsgOverworldTokenCount {
        <CMsgOverworldTokenCount as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgOverworldTokenCount {
    pub fn new() -> CMsgOverworldTokenCount {
        ::std::default::Default::default()
    }

    // optional uint32 token_id = 1;

    pub fn token_id(&self) -> u32 {
        self.token_id.unwrap_or(0)
    }

    pub fn clear_token_id(&mut self) {
        self.token_id = ::std::option::Option::None;
    }

    pub fn has_token_id(&self) -> bool {
        self.token_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token_id(&mut self, v: u32) {
        self.token_id = ::std::option::Option::Some(v);
    }

    // optional uint32 token_count = 2;

    pub fn token_count(&self) -> u32 {
        self.token_count.unwrap_or(0)
    }

    pub fn clear_token_count(&mut self) {
        self.token_count = ::std::option::Option::None;
    }

    pub fn has_token_count(&self) -> bool {
        self.token_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token_count(&mut self, v: u32) {
        self.token_count = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgOverworldTokenCount {
    const NAME: &'static str = "CMsgOverworldTokenCount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.token_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.token_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.token_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.token_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.token_count {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOverworldTokenCount {
        CMsgOverworldTokenCount::new()
    }

    fn clear(&mut self) {
        self.token_id = ::std::option::Option::None;
        self.token_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOverworldTokenCount {
        static instance: CMsgOverworldTokenCount = CMsgOverworldTokenCount {
            token_id: ::std::option::Option::None,
            token_count: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgOverworldTokenQuantity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOverworldTokenQuantity {
    // message fields
    // @@protoc_insertion_point(field:CMsgOverworldTokenQuantity.token_counts)
    pub token_counts: ::std::vec::Vec<CMsgOverworldTokenCount>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOverworldTokenQuantity.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOverworldTokenQuantity {
    fn default() -> &'a CMsgOverworldTokenQuantity {
        <CMsgOverworldTokenQuantity as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgOverworldTokenQuantity {
    pub fn new() -> CMsgOverworldTokenQuantity {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgOverworldTokenQuantity {
    const NAME: &'static str = "CMsgOverworldTokenQuantity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.token_counts.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.token_counts {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.token_counts {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOverworldTokenQuantity {
        CMsgOverworldTokenQuantity::new()
    }

    fn clear(&mut self) {
        self.token_counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOverworldTokenQuantity {
        static instance: CMsgOverworldTokenQuantity = CMsgOverworldTokenQuantity {
            token_counts: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgOverworldEncounterTokenTreasureData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOverworldEncounterTokenTreasureData {
    // message fields
    // @@protoc_insertion_point(field:CMsgOverworldEncounterTokenTreasureData.reward_options)
    pub reward_options: ::std::vec::Vec<cmsg_overworld_encounter_token_treasure_data::RewardOption>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOverworldEncounterTokenTreasureData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOverworldEncounterTokenTreasureData {
    fn default() -> &'a CMsgOverworldEncounterTokenTreasureData {
        <CMsgOverworldEncounterTokenTreasureData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgOverworldEncounterTokenTreasureData {
    pub fn new() -> CMsgOverworldEncounterTokenTreasureData {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgOverworldEncounterTokenTreasureData {
    const NAME: &'static str = "CMsgOverworldEncounterTokenTreasureData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.reward_options.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.reward_options {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.reward_options {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOverworldEncounterTokenTreasureData {
        CMsgOverworldEncounterTokenTreasureData::new()
    }

    fn clear(&mut self) {
        self.reward_options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOverworldEncounterTokenTreasureData {
        static instance: CMsgOverworldEncounterTokenTreasureData = CMsgOverworldEncounterTokenTreasureData {
            reward_options: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgOverworldEncounterTokenTreasureData`
pub mod cmsg_overworld_encounter_token_treasure_data {
    // @@protoc_insertion_point(message:CMsgOverworldEncounterTokenTreasureData.RewardOption)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RewardOption {
        // message fields
        // @@protoc_insertion_point(field:CMsgOverworldEncounterTokenTreasureData.RewardOption.reward_data)
        pub reward_data: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgOverworldEncounterTokenTreasureData.RewardOption.token_cost)
        pub token_cost: ::steam_vent_proto_common::protobuf::MessageField<super::CMsgOverworldTokenQuantity>,
        // @@protoc_insertion_point(field:CMsgOverworldEncounterTokenTreasureData.RewardOption.token_reward)
        pub token_reward: ::steam_vent_proto_common::protobuf::MessageField<super::CMsgOverworldTokenQuantity>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgOverworldEncounterTokenTreasureData.RewardOption.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RewardOption {
        fn default() -> &'a RewardOption {
            <RewardOption as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl RewardOption {
        pub fn new() -> RewardOption {
            ::std::default::Default::default()
        }

        // optional uint32 reward_data = 1;

        pub fn reward_data(&self) -> u32 {
            self.reward_data.unwrap_or(0)
        }

        pub fn clear_reward_data(&mut self) {
            self.reward_data = ::std::option::Option::None;
        }

        pub fn has_reward_data(&self) -> bool {
            self.reward_data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reward_data(&mut self, v: u32) {
            self.reward_data = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for RewardOption {
        const NAME: &'static str = "RewardOption";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.reward_data = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.token_cost)?;
                    },
                    26 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.token_reward)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.reward_data {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.token_cost.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.token_reward.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.reward_data {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.token_cost.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.token_reward.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RewardOption {
            RewardOption::new()
        }

        fn clear(&mut self) {
            self.reward_data = ::std::option::Option::None;
            self.token_cost.clear();
            self.token_reward.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RewardOption {
            static instance: RewardOption = RewardOption {
                reward_data: ::std::option::Option::None,
                token_cost: ::steam_vent_proto_common::protobuf::MessageField::none(),
                token_reward: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgOverworldEncounterTokenQuestData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOverworldEncounterTokenQuestData {
    // message fields
    // @@protoc_insertion_point(field:CMsgOverworldEncounterTokenQuestData.quests)
    pub quests: ::std::vec::Vec<cmsg_overworld_encounter_token_quest_data::Quest>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOverworldEncounterTokenQuestData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOverworldEncounterTokenQuestData {
    fn default() -> &'a CMsgOverworldEncounterTokenQuestData {
        <CMsgOverworldEncounterTokenQuestData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgOverworldEncounterTokenQuestData {
    pub fn new() -> CMsgOverworldEncounterTokenQuestData {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgOverworldEncounterTokenQuestData {
    const NAME: &'static str = "CMsgOverworldEncounterTokenQuestData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.quests.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.quests {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.quests {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOverworldEncounterTokenQuestData {
        CMsgOverworldEncounterTokenQuestData::new()
    }

    fn clear(&mut self) {
        self.quests.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOverworldEncounterTokenQuestData {
        static instance: CMsgOverworldEncounterTokenQuestData = CMsgOverworldEncounterTokenQuestData {
            quests: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgOverworldEncounterTokenQuestData`
pub mod cmsg_overworld_encounter_token_quest_data {
    // @@protoc_insertion_point(message:CMsgOverworldEncounterTokenQuestData.Quest)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Quest {
        // message fields
        // @@protoc_insertion_point(field:CMsgOverworldEncounterTokenQuestData.Quest.reward_data)
        pub reward_data: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgOverworldEncounterTokenQuestData.Quest.token_cost)
        pub token_cost: ::steam_vent_proto_common::protobuf::MessageField<super::CMsgOverworldTokenQuantity>,
        // @@protoc_insertion_point(field:CMsgOverworldEncounterTokenQuestData.Quest.token_reward)
        pub token_reward: ::steam_vent_proto_common::protobuf::MessageField<super::CMsgOverworldTokenQuantity>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgOverworldEncounterTokenQuestData.Quest.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Quest {
        fn default() -> &'a Quest {
            <Quest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Quest {
        pub fn new() -> Quest {
            ::std::default::Default::default()
        }

        // optional uint32 reward_data = 1;

        pub fn reward_data(&self) -> u32 {
            self.reward_data.unwrap_or(0)
        }

        pub fn clear_reward_data(&mut self) {
            self.reward_data = ::std::option::Option::None;
        }

        pub fn has_reward_data(&self) -> bool {
            self.reward_data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reward_data(&mut self, v: u32) {
            self.reward_data = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Quest {
        const NAME: &'static str = "Quest";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.reward_data = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.token_cost)?;
                    },
                    26 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.token_reward)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.reward_data {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.token_cost.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.token_reward.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.reward_data {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.token_cost.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.token_reward.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Quest {
            Quest::new()
        }

        fn clear(&mut self) {
            self.reward_data = ::std::option::Option::None;
            self.token_cost.clear();
            self.token_reward.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Quest {
            static instance: Quest = Quest {
                reward_data: ::std::option::Option::None,
                token_cost: ::steam_vent_proto_common::protobuf::MessageField::none(),
                token_reward: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgOverworldHeroList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOverworldHeroList {
    // message fields
    // @@protoc_insertion_point(field:CMsgOverworldHeroList.hero_ids)
    pub hero_ids: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOverworldHeroList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOverworldHeroList {
    fn default() -> &'a CMsgOverworldHeroList {
        <CMsgOverworldHeroList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgOverworldHeroList {
    pub fn new() -> CMsgOverworldHeroList {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgOverworldHeroList {
    const NAME: &'static str = "CMsgOverworldHeroList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.hero_ids)?;
                },
                8 => {
                    self.hero_ids.push(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.hero_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.hero_ids {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOverworldHeroList {
        CMsgOverworldHeroList::new()
    }

    fn clear(&mut self) {
        self.hero_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOverworldHeroList {
        static instance: CMsgOverworldHeroList = CMsgOverworldHeroList {
            hero_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgOverworldEncounterChooseHeroData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOverworldEncounterChooseHeroData {
    // message fields
    // @@protoc_insertion_point(field:CMsgOverworldEncounterChooseHeroData.hero_list)
    pub hero_list: ::steam_vent_proto_common::protobuf::MessageField<CMsgOverworldHeroList>,
    // @@protoc_insertion_point(field:CMsgOverworldEncounterChooseHeroData.additive)
    pub additive: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOverworldEncounterChooseHeroData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOverworldEncounterChooseHeroData {
    fn default() -> &'a CMsgOverworldEncounterChooseHeroData {
        <CMsgOverworldEncounterChooseHeroData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgOverworldEncounterChooseHeroData {
    pub fn new() -> CMsgOverworldEncounterChooseHeroData {
        ::std::default::Default::default()
    }

    // optional bool additive = 2;

    pub fn additive(&self) -> bool {
        self.additive.unwrap_or(false)
    }

    pub fn clear_additive(&mut self) {
        self.additive = ::std::option::Option::None;
    }

    pub fn has_additive(&self) -> bool {
        self.additive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additive(&mut self, v: bool) {
        self.additive = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgOverworldEncounterChooseHeroData {
    const NAME: &'static str = "CMsgOverworldEncounterChooseHeroData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.hero_list)?;
                },
                16 => {
                    self.additive = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.additive {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hero_list.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.additive {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOverworldEncounterChooseHeroData {
        CMsgOverworldEncounterChooseHeroData::new()
    }

    fn clear(&mut self) {
        self.hero_list.clear();
        self.additive = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOverworldEncounterChooseHeroData {
        static instance: CMsgOverworldEncounterChooseHeroData = CMsgOverworldEncounterChooseHeroData {
            hero_list: ::steam_vent_proto_common::protobuf::MessageField::none(),
            additive: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgOverworldEncounterProgressData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOverworldEncounterProgressData {
    // message fields
    // @@protoc_insertion_point(field:CMsgOverworldEncounterProgressData.choice)
    pub choice: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgOverworldEncounterProgressData.progress)
    pub progress: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgOverworldEncounterProgressData.max_progress)
    pub max_progress: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgOverworldEncounterProgressData.visited)
    pub visited: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOverworldEncounterProgressData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOverworldEncounterProgressData {
    fn default() -> &'a CMsgOverworldEncounterProgressData {
        <CMsgOverworldEncounterProgressData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgOverworldEncounterProgressData {
    pub fn new() -> CMsgOverworldEncounterProgressData {
        ::std::default::Default::default()
    }

    // optional int32 choice = 1;

    pub fn choice(&self) -> i32 {
        self.choice.unwrap_or(0)
    }

    pub fn clear_choice(&mut self) {
        self.choice = ::std::option::Option::None;
    }

    pub fn has_choice(&self) -> bool {
        self.choice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_choice(&mut self, v: i32) {
        self.choice = ::std::option::Option::Some(v);
    }

    // optional int32 progress = 2;

    pub fn progress(&self) -> i32 {
        self.progress.unwrap_or(0)
    }

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: i32) {
        self.progress = ::std::option::Option::Some(v);
    }

    // optional int32 max_progress = 3;

    pub fn max_progress(&self) -> i32 {
        self.max_progress.unwrap_or(0)
    }

    pub fn clear_max_progress(&mut self) {
        self.max_progress = ::std::option::Option::None;
    }

    pub fn has_max_progress(&self) -> bool {
        self.max_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_progress(&mut self, v: i32) {
        self.max_progress = ::std::option::Option::Some(v);
    }

    // optional bool visited = 4;

    pub fn visited(&self) -> bool {
        self.visited.unwrap_or(false)
    }

    pub fn clear_visited(&mut self) {
        self.visited = ::std::option::Option::None;
    }

    pub fn has_visited(&self) -> bool {
        self.visited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visited(&mut self, v: bool) {
        self.visited = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgOverworldEncounterProgressData {
    const NAME: &'static str = "CMsgOverworldEncounterProgressData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.choice = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.progress = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.max_progress = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.visited = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.choice {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.progress {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.max_progress {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.visited {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.choice {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.progress {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.max_progress {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.visited {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOverworldEncounterProgressData {
        CMsgOverworldEncounterProgressData::new()
    }

    fn clear(&mut self) {
        self.choice = ::std::option::Option::None;
        self.progress = ::std::option::Option::None;
        self.max_progress = ::std::option::Option::None;
        self.visited = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOverworldEncounterProgressData {
        static instance: CMsgOverworldEncounterProgressData = CMsgOverworldEncounterProgressData {
            choice: ::std::option::Option::None,
            progress: ::std::option::Option::None,
            max_progress: ::std::option::Option::None,
            visited: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgOverworldEncounterData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOverworldEncounterData {
    // message fields
    // @@protoc_insertion_point(field:CMsgOverworldEncounterData.extra_encounter_data)
    pub extra_encounter_data: ::std::vec::Vec<super::gcsdk_gcmessages::CExtraMsgBlock>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOverworldEncounterData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOverworldEncounterData {
    fn default() -> &'a CMsgOverworldEncounterData {
        <CMsgOverworldEncounterData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgOverworldEncounterData {
    pub fn new() -> CMsgOverworldEncounterData {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgOverworldEncounterData {
    const NAME: &'static str = "CMsgOverworldEncounterData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.extra_encounter_data.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.extra_encounter_data {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.extra_encounter_data {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOverworldEncounterData {
        CMsgOverworldEncounterData::new()
    }

    fn clear(&mut self) {
        self.extra_encounter_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOverworldEncounterData {
        static instance: CMsgOverworldEncounterData = CMsgOverworldEncounterData {
            extra_encounter_data: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgOverworldNode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOverworldNode {
    // message fields
    // @@protoc_insertion_point(field:CMsgOverworldNode.node_id)
    pub node_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgOverworldNode.node_state)
    pub node_state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EOverworldNodeState>>,
    // @@protoc_insertion_point(field:CMsgOverworldNode.node_encounter_data)
    pub node_encounter_data: ::steam_vent_proto_common::protobuf::MessageField<CMsgOverworldEncounterData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOverworldNode.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOverworldNode {
    fn default() -> &'a CMsgOverworldNode {
        <CMsgOverworldNode as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgOverworldNode {
    pub fn new() -> CMsgOverworldNode {
        ::std::default::Default::default()
    }

    // optional uint32 node_id = 1;

    pub fn node_id(&self) -> u32 {
        self.node_id.unwrap_or(0)
    }

    pub fn clear_node_id(&mut self) {
        self.node_id = ::std::option::Option::None;
    }

    pub fn has_node_id(&self) -> bool {
        self.node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u32) {
        self.node_id = ::std::option::Option::Some(v);
    }

    // optional .EOverworldNodeState node_state = 2;

    pub fn node_state(&self) -> EOverworldNodeState {
        match self.node_state {
            Some(e) => e.enum_value_or(EOverworldNodeState::k_eOverworldNodeState_Invalid),
            None => EOverworldNodeState::k_eOverworldNodeState_Invalid,
        }
    }

    pub fn clear_node_state(&mut self) {
        self.node_state = ::std::option::Option::None;
    }

    pub fn has_node_state(&self) -> bool {
        self.node_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_state(&mut self, v: EOverworldNodeState) {
        self.node_state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgOverworldNode {
    const NAME: &'static str = "CMsgOverworldNode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.node_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.node_encounter_data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.node_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.node_state {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.node_encounter_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.node_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.node_state {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.node_encounter_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOverworldNode {
        CMsgOverworldNode::new()
    }

    fn clear(&mut self) {
        self.node_id = ::std::option::Option::None;
        self.node_state = ::std::option::Option::None;
        self.node_encounter_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOverworldNode {
        static instance: CMsgOverworldNode = CMsgOverworldNode {
            node_id: ::std::option::Option::None,
            node_state: ::std::option::Option::None,
            node_encounter_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgOverworldPath)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOverworldPath {
    // message fields
    // @@protoc_insertion_point(field:CMsgOverworldPath.path_id)
    pub path_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgOverworldPath.path_cost)
    pub path_cost: ::steam_vent_proto_common::protobuf::MessageField<CMsgOverworldTokenQuantity>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOverworldPath.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOverworldPath {
    fn default() -> &'a CMsgOverworldPath {
        <CMsgOverworldPath as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgOverworldPath {
    pub fn new() -> CMsgOverworldPath {
        ::std::default::Default::default()
    }

    // optional uint32 path_id = 1;

    pub fn path_id(&self) -> u32 {
        self.path_id.unwrap_or(0)
    }

    pub fn clear_path_id(&mut self) {
        self.path_id = ::std::option::Option::None;
    }

    pub fn has_path_id(&self) -> bool {
        self.path_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path_id(&mut self, v: u32) {
        self.path_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgOverworldPath {
    const NAME: &'static str = "CMsgOverworldPath";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.path_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.path_cost)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.path_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.path_cost.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.path_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.path_cost.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOverworldPath {
        CMsgOverworldPath::new()
    }

    fn clear(&mut self) {
        self.path_id = ::std::option::Option::None;
        self.path_cost.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOverworldPath {
        static instance: CMsgOverworldPath = CMsgOverworldPath {
            path_id: ::std::option::Option::None,
            path_cost: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgOverworldUserData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOverworldUserData {
    // message fields
    // @@protoc_insertion_point(field:CMsgOverworldUserData.token_inventory)
    pub token_inventory: ::steam_vent_proto_common::protobuf::MessageField<CMsgOverworldTokenQuantity>,
    // @@protoc_insertion_point(field:CMsgOverworldUserData.overworld_nodes)
    pub overworld_nodes: ::std::vec::Vec<CMsgOverworldNode>,
    // @@protoc_insertion_point(field:CMsgOverworldUserData.overworld_paths)
    pub overworld_paths: ::std::vec::Vec<CMsgOverworldPath>,
    // @@protoc_insertion_point(field:CMsgOverworldUserData.current_node_id)
    pub current_node_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOverworldUserData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOverworldUserData {
    fn default() -> &'a CMsgOverworldUserData {
        <CMsgOverworldUserData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgOverworldUserData {
    pub fn new() -> CMsgOverworldUserData {
        ::std::default::Default::default()
    }

    // optional uint32 current_node_id = 4;

    pub fn current_node_id(&self) -> u32 {
        self.current_node_id.unwrap_or(0)
    }

    pub fn clear_current_node_id(&mut self) {
        self.current_node_id = ::std::option::Option::None;
    }

    pub fn has_current_node_id(&self) -> bool {
        self.current_node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_node_id(&mut self, v: u32) {
        self.current_node_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgOverworldUserData {
    const NAME: &'static str = "CMsgOverworldUserData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.token_inventory)?;
                },
                18 => {
                    self.overworld_nodes.push(is.read_message()?);
                },
                26 => {
                    self.overworld_paths.push(is.read_message()?);
                },
                32 => {
                    self.current_node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token_inventory.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.overworld_nodes {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.overworld_paths {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.current_node_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.token_inventory.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.overworld_nodes {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.overworld_paths {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.current_node_id {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOverworldUserData {
        CMsgOverworldUserData::new()
    }

    fn clear(&mut self) {
        self.token_inventory.clear();
        self.overworld_nodes.clear();
        self.overworld_paths.clear();
        self.current_node_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOverworldUserData {
        static instance: CMsgOverworldUserData = CMsgOverworldUserData {
            token_inventory: ::steam_vent_proto_common::protobuf::MessageField::none(),
            overworld_nodes: ::std::vec::Vec::new(),
            overworld_paths: ::std::vec::Vec::new(),
            current_node_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgOverworldMatchRewards)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOverworldMatchRewards {
    // message fields
    // @@protoc_insertion_point(field:CMsgOverworldMatchRewards.players)
    pub players: ::std::vec::Vec<cmsg_overworld_match_rewards::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOverworldMatchRewards.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOverworldMatchRewards {
    fn default() -> &'a CMsgOverworldMatchRewards {
        <CMsgOverworldMatchRewards as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgOverworldMatchRewards {
    pub fn new() -> CMsgOverworldMatchRewards {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgOverworldMatchRewards {
    const NAME: &'static str = "CMsgOverworldMatchRewards";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOverworldMatchRewards {
        CMsgOverworldMatchRewards::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOverworldMatchRewards {
        static instance: CMsgOverworldMatchRewards = CMsgOverworldMatchRewards {
            players: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgOverworldMatchRewards`
pub mod cmsg_overworld_match_rewards {
    // @@protoc_insertion_point(message:CMsgOverworldMatchRewards.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgOverworldMatchRewards.Player.player_slot)
        pub player_slot: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgOverworldMatchRewards.Player.tokens)
        pub tokens: ::steam_vent_proto_common::protobuf::MessageField<super::CMsgOverworldTokenQuantity>,
        // @@protoc_insertion_point(field:CMsgOverworldMatchRewards.Player.overworld_id)
        pub overworld_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgOverworldMatchRewards.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 player_slot = 1;

        pub fn player_slot(&self) -> u32 {
            self.player_slot.unwrap_or(0)
        }

        pub fn clear_player_slot(&mut self) {
            self.player_slot = ::std::option::Option::None;
        }

        pub fn has_player_slot(&self) -> bool {
            self.player_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_slot(&mut self, v: u32) {
            self.player_slot = ::std::option::Option::Some(v);
        }

        // optional uint32 overworld_id = 3;

        pub fn overworld_id(&self) -> u32 {
            self.overworld_id.unwrap_or(0)
        }

        pub fn clear_overworld_id(&mut self) {
            self.overworld_id = ::std::option::Option::None;
        }

        pub fn has_overworld_id(&self) -> bool {
            self.overworld_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_overworld_id(&mut self, v: u32) {
            self.overworld_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.tokens)?;
                    },
                    24 => {
                        self.overworld_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_slot {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.tokens.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.overworld_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.player_slot {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.tokens.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.overworld_id {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.player_slot = ::std::option::Option::None;
            self.tokens.clear();
            self.overworld_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                player_slot: ::std::option::Option::None,
                tokens: ::steam_vent_proto_common::protobuf::MessageField::none(),
                overworld_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldGetUserData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldGetUserData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldGetUserData.overworld_id)
    pub overworld_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldGetUserData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldGetUserData {
    fn default() -> &'a CMsgClientToGCOverworldGetUserData {
        <CMsgClientToGCOverworldGetUserData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldGetUserData {
    pub fn new() -> CMsgClientToGCOverworldGetUserData {
        ::std::default::Default::default()
    }

    // optional uint32 overworld_id = 1;

    pub fn overworld_id(&self) -> u32 {
        self.overworld_id.unwrap_or(0)
    }

    pub fn clear_overworld_id(&mut self) {
        self.overworld_id = ::std::option::Option::None;
    }

    pub fn has_overworld_id(&self) -> bool {
        self.overworld_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overworld_id(&mut self, v: u32) {
        self.overworld_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldGetUserData {
    const NAME: &'static str = "CMsgClientToGCOverworldGetUserData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.overworld_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.overworld_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.overworld_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldGetUserData {
        CMsgClientToGCOverworldGetUserData::new()
    }

    fn clear(&mut self) {
        self.overworld_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldGetUserData {
        static instance: CMsgClientToGCOverworldGetUserData = CMsgClientToGCOverworldGetUserData {
            overworld_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldGetUserDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldGetUserDataResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldGetUserDataResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcoverworld_get_user_data_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldGetUserDataResponse.user_data)
    pub user_data: ::steam_vent_proto_common::protobuf::MessageField<CMsgOverworldUserData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldGetUserDataResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldGetUserDataResponse {
    fn default() -> &'a CMsgClientToGCOverworldGetUserDataResponse {
        <CMsgClientToGCOverworldGetUserDataResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldGetUserDataResponse {
    pub fn new() -> CMsgClientToGCOverworldGetUserDataResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCOverworldGetUserDataResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcoverworld_get_user_data_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcoverworld_get_user_data_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcoverworld_get_user_data_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcoverworld_get_user_data_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldGetUserDataResponse {
    const NAME: &'static str = "CMsgClientToGCOverworldGetUserDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.user_data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.user_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.user_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldGetUserDataResponse {
        CMsgClientToGCOverworldGetUserDataResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.user_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldGetUserDataResponse {
        static instance: CMsgClientToGCOverworldGetUserDataResponse = CMsgClientToGCOverworldGetUserDataResponse {
            response: ::std::option::Option::None,
            user_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCOverworldGetUserDataResponse`
pub mod cmsg_client_to_gcoverworld_get_user_data_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCOverworldGetUserDataResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldGetUserDataResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldGetUserDataResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldGetUserDataResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldGetUserDataResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldGetUserDataResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldGetUserDataResponse.EResponse.k_eInvalidOverworld)
        k_eInvalidOverworld = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidOverworld" => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidOverworld,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCToClientOverworldUserDataUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientOverworldUserDataUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientOverworldUserDataUpdated.overworld_id)
    pub overworld_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientOverworldUserDataUpdated.user_data)
    pub user_data: ::steam_vent_proto_common::protobuf::MessageField<CMsgOverworldUserData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientOverworldUserDataUpdated.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientOverworldUserDataUpdated {
    fn default() -> &'a CMsgGCToClientOverworldUserDataUpdated {
        <CMsgGCToClientOverworldUserDataUpdated as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientOverworldUserDataUpdated {
    pub fn new() -> CMsgGCToClientOverworldUserDataUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 overworld_id = 1;

    pub fn overworld_id(&self) -> u32 {
        self.overworld_id.unwrap_or(0)
    }

    pub fn clear_overworld_id(&mut self) {
        self.overworld_id = ::std::option::Option::None;
    }

    pub fn has_overworld_id(&self) -> bool {
        self.overworld_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overworld_id(&mut self, v: u32) {
        self.overworld_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientOverworldUserDataUpdated {
    const NAME: &'static str = "CMsgGCToClientOverworldUserDataUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.overworld_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.user_data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.overworld_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.user_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.overworld_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.user_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientOverworldUserDataUpdated {
        CMsgGCToClientOverworldUserDataUpdated::new()
    }

    fn clear(&mut self) {
        self.overworld_id = ::std::option::Option::None;
        self.user_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientOverworldUserDataUpdated {
        static instance: CMsgGCToClientOverworldUserDataUpdated = CMsgGCToClientOverworldUserDataUpdated {
            overworld_id: ::std::option::Option::None,
            user_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldCompletePath)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldCompletePath {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldCompletePath.overworld_id)
    pub overworld_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldCompletePath.path_id)
    pub path_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldCompletePath.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldCompletePath {
    fn default() -> &'a CMsgClientToGCOverworldCompletePath {
        <CMsgClientToGCOverworldCompletePath as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldCompletePath {
    pub fn new() -> CMsgClientToGCOverworldCompletePath {
        ::std::default::Default::default()
    }

    // optional uint32 overworld_id = 1;

    pub fn overworld_id(&self) -> u32 {
        self.overworld_id.unwrap_or(0)
    }

    pub fn clear_overworld_id(&mut self) {
        self.overworld_id = ::std::option::Option::None;
    }

    pub fn has_overworld_id(&self) -> bool {
        self.overworld_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overworld_id(&mut self, v: u32) {
        self.overworld_id = ::std::option::Option::Some(v);
    }

    // optional uint32 path_id = 2;

    pub fn path_id(&self) -> u32 {
        self.path_id.unwrap_or(0)
    }

    pub fn clear_path_id(&mut self) {
        self.path_id = ::std::option::Option::None;
    }

    pub fn has_path_id(&self) -> bool {
        self.path_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path_id(&mut self, v: u32) {
        self.path_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldCompletePath {
    const NAME: &'static str = "CMsgClientToGCOverworldCompletePath";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.overworld_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.path_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.overworld_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.path_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.overworld_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.path_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldCompletePath {
        CMsgClientToGCOverworldCompletePath::new()
    }

    fn clear(&mut self) {
        self.overworld_id = ::std::option::Option::None;
        self.path_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldCompletePath {
        static instance: CMsgClientToGCOverworldCompletePath = CMsgClientToGCOverworldCompletePath {
            overworld_id: ::std::option::Option::None,
            path_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldCompletePathResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldCompletePathResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldCompletePathResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcoverworld_complete_path_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldCompletePathResponse.claim_response)
    pub claim_response: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgDOTAClaimEventActionResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldCompletePathResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldCompletePathResponse {
    fn default() -> &'a CMsgClientToGCOverworldCompletePathResponse {
        <CMsgClientToGCOverworldCompletePathResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldCompletePathResponse {
    pub fn new() -> CMsgClientToGCOverworldCompletePathResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCOverworldCompletePathResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcoverworld_complete_path_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcoverworld_complete_path_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcoverworld_complete_path_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcoverworld_complete_path_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldCompletePathResponse {
    const NAME: &'static str = "CMsgClientToGCOverworldCompletePathResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.claim_response)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.claim_response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.claim_response.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldCompletePathResponse {
        CMsgClientToGCOverworldCompletePathResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.claim_response.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldCompletePathResponse {
        static instance: CMsgClientToGCOverworldCompletePathResponse = CMsgClientToGCOverworldCompletePathResponse {
            response: ::std::option::Option::None,
            claim_response: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCOverworldCompletePathResponse`
pub mod cmsg_client_to_gcoverworld_complete_path_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCOverworldCompletePathResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldCompletePathResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldCompletePathResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldCompletePathResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldCompletePathResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldCompletePathResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldCompletePathResponse.EResponse.k_eInvalidOverworld)
        k_eInvalidOverworld = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldCompletePathResponse.EResponse.k_eInvalidPath)
        k_eInvalidPath = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldCompletePathResponse.EResponse.k_eNotEnoughTokens)
        k_eNotEnoughTokens = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldCompletePathResponse.EResponse.k_ePathIsLocked)
        k_ePathIsLocked = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldCompletePathResponse.EResponse.k_ePathAlreadyUnlocked)
        k_ePathAlreadyUnlocked = 9,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidPath),
                7 => ::std::option::Option::Some(EResponse::k_eNotEnoughTokens),
                8 => ::std::option::Option::Some(EResponse::k_ePathIsLocked),
                9 => ::std::option::Option::Some(EResponse::k_ePathAlreadyUnlocked),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidOverworld" => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                "k_eInvalidPath" => ::std::option::Option::Some(EResponse::k_eInvalidPath),
                "k_eNotEnoughTokens" => ::std::option::Option::Some(EResponse::k_eNotEnoughTokens),
                "k_ePathIsLocked" => ::std::option::Option::Some(EResponse::k_ePathIsLocked),
                "k_ePathAlreadyUnlocked" => ::std::option::Option::Some(EResponse::k_ePathAlreadyUnlocked),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidOverworld,
            EResponse::k_eInvalidPath,
            EResponse::k_eNotEnoughTokens,
            EResponse::k_ePathIsLocked,
            EResponse::k_ePathAlreadyUnlocked,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgOverworldEncounterPitFighterRewardData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgOverworldEncounterPitFighterRewardData {
    // message fields
    // @@protoc_insertion_point(field:CMsgOverworldEncounterPitFighterRewardData.token_id)
    pub token_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgOverworldEncounterPitFighterRewardData.choice)
    pub choice: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgOverworldEncounterPitFighterRewardData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgOverworldEncounterPitFighterRewardData {
    fn default() -> &'a CMsgOverworldEncounterPitFighterRewardData {
        <CMsgOverworldEncounterPitFighterRewardData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgOverworldEncounterPitFighterRewardData {
    pub fn new() -> CMsgOverworldEncounterPitFighterRewardData {
        ::std::default::Default::default()
    }

    // optional uint32 token_id = 1;

    pub fn token_id(&self) -> u32 {
        self.token_id.unwrap_or(0)
    }

    pub fn clear_token_id(&mut self) {
        self.token_id = ::std::option::Option::None;
    }

    pub fn has_token_id(&self) -> bool {
        self.token_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token_id(&mut self, v: u32) {
        self.token_id = ::std::option::Option::Some(v);
    }

    // optional uint32 choice = 2;

    pub fn choice(&self) -> u32 {
        self.choice.unwrap_or(0)
    }

    pub fn clear_choice(&mut self) {
        self.choice = ::std::option::Option::None;
    }

    pub fn has_choice(&self) -> bool {
        self.choice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_choice(&mut self, v: u32) {
        self.choice = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgOverworldEncounterPitFighterRewardData {
    const NAME: &'static str = "CMsgOverworldEncounterPitFighterRewardData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.token_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.choice = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.choice {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.token_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.choice {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgOverworldEncounterPitFighterRewardData {
        CMsgOverworldEncounterPitFighterRewardData::new()
    }

    fn clear(&mut self) {
        self.token_id = ::std::option::Option::None;
        self.choice = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgOverworldEncounterPitFighterRewardData {
        static instance: CMsgOverworldEncounterPitFighterRewardData = CMsgOverworldEncounterPitFighterRewardData {
            token_id: ::std::option::Option::None,
            choice: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldClaimEncounterReward)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldClaimEncounterReward {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldClaimEncounterReward.overworld_id)
    pub overworld_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldClaimEncounterReward.node_id)
    pub node_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldClaimEncounterReward.reward_data)
    pub reward_data: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldClaimEncounterReward.periodic_resource_id)
    pub periodic_resource_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldClaimEncounterReward.extra_reward_data)
    pub extra_reward_data: ::steam_vent_proto_common::protobuf::MessageField<CMsgOverworldEncounterData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldClaimEncounterReward.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldClaimEncounterReward {
    fn default() -> &'a CMsgClientToGCOverworldClaimEncounterReward {
        <CMsgClientToGCOverworldClaimEncounterReward as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldClaimEncounterReward {
    pub fn new() -> CMsgClientToGCOverworldClaimEncounterReward {
        ::std::default::Default::default()
    }

    // optional uint32 overworld_id = 1;

    pub fn overworld_id(&self) -> u32 {
        self.overworld_id.unwrap_or(0)
    }

    pub fn clear_overworld_id(&mut self) {
        self.overworld_id = ::std::option::Option::None;
    }

    pub fn has_overworld_id(&self) -> bool {
        self.overworld_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overworld_id(&mut self, v: u32) {
        self.overworld_id = ::std::option::Option::Some(v);
    }

    // optional uint32 node_id = 2;

    pub fn node_id(&self) -> u32 {
        self.node_id.unwrap_or(0)
    }

    pub fn clear_node_id(&mut self) {
        self.node_id = ::std::option::Option::None;
    }

    pub fn has_node_id(&self) -> bool {
        self.node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u32) {
        self.node_id = ::std::option::Option::Some(v);
    }

    // optional uint32 reward_data = 3;

    pub fn reward_data(&self) -> u32 {
        self.reward_data.unwrap_or(0)
    }

    pub fn clear_reward_data(&mut self) {
        self.reward_data = ::std::option::Option::None;
    }

    pub fn has_reward_data(&self) -> bool {
        self.reward_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_data(&mut self, v: u32) {
        self.reward_data = ::std::option::Option::Some(v);
    }

    // optional uint32 periodic_resource_id = 4;

    pub fn periodic_resource_id(&self) -> u32 {
        self.periodic_resource_id.unwrap_or(0)
    }

    pub fn clear_periodic_resource_id(&mut self) {
        self.periodic_resource_id = ::std::option::Option::None;
    }

    pub fn has_periodic_resource_id(&self) -> bool {
        self.periodic_resource_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_periodic_resource_id(&mut self, v: u32) {
        self.periodic_resource_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldClaimEncounterReward {
    const NAME: &'static str = "CMsgClientToGCOverworldClaimEncounterReward";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.overworld_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.reward_data = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.periodic_resource_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.extra_reward_data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.overworld_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.node_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.reward_data {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.periodic_resource_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.extra_reward_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.overworld_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.node_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.reward_data {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.periodic_resource_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.extra_reward_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldClaimEncounterReward {
        CMsgClientToGCOverworldClaimEncounterReward::new()
    }

    fn clear(&mut self) {
        self.overworld_id = ::std::option::Option::None;
        self.node_id = ::std::option::Option::None;
        self.reward_data = ::std::option::Option::None;
        self.periodic_resource_id = ::std::option::Option::None;
        self.extra_reward_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldClaimEncounterReward {
        static instance: CMsgClientToGCOverworldClaimEncounterReward = CMsgClientToGCOverworldClaimEncounterReward {
            overworld_id: ::std::option::Option::None,
            node_id: ::std::option::Option::None,
            reward_data: ::std::option::Option::None,
            periodic_resource_id: ::std::option::Option::None,
            extra_reward_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldClaimEncounterRewardResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldClaimEncounterRewardResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldClaimEncounterRewardResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcoverworld_claim_encounter_reward_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldClaimEncounterRewardResponse.claim_response)
    pub claim_response: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgDOTAClaimEventActionResponse>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldClaimEncounterRewardResponse.tokens_received)
    pub tokens_received: ::steam_vent_proto_common::protobuf::MessageField<CMsgOverworldTokenQuantity>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldClaimEncounterRewardResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldClaimEncounterRewardResponse {
    fn default() -> &'a CMsgClientToGCOverworldClaimEncounterRewardResponse {
        <CMsgClientToGCOverworldClaimEncounterRewardResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldClaimEncounterRewardResponse {
    pub fn new() -> CMsgClientToGCOverworldClaimEncounterRewardResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcoverworld_claim_encounter_reward_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcoverworld_claim_encounter_reward_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcoverworld_claim_encounter_reward_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcoverworld_claim_encounter_reward_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldClaimEncounterRewardResponse {
    const NAME: &'static str = "CMsgClientToGCOverworldClaimEncounterRewardResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.claim_response)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.tokens_received)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.claim_response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tokens_received.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.claim_response.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.tokens_received.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldClaimEncounterRewardResponse {
        CMsgClientToGCOverworldClaimEncounterRewardResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.claim_response.clear();
        self.tokens_received.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldClaimEncounterRewardResponse {
        static instance: CMsgClientToGCOverworldClaimEncounterRewardResponse = CMsgClientToGCOverworldClaimEncounterRewardResponse {
            response: ::std::option::Option::None,
            claim_response: ::steam_vent_proto_common::protobuf::MessageField::none(),
            tokens_received: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCOverworldClaimEncounterRewardResponse`
pub mod cmsg_client_to_gcoverworld_claim_encounter_reward_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse.k_eInvalidOverworld)
        k_eInvalidOverworld = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse.k_eInvalidNode)
        k_eInvalidNode = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse.k_eNodeLocked)
        k_eNodeLocked = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse.k_eRewardAlreadyClaimed)
        k_eRewardAlreadyClaimed = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse.k_eNodeNotEncounter)
        k_eNodeNotEncounter = 9,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse.k_eEncounterMissingRewards)
        k_eEncounterMissingRewards = 10,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse.k_eInvalidEncounterRewardStyle)
        k_eInvalidEncounterRewardStyle = 11,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse.k_eInvalidEncounterData)
        k_eInvalidEncounterData = 12,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse.k_eNotEnoughTokensForReward)
        k_eNotEnoughTokensForReward = 13,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse.k_eNotEnoughResourceForReward)
        k_eNotEnoughResourceForReward = 14,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidNode),
                7 => ::std::option::Option::Some(EResponse::k_eNodeLocked),
                8 => ::std::option::Option::Some(EResponse::k_eRewardAlreadyClaimed),
                9 => ::std::option::Option::Some(EResponse::k_eNodeNotEncounter),
                10 => ::std::option::Option::Some(EResponse::k_eEncounterMissingRewards),
                11 => ::std::option::Option::Some(EResponse::k_eInvalidEncounterRewardStyle),
                12 => ::std::option::Option::Some(EResponse::k_eInvalidEncounterData),
                13 => ::std::option::Option::Some(EResponse::k_eNotEnoughTokensForReward),
                14 => ::std::option::Option::Some(EResponse::k_eNotEnoughResourceForReward),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidOverworld" => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                "k_eInvalidNode" => ::std::option::Option::Some(EResponse::k_eInvalidNode),
                "k_eNodeLocked" => ::std::option::Option::Some(EResponse::k_eNodeLocked),
                "k_eRewardAlreadyClaimed" => ::std::option::Option::Some(EResponse::k_eRewardAlreadyClaimed),
                "k_eNodeNotEncounter" => ::std::option::Option::Some(EResponse::k_eNodeNotEncounter),
                "k_eEncounterMissingRewards" => ::std::option::Option::Some(EResponse::k_eEncounterMissingRewards),
                "k_eInvalidEncounterRewardStyle" => ::std::option::Option::Some(EResponse::k_eInvalidEncounterRewardStyle),
                "k_eInvalidEncounterData" => ::std::option::Option::Some(EResponse::k_eInvalidEncounterData),
                "k_eNotEnoughTokensForReward" => ::std::option::Option::Some(EResponse::k_eNotEnoughTokensForReward),
                "k_eNotEnoughResourceForReward" => ::std::option::Option::Some(EResponse::k_eNotEnoughResourceForReward),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidOverworld,
            EResponse::k_eInvalidNode,
            EResponse::k_eNodeLocked,
            EResponse::k_eRewardAlreadyClaimed,
            EResponse::k_eNodeNotEncounter,
            EResponse::k_eEncounterMissingRewards,
            EResponse::k_eInvalidEncounterRewardStyle,
            EResponse::k_eInvalidEncounterData,
            EResponse::k_eNotEnoughTokensForReward,
            EResponse::k_eNotEnoughResourceForReward,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldVisitEncounter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldVisitEncounter {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldVisitEncounter.overworld_id)
    pub overworld_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldVisitEncounter.node_id)
    pub node_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldVisitEncounter.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldVisitEncounter {
    fn default() -> &'a CMsgClientToGCOverworldVisitEncounter {
        <CMsgClientToGCOverworldVisitEncounter as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldVisitEncounter {
    pub fn new() -> CMsgClientToGCOverworldVisitEncounter {
        ::std::default::Default::default()
    }

    // optional uint32 overworld_id = 1;

    pub fn overworld_id(&self) -> u32 {
        self.overworld_id.unwrap_or(0)
    }

    pub fn clear_overworld_id(&mut self) {
        self.overworld_id = ::std::option::Option::None;
    }

    pub fn has_overworld_id(&self) -> bool {
        self.overworld_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overworld_id(&mut self, v: u32) {
        self.overworld_id = ::std::option::Option::Some(v);
    }

    // optional uint32 node_id = 2;

    pub fn node_id(&self) -> u32 {
        self.node_id.unwrap_or(0)
    }

    pub fn clear_node_id(&mut self) {
        self.node_id = ::std::option::Option::None;
    }

    pub fn has_node_id(&self) -> bool {
        self.node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u32) {
        self.node_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldVisitEncounter {
    const NAME: &'static str = "CMsgClientToGCOverworldVisitEncounter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.overworld_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.overworld_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.node_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.overworld_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.node_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldVisitEncounter {
        CMsgClientToGCOverworldVisitEncounter::new()
    }

    fn clear(&mut self) {
        self.overworld_id = ::std::option::Option::None;
        self.node_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldVisitEncounter {
        static instance: CMsgClientToGCOverworldVisitEncounter = CMsgClientToGCOverworldVisitEncounter {
            overworld_id: ::std::option::Option::None,
            node_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldVisitEncounterResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldVisitEncounterResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldVisitEncounterResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcoverworld_visit_encounter_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldVisitEncounterResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldVisitEncounterResponse {
    fn default() -> &'a CMsgClientToGCOverworldVisitEncounterResponse {
        <CMsgClientToGCOverworldVisitEncounterResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldVisitEncounterResponse {
    pub fn new() -> CMsgClientToGCOverworldVisitEncounterResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCOverworldVisitEncounterResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcoverworld_visit_encounter_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcoverworld_visit_encounter_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcoverworld_visit_encounter_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcoverworld_visit_encounter_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldVisitEncounterResponse {
    const NAME: &'static str = "CMsgClientToGCOverworldVisitEncounterResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldVisitEncounterResponse {
        CMsgClientToGCOverworldVisitEncounterResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldVisitEncounterResponse {
        static instance: CMsgClientToGCOverworldVisitEncounterResponse = CMsgClientToGCOverworldVisitEncounterResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCOverworldVisitEncounterResponse`
pub mod cmsg_client_to_gcoverworld_visit_encounter_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCOverworldVisitEncounterResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldVisitEncounterResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldVisitEncounterResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldVisitEncounterResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldVisitEncounterResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldVisitEncounterResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldVisitEncounterResponse.EResponse.k_eInvalidOverworld)
        k_eInvalidOverworld = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldVisitEncounterResponse.EResponse.k_eInvalidNode)
        k_eInvalidNode = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldVisitEncounterResponse.EResponse.k_eNodeLocked)
        k_eNodeLocked = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldVisitEncounterResponse.EResponse.k_eNodeNotEncounter)
        k_eNodeNotEncounter = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldVisitEncounterResponse.EResponse.k_eAlreadyVisited)
        k_eAlreadyVisited = 9,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidNode),
                7 => ::std::option::Option::Some(EResponse::k_eNodeLocked),
                8 => ::std::option::Option::Some(EResponse::k_eNodeNotEncounter),
                9 => ::std::option::Option::Some(EResponse::k_eAlreadyVisited),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidOverworld" => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                "k_eInvalidNode" => ::std::option::Option::Some(EResponse::k_eInvalidNode),
                "k_eNodeLocked" => ::std::option::Option::Some(EResponse::k_eNodeLocked),
                "k_eNodeNotEncounter" => ::std::option::Option::Some(EResponse::k_eNodeNotEncounter),
                "k_eAlreadyVisited" => ::std::option::Option::Some(EResponse::k_eAlreadyVisited),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidOverworld,
            EResponse::k_eInvalidNode,
            EResponse::k_eNodeLocked,
            EResponse::k_eNodeNotEncounter,
            EResponse::k_eAlreadyVisited,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldMoveToNode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldMoveToNode {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldMoveToNode.overworld_id)
    pub overworld_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldMoveToNode.node_id)
    pub node_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldMoveToNode.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldMoveToNode {
    fn default() -> &'a CMsgClientToGCOverworldMoveToNode {
        <CMsgClientToGCOverworldMoveToNode as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldMoveToNode {
    pub fn new() -> CMsgClientToGCOverworldMoveToNode {
        ::std::default::Default::default()
    }

    // optional uint32 overworld_id = 1;

    pub fn overworld_id(&self) -> u32 {
        self.overworld_id.unwrap_or(0)
    }

    pub fn clear_overworld_id(&mut self) {
        self.overworld_id = ::std::option::Option::None;
    }

    pub fn has_overworld_id(&self) -> bool {
        self.overworld_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overworld_id(&mut self, v: u32) {
        self.overworld_id = ::std::option::Option::Some(v);
    }

    // optional uint32 node_id = 2;

    pub fn node_id(&self) -> u32 {
        self.node_id.unwrap_or(0)
    }

    pub fn clear_node_id(&mut self) {
        self.node_id = ::std::option::Option::None;
    }

    pub fn has_node_id(&self) -> bool {
        self.node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u32) {
        self.node_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldMoveToNode {
    const NAME: &'static str = "CMsgClientToGCOverworldMoveToNode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.overworld_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.overworld_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.node_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.overworld_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.node_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldMoveToNode {
        CMsgClientToGCOverworldMoveToNode::new()
    }

    fn clear(&mut self) {
        self.overworld_id = ::std::option::Option::None;
        self.node_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldMoveToNode {
        static instance: CMsgClientToGCOverworldMoveToNode = CMsgClientToGCOverworldMoveToNode {
            overworld_id: ::std::option::Option::None,
            node_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldMoveToNodeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldMoveToNodeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldMoveToNodeResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcoverworld_move_to_node_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldMoveToNodeResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldMoveToNodeResponse {
    fn default() -> &'a CMsgClientToGCOverworldMoveToNodeResponse {
        <CMsgClientToGCOverworldMoveToNodeResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldMoveToNodeResponse {
    pub fn new() -> CMsgClientToGCOverworldMoveToNodeResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCOverworldMoveToNodeResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcoverworld_move_to_node_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcoverworld_move_to_node_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcoverworld_move_to_node_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcoverworld_move_to_node_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldMoveToNodeResponse {
    const NAME: &'static str = "CMsgClientToGCOverworldMoveToNodeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldMoveToNodeResponse {
        CMsgClientToGCOverworldMoveToNodeResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldMoveToNodeResponse {
        static instance: CMsgClientToGCOverworldMoveToNodeResponse = CMsgClientToGCOverworldMoveToNodeResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCOverworldMoveToNodeResponse`
pub mod cmsg_client_to_gcoverworld_move_to_node_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCOverworldMoveToNodeResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldMoveToNodeResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldMoveToNodeResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldMoveToNodeResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldMoveToNodeResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldMoveToNodeResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldMoveToNodeResponse.EResponse.k_eInvalidOverworld)
        k_eInvalidOverworld = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldMoveToNodeResponse.EResponse.k_eInvalidNode)
        k_eInvalidNode = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldMoveToNodeResponse.EResponse.k_eNodeLocked)
        k_eNodeLocked = 7,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidNode),
                7 => ::std::option::Option::Some(EResponse::k_eNodeLocked),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidOverworld" => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                "k_eInvalidNode" => ::std::option::Option::Some(EResponse::k_eInvalidNode),
                "k_eNodeLocked" => ::std::option::Option::Some(EResponse::k_eNodeLocked),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidOverworld,
            EResponse::k_eInvalidNode,
            EResponse::k_eNodeLocked,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldTradeTokens)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldTradeTokens {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldTradeTokens.overworld_id)
    pub overworld_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldTradeTokens.token_offer)
    pub token_offer: ::steam_vent_proto_common::protobuf::MessageField<CMsgOverworldTokenQuantity>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldTradeTokens.token_request)
    pub token_request: ::steam_vent_proto_common::protobuf::MessageField<CMsgOverworldTokenQuantity>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldTradeTokens.recipe)
    pub recipe: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldTradeTokens.encounter_id)
    pub encounter_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldTradeTokens.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldTradeTokens {
    fn default() -> &'a CMsgClientToGCOverworldTradeTokens {
        <CMsgClientToGCOverworldTradeTokens as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldTradeTokens {
    pub fn new() -> CMsgClientToGCOverworldTradeTokens {
        ::std::default::Default::default()
    }

    // optional uint32 overworld_id = 1;

    pub fn overworld_id(&self) -> u32 {
        self.overworld_id.unwrap_or(0)
    }

    pub fn clear_overworld_id(&mut self) {
        self.overworld_id = ::std::option::Option::None;
    }

    pub fn has_overworld_id(&self) -> bool {
        self.overworld_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overworld_id(&mut self, v: u32) {
        self.overworld_id = ::std::option::Option::Some(v);
    }

    // optional uint32 recipe = 4;

    pub fn recipe(&self) -> u32 {
        self.recipe.unwrap_or(0)
    }

    pub fn clear_recipe(&mut self) {
        self.recipe = ::std::option::Option::None;
    }

    pub fn has_recipe(&self) -> bool {
        self.recipe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipe(&mut self, v: u32) {
        self.recipe = ::std::option::Option::Some(v);
    }

    // optional uint32 encounter_id = 5;

    pub fn encounter_id(&self) -> u32 {
        self.encounter_id.unwrap_or(0)
    }

    pub fn clear_encounter_id(&mut self) {
        self.encounter_id = ::std::option::Option::None;
    }

    pub fn has_encounter_id(&self) -> bool {
        self.encounter_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encounter_id(&mut self, v: u32) {
        self.encounter_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldTradeTokens {
    const NAME: &'static str = "CMsgClientToGCOverworldTradeTokens";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.overworld_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.token_offer)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.token_request)?;
                },
                32 => {
                    self.recipe = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.encounter_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.overworld_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.token_offer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.token_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.recipe {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.encounter_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.overworld_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.token_offer.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.token_request.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.recipe {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.encounter_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldTradeTokens {
        CMsgClientToGCOverworldTradeTokens::new()
    }

    fn clear(&mut self) {
        self.overworld_id = ::std::option::Option::None;
        self.token_offer.clear();
        self.token_request.clear();
        self.recipe = ::std::option::Option::None;
        self.encounter_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldTradeTokens {
        static instance: CMsgClientToGCOverworldTradeTokens = CMsgClientToGCOverworldTradeTokens {
            overworld_id: ::std::option::Option::None,
            token_offer: ::steam_vent_proto_common::protobuf::MessageField::none(),
            token_request: ::steam_vent_proto_common::protobuf::MessageField::none(),
            recipe: ::std::option::Option::None,
            encounter_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldTradeTokensResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldTradeTokensResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldTradeTokensResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcoverworld_trade_tokens_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldTradeTokensResponse.tokens_received)
    pub tokens_received: ::steam_vent_proto_common::protobuf::MessageField<CMsgOverworldTokenQuantity>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldTradeTokensResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldTradeTokensResponse {
    fn default() -> &'a CMsgClientToGCOverworldTradeTokensResponse {
        <CMsgClientToGCOverworldTradeTokensResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldTradeTokensResponse {
    pub fn new() -> CMsgClientToGCOverworldTradeTokensResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCOverworldTradeTokensResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcoverworld_trade_tokens_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcoverworld_trade_tokens_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcoverworld_trade_tokens_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcoverworld_trade_tokens_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldTradeTokensResponse {
    const NAME: &'static str = "CMsgClientToGCOverworldTradeTokensResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.tokens_received)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.tokens_received.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.tokens_received.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldTradeTokensResponse {
        CMsgClientToGCOverworldTradeTokensResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.tokens_received.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldTradeTokensResponse {
        static instance: CMsgClientToGCOverworldTradeTokensResponse = CMsgClientToGCOverworldTradeTokensResponse {
            response: ::std::option::Option::None,
            tokens_received: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCOverworldTradeTokensResponse`
pub mod cmsg_client_to_gcoverworld_trade_tokens_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCOverworldTradeTokensResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldTradeTokensResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldTradeTokensResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldTradeTokensResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldTradeTokensResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldTradeTokensResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldTradeTokensResponse.EResponse.k_eNotAllowed)
        k_eNotAllowed = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldTradeTokensResponse.EResponse.k_eNodeLocked)
        k_eNodeLocked = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldTradeTokensResponse.EResponse.k_eInvalidOverworld)
        k_eInvalidOverworld = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldTradeTokensResponse.EResponse.k_eInvalidOffer)
        k_eInvalidOffer = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldTradeTokensResponse.EResponse.k_eNotEnoughTokens)
        k_eNotEnoughTokens = 9,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldTradeTokensResponse.EResponse.k_eInvalidNode)
        k_eInvalidNode = 10,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldTradeTokensResponse.EResponse.k_eInvalidEncounter)
        k_eInvalidEncounter = 11,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldTradeTokensResponse.EResponse.k_eRewardDoesNotMatchRecipe)
        k_eRewardDoesNotMatchRecipe = 12,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                6 => ::std::option::Option::Some(EResponse::k_eNodeLocked),
                7 => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                8 => ::std::option::Option::Some(EResponse::k_eInvalidOffer),
                9 => ::std::option::Option::Some(EResponse::k_eNotEnoughTokens),
                10 => ::std::option::Option::Some(EResponse::k_eInvalidNode),
                11 => ::std::option::Option::Some(EResponse::k_eInvalidEncounter),
                12 => ::std::option::Option::Some(EResponse::k_eRewardDoesNotMatchRecipe),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNotAllowed" => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                "k_eNodeLocked" => ::std::option::Option::Some(EResponse::k_eNodeLocked),
                "k_eInvalidOverworld" => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                "k_eInvalidOffer" => ::std::option::Option::Some(EResponse::k_eInvalidOffer),
                "k_eNotEnoughTokens" => ::std::option::Option::Some(EResponse::k_eNotEnoughTokens),
                "k_eInvalidNode" => ::std::option::Option::Some(EResponse::k_eInvalidNode),
                "k_eInvalidEncounter" => ::std::option::Option::Some(EResponse::k_eInvalidEncounter),
                "k_eRewardDoesNotMatchRecipe" => ::std::option::Option::Some(EResponse::k_eRewardDoesNotMatchRecipe),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNotAllowed,
            EResponse::k_eNodeLocked,
            EResponse::k_eInvalidOverworld,
            EResponse::k_eInvalidOffer,
            EResponse::k_eNotEnoughTokens,
            EResponse::k_eInvalidNode,
            EResponse::k_eInvalidEncounter,
            EResponse::k_eRewardDoesNotMatchRecipe,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldGiftTokens)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldGiftTokens {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldGiftTokens.overworld_id)
    pub overworld_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldGiftTokens.token_gift)
    pub token_gift: ::steam_vent_proto_common::protobuf::MessageField<CMsgOverworldTokenCount>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldGiftTokens.recipient_account_id)
    pub recipient_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldGiftTokens.periodic_resource_id)
    pub periodic_resource_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldGiftTokens.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldGiftTokens {
    fn default() -> &'a CMsgClientToGCOverworldGiftTokens {
        <CMsgClientToGCOverworldGiftTokens as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldGiftTokens {
    pub fn new() -> CMsgClientToGCOverworldGiftTokens {
        ::std::default::Default::default()
    }

    // optional uint32 overworld_id = 1;

    pub fn overworld_id(&self) -> u32 {
        self.overworld_id.unwrap_or(0)
    }

    pub fn clear_overworld_id(&mut self) {
        self.overworld_id = ::std::option::Option::None;
    }

    pub fn has_overworld_id(&self) -> bool {
        self.overworld_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overworld_id(&mut self, v: u32) {
        self.overworld_id = ::std::option::Option::Some(v);
    }

    // optional uint32 recipient_account_id = 3;

    pub fn recipient_account_id(&self) -> u32 {
        self.recipient_account_id.unwrap_or(0)
    }

    pub fn clear_recipient_account_id(&mut self) {
        self.recipient_account_id = ::std::option::Option::None;
    }

    pub fn has_recipient_account_id(&self) -> bool {
        self.recipient_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_account_id(&mut self, v: u32) {
        self.recipient_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 periodic_resource_id = 4;

    pub fn periodic_resource_id(&self) -> u32 {
        self.periodic_resource_id.unwrap_or(0)
    }

    pub fn clear_periodic_resource_id(&mut self) {
        self.periodic_resource_id = ::std::option::Option::None;
    }

    pub fn has_periodic_resource_id(&self) -> bool {
        self.periodic_resource_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_periodic_resource_id(&mut self, v: u32) {
        self.periodic_resource_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldGiftTokens {
    const NAME: &'static str = "CMsgClientToGCOverworldGiftTokens";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.overworld_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.token_gift)?;
                },
                24 => {
                    self.recipient_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.periodic_resource_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.overworld_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.token_gift.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.recipient_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.periodic_resource_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.overworld_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.token_gift.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.recipient_account_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.periodic_resource_id {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldGiftTokens {
        CMsgClientToGCOverworldGiftTokens::new()
    }

    fn clear(&mut self) {
        self.overworld_id = ::std::option::Option::None;
        self.token_gift.clear();
        self.recipient_account_id = ::std::option::Option::None;
        self.periodic_resource_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldGiftTokens {
        static instance: CMsgClientToGCOverworldGiftTokens = CMsgClientToGCOverworldGiftTokens {
            overworld_id: ::std::option::Option::None,
            token_gift: ::steam_vent_proto_common::protobuf::MessageField::none(),
            recipient_account_id: ::std::option::Option::None,
            periodic_resource_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldGiftTokensResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldGiftTokensResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldGiftTokensResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcoverworld_gift_tokens_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldGiftTokensResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldGiftTokensResponse {
    fn default() -> &'a CMsgClientToGCOverworldGiftTokensResponse {
        <CMsgClientToGCOverworldGiftTokensResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldGiftTokensResponse {
    pub fn new() -> CMsgClientToGCOverworldGiftTokensResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCOverworldGiftTokensResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcoverworld_gift_tokens_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcoverworld_gift_tokens_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcoverworld_gift_tokens_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcoverworld_gift_tokens_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldGiftTokensResponse {
    const NAME: &'static str = "CMsgClientToGCOverworldGiftTokensResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldGiftTokensResponse {
        CMsgClientToGCOverworldGiftTokensResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldGiftTokensResponse {
        static instance: CMsgClientToGCOverworldGiftTokensResponse = CMsgClientToGCOverworldGiftTokensResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCOverworldGiftTokensResponse`
pub mod cmsg_client_to_gcoverworld_gift_tokens_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCOverworldGiftTokensResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldGiftTokensResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldGiftTokensResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldGiftTokensResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldGiftTokensResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldGiftTokensResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldGiftTokensResponse.EResponse.k_eNotAllowed)
        k_eNotAllowed = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldGiftTokensResponse.EResponse.k_eNodeLocked)
        k_eNodeLocked = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldGiftTokensResponse.EResponse.k_eInvalidOverworld)
        k_eInvalidOverworld = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldGiftTokensResponse.EResponse.k_eInvalidGift)
        k_eInvalidGift = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldGiftTokensResponse.EResponse.k_eNotEnoughTokens)
        k_eNotEnoughTokens = 9,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldGiftTokensResponse.EResponse.k_eInvalidRecipient)
        k_eInvalidRecipient = 10,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldGiftTokensResponse.EResponse.k_eNotEnoughPeriodicResource)
        k_eNotEnoughPeriodicResource = 11,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                6 => ::std::option::Option::Some(EResponse::k_eNodeLocked),
                7 => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                8 => ::std::option::Option::Some(EResponse::k_eInvalidGift),
                9 => ::std::option::Option::Some(EResponse::k_eNotEnoughTokens),
                10 => ::std::option::Option::Some(EResponse::k_eInvalidRecipient),
                11 => ::std::option::Option::Some(EResponse::k_eNotEnoughPeriodicResource),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNotAllowed" => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                "k_eNodeLocked" => ::std::option::Option::Some(EResponse::k_eNodeLocked),
                "k_eInvalidOverworld" => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                "k_eInvalidGift" => ::std::option::Option::Some(EResponse::k_eInvalidGift),
                "k_eNotEnoughTokens" => ::std::option::Option::Some(EResponse::k_eNotEnoughTokens),
                "k_eInvalidRecipient" => ::std::option::Option::Some(EResponse::k_eInvalidRecipient),
                "k_eNotEnoughPeriodicResource" => ::std::option::Option::Some(EResponse::k_eNotEnoughPeriodicResource),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNotAllowed,
            EResponse::k_eNodeLocked,
            EResponse::k_eInvalidOverworld,
            EResponse::k_eInvalidGift,
            EResponse::k_eNotEnoughTokens,
            EResponse::k_eInvalidRecipient,
            EResponse::k_eNotEnoughPeriodicResource,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldDevResetAll)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldDevResetAll {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldDevResetAll.overworld_id)
    pub overworld_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldDevResetAll.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldDevResetAll {
    fn default() -> &'a CMsgClientToGCOverworldDevResetAll {
        <CMsgClientToGCOverworldDevResetAll as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldDevResetAll {
    pub fn new() -> CMsgClientToGCOverworldDevResetAll {
        ::std::default::Default::default()
    }

    // optional uint32 overworld_id = 1;

    pub fn overworld_id(&self) -> u32 {
        self.overworld_id.unwrap_or(0)
    }

    pub fn clear_overworld_id(&mut self) {
        self.overworld_id = ::std::option::Option::None;
    }

    pub fn has_overworld_id(&self) -> bool {
        self.overworld_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overworld_id(&mut self, v: u32) {
        self.overworld_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldDevResetAll {
    const NAME: &'static str = "CMsgClientToGCOverworldDevResetAll";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.overworld_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.overworld_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.overworld_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldDevResetAll {
        CMsgClientToGCOverworldDevResetAll::new()
    }

    fn clear(&mut self) {
        self.overworld_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldDevResetAll {
        static instance: CMsgClientToGCOverworldDevResetAll = CMsgClientToGCOverworldDevResetAll {
            overworld_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldDevResetAllResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldDevResetAllResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldDevResetAllResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcoverworld_dev_reset_all_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldDevResetAllResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldDevResetAllResponse {
    fn default() -> &'a CMsgClientToGCOverworldDevResetAllResponse {
        <CMsgClientToGCOverworldDevResetAllResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldDevResetAllResponse {
    pub fn new() -> CMsgClientToGCOverworldDevResetAllResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCOverworldDevResetAllResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcoverworld_dev_reset_all_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcoverworld_dev_reset_all_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcoverworld_dev_reset_all_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcoverworld_dev_reset_all_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldDevResetAllResponse {
    const NAME: &'static str = "CMsgClientToGCOverworldDevResetAllResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldDevResetAllResponse {
        CMsgClientToGCOverworldDevResetAllResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldDevResetAllResponse {
        static instance: CMsgClientToGCOverworldDevResetAllResponse = CMsgClientToGCOverworldDevResetAllResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCOverworldDevResetAllResponse`
pub mod cmsg_client_to_gcoverworld_dev_reset_all_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCOverworldDevResetAllResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevResetAllResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevResetAllResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevResetAllResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevResetAllResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevResetAllResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevResetAllResponse.EResponse.k_eNotAllowed)
        k_eNotAllowed = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevResetAllResponse.EResponse.k_eInvalidOverworld)
        k_eInvalidOverworld = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNotAllowed" => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                "k_eInvalidOverworld" => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNotAllowed,
            EResponse::k_eInvalidOverworld,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldDevResetNode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldDevResetNode {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldDevResetNode.overworld_id)
    pub overworld_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldDevResetNode.node_id)
    pub node_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldDevResetNode.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldDevResetNode {
    fn default() -> &'a CMsgClientToGCOverworldDevResetNode {
        <CMsgClientToGCOverworldDevResetNode as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldDevResetNode {
    pub fn new() -> CMsgClientToGCOverworldDevResetNode {
        ::std::default::Default::default()
    }

    // optional uint32 overworld_id = 1;

    pub fn overworld_id(&self) -> u32 {
        self.overworld_id.unwrap_or(0)
    }

    pub fn clear_overworld_id(&mut self) {
        self.overworld_id = ::std::option::Option::None;
    }

    pub fn has_overworld_id(&self) -> bool {
        self.overworld_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overworld_id(&mut self, v: u32) {
        self.overworld_id = ::std::option::Option::Some(v);
    }

    // optional uint32 node_id = 2;

    pub fn node_id(&self) -> u32 {
        self.node_id.unwrap_or(0)
    }

    pub fn clear_node_id(&mut self) {
        self.node_id = ::std::option::Option::None;
    }

    pub fn has_node_id(&self) -> bool {
        self.node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u32) {
        self.node_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldDevResetNode {
    const NAME: &'static str = "CMsgClientToGCOverworldDevResetNode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.overworld_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.overworld_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.node_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.overworld_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.node_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldDevResetNode {
        CMsgClientToGCOverworldDevResetNode::new()
    }

    fn clear(&mut self) {
        self.overworld_id = ::std::option::Option::None;
        self.node_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldDevResetNode {
        static instance: CMsgClientToGCOverworldDevResetNode = CMsgClientToGCOverworldDevResetNode {
            overworld_id: ::std::option::Option::None,
            node_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldDevResetNodeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldDevResetNodeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldDevResetNodeResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcoverworld_dev_reset_node_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldDevResetNodeResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldDevResetNodeResponse {
    fn default() -> &'a CMsgClientToGCOverworldDevResetNodeResponse {
        <CMsgClientToGCOverworldDevResetNodeResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldDevResetNodeResponse {
    pub fn new() -> CMsgClientToGCOverworldDevResetNodeResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCOverworldDevResetNodeResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcoverworld_dev_reset_node_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcoverworld_dev_reset_node_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcoverworld_dev_reset_node_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcoverworld_dev_reset_node_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldDevResetNodeResponse {
    const NAME: &'static str = "CMsgClientToGCOverworldDevResetNodeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldDevResetNodeResponse {
        CMsgClientToGCOverworldDevResetNodeResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldDevResetNodeResponse {
        static instance: CMsgClientToGCOverworldDevResetNodeResponse = CMsgClientToGCOverworldDevResetNodeResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCOverworldDevResetNodeResponse`
pub mod cmsg_client_to_gcoverworld_dev_reset_node_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCOverworldDevResetNodeResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevResetNodeResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevResetNodeResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevResetNodeResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevResetNodeResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevResetNodeResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevResetNodeResponse.EResponse.k_eNotAllowed)
        k_eNotAllowed = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevResetNodeResponse.EResponse.k_eInvalidOverworld)
        k_eInvalidOverworld = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevResetNodeResponse.EResponse.k_eInvalidNode)
        k_eInvalidNode = 7,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                7 => ::std::option::Option::Some(EResponse::k_eInvalidNode),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNotAllowed" => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                "k_eInvalidOverworld" => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                "k_eInvalidNode" => ::std::option::Option::Some(EResponse::k_eInvalidNode),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNotAllowed,
            EResponse::k_eInvalidOverworld,
            EResponse::k_eInvalidNode,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldDevGrantTokens)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldDevGrantTokens {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldDevGrantTokens.overworld_id)
    pub overworld_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldDevGrantTokens.token_quantity)
    pub token_quantity: ::steam_vent_proto_common::protobuf::MessageField<CMsgOverworldTokenQuantity>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldDevGrantTokens.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldDevGrantTokens {
    fn default() -> &'a CMsgClientToGCOverworldDevGrantTokens {
        <CMsgClientToGCOverworldDevGrantTokens as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldDevGrantTokens {
    pub fn new() -> CMsgClientToGCOverworldDevGrantTokens {
        ::std::default::Default::default()
    }

    // optional uint32 overworld_id = 1;

    pub fn overworld_id(&self) -> u32 {
        self.overworld_id.unwrap_or(0)
    }

    pub fn clear_overworld_id(&mut self) {
        self.overworld_id = ::std::option::Option::None;
    }

    pub fn has_overworld_id(&self) -> bool {
        self.overworld_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overworld_id(&mut self, v: u32) {
        self.overworld_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldDevGrantTokens {
    const NAME: &'static str = "CMsgClientToGCOverworldDevGrantTokens";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.overworld_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.token_quantity)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.overworld_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.token_quantity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.overworld_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.token_quantity.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldDevGrantTokens {
        CMsgClientToGCOverworldDevGrantTokens::new()
    }

    fn clear(&mut self) {
        self.overworld_id = ::std::option::Option::None;
        self.token_quantity.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldDevGrantTokens {
        static instance: CMsgClientToGCOverworldDevGrantTokens = CMsgClientToGCOverworldDevGrantTokens {
            overworld_id: ::std::option::Option::None,
            token_quantity: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldDevGrantTokensResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldDevGrantTokensResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldDevGrantTokensResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcoverworld_dev_grant_tokens_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldDevGrantTokensResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldDevGrantTokensResponse {
    fn default() -> &'a CMsgClientToGCOverworldDevGrantTokensResponse {
        <CMsgClientToGCOverworldDevGrantTokensResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldDevGrantTokensResponse {
    pub fn new() -> CMsgClientToGCOverworldDevGrantTokensResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCOverworldDevGrantTokensResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcoverworld_dev_grant_tokens_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcoverworld_dev_grant_tokens_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcoverworld_dev_grant_tokens_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcoverworld_dev_grant_tokens_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldDevGrantTokensResponse {
    const NAME: &'static str = "CMsgClientToGCOverworldDevGrantTokensResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldDevGrantTokensResponse {
        CMsgClientToGCOverworldDevGrantTokensResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldDevGrantTokensResponse {
        static instance: CMsgClientToGCOverworldDevGrantTokensResponse = CMsgClientToGCOverworldDevGrantTokensResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCOverworldDevGrantTokensResponse`
pub mod cmsg_client_to_gcoverworld_dev_grant_tokens_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCOverworldDevGrantTokensResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevGrantTokensResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevGrantTokensResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevGrantTokensResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevGrantTokensResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevGrantTokensResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevGrantTokensResponse.EResponse.k_eNotAllowed)
        k_eNotAllowed = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevGrantTokensResponse.EResponse.k_eInvalidOverworld)
        k_eInvalidOverworld = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNotAllowed" => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                "k_eInvalidOverworld" => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNotAllowed,
            EResponse::k_eInvalidOverworld,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldDevClearInventory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldDevClearInventory {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldDevClearInventory.overworld_id)
    pub overworld_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldDevClearInventory.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldDevClearInventory {
    fn default() -> &'a CMsgClientToGCOverworldDevClearInventory {
        <CMsgClientToGCOverworldDevClearInventory as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldDevClearInventory {
    pub fn new() -> CMsgClientToGCOverworldDevClearInventory {
        ::std::default::Default::default()
    }

    // optional uint32 overworld_id = 1;

    pub fn overworld_id(&self) -> u32 {
        self.overworld_id.unwrap_or(0)
    }

    pub fn clear_overworld_id(&mut self) {
        self.overworld_id = ::std::option::Option::None;
    }

    pub fn has_overworld_id(&self) -> bool {
        self.overworld_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overworld_id(&mut self, v: u32) {
        self.overworld_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldDevClearInventory {
    const NAME: &'static str = "CMsgClientToGCOverworldDevClearInventory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.overworld_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.overworld_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.overworld_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldDevClearInventory {
        CMsgClientToGCOverworldDevClearInventory::new()
    }

    fn clear(&mut self) {
        self.overworld_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldDevClearInventory {
        static instance: CMsgClientToGCOverworldDevClearInventory = CMsgClientToGCOverworldDevClearInventory {
            overworld_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldDevClearInventoryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldDevClearInventoryResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldDevClearInventoryResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcoverworld_dev_clear_inventory_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldDevClearInventoryResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldDevClearInventoryResponse {
    fn default() -> &'a CMsgClientToGCOverworldDevClearInventoryResponse {
        <CMsgClientToGCOverworldDevClearInventoryResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldDevClearInventoryResponse {
    pub fn new() -> CMsgClientToGCOverworldDevClearInventoryResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCOverworldDevClearInventoryResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcoverworld_dev_clear_inventory_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcoverworld_dev_clear_inventory_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcoverworld_dev_clear_inventory_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcoverworld_dev_clear_inventory_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldDevClearInventoryResponse {
    const NAME: &'static str = "CMsgClientToGCOverworldDevClearInventoryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldDevClearInventoryResponse {
        CMsgClientToGCOverworldDevClearInventoryResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldDevClearInventoryResponse {
        static instance: CMsgClientToGCOverworldDevClearInventoryResponse = CMsgClientToGCOverworldDevClearInventoryResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCOverworldDevClearInventoryResponse`
pub mod cmsg_client_to_gcoverworld_dev_clear_inventory_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCOverworldDevClearInventoryResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevClearInventoryResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevClearInventoryResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevClearInventoryResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevClearInventoryResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevClearInventoryResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevClearInventoryResponse.EResponse.k_eNotAllowed)
        k_eNotAllowed = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldDevClearInventoryResponse.EResponse.k_eInvalidOverworld)
        k_eInvalidOverworld = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNotAllowed" => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                "k_eInvalidOverworld" => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNotAllowed,
            EResponse::k_eInvalidOverworld,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldFeedback)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldFeedback {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldFeedback.language)
    pub language: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldFeedback.overworld_id)
    pub overworld_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldFeedback.feedback)
    pub feedback: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldFeedback.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldFeedback {
    fn default() -> &'a CMsgClientToGCOverworldFeedback {
        <CMsgClientToGCOverworldFeedback as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldFeedback {
    pub fn new() -> CMsgClientToGCOverworldFeedback {
        ::std::default::Default::default()
    }

    // optional uint32 language = 1;

    pub fn language(&self) -> u32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: u32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional uint32 overworld_id = 2;

    pub fn overworld_id(&self) -> u32 {
        self.overworld_id.unwrap_or(0)
    }

    pub fn clear_overworld_id(&mut self) {
        self.overworld_id = ::std::option::Option::None;
    }

    pub fn has_overworld_id(&self) -> bool {
        self.overworld_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overworld_id(&mut self, v: u32) {
        self.overworld_id = ::std::option::Option::Some(v);
    }

    // optional string feedback = 3;

    pub fn feedback(&self) -> &str {
        match self.feedback.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_feedback(&mut self) {
        self.feedback = ::std::option::Option::None;
    }

    pub fn has_feedback(&self) -> bool {
        self.feedback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feedback(&mut self, v: ::std::string::String) {
        self.feedback = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feedback(&mut self) -> &mut ::std::string::String {
        if self.feedback.is_none() {
            self.feedback = ::std::option::Option::Some(::std::string::String::new());
        }
        self.feedback.as_mut().unwrap()
    }

    // Take field
    pub fn take_feedback(&mut self) -> ::std::string::String {
        self.feedback.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldFeedback {
    const NAME: &'static str = "CMsgClientToGCOverworldFeedback";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.language = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.overworld_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.feedback = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.language {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.overworld_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.feedback.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.language {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.overworld_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.feedback.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldFeedback {
        CMsgClientToGCOverworldFeedback::new()
    }

    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.overworld_id = ::std::option::Option::None;
        self.feedback = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldFeedback {
        static instance: CMsgClientToGCOverworldFeedback = CMsgClientToGCOverworldFeedback {
            language: ::std::option::Option::None,
            overworld_id: ::std::option::Option::None,
            feedback: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldFeedbackResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldFeedbackResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldFeedbackResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcoverworld_feedback_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldFeedbackResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldFeedbackResponse {
    fn default() -> &'a CMsgClientToGCOverworldFeedbackResponse {
        <CMsgClientToGCOverworldFeedbackResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldFeedbackResponse {
    pub fn new() -> CMsgClientToGCOverworldFeedbackResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCOverworldFeedbackResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcoverworld_feedback_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcoverworld_feedback_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcoverworld_feedback_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcoverworld_feedback_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldFeedbackResponse {
    const NAME: &'static str = "CMsgClientToGCOverworldFeedbackResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldFeedbackResponse {
        CMsgClientToGCOverworldFeedbackResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldFeedbackResponse {
        static instance: CMsgClientToGCOverworldFeedbackResponse = CMsgClientToGCOverworldFeedbackResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCOverworldFeedbackResponse`
pub mod cmsg_client_to_gcoverworld_feedback_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCOverworldFeedbackResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldFeedbackResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldFeedbackResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldFeedbackResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldFeedbackResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldFeedbackResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldFeedbackResponse.EResponse.k_eNotAllowed)
        k_eNotAllowed = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldFeedbackResponse.EResponse.k_eInvalidOverworld)
        k_eInvalidOverworld = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNotAllowed" => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                "k_eInvalidOverworld" => ::std::option::Option::Some(EResponse::k_eInvalidOverworld),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eNotAllowed,
            EResponse::k_eInvalidOverworld,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldGetDynamicImage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldGetDynamicImage {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldGetDynamicImage.magic)
    pub magic: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldGetDynamicImage.image_id)
    pub image_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldGetDynamicImage.language)
    pub language: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldGetDynamicImage.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldGetDynamicImage {
    fn default() -> &'a CMsgClientToGCOverworldGetDynamicImage {
        <CMsgClientToGCOverworldGetDynamicImage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldGetDynamicImage {
    pub fn new() -> CMsgClientToGCOverworldGetDynamicImage {
        ::std::default::Default::default()
    }

    // optional uint32 magic = 1;

    pub fn magic(&self) -> u32 {
        self.magic.unwrap_or(0)
    }

    pub fn clear_magic(&mut self) {
        self.magic = ::std::option::Option::None;
    }

    pub fn has_magic(&self) -> bool {
        self.magic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_magic(&mut self, v: u32) {
        self.magic = ::std::option::Option::Some(v);
    }

    // optional uint32 image_id = 2;

    pub fn image_id(&self) -> u32 {
        self.image_id.unwrap_or(0)
    }

    pub fn clear_image_id(&mut self) {
        self.image_id = ::std::option::Option::None;
    }

    pub fn has_image_id(&self) -> bool {
        self.image_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_id(&mut self, v: u32) {
        self.image_id = ::std::option::Option::Some(v);
    }

    // optional uint32 language = 3;

    pub fn language(&self) -> u32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: u32) {
        self.language = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldGetDynamicImage {
    const NAME: &'static str = "CMsgClientToGCOverworldGetDynamicImage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.magic = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.image_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.language = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.magic {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.image_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.language {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.magic {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.image_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.language {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldGetDynamicImage {
        CMsgClientToGCOverworldGetDynamicImage::new()
    }

    fn clear(&mut self) {
        self.magic = ::std::option::Option::None;
        self.image_id = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldGetDynamicImage {
        static instance: CMsgClientToGCOverworldGetDynamicImage = CMsgClientToGCOverworldGetDynamicImage {
            magic: ::std::option::Option::None,
            image_id: ::std::option::Option::None,
            language: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCOverworldGetDynamicImageResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverworldGetDynamicImageResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldGetDynamicImageResponse.image_id)
    pub image_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCOverworldGetDynamicImageResponse.images)
    pub images: ::std::vec::Vec<cmsg_client_to_gcoverworld_get_dynamic_image_response::Image>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldGetDynamicImageResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverworldGetDynamicImageResponse {
    fn default() -> &'a CMsgClientToGCOverworldGetDynamicImageResponse {
        <CMsgClientToGCOverworldGetDynamicImageResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverworldGetDynamicImageResponse {
    pub fn new() -> CMsgClientToGCOverworldGetDynamicImageResponse {
        ::std::default::Default::default()
    }

    // optional uint32 image_id = 1;

    pub fn image_id(&self) -> u32 {
        self.image_id.unwrap_or(0)
    }

    pub fn clear_image_id(&mut self) {
        self.image_id = ::std::option::Option::None;
    }

    pub fn has_image_id(&self) -> bool {
        self.image_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_id(&mut self, v: u32) {
        self.image_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverworldGetDynamicImageResponse {
    const NAME: &'static str = "CMsgClientToGCOverworldGetDynamicImageResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.image_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.images.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.image_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.images {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.image_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.images {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverworldGetDynamicImageResponse {
        CMsgClientToGCOverworldGetDynamicImageResponse::new()
    }

    fn clear(&mut self) {
        self.image_id = ::std::option::Option::None;
        self.images.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverworldGetDynamicImageResponse {
        static instance: CMsgClientToGCOverworldGetDynamicImageResponse = CMsgClientToGCOverworldGetDynamicImageResponse {
            image_id: ::std::option::Option::None,
            images: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCOverworldGetDynamicImageResponse`
pub mod cmsg_client_to_gcoverworld_get_dynamic_image_response {
    // @@protoc_insertion_point(message:CMsgClientToGCOverworldGetDynamicImageResponse.Image)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Image {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCOverworldGetDynamicImageResponse.Image.width)
        pub width: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCOverworldGetDynamicImageResponse.Image.height)
        pub height: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCOverworldGetDynamicImageResponse.Image.format)
        pub format: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EDynamicImageFormat>>,
        // @@protoc_insertion_point(field:CMsgClientToGCOverworldGetDynamicImageResponse.Image.image_bytes)
        pub image_bytes: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCOverworldGetDynamicImageResponse.Image.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Image {
        fn default() -> &'a Image {
            <Image as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Image {
        pub fn new() -> Image {
            ::std::default::Default::default()
        }

        // optional uint32 width = 1;

        pub fn width(&self) -> u32 {
            self.width.unwrap_or(0)
        }

        pub fn clear_width(&mut self) {
            self.width = ::std::option::Option::None;
        }

        pub fn has_width(&self) -> bool {
            self.width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_width(&mut self, v: u32) {
            self.width = ::std::option::Option::Some(v);
        }

        // optional uint32 height = 2;

        pub fn height(&self) -> u32 {
            self.height.unwrap_or(0)
        }

        pub fn clear_height(&mut self) {
            self.height = ::std::option::Option::None;
        }

        pub fn has_height(&self) -> bool {
            self.height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_height(&mut self, v: u32) {
            self.height = ::std::option::Option::Some(v);
        }

        // optional .CMsgClientToGCOverworldGetDynamicImageResponse.EDynamicImageFormat format = 3;

        pub fn format(&self) -> EDynamicImageFormat {
            match self.format {
                Some(e) => e.enum_value_or(EDynamicImageFormat::k_eUnknown),
                None => EDynamicImageFormat::k_eUnknown,
            }
        }

        pub fn clear_format(&mut self) {
            self.format = ::std::option::Option::None;
        }

        pub fn has_format(&self) -> bool {
            self.format.is_some()
        }

        // Param is passed by value, moved
        pub fn set_format(&mut self, v: EDynamicImageFormat) {
            self.format = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional bytes image_bytes = 4;

        pub fn image_bytes(&self) -> &[u8] {
            match self.image_bytes.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_image_bytes(&mut self) {
            self.image_bytes = ::std::option::Option::None;
        }

        pub fn has_image_bytes(&self) -> bool {
            self.image_bytes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_image_bytes(&mut self, v: ::std::vec::Vec<u8>) {
            self.image_bytes = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_image_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.image_bytes.is_none() {
                self.image_bytes = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.image_bytes.as_mut().unwrap()
        }

        // Take field
        pub fn take_image_bytes(&mut self) -> ::std::vec::Vec<u8> {
            self.image_bytes.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Image {
        const NAME: &'static str = "Image";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.width = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.height = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.format = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    34 => {
                        self.image_bytes = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.width {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.height {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.format {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
            }
            if let Some(v) = self.image_bytes.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(4, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.width {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.height {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.format {
                os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.image_bytes.as_ref() {
                os.write_bytes(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Image {
            Image::new()
        }

        fn clear(&mut self) {
            self.width = ::std::option::Option::None;
            self.height = ::std::option::Option::None;
            self.format = ::std::option::Option::None;
            self.image_bytes = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Image {
            static instance: Image = Image {
                width: ::std::option::Option::None,
                height: ::std::option::Option::None,
                format: ::std::option::Option::None,
                image_bytes: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCOverworldGetDynamicImageResponse.EDynamicImageFormat)
    pub enum EDynamicImageFormat {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldGetDynamicImageResponse.EDynamicImageFormat.k_eUnknown)
        k_eUnknown = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldGetDynamicImageResponse.EDynamicImageFormat.k_ePNG)
        k_ePNG = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOverworldGetDynamicImageResponse.EDynamicImageFormat.k_eData)
        k_eData = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EDynamicImageFormat {
        const NAME: &'static str = "EDynamicImageFormat";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EDynamicImageFormat> {
            match value {
                0 => ::std::option::Option::Some(EDynamicImageFormat::k_eUnknown),
                1 => ::std::option::Option::Some(EDynamicImageFormat::k_ePNG),
                2 => ::std::option::Option::Some(EDynamicImageFormat::k_eData),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EDynamicImageFormat> {
            match str {
                "k_eUnknown" => ::std::option::Option::Some(EDynamicImageFormat::k_eUnknown),
                "k_ePNG" => ::std::option::Option::Some(EDynamicImageFormat::k_ePNG),
                "k_eData" => ::std::option::Option::Some(EDynamicImageFormat::k_eData),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EDynamicImageFormat] = &[
            EDynamicImageFormat::k_eUnknown,
            EDynamicImageFormat::k_ePNG,
            EDynamicImageFormat::k_eData,
        ];
    }

    impl ::std::default::Default for EDynamicImageFormat {
        fn default() -> Self {
            EDynamicImageFormat::k_eUnknown
        }
    }

}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EOverworldNodeState)
pub enum EOverworldNodeState {
    // @@protoc_insertion_point(enum_value:EOverworldNodeState.k_eOverworldNodeState_Invalid)
    k_eOverworldNodeState_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EOverworldNodeState.k_eOverworldNodeState_Locked)
    k_eOverworldNodeState_Locked = 1,
    // @@protoc_insertion_point(enum_value:EOverworldNodeState.k_eOverworldNodeState_Unlocked)
    k_eOverworldNodeState_Unlocked = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for EOverworldNodeState {
    const NAME: &'static str = "EOverworldNodeState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EOverworldNodeState> {
        match value {
            0 => ::std::option::Option::Some(EOverworldNodeState::k_eOverworldNodeState_Invalid),
            1 => ::std::option::Option::Some(EOverworldNodeState::k_eOverworldNodeState_Locked),
            2 => ::std::option::Option::Some(EOverworldNodeState::k_eOverworldNodeState_Unlocked),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EOverworldNodeState> {
        match str {
            "k_eOverworldNodeState_Invalid" => ::std::option::Option::Some(EOverworldNodeState::k_eOverworldNodeState_Invalid),
            "k_eOverworldNodeState_Locked" => ::std::option::Option::Some(EOverworldNodeState::k_eOverworldNodeState_Locked),
            "k_eOverworldNodeState_Unlocked" => ::std::option::Option::Some(EOverworldNodeState::k_eOverworldNodeState_Unlocked),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EOverworldNodeState] = &[
        EOverworldNodeState::k_eOverworldNodeState_Invalid,
        EOverworldNodeState::k_eOverworldNodeState_Locked,
        EOverworldNodeState::k_eOverworldNodeState_Unlocked,
    ];
}

impl ::std::default::Default for EOverworldNodeState {
    fn default() -> Self {
        EOverworldNodeState::k_eOverworldNodeState_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EOverworldAuditAction)
pub enum EOverworldAuditAction {
    // @@protoc_insertion_point(enum_value:EOverworldAuditAction.k_eOverworldAuditAction_Invalid)
    k_eOverworldAuditAction_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EOverworldAuditAction.k_eOverworldAuditAction_DevModifyTokens)
    k_eOverworldAuditAction_DevModifyTokens = 1,
    // @@protoc_insertion_point(enum_value:EOverworldAuditAction.k_eOverworldAuditAction_DevClearInventory)
    k_eOverworldAuditAction_DevClearInventory = 2,
    // @@protoc_insertion_point(enum_value:EOverworldAuditAction.k_eOverworldAuditAction_DevGrantTokens)
    k_eOverworldAuditAction_DevGrantTokens = 3,
    // @@protoc_insertion_point(enum_value:EOverworldAuditAction.k_eOverworldAuditAction_CompletePath)
    k_eOverworldAuditAction_CompletePath = 4,
    // @@protoc_insertion_point(enum_value:EOverworldAuditAction.k_eOverworldAuditAction_ClaimEncounterReward)
    k_eOverworldAuditAction_ClaimEncounterReward = 5,
    // @@protoc_insertion_point(enum_value:EOverworldAuditAction.k_eOverworldAuditAction_DevResetNode)
    k_eOverworldAuditAction_DevResetNode = 6,
    // @@protoc_insertion_point(enum_value:EOverworldAuditAction.k_eOverworldAuditAction_DevResetPath)
    k_eOverworldAuditAction_DevResetPath = 7,
    // @@protoc_insertion_point(enum_value:EOverworldAuditAction.k_eOverworldAuditAction_MatchRewardsFull)
    k_eOverworldAuditAction_MatchRewardsFull = 8,
    // @@protoc_insertion_point(enum_value:EOverworldAuditAction.k_eOverworldAuditAction_MatchRewardsHalf)
    k_eOverworldAuditAction_MatchRewardsHalf = 9,
    // @@protoc_insertion_point(enum_value:EOverworldAuditAction.k_eOverworldAuditAction_EventActionTokenGrant)
    k_eOverworldAuditAction_EventActionTokenGrant = 10,
    // @@protoc_insertion_point(enum_value:EOverworldAuditAction.k_eOverworldAuditAction_TokenTraderLost)
    k_eOverworldAuditAction_TokenTraderLost = 11,
    // @@protoc_insertion_point(enum_value:EOverworldAuditAction.k_eOverworldAuditAction_TokenTraderGained)
    k_eOverworldAuditAction_TokenTraderGained = 12,
    // @@protoc_insertion_point(enum_value:EOverworldAuditAction.k_eOverworldAuditAction_EncounterRewardTokenCost)
    k_eOverworldAuditAction_EncounterRewardTokenCost = 13,
    // @@protoc_insertion_point(enum_value:EOverworldAuditAction.k_eOverworldAuditAction_EncounterRewardTokenReward)
    k_eOverworldAuditAction_EncounterRewardTokenReward = 14,
    // @@protoc_insertion_point(enum_value:EOverworldAuditAction.k_eOverworldAuditAction_SupportGrantTokens)
    k_eOverworldAuditAction_SupportGrantTokens = 16,
    // @@protoc_insertion_point(enum_value:EOverworldAuditAction.k_eOverworldAuditAction_TokenGiftSent)
    k_eOverworldAuditAction_TokenGiftSent = 17,
}

impl ::steam_vent_proto_common::protobuf::Enum for EOverworldAuditAction {
    const NAME: &'static str = "EOverworldAuditAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EOverworldAuditAction> {
        match value {
            0 => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_Invalid),
            1 => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_DevModifyTokens),
            2 => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_DevClearInventory),
            3 => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_DevGrantTokens),
            4 => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_CompletePath),
            5 => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_ClaimEncounterReward),
            6 => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_DevResetNode),
            7 => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_DevResetPath),
            8 => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_MatchRewardsFull),
            9 => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_MatchRewardsHalf),
            10 => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_EventActionTokenGrant),
            11 => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_TokenTraderLost),
            12 => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_TokenTraderGained),
            13 => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_EncounterRewardTokenCost),
            14 => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_EncounterRewardTokenReward),
            16 => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_SupportGrantTokens),
            17 => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_TokenGiftSent),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EOverworldAuditAction> {
        match str {
            "k_eOverworldAuditAction_Invalid" => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_Invalid),
            "k_eOverworldAuditAction_DevModifyTokens" => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_DevModifyTokens),
            "k_eOverworldAuditAction_DevClearInventory" => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_DevClearInventory),
            "k_eOverworldAuditAction_DevGrantTokens" => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_DevGrantTokens),
            "k_eOverworldAuditAction_CompletePath" => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_CompletePath),
            "k_eOverworldAuditAction_ClaimEncounterReward" => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_ClaimEncounterReward),
            "k_eOverworldAuditAction_DevResetNode" => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_DevResetNode),
            "k_eOverworldAuditAction_DevResetPath" => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_DevResetPath),
            "k_eOverworldAuditAction_MatchRewardsFull" => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_MatchRewardsFull),
            "k_eOverworldAuditAction_MatchRewardsHalf" => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_MatchRewardsHalf),
            "k_eOverworldAuditAction_EventActionTokenGrant" => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_EventActionTokenGrant),
            "k_eOverworldAuditAction_TokenTraderLost" => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_TokenTraderLost),
            "k_eOverworldAuditAction_TokenTraderGained" => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_TokenTraderGained),
            "k_eOverworldAuditAction_EncounterRewardTokenCost" => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_EncounterRewardTokenCost),
            "k_eOverworldAuditAction_EncounterRewardTokenReward" => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_EncounterRewardTokenReward),
            "k_eOverworldAuditAction_SupportGrantTokens" => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_SupportGrantTokens),
            "k_eOverworldAuditAction_TokenGiftSent" => ::std::option::Option::Some(EOverworldAuditAction::k_eOverworldAuditAction_TokenGiftSent),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EOverworldAuditAction] = &[
        EOverworldAuditAction::k_eOverworldAuditAction_Invalid,
        EOverworldAuditAction::k_eOverworldAuditAction_DevModifyTokens,
        EOverworldAuditAction::k_eOverworldAuditAction_DevClearInventory,
        EOverworldAuditAction::k_eOverworldAuditAction_DevGrantTokens,
        EOverworldAuditAction::k_eOverworldAuditAction_CompletePath,
        EOverworldAuditAction::k_eOverworldAuditAction_ClaimEncounterReward,
        EOverworldAuditAction::k_eOverworldAuditAction_DevResetNode,
        EOverworldAuditAction::k_eOverworldAuditAction_DevResetPath,
        EOverworldAuditAction::k_eOverworldAuditAction_MatchRewardsFull,
        EOverworldAuditAction::k_eOverworldAuditAction_MatchRewardsHalf,
        EOverworldAuditAction::k_eOverworldAuditAction_EventActionTokenGrant,
        EOverworldAuditAction::k_eOverworldAuditAction_TokenTraderLost,
        EOverworldAuditAction::k_eOverworldAuditAction_TokenTraderGained,
        EOverworldAuditAction::k_eOverworldAuditAction_EncounterRewardTokenCost,
        EOverworldAuditAction::k_eOverworldAuditAction_EncounterRewardTokenReward,
        EOverworldAuditAction::k_eOverworldAuditAction_SupportGrantTokens,
        EOverworldAuditAction::k_eOverworldAuditAction_TokenGiftSent,
    ];
}

impl ::std::default::Default for EOverworldAuditAction {
    fn default() -> Self {
        EOverworldAuditAction::k_eOverworldAuditAction_Invalid
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::steammessages::*;
#[allow(unused_imports)]
use crate::dota_shared_enums::*;
#[allow(unused_imports)]
use crate::dota_gcmessages_common::*;
#[allow(unused_imports)]
use crate::gcsdk_gcmessages::*;
impl ::steam_vent_proto_common::RpcMessage for CMsgOverworldTokenCount {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgOverworldTokenQuantity {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgOverworldEncounterTokenTreasureData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgOverworldEncounterTokenTreasureData {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgOverworldEncounterTokenTreasureData;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgOverworldEncounterTokenQuestData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgOverworldEncounterTokenQuestData {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgOverworldEncounterTokenQuestData;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgOverworldHeroList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgOverworldEncounterChooseHeroData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgOverworldEncounterChooseHeroData {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgOverworldEncounterChooseHeroData;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgOverworldEncounterProgressData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgOverworldEncounterProgressData {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgOverworldEncounterProgressData;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgOverworldEncounterData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgOverworldNode {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgOverworldPath {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgOverworldUserData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgOverworldMatchRewards {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCOverworldGetUserData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldGetUserData {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldGetUserData;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCOverworldGetUserDataResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldGetUserDataResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldGetUserDataResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientOverworldUserDataUpdated {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientOverworldUserDataUpdated {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientOverworldUserDataUpdated;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCOverworldCompletePath {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldCompletePath {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldCompletePath;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCOverworldCompletePathResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldCompletePathResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldCompletePathResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgOverworldEncounterPitFighterRewardData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgOverworldEncounterPitFighterRewardData {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgOverworldEncounterPitFighterRewardData;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCOverworldClaimEncounterReward {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldClaimEncounterReward {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldClaimEncounterReward;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCOverworldClaimEncounterRewardResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldClaimEncounterRewardResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldClaimEncounterRewardResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCOverworldVisitEncounter {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldVisitEncounter {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldVisitEncounter;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCOverworldVisitEncounterResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldVisitEncounterResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldVisitEncounterResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCOverworldMoveToNode {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldMoveToNode {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldMoveToNode;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCOverworldMoveToNodeResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldMoveToNodeResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldMoveToNodeResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCOverworldTradeTokens {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldTradeTokens {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldTradeTokens;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCOverworldTradeTokensResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldTradeTokensResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldTradeTokensResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCOverworldGiftTokens {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldGiftTokens {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldGiftTokens;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCOverworldGiftTokensResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldGiftTokensResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldGiftTokensResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCOverworldDevResetAll {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldDevResetAll {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldDevResetAll;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCOverworldDevResetAllResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldDevResetAllResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldDevResetAllResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCOverworldDevResetNode {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldDevResetNode {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldDevResetNode;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCOverworldDevResetNodeResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldDevResetNodeResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldDevResetNodeResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCOverworldDevGrantTokens {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldDevGrantTokens {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldDevGrantTokens;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCOverworldDevGrantTokensResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldDevGrantTokensResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldDevGrantTokensResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCOverworldDevClearInventory {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldDevClearInventory {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldDevClearInventory;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCOverworldDevClearInventoryResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldDevClearInventoryResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldDevClearInventoryResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCOverworldFeedback {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCOverworldFeedback {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldFeedback;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCOverworldFeedbackResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldFeedbackResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldFeedbackResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCOverworldGetDynamicImage {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldGetDynamicImage {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldGetDynamicImage;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCOverworldGetDynamicImageResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverworldGetDynamicImageResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverworldGetDynamicImageResponse;
}
