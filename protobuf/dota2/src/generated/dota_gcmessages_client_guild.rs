// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_client_guild.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CMsgGuildInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgGuildInfo.guild_name)
    pub guild_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGuildInfo.guild_tag)
    pub guild_tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGuildInfo.created_timestamp)
    pub created_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildInfo.guild_language)
    pub guild_language: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildInfo.guild_flags)
    pub guild_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildInfo.guild_logo)
    pub guild_logo: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGuildInfo.guild_region)
    pub guild_region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildInfo.guild_chat_group_id)
    pub guild_chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGuildInfo.guild_description)
    pub guild_description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGuildInfo.default_chat_channel_id)
    pub default_chat_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGuildInfo.guild_primary_color)
    pub guild_primary_color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildInfo.guild_secondary_color)
    pub guild_secondary_color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildInfo.guild_pattern)
    pub guild_pattern: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildInfo.guild_refresh_time_offset)
    pub guild_refresh_time_offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildInfo.guild_required_rank_tier)
    pub guild_required_rank_tier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildInfo.guild_motd_timestamp)
    pub guild_motd_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildInfo.guild_motd)
    pub guild_motd: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGuildInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildInfo {
    fn default() -> &'a CMsgGuildInfo {
        <CMsgGuildInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildInfo {
    pub fn new() -> CMsgGuildInfo {
        ::std::default::Default::default()
    }

    // optional string guild_name = 1;

    pub fn guild_name(&self) -> &str {
        match self.guild_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_guild_name(&mut self) {
        self.guild_name = ::std::option::Option::None;
    }

    pub fn has_guild_name(&self) -> bool {
        self.guild_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_name(&mut self, v: ::std::string::String) {
        self.guild_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guild_name(&mut self) -> &mut ::std::string::String {
        if self.guild_name.is_none() {
            self.guild_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.guild_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_guild_name(&mut self) -> ::std::string::String {
        self.guild_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string guild_tag = 2;

    pub fn guild_tag(&self) -> &str {
        match self.guild_tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_guild_tag(&mut self) {
        self.guild_tag = ::std::option::Option::None;
    }

    pub fn has_guild_tag(&self) -> bool {
        self.guild_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_tag(&mut self, v: ::std::string::String) {
        self.guild_tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guild_tag(&mut self) -> &mut ::std::string::String {
        if self.guild_tag.is_none() {
            self.guild_tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.guild_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_guild_tag(&mut self) -> ::std::string::String {
        self.guild_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 created_timestamp = 3;

    pub fn created_timestamp(&self) -> u32 {
        self.created_timestamp.unwrap_or(0)
    }

    pub fn clear_created_timestamp(&mut self) {
        self.created_timestamp = ::std::option::Option::None;
    }

    pub fn has_created_timestamp(&self) -> bool {
        self.created_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_timestamp(&mut self, v: u32) {
        self.created_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_language = 4;

    pub fn guild_language(&self) -> u32 {
        self.guild_language.unwrap_or(0)
    }

    pub fn clear_guild_language(&mut self) {
        self.guild_language = ::std::option::Option::None;
    }

    pub fn has_guild_language(&self) -> bool {
        self.guild_language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_language(&mut self, v: u32) {
        self.guild_language = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_flags = 5;

    pub fn guild_flags(&self) -> u32 {
        self.guild_flags.unwrap_or(0)
    }

    pub fn clear_guild_flags(&mut self) {
        self.guild_flags = ::std::option::Option::None;
    }

    pub fn has_guild_flags(&self) -> bool {
        self.guild_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_flags(&mut self, v: u32) {
        self.guild_flags = ::std::option::Option::Some(v);
    }

    // optional uint64 guild_logo = 7;

    pub fn guild_logo(&self) -> u64 {
        self.guild_logo.unwrap_or(0)
    }

    pub fn clear_guild_logo(&mut self) {
        self.guild_logo = ::std::option::Option::None;
    }

    pub fn has_guild_logo(&self) -> bool {
        self.guild_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_logo(&mut self, v: u64) {
        self.guild_logo = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_region = 8;

    pub fn guild_region(&self) -> u32 {
        self.guild_region.unwrap_or(0)
    }

    pub fn clear_guild_region(&mut self) {
        self.guild_region = ::std::option::Option::None;
    }

    pub fn has_guild_region(&self) -> bool {
        self.guild_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_region(&mut self, v: u32) {
        self.guild_region = ::std::option::Option::Some(v);
    }

    // optional uint64 guild_chat_group_id = 9;

    pub fn guild_chat_group_id(&self) -> u64 {
        self.guild_chat_group_id.unwrap_or(0)
    }

    pub fn clear_guild_chat_group_id(&mut self) {
        self.guild_chat_group_id = ::std::option::Option::None;
    }

    pub fn has_guild_chat_group_id(&self) -> bool {
        self.guild_chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_chat_group_id(&mut self, v: u64) {
        self.guild_chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string guild_description = 10;

    pub fn guild_description(&self) -> &str {
        match self.guild_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_guild_description(&mut self) {
        self.guild_description = ::std::option::Option::None;
    }

    pub fn has_guild_description(&self) -> bool {
        self.guild_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_description(&mut self, v: ::std::string::String) {
        self.guild_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guild_description(&mut self) -> &mut ::std::string::String {
        if self.guild_description.is_none() {
            self.guild_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.guild_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_guild_description(&mut self) -> ::std::string::String {
        self.guild_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 default_chat_channel_id = 11;

    pub fn default_chat_channel_id(&self) -> u64 {
        self.default_chat_channel_id.unwrap_or(0)
    }

    pub fn clear_default_chat_channel_id(&mut self) {
        self.default_chat_channel_id = ::std::option::Option::None;
    }

    pub fn has_default_chat_channel_id(&self) -> bool {
        self.default_chat_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_chat_channel_id(&mut self, v: u64) {
        self.default_chat_channel_id = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_primary_color = 12;

    pub fn guild_primary_color(&self) -> u32 {
        self.guild_primary_color.unwrap_or(0)
    }

    pub fn clear_guild_primary_color(&mut self) {
        self.guild_primary_color = ::std::option::Option::None;
    }

    pub fn has_guild_primary_color(&self) -> bool {
        self.guild_primary_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_primary_color(&mut self, v: u32) {
        self.guild_primary_color = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_secondary_color = 13;

    pub fn guild_secondary_color(&self) -> u32 {
        self.guild_secondary_color.unwrap_or(0)
    }

    pub fn clear_guild_secondary_color(&mut self) {
        self.guild_secondary_color = ::std::option::Option::None;
    }

    pub fn has_guild_secondary_color(&self) -> bool {
        self.guild_secondary_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_secondary_color(&mut self, v: u32) {
        self.guild_secondary_color = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_pattern = 14;

    pub fn guild_pattern(&self) -> u32 {
        self.guild_pattern.unwrap_or(0)
    }

    pub fn clear_guild_pattern(&mut self) {
        self.guild_pattern = ::std::option::Option::None;
    }

    pub fn has_guild_pattern(&self) -> bool {
        self.guild_pattern.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_pattern(&mut self, v: u32) {
        self.guild_pattern = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_refresh_time_offset = 15;

    pub fn guild_refresh_time_offset(&self) -> u32 {
        self.guild_refresh_time_offset.unwrap_or(0)
    }

    pub fn clear_guild_refresh_time_offset(&mut self) {
        self.guild_refresh_time_offset = ::std::option::Option::None;
    }

    pub fn has_guild_refresh_time_offset(&self) -> bool {
        self.guild_refresh_time_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_refresh_time_offset(&mut self, v: u32) {
        self.guild_refresh_time_offset = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_required_rank_tier = 16;

    pub fn guild_required_rank_tier(&self) -> u32 {
        self.guild_required_rank_tier.unwrap_or(0)
    }

    pub fn clear_guild_required_rank_tier(&mut self) {
        self.guild_required_rank_tier = ::std::option::Option::None;
    }

    pub fn has_guild_required_rank_tier(&self) -> bool {
        self.guild_required_rank_tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_required_rank_tier(&mut self, v: u32) {
        self.guild_required_rank_tier = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_motd_timestamp = 17;

    pub fn guild_motd_timestamp(&self) -> u32 {
        self.guild_motd_timestamp.unwrap_or(0)
    }

    pub fn clear_guild_motd_timestamp(&mut self) {
        self.guild_motd_timestamp = ::std::option::Option::None;
    }

    pub fn has_guild_motd_timestamp(&self) -> bool {
        self.guild_motd_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_motd_timestamp(&mut self, v: u32) {
        self.guild_motd_timestamp = ::std::option::Option::Some(v);
    }

    // optional string guild_motd = 18;

    pub fn guild_motd(&self) -> &str {
        match self.guild_motd.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_guild_motd(&mut self) {
        self.guild_motd = ::std::option::Option::None;
    }

    pub fn has_guild_motd(&self) -> bool {
        self.guild_motd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_motd(&mut self, v: ::std::string::String) {
        self.guild_motd = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guild_motd(&mut self) -> &mut ::std::string::String {
        if self.guild_motd.is_none() {
            self.guild_motd = ::std::option::Option::Some(::std::string::String::new());
        }
        self.guild_motd.as_mut().unwrap()
    }

    // Take field
    pub fn take_guild_motd(&mut self) -> ::std::string::String {
        self.guild_motd.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGuildInfo {
    const NAME: &'static str = "CMsgGuildInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.guild_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.guild_tag = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.created_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.guild_language = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.guild_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.guild_logo = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.guild_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.guild_chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                82 => {
                    self.guild_description = ::std::option::Option::Some(is.read_string()?);
                },
                88 => {
                    self.default_chat_channel_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                96 => {
                    self.guild_primary_color = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.guild_secondary_color = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.guild_pattern = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.guild_refresh_time_offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.guild_required_rank_tier = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.guild_motd_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                146 => {
                    self.guild_motd = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.guild_tag.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.created_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.guild_language {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.guild_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.guild_logo {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.guild_region {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.guild_chat_group_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.guild_description.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.default_chat_channel_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(11, v);
        }
        if let Some(v) = self.guild_primary_color {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.guild_secondary_color {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.guild_pattern {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.guild_refresh_time_offset {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.guild_required_rank_tier {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.guild_motd_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.guild_motd.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(18, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.guild_tag.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.created_timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.guild_language {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.guild_flags {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.guild_logo {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.guild_region {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.guild_chat_group_id {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.guild_description.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.default_chat_channel_id {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.guild_primary_color {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.guild_secondary_color {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.guild_pattern {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.guild_refresh_time_offset {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.guild_required_rank_tier {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.guild_motd_timestamp {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.guild_motd.as_ref() {
            os.write_string(18, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildInfo {
        CMsgGuildInfo::new()
    }

    fn clear(&mut self) {
        self.guild_name = ::std::option::Option::None;
        self.guild_tag = ::std::option::Option::None;
        self.created_timestamp = ::std::option::Option::None;
        self.guild_language = ::std::option::Option::None;
        self.guild_flags = ::std::option::Option::None;
        self.guild_logo = ::std::option::Option::None;
        self.guild_region = ::std::option::Option::None;
        self.guild_chat_group_id = ::std::option::Option::None;
        self.guild_description = ::std::option::Option::None;
        self.default_chat_channel_id = ::std::option::Option::None;
        self.guild_primary_color = ::std::option::Option::None;
        self.guild_secondary_color = ::std::option::Option::None;
        self.guild_pattern = ::std::option::Option::None;
        self.guild_refresh_time_offset = ::std::option::Option::None;
        self.guild_required_rank_tier = ::std::option::Option::None;
        self.guild_motd_timestamp = ::std::option::Option::None;
        self.guild_motd = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildInfo {
        static instance: CMsgGuildInfo = CMsgGuildInfo {
            guild_name: ::std::option::Option::None,
            guild_tag: ::std::option::Option::None,
            created_timestamp: ::std::option::Option::None,
            guild_language: ::std::option::Option::None,
            guild_flags: ::std::option::Option::None,
            guild_logo: ::std::option::Option::None,
            guild_region: ::std::option::Option::None,
            guild_chat_group_id: ::std::option::Option::None,
            guild_description: ::std::option::Option::None,
            default_chat_channel_id: ::std::option::Option::None,
            guild_primary_color: ::std::option::Option::None,
            guild_secondary_color: ::std::option::Option::None,
            guild_pattern: ::std::option::Option::None,
            guild_refresh_time_offset: ::std::option::Option::None,
            guild_required_rank_tier: ::std::option::Option::None,
            guild_motd_timestamp: ::std::option::Option::None,
            guild_motd: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGuildSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildSummary {
    // message fields
    // @@protoc_insertion_point(field:CMsgGuildSummary.guild_info)
    pub guild_info: ::steam_vent_proto_common::protobuf::MessageField<CMsgGuildInfo>,
    // @@protoc_insertion_point(field:CMsgGuildSummary.member_count)
    pub member_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildSummary.event_points)
    pub event_points: ::std::vec::Vec<cmsg_guild_summary::EventPoints>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGuildSummary.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildSummary {
    fn default() -> &'a CMsgGuildSummary {
        <CMsgGuildSummary as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildSummary {
    pub fn new() -> CMsgGuildSummary {
        ::std::default::Default::default()
    }

    // optional uint32 member_count = 2;

    pub fn member_count(&self) -> u32 {
        self.member_count.unwrap_or(0)
    }

    pub fn clear_member_count(&mut self) {
        self.member_count = ::std::option::Option::None;
    }

    pub fn has_member_count(&self) -> bool {
        self.member_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member_count(&mut self, v: u32) {
        self.member_count = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGuildSummary {
    const NAME: &'static str = "CMsgGuildSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_info)?;
                },
                16 => {
                    self.member_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.event_points.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.member_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.event_points {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_info.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.member_count {
            os.write_uint32(2, v)?;
        }
        for v in &self.event_points {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildSummary {
        CMsgGuildSummary::new()
    }

    fn clear(&mut self) {
        self.guild_info.clear();
        self.member_count = ::std::option::Option::None;
        self.event_points.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildSummary {
        static instance: CMsgGuildSummary = CMsgGuildSummary {
            guild_info: ::steam_vent_proto_common::protobuf::MessageField::none(),
            member_count: ::std::option::Option::None,
            event_points: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGuildSummary`
pub mod cmsg_guild_summary {
    // @@protoc_insertion_point(message:CMsgGuildSummary.EventPoints)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct EventPoints {
        // message fields
        // @@protoc_insertion_point(field:CMsgGuildSummary.EventPoints.event_id)
        pub event_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGuildSummary.EventPoints.guild_points)
        pub guild_points: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGuildSummary.EventPoints.guild_rank)
        pub guild_rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGuildSummary.EventPoints.guild_weekly_rank)
        pub guild_weekly_rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGuildSummary.EventPoints.guild_weekly_percentile)
        pub guild_weekly_percentile: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGuildSummary.EventPoints.guild_current_percentile)
        pub guild_current_percentile: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGuildSummary.EventPoints.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EventPoints {
        fn default() -> &'a EventPoints {
            <EventPoints as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl EventPoints {
        pub fn new() -> EventPoints {
            ::std::default::Default::default()
        }

        // optional uint32 event_id = 1;

        pub fn event_id(&self) -> u32 {
            self.event_id.unwrap_or(0)
        }

        pub fn clear_event_id(&mut self) {
            self.event_id = ::std::option::Option::None;
        }

        pub fn has_event_id(&self) -> bool {
            self.event_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_id(&mut self, v: u32) {
            self.event_id = ::std::option::Option::Some(v);
        }

        // optional uint32 guild_points = 2;

        pub fn guild_points(&self) -> u32 {
            self.guild_points.unwrap_or(0)
        }

        pub fn clear_guild_points(&mut self) {
            self.guild_points = ::std::option::Option::None;
        }

        pub fn has_guild_points(&self) -> bool {
            self.guild_points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guild_points(&mut self, v: u32) {
            self.guild_points = ::std::option::Option::Some(v);
        }

        // optional uint32 guild_rank = 3;

        pub fn guild_rank(&self) -> u32 {
            self.guild_rank.unwrap_or(0)
        }

        pub fn clear_guild_rank(&mut self) {
            self.guild_rank = ::std::option::Option::None;
        }

        pub fn has_guild_rank(&self) -> bool {
            self.guild_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guild_rank(&mut self, v: u32) {
            self.guild_rank = ::std::option::Option::Some(v);
        }

        // optional uint32 guild_weekly_rank = 4;

        pub fn guild_weekly_rank(&self) -> u32 {
            self.guild_weekly_rank.unwrap_or(0)
        }

        pub fn clear_guild_weekly_rank(&mut self) {
            self.guild_weekly_rank = ::std::option::Option::None;
        }

        pub fn has_guild_weekly_rank(&self) -> bool {
            self.guild_weekly_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guild_weekly_rank(&mut self, v: u32) {
            self.guild_weekly_rank = ::std::option::Option::Some(v);
        }

        // optional uint32 guild_weekly_percentile = 5;

        pub fn guild_weekly_percentile(&self) -> u32 {
            self.guild_weekly_percentile.unwrap_or(0)
        }

        pub fn clear_guild_weekly_percentile(&mut self) {
            self.guild_weekly_percentile = ::std::option::Option::None;
        }

        pub fn has_guild_weekly_percentile(&self) -> bool {
            self.guild_weekly_percentile.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guild_weekly_percentile(&mut self, v: u32) {
            self.guild_weekly_percentile = ::std::option::Option::Some(v);
        }

        // optional uint32 guild_current_percentile = 6;

        pub fn guild_current_percentile(&self) -> u32 {
            self.guild_current_percentile.unwrap_or(0)
        }

        pub fn clear_guild_current_percentile(&mut self) {
            self.guild_current_percentile = ::std::option::Option::None;
        }

        pub fn has_guild_current_percentile(&self) -> bool {
            self.guild_current_percentile.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guild_current_percentile(&mut self, v: u32) {
            self.guild_current_percentile = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for EventPoints {
        const NAME: &'static str = "EventPoints";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.guild_points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.guild_rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.guild_weekly_rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.guild_weekly_percentile = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.guild_current_percentile = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.event_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.guild_points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.guild_rank {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.guild_weekly_rank {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.guild_weekly_percentile {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.guild_current_percentile {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.event_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.guild_points {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.guild_rank {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.guild_weekly_rank {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.guild_weekly_percentile {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.guild_current_percentile {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EventPoints {
            EventPoints::new()
        }

        fn clear(&mut self) {
            self.event_id = ::std::option::Option::None;
            self.guild_points = ::std::option::Option::None;
            self.guild_rank = ::std::option::Option::None;
            self.guild_weekly_rank = ::std::option::Option::None;
            self.guild_weekly_percentile = ::std::option::Option::None;
            self.guild_current_percentile = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EventPoints {
            static instance: EventPoints = EventPoints {
                event_id: ::std::option::Option::None,
                guild_points: ::std::option::Option::None,
                guild_rank: ::std::option::Option::None,
                guild_weekly_rank: ::std::option::Option::None,
                guild_weekly_percentile: ::std::option::Option::None,
                guild_current_percentile: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGuildRole)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildRole {
    // message fields
    // @@protoc_insertion_point(field:CMsgGuildRole.role_id)
    pub role_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildRole.role_name)
    pub role_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGuildRole.role_flags)
    pub role_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildRole.role_order)
    pub role_order: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGuildRole.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildRole {
    fn default() -> &'a CMsgGuildRole {
        <CMsgGuildRole as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildRole {
    pub fn new() -> CMsgGuildRole {
        ::std::default::Default::default()
    }

    // optional uint32 role_id = 1;

    pub fn role_id(&self) -> u32 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u32) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional string role_name = 2;

    pub fn role_name(&self) -> &str {
        match self.role_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_role_name(&mut self) {
        self.role_name = ::std::option::Option::None;
    }

    pub fn has_role_name(&self) -> bool {
        self.role_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_name(&mut self, v: ::std::string::String) {
        self.role_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role_name(&mut self) -> &mut ::std::string::String {
        if self.role_name.is_none() {
            self.role_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.role_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_role_name(&mut self) -> ::std::string::String {
        self.role_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 role_flags = 3;

    pub fn role_flags(&self) -> u32 {
        self.role_flags.unwrap_or(0)
    }

    pub fn clear_role_flags(&mut self) {
        self.role_flags = ::std::option::Option::None;
    }

    pub fn has_role_flags(&self) -> bool {
        self.role_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_flags(&mut self, v: u32) {
        self.role_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 role_order = 4;

    pub fn role_order(&self) -> u32 {
        self.role_order.unwrap_or(0)
    }

    pub fn clear_role_order(&mut self) {
        self.role_order = ::std::option::Option::None;
    }

    pub fn has_role_order(&self) -> bool {
        self.role_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_order(&mut self, v: u32) {
        self.role_order = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGuildRole {
    const NAME: &'static str = "CMsgGuildRole";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.role_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.role_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.role_order = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.role_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.role_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.role_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.role_order {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.role_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.role_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.role_flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.role_order {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildRole {
        CMsgGuildRole::new()
    }

    fn clear(&mut self) {
        self.role_id = ::std::option::Option::None;
        self.role_name = ::std::option::Option::None;
        self.role_flags = ::std::option::Option::None;
        self.role_order = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildRole {
        static instance: CMsgGuildRole = CMsgGuildRole {
            role_id: ::std::option::Option::None,
            role_name: ::std::option::Option::None,
            role_flags: ::std::option::Option::None,
            role_order: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGuildMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildMember {
    // message fields
    // @@protoc_insertion_point(field:CMsgGuildMember.member_account_id)
    pub member_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildMember.member_role_id)
    pub member_role_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildMember.member_joined_timestamp)
    pub member_joined_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildMember.member_last_active_timestamp)
    pub member_last_active_timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGuildMember.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildMember {
    fn default() -> &'a CMsgGuildMember {
        <CMsgGuildMember as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildMember {
    pub fn new() -> CMsgGuildMember {
        ::std::default::Default::default()
    }

    // optional uint32 member_account_id = 1;

    pub fn member_account_id(&self) -> u32 {
        self.member_account_id.unwrap_or(0)
    }

    pub fn clear_member_account_id(&mut self) {
        self.member_account_id = ::std::option::Option::None;
    }

    pub fn has_member_account_id(&self) -> bool {
        self.member_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member_account_id(&mut self, v: u32) {
        self.member_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 member_role_id = 2;

    pub fn member_role_id(&self) -> u32 {
        self.member_role_id.unwrap_or(0)
    }

    pub fn clear_member_role_id(&mut self) {
        self.member_role_id = ::std::option::Option::None;
    }

    pub fn has_member_role_id(&self) -> bool {
        self.member_role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member_role_id(&mut self, v: u32) {
        self.member_role_id = ::std::option::Option::Some(v);
    }

    // optional uint32 member_joined_timestamp = 3;

    pub fn member_joined_timestamp(&self) -> u32 {
        self.member_joined_timestamp.unwrap_or(0)
    }

    pub fn clear_member_joined_timestamp(&mut self) {
        self.member_joined_timestamp = ::std::option::Option::None;
    }

    pub fn has_member_joined_timestamp(&self) -> bool {
        self.member_joined_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member_joined_timestamp(&mut self, v: u32) {
        self.member_joined_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 member_last_active_timestamp = 4;

    pub fn member_last_active_timestamp(&self) -> u32 {
        self.member_last_active_timestamp.unwrap_or(0)
    }

    pub fn clear_member_last_active_timestamp(&mut self) {
        self.member_last_active_timestamp = ::std::option::Option::None;
    }

    pub fn has_member_last_active_timestamp(&self) -> bool {
        self.member_last_active_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member_last_active_timestamp(&mut self, v: u32) {
        self.member_last_active_timestamp = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGuildMember {
    const NAME: &'static str = "CMsgGuildMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.member_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.member_role_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.member_joined_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.member_last_active_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.member_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.member_role_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.member_joined_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.member_last_active_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.member_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.member_role_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.member_joined_timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.member_last_active_timestamp {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildMember {
        CMsgGuildMember::new()
    }

    fn clear(&mut self) {
        self.member_account_id = ::std::option::Option::None;
        self.member_role_id = ::std::option::Option::None;
        self.member_joined_timestamp = ::std::option::Option::None;
        self.member_last_active_timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildMember {
        static instance: CMsgGuildMember = CMsgGuildMember {
            member_account_id: ::std::option::Option::None,
            member_role_id: ::std::option::Option::None,
            member_joined_timestamp: ::std::option::Option::None,
            member_last_active_timestamp: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGuildInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildInvite {
    // message fields
    // @@protoc_insertion_point(field:CMsgGuildInvite.requester_account_id)
    pub requester_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildInvite.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildInvite.timestamp_sent)
    pub timestamp_sent: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGuildInvite.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildInvite {
    fn default() -> &'a CMsgGuildInvite {
        <CMsgGuildInvite as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildInvite {
    pub fn new() -> CMsgGuildInvite {
        ::std::default::Default::default()
    }

    // optional uint32 requester_account_id = 1;

    pub fn requester_account_id(&self) -> u32 {
        self.requester_account_id.unwrap_or(0)
    }

    pub fn clear_requester_account_id(&mut self) {
        self.requester_account_id = ::std::option::Option::None;
    }

    pub fn has_requester_account_id(&self) -> bool {
        self.requester_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requester_account_id(&mut self, v: u32) {
        self.requester_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 target_account_id = 2;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp_sent = 3;

    pub fn timestamp_sent(&self) -> u32 {
        self.timestamp_sent.unwrap_or(0)
    }

    pub fn clear_timestamp_sent(&mut self) {
        self.timestamp_sent = ::std::option::Option::None;
    }

    pub fn has_timestamp_sent(&self) -> bool {
        self.timestamp_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_sent(&mut self, v: u32) {
        self.timestamp_sent = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGuildInvite {
    const NAME: &'static str = "CMsgGuildInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.requester_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.timestamp_sent = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.requester_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.timestamp_sent {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.requester_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.timestamp_sent {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildInvite {
        CMsgGuildInvite::new()
    }

    fn clear(&mut self) {
        self.requester_account_id = ::std::option::Option::None;
        self.target_account_id = ::std::option::Option::None;
        self.timestamp_sent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildInvite {
        static instance: CMsgGuildInvite = CMsgGuildInvite {
            requester_account_id: ::std::option::Option::None,
            target_account_id: ::std::option::Option::None,
            timestamp_sent: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGuildData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGuildData.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildData.guild_info)
    pub guild_info: ::steam_vent_proto_common::protobuf::MessageField<CMsgGuildInfo>,
    // @@protoc_insertion_point(field:CMsgGuildData.guild_roles)
    pub guild_roles: ::std::vec::Vec<CMsgGuildRole>,
    // @@protoc_insertion_point(field:CMsgGuildData.guild_members)
    pub guild_members: ::std::vec::Vec<CMsgGuildMember>,
    // @@protoc_insertion_point(field:CMsgGuildData.guild_invites)
    pub guild_invites: ::std::vec::Vec<CMsgGuildInvite>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGuildData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildData {
    fn default() -> &'a CMsgGuildData {
        <CMsgGuildData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildData {
    pub fn new() -> CMsgGuildData {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGuildData {
    const NAME: &'static str = "CMsgGuildData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_info)?;
                },
                26 => {
                    self.guild_roles.push(is.read_message()?);
                },
                34 => {
                    self.guild_members.push(is.read_message()?);
                },
                42 => {
                    self.guild_invites.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.guild_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.guild_roles {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.guild_members {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.guild_invites {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.guild_info.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.guild_roles {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.guild_members {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.guild_invites {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildData {
        CMsgGuildData::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.guild_info.clear();
        self.guild_roles.clear();
        self.guild_members.clear();
        self.guild_invites.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildData {
        static instance: CMsgGuildData = CMsgGuildData {
            guild_id: ::std::option::Option::None,
            guild_info: ::steam_vent_proto_common::protobuf::MessageField::none(),
            guild_roles: ::std::vec::Vec::new(),
            guild_members: ::std::vec::Vec::new(),
            guild_invites: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAccountGuildInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAccountGuildInvite {
    // message fields
    // @@protoc_insertion_point(field:CMsgAccountGuildInvite.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAccountGuildInvite.requester_account_id)
    pub requester_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAccountGuildInvite.timestamp_sent)
    pub timestamp_sent: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAccountGuildInvite.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAccountGuildInvite {
    fn default() -> &'a CMsgAccountGuildInvite {
        <CMsgAccountGuildInvite as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgAccountGuildInvite {
    pub fn new() -> CMsgAccountGuildInvite {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 requester_account_id = 2;

    pub fn requester_account_id(&self) -> u32 {
        self.requester_account_id.unwrap_or(0)
    }

    pub fn clear_requester_account_id(&mut self) {
        self.requester_account_id = ::std::option::Option::None;
    }

    pub fn has_requester_account_id(&self) -> bool {
        self.requester_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requester_account_id(&mut self, v: u32) {
        self.requester_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp_sent = 3;

    pub fn timestamp_sent(&self) -> u32 {
        self.timestamp_sent.unwrap_or(0)
    }

    pub fn clear_timestamp_sent(&mut self) {
        self.timestamp_sent = ::std::option::Option::None;
    }

    pub fn has_timestamp_sent(&self) -> bool {
        self.timestamp_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_sent(&mut self, v: u32) {
        self.timestamp_sent = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgAccountGuildInvite {
    const NAME: &'static str = "CMsgAccountGuildInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.requester_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.timestamp_sent = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.requester_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.timestamp_sent {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.requester_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.timestamp_sent {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAccountGuildInvite {
        CMsgAccountGuildInvite::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.requester_account_id = ::std::option::Option::None;
        self.timestamp_sent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAccountGuildInvite {
        static instance: CMsgAccountGuildInvite = CMsgAccountGuildInvite {
            guild_id: ::std::option::Option::None,
            requester_account_id: ::std::option::Option::None,
            timestamp_sent: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAccountGuildMemberships)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAccountGuildMemberships {
    // message fields
    // @@protoc_insertion_point(field:CMsgAccountGuildMemberships.guild_ids)
    pub guild_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgAccountGuildMemberships.guild_invites)
    pub guild_invites: ::std::vec::Vec<CMsgAccountGuildInvite>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAccountGuildMemberships.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAccountGuildMemberships {
    fn default() -> &'a CMsgAccountGuildMemberships {
        <CMsgAccountGuildMemberships as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgAccountGuildMemberships {
    pub fn new() -> CMsgAccountGuildMemberships {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgAccountGuildMemberships {
    const NAME: &'static str = "CMsgAccountGuildMemberships";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.guild_ids)?;
                },
                8 => {
                    self.guild_ids.push(is.read_uint32()?);
                },
                18 => {
                    self.guild_invites.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.guild_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.guild_invites {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.guild_ids {
            os.write_uint32(1, *v)?;
        };
        for v in &self.guild_invites {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAccountGuildMemberships {
        CMsgAccountGuildMemberships::new()
    }

    fn clear(&mut self) {
        self.guild_ids.clear();
        self.guild_invites.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAccountGuildMemberships {
        static instance: CMsgAccountGuildMemberships = CMsgAccountGuildMemberships {
            guild_ids: ::std::vec::Vec::new(),
            guild_invites: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGuildPersonaInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildPersonaInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgGuildPersonaInfo.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildPersonaInfo.guild_tag)
    pub guild_tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGuildPersonaInfo.guild_flags)
    pub guild_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGuildPersonaInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildPersonaInfo {
    fn default() -> &'a CMsgGuildPersonaInfo {
        <CMsgGuildPersonaInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildPersonaInfo {
    pub fn new() -> CMsgGuildPersonaInfo {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional string guild_tag = 2;

    pub fn guild_tag(&self) -> &str {
        match self.guild_tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_guild_tag(&mut self) {
        self.guild_tag = ::std::option::Option::None;
    }

    pub fn has_guild_tag(&self) -> bool {
        self.guild_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_tag(&mut self, v: ::std::string::String) {
        self.guild_tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guild_tag(&mut self) -> &mut ::std::string::String {
        if self.guild_tag.is_none() {
            self.guild_tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.guild_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_guild_tag(&mut self) -> ::std::string::String {
        self.guild_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 guild_flags = 3;

    pub fn guild_flags(&self) -> u32 {
        self.guild_flags.unwrap_or(0)
    }

    pub fn clear_guild_flags(&mut self) {
        self.guild_flags = ::std::option::Option::None;
    }

    pub fn has_guild_flags(&self) -> bool {
        self.guild_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_flags(&mut self, v: u32) {
        self.guild_flags = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGuildPersonaInfo {
    const NAME: &'static str = "CMsgGuildPersonaInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.guild_tag = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.guild_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.guild_tag.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.guild_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.guild_tag.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.guild_flags {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildPersonaInfo {
        CMsgGuildPersonaInfo::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.guild_tag = ::std::option::Option::None;
        self.guild_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildPersonaInfo {
        static instance: CMsgGuildPersonaInfo = CMsgGuildPersonaInfo {
            guild_id: ::std::option::Option::None,
            guild_tag: ::std::option::Option::None,
            guild_flags: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAccountGuildsPersonaInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAccountGuildsPersonaInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgAccountGuildsPersonaInfo.guild_persona_infos)
    pub guild_persona_infos: ::std::vec::Vec<CMsgGuildPersonaInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAccountGuildsPersonaInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAccountGuildsPersonaInfo {
    fn default() -> &'a CMsgAccountGuildsPersonaInfo {
        <CMsgAccountGuildsPersonaInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgAccountGuildsPersonaInfo {
    pub fn new() -> CMsgAccountGuildsPersonaInfo {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgAccountGuildsPersonaInfo {
    const NAME: &'static str = "CMsgAccountGuildsPersonaInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.guild_persona_infos.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.guild_persona_infos {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.guild_persona_infos {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAccountGuildsPersonaInfo {
        CMsgAccountGuildsPersonaInfo::new()
    }

    fn clear(&mut self) {
        self.guild_persona_infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAccountGuildsPersonaInfo {
        static instance: CMsgAccountGuildsPersonaInfo = CMsgAccountGuildsPersonaInfo {
            guild_persona_infos: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGuildFeedEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildFeedEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgGuildFeedEvent.feed_event_id)
    pub feed_event_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGuildFeedEvent.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildFeedEvent.event_type)
    pub event_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildFeedEvent.param_uint_1)
    pub param_uint_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildFeedEvent.param_uint_2)
    pub param_uint_2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildFeedEvent.param_uint_3)
    pub param_uint_3: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGuildFeedEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildFeedEvent {
    fn default() -> &'a CMsgGuildFeedEvent {
        <CMsgGuildFeedEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildFeedEvent {
    pub fn new() -> CMsgGuildFeedEvent {
        ::std::default::Default::default()
    }

    // optional uint64 feed_event_id = 1;

    pub fn feed_event_id(&self) -> u64 {
        self.feed_event_id.unwrap_or(0)
    }

    pub fn clear_feed_event_id(&mut self) {
        self.feed_event_id = ::std::option::Option::None;
    }

    pub fn has_feed_event_id(&self) -> bool {
        self.feed_event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feed_event_id(&mut self, v: u64) {
        self.feed_event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 event_type = 3;

    pub fn event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    // optional uint32 param_uint_1 = 4;

    pub fn param_uint_1(&self) -> u32 {
        self.param_uint_1.unwrap_or(0)
    }

    pub fn clear_param_uint_1(&mut self) {
        self.param_uint_1 = ::std::option::Option::None;
    }

    pub fn has_param_uint_1(&self) -> bool {
        self.param_uint_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_uint_1(&mut self, v: u32) {
        self.param_uint_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 param_uint_2 = 5;

    pub fn param_uint_2(&self) -> u32 {
        self.param_uint_2.unwrap_or(0)
    }

    pub fn clear_param_uint_2(&mut self) {
        self.param_uint_2 = ::std::option::Option::None;
    }

    pub fn has_param_uint_2(&self) -> bool {
        self.param_uint_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_uint_2(&mut self, v: u32) {
        self.param_uint_2 = ::std::option::Option::Some(v);
    }

    // optional uint32 param_uint_3 = 6;

    pub fn param_uint_3(&self) -> u32 {
        self.param_uint_3.unwrap_or(0)
    }

    pub fn clear_param_uint_3(&mut self) {
        self.param_uint_3 = ::std::option::Option::None;
    }

    pub fn has_param_uint_3(&self) -> bool {
        self.param_uint_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_uint_3(&mut self, v: u32) {
        self.param_uint_3 = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGuildFeedEvent {
    const NAME: &'static str = "CMsgGuildFeedEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.feed_event_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.param_uint_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.param_uint_2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.param_uint_3 = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.feed_event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.event_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.param_uint_1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.param_uint_2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.param_uint_3 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.feed_event_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.param_uint_1 {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.param_uint_2 {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.param_uint_3 {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildFeedEvent {
        CMsgGuildFeedEvent::new()
    }

    fn clear(&mut self) {
        self.feed_event_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.param_uint_1 = ::std::option::Option::None;
        self.param_uint_2 = ::std::option::Option::None;
        self.param_uint_3 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildFeedEvent {
        static instance: CMsgGuildFeedEvent = CMsgGuildFeedEvent {
            feed_event_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            event_type: ::std::option::Option::None,
            param_uint_1: ::std::option::Option::None,
            param_uint_2: ::std::option::Option::None,
            param_uint_3: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCCreateGuild)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCreateGuild {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCreateGuild.guild_info)
    pub guild_info: ::steam_vent_proto_common::protobuf::MessageField<CMsgGuildInfo>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreateGuild.guild_chat_type)
    pub guild_chat_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EGuildChatType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCreateGuild.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCreateGuild {
    fn default() -> &'a CMsgClientToGCCreateGuild {
        <CMsgClientToGCCreateGuild as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCreateGuild {
    pub fn new() -> CMsgClientToGCCreateGuild {
        ::std::default::Default::default()
    }

    // optional .EGuildChatType guild_chat_type = 2;

    pub fn guild_chat_type(&self) -> EGuildChatType {
        match self.guild_chat_type {
            Some(e) => e.enum_value_or(EGuildChatType::k_EGuildChatType_Unspecified),
            None => EGuildChatType::k_EGuildChatType_Unspecified,
        }
    }

    pub fn clear_guild_chat_type(&mut self) {
        self.guild_chat_type = ::std::option::Option::None;
    }

    pub fn has_guild_chat_type(&self) -> bool {
        self.guild_chat_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_chat_type(&mut self, v: EGuildChatType) {
        self.guild_chat_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCreateGuild {
    const NAME: &'static str = "CMsgClientToGCCreateGuild";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_info)?;
                },
                16 => {
                    self.guild_chat_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.guild_chat_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_info.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.guild_chat_type {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCreateGuild {
        CMsgClientToGCCreateGuild::new()
    }

    fn clear(&mut self) {
        self.guild_info.clear();
        self.guild_chat_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCreateGuild {
        static instance: CMsgClientToGCCreateGuild = CMsgClientToGCCreateGuild {
            guild_info: ::steam_vent_proto_common::protobuf::MessageField::none(),
            guild_chat_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCCreateGuildResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCreateGuildResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCreateGuildResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gccreate_guild_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreateGuildResponse.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCreateGuildResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCreateGuildResponse {
    fn default() -> &'a CMsgClientToGCCreateGuildResponse {
        <CMsgClientToGCCreateGuildResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCreateGuildResponse {
    pub fn new() -> CMsgClientToGCCreateGuildResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCCreateGuildResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gccreate_guild_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gccreate_guild_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gccreate_guild_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gccreate_guild_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 guild_id = 2;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCreateGuildResponse {
    const NAME: &'static str = "CMsgClientToGCCreateGuildResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.guild_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCreateGuildResponse {
        CMsgClientToGCCreateGuildResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.guild_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCreateGuildResponse {
        static instance: CMsgClientToGCCreateGuildResponse = CMsgClientToGCCreateGuildResponse {
            result: ::std::option::Option::None,
            guild_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCCreateGuildResponse`
pub mod cmsg_client_to_gccreate_guild_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCCreateGuildResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateGuildResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateGuildResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateGuildResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateGuildResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateGuildResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateGuildResponse.EResponse.k_eInvalidName)
        k_eInvalidName = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateGuildResponse.EResponse.k_eNameAlreadyUsed)
        k_eNameAlreadyUsed = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateGuildResponse.EResponse.k_eInvalidTag)
        k_eInvalidTag = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateGuildResponse.EResponse.k_eTagAlreadyUsed)
        k_eTagAlreadyUsed = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateGuildResponse.EResponse.k_eInvalidDescription)
        k_eInvalidDescription = 9,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateGuildResponse.EResponse.k_eInvalidRegion)
        k_eInvalidRegion = 10,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateGuildResponse.EResponse.k_eInvalidLogo)
        k_eInvalidLogo = 11,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateGuildResponse.EResponse.k_eDoesNotOwnEvent)
        k_eDoesNotOwnEvent = 12,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateGuildResponse.EResponse.k_eGuildLimit)
        k_eGuildLimit = 13,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateGuildResponse.EResponse.k_eInvalidMotD)
        k_eInvalidMotD = 14,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateGuildResponse.EResponse.k_eBlocked)
        k_eBlocked = 15,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateGuildResponse.EResponse.k_eFreeTrialNotAllowed)
        k_eFreeTrialNotAllowed = 16,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidName),
                6 => ::std::option::Option::Some(EResponse::k_eNameAlreadyUsed),
                7 => ::std::option::Option::Some(EResponse::k_eInvalidTag),
                8 => ::std::option::Option::Some(EResponse::k_eTagAlreadyUsed),
                9 => ::std::option::Option::Some(EResponse::k_eInvalidDescription),
                10 => ::std::option::Option::Some(EResponse::k_eInvalidRegion),
                11 => ::std::option::Option::Some(EResponse::k_eInvalidLogo),
                12 => ::std::option::Option::Some(EResponse::k_eDoesNotOwnEvent),
                13 => ::std::option::Option::Some(EResponse::k_eGuildLimit),
                14 => ::std::option::Option::Some(EResponse::k_eInvalidMotD),
                15 => ::std::option::Option::Some(EResponse::k_eBlocked),
                16 => ::std::option::Option::Some(EResponse::k_eFreeTrialNotAllowed),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidName" => ::std::option::Option::Some(EResponse::k_eInvalidName),
                "k_eNameAlreadyUsed" => ::std::option::Option::Some(EResponse::k_eNameAlreadyUsed),
                "k_eInvalidTag" => ::std::option::Option::Some(EResponse::k_eInvalidTag),
                "k_eTagAlreadyUsed" => ::std::option::Option::Some(EResponse::k_eTagAlreadyUsed),
                "k_eInvalidDescription" => ::std::option::Option::Some(EResponse::k_eInvalidDescription),
                "k_eInvalidRegion" => ::std::option::Option::Some(EResponse::k_eInvalidRegion),
                "k_eInvalidLogo" => ::std::option::Option::Some(EResponse::k_eInvalidLogo),
                "k_eDoesNotOwnEvent" => ::std::option::Option::Some(EResponse::k_eDoesNotOwnEvent),
                "k_eGuildLimit" => ::std::option::Option::Some(EResponse::k_eGuildLimit),
                "k_eInvalidMotD" => ::std::option::Option::Some(EResponse::k_eInvalidMotD),
                "k_eBlocked" => ::std::option::Option::Some(EResponse::k_eBlocked),
                "k_eFreeTrialNotAllowed" => ::std::option::Option::Some(EResponse::k_eFreeTrialNotAllowed),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidName,
            EResponse::k_eNameAlreadyUsed,
            EResponse::k_eInvalidTag,
            EResponse::k_eTagAlreadyUsed,
            EResponse::k_eInvalidDescription,
            EResponse::k_eInvalidRegion,
            EResponse::k_eInvalidLogo,
            EResponse::k_eDoesNotOwnEvent,
            EResponse::k_eGuildLimit,
            EResponse::k_eInvalidMotD,
            EResponse::k_eBlocked,
            EResponse::k_eFreeTrialNotAllowed,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCSetGuildInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetGuildInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSetGuildInfo.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCSetGuildInfo.guild_info)
    pub guild_info: ::steam_vent_proto_common::protobuf::MessageField<CMsgGuildInfo>,
    // @@protoc_insertion_point(field:CMsgClientToGCSetGuildInfo.guild_chat_type)
    pub guild_chat_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EGuildChatType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSetGuildInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetGuildInfo {
    fn default() -> &'a CMsgClientToGCSetGuildInfo {
        <CMsgClientToGCSetGuildInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetGuildInfo {
    pub fn new() -> CMsgClientToGCSetGuildInfo {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .EGuildChatType guild_chat_type = 3;

    pub fn guild_chat_type(&self) -> EGuildChatType {
        match self.guild_chat_type {
            Some(e) => e.enum_value_or(EGuildChatType::k_EGuildChatType_Unspecified),
            None => EGuildChatType::k_EGuildChatType_Unspecified,
        }
    }

    pub fn clear_guild_chat_type(&mut self) {
        self.guild_chat_type = ::std::option::Option::None;
    }

    pub fn has_guild_chat_type(&self) -> bool {
        self.guild_chat_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_chat_type(&mut self, v: EGuildChatType) {
        self.guild_chat_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSetGuildInfo {
    const NAME: &'static str = "CMsgClientToGCSetGuildInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_info)?;
                },
                24 => {
                    self.guild_chat_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.guild_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.guild_chat_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.guild_info.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.guild_chat_type {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetGuildInfo {
        CMsgClientToGCSetGuildInfo::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.guild_info.clear();
        self.guild_chat_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetGuildInfo {
        static instance: CMsgClientToGCSetGuildInfo = CMsgClientToGCSetGuildInfo {
            guild_id: ::std::option::Option::None,
            guild_info: ::steam_vent_proto_common::protobuf::MessageField::none(),
            guild_chat_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCSetGuildInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetGuildInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSetGuildInfoResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcset_guild_info_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSetGuildInfoResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetGuildInfoResponse {
    fn default() -> &'a CMsgClientToGCSetGuildInfoResponse {
        <CMsgClientToGCSetGuildInfoResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetGuildInfoResponse {
    pub fn new() -> CMsgClientToGCSetGuildInfoResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCSetGuildInfoResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcset_guild_info_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcset_guild_info_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcset_guild_info_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcset_guild_info_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSetGuildInfoResponse {
    const NAME: &'static str = "CMsgClientToGCSetGuildInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetGuildInfoResponse {
        CMsgClientToGCSetGuildInfoResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetGuildInfoResponse {
        static instance: CMsgClientToGCSetGuildInfoResponse = CMsgClientToGCSetGuildInfoResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCSetGuildInfoResponse`
pub mod cmsg_client_to_gcset_guild_info_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCSetGuildInfoResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildInfoResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildInfoResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildInfoResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildInfoResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildInfoResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildInfoResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildInfoResponse.EResponse.k_eNotMember)
        k_eNotMember = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildInfoResponse.EResponse.k_eNoPermission)
        k_eNoPermission = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildInfoResponse.EResponse.k_eMotDTooLong)
        k_eMotDTooLong = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildInfoResponse.EResponse.k_eNameChangeNoPermissions)
        k_eNameChangeNoPermissions = 9,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildInfoResponse.EResponse.k_eTagChangeNoPermissions)
        k_eTagChangeNoPermissions = 10,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildInfoResponse.EResponse.k_eNameInvalid)
        k_eNameInvalid = 11,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildInfoResponse.EResponse.k_eTagInvalid)
        k_eTagInvalid = 12,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildInfoResponse.EResponse.k_eDescriptionInvalid)
        k_eDescriptionInvalid = 13,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildInfoResponse.EResponse.k_eBlocked)
        k_eBlocked = 14,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eNotMember),
                7 => ::std::option::Option::Some(EResponse::k_eNoPermission),
                8 => ::std::option::Option::Some(EResponse::k_eMotDTooLong),
                9 => ::std::option::Option::Some(EResponse::k_eNameChangeNoPermissions),
                10 => ::std::option::Option::Some(EResponse::k_eTagChangeNoPermissions),
                11 => ::std::option::Option::Some(EResponse::k_eNameInvalid),
                12 => ::std::option::Option::Some(EResponse::k_eTagInvalid),
                13 => ::std::option::Option::Some(EResponse::k_eDescriptionInvalid),
                14 => ::std::option::Option::Some(EResponse::k_eBlocked),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNotMember" => ::std::option::Option::Some(EResponse::k_eNotMember),
                "k_eNoPermission" => ::std::option::Option::Some(EResponse::k_eNoPermission),
                "k_eMotDTooLong" => ::std::option::Option::Some(EResponse::k_eMotDTooLong),
                "k_eNameChangeNoPermissions" => ::std::option::Option::Some(EResponse::k_eNameChangeNoPermissions),
                "k_eTagChangeNoPermissions" => ::std::option::Option::Some(EResponse::k_eTagChangeNoPermissions),
                "k_eNameInvalid" => ::std::option::Option::Some(EResponse::k_eNameInvalid),
                "k_eTagInvalid" => ::std::option::Option::Some(EResponse::k_eTagInvalid),
                "k_eDescriptionInvalid" => ::std::option::Option::Some(EResponse::k_eDescriptionInvalid),
                "k_eBlocked" => ::std::option::Option::Some(EResponse::k_eBlocked),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNotMember,
            EResponse::k_eNoPermission,
            EResponse::k_eMotDTooLong,
            EResponse::k_eNameChangeNoPermissions,
            EResponse::k_eTagChangeNoPermissions,
            EResponse::k_eNameInvalid,
            EResponse::k_eTagInvalid,
            EResponse::k_eDescriptionInvalid,
            EResponse::k_eBlocked,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCRequestGuildData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestGuildData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestGuildData.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestGuildData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestGuildData {
    fn default() -> &'a CMsgClientToGCRequestGuildData {
        <CMsgClientToGCRequestGuildData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestGuildData {
    pub fn new() -> CMsgClientToGCRequestGuildData {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestGuildData {
    const NAME: &'static str = "CMsgClientToGCRequestGuildData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestGuildData {
        CMsgClientToGCRequestGuildData::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestGuildData {
        static instance: CMsgClientToGCRequestGuildData = CMsgClientToGCRequestGuildData {
            guild_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestGuildDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestGuildDataResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestGuildDataResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_guild_data_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestGuildDataResponse.guild_data)
    pub guild_data: ::steam_vent_proto_common::protobuf::MessageField<CMsgGuildData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestGuildDataResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestGuildDataResponse {
    fn default() -> &'a CMsgClientToGCRequestGuildDataResponse {
        <CMsgClientToGCRequestGuildDataResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestGuildDataResponse {
    pub fn new() -> CMsgClientToGCRequestGuildDataResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCRequestGuildDataResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_guild_data_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_guild_data_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_guild_data_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_guild_data_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestGuildDataResponse {
    const NAME: &'static str = "CMsgClientToGCRequestGuildDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.guild_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.guild_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestGuildDataResponse {
        CMsgClientToGCRequestGuildDataResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.guild_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestGuildDataResponse {
        static instance: CMsgClientToGCRequestGuildDataResponse = CMsgClientToGCRequestGuildDataResponse {
            result: ::std::option::Option::None,
            guild_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCRequestGuildDataResponse`
pub mod cmsg_client_to_gcrequest_guild_data_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCRequestGuildDataResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildDataResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildDataResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildDataResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildDataResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildDataResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildDataResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildDataResponse.EResponse.k_eNotMember)
        k_eNotMember = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eNotMember),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNotMember" => ::std::option::Option::Some(EResponse::k_eNotMember),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNotMember,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCToClientGuildDataUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientGuildDataUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientGuildDataUpdated.guild_data)
    pub guild_data: ::steam_vent_proto_common::protobuf::MessageField<CMsgGuildData>,
    // @@protoc_insertion_point(field:CMsgGCToClientGuildDataUpdated.update_flags)
    pub update_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientGuildDataUpdated.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientGuildDataUpdated {
    fn default() -> &'a CMsgGCToClientGuildDataUpdated {
        <CMsgGCToClientGuildDataUpdated as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientGuildDataUpdated {
    pub fn new() -> CMsgGCToClientGuildDataUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 update_flags = 2;

    pub fn update_flags(&self) -> u32 {
        self.update_flags.unwrap_or(0)
    }

    pub fn clear_update_flags(&mut self) {
        self.update_flags = ::std::option::Option::None;
    }

    pub fn has_update_flags(&self) -> bool {
        self.update_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_flags(&mut self, v: u32) {
        self.update_flags = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientGuildDataUpdated {
    const NAME: &'static str = "CMsgGCToClientGuildDataUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_data)?;
                },
                16 => {
                    self.update_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.update_flags {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientGuildDataUpdated {
        CMsgGCToClientGuildDataUpdated::new()
    }

    fn clear(&mut self) {
        self.guild_data.clear();
        self.update_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientGuildDataUpdated {
        static instance: CMsgGCToClientGuildDataUpdated = CMsgGCToClientGuildDataUpdated {
            guild_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            update_flags: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientGuildMembersDataUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientGuildMembersDataUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientGuildMembersDataUpdated.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientGuildMembersDataUpdated.members_data)
    pub members_data: ::std::vec::Vec<CMsgGuildMember>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientGuildMembersDataUpdated.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientGuildMembersDataUpdated {
    fn default() -> &'a CMsgGCToClientGuildMembersDataUpdated {
        <CMsgGCToClientGuildMembersDataUpdated as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientGuildMembersDataUpdated {
    pub fn new() -> CMsgGCToClientGuildMembersDataUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientGuildMembersDataUpdated {
    const NAME: &'static str = "CMsgGCToClientGuildMembersDataUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.members_data.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.members_data {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.members_data {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientGuildMembersDataUpdated {
        CMsgGCToClientGuildMembersDataUpdated::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.members_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientGuildMembersDataUpdated {
        static instance: CMsgGCToClientGuildMembersDataUpdated = CMsgGCToClientGuildMembersDataUpdated {
            guild_id: ::std::option::Option::None,
            members_data: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestGuildMembership)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestGuildMembership {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestGuildMembership.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestGuildMembership {
    fn default() -> &'a CMsgClientToGCRequestGuildMembership {
        <CMsgClientToGCRequestGuildMembership as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestGuildMembership {
    pub fn new() -> CMsgClientToGCRequestGuildMembership {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestGuildMembership {
    const NAME: &'static str = "CMsgClientToGCRequestGuildMembership";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestGuildMembership {
        CMsgClientToGCRequestGuildMembership::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestGuildMembership {
        static instance: CMsgClientToGCRequestGuildMembership = CMsgClientToGCRequestGuildMembership {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestGuildMembershipResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestGuildMembershipResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestGuildMembershipResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_guild_membership_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestGuildMembershipResponse.guild_memberships)
    pub guild_memberships: ::steam_vent_proto_common::protobuf::MessageField<CMsgAccountGuildMemberships>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestGuildMembershipResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestGuildMembershipResponse {
    fn default() -> &'a CMsgClientToGCRequestGuildMembershipResponse {
        <CMsgClientToGCRequestGuildMembershipResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestGuildMembershipResponse {
    pub fn new() -> CMsgClientToGCRequestGuildMembershipResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCRequestGuildMembershipResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_guild_membership_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_guild_membership_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_guild_membership_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_guild_membership_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestGuildMembershipResponse {
    const NAME: &'static str = "CMsgClientToGCRequestGuildMembershipResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_memberships)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.guild_memberships.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.guild_memberships.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestGuildMembershipResponse {
        CMsgClientToGCRequestGuildMembershipResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.guild_memberships.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestGuildMembershipResponse {
        static instance: CMsgClientToGCRequestGuildMembershipResponse = CMsgClientToGCRequestGuildMembershipResponse {
            result: ::std::option::Option::None,
            guild_memberships: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCRequestGuildMembershipResponse`
pub mod cmsg_client_to_gcrequest_guild_membership_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCRequestGuildMembershipResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildMembershipResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildMembershipResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildMembershipResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildMembershipResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildMembershipResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCToClientGuildMembershipUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientGuildMembershipUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientGuildMembershipUpdated.guild_memberships)
    pub guild_memberships: ::steam_vent_proto_common::protobuf::MessageField<CMsgAccountGuildMemberships>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientGuildMembershipUpdated.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientGuildMembershipUpdated {
    fn default() -> &'a CMsgGCToClientGuildMembershipUpdated {
        <CMsgGCToClientGuildMembershipUpdated as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientGuildMembershipUpdated {
    pub fn new() -> CMsgGCToClientGuildMembershipUpdated {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientGuildMembershipUpdated {
    const NAME: &'static str = "CMsgGCToClientGuildMembershipUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_memberships)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_memberships.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_memberships.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientGuildMembershipUpdated {
        CMsgGCToClientGuildMembershipUpdated::new()
    }

    fn clear(&mut self) {
        self.guild_memberships.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientGuildMembershipUpdated {
        static instance: CMsgGCToClientGuildMembershipUpdated = CMsgGCToClientGuildMembershipUpdated {
            guild_memberships: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCJoinGuild)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCJoinGuild {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCJoinGuild.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCJoinGuild.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCJoinGuild {
    fn default() -> &'a CMsgClientToGCJoinGuild {
        <CMsgClientToGCJoinGuild as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCJoinGuild {
    pub fn new() -> CMsgClientToGCJoinGuild {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCJoinGuild {
    const NAME: &'static str = "CMsgClientToGCJoinGuild";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCJoinGuild {
        CMsgClientToGCJoinGuild::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCJoinGuild {
        static instance: CMsgClientToGCJoinGuild = CMsgClientToGCJoinGuild {
            guild_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCJoinGuildResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCJoinGuildResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCJoinGuildResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcjoin_guild_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCJoinGuildResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCJoinGuildResponse {
    fn default() -> &'a CMsgClientToGCJoinGuildResponse {
        <CMsgClientToGCJoinGuildResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCJoinGuildResponse {
    pub fn new() -> CMsgClientToGCJoinGuildResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCJoinGuildResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcjoin_guild_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcjoin_guild_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcjoin_guild_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcjoin_guild_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCJoinGuildResponse {
    const NAME: &'static str = "CMsgClientToGCJoinGuildResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCJoinGuildResponse {
        CMsgClientToGCJoinGuildResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCJoinGuildResponse {
        static instance: CMsgClientToGCJoinGuildResponse = CMsgClientToGCJoinGuildResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCJoinGuildResponse`
pub mod cmsg_client_to_gcjoin_guild_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCJoinGuildResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCJoinGuildResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCJoinGuildResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCJoinGuildResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCJoinGuildResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCJoinGuildResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCJoinGuildResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCJoinGuildResponse.EResponse.k_eGuildFull)
        k_eGuildFull = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCJoinGuildResponse.EResponse.k_eAlreadyMember)
        k_eAlreadyMember = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCJoinGuildResponse.EResponse.k_eGuildLimit)
        k_eGuildLimit = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCJoinGuildResponse.EResponse.k_eGuildRequiresInvite)
        k_eGuildRequiresInvite = 9,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCJoinGuildResponse.EResponse.k_eGuildRankTooLow)
        k_eGuildRankTooLow = 10,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eGuildFull),
                7 => ::std::option::Option::Some(EResponse::k_eAlreadyMember),
                8 => ::std::option::Option::Some(EResponse::k_eGuildLimit),
                9 => ::std::option::Option::Some(EResponse::k_eGuildRequiresInvite),
                10 => ::std::option::Option::Some(EResponse::k_eGuildRankTooLow),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eGuildFull" => ::std::option::Option::Some(EResponse::k_eGuildFull),
                "k_eAlreadyMember" => ::std::option::Option::Some(EResponse::k_eAlreadyMember),
                "k_eGuildLimit" => ::std::option::Option::Some(EResponse::k_eGuildLimit),
                "k_eGuildRequiresInvite" => ::std::option::Option::Some(EResponse::k_eGuildRequiresInvite),
                "k_eGuildRankTooLow" => ::std::option::Option::Some(EResponse::k_eGuildRankTooLow),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eGuildFull,
            EResponse::k_eAlreadyMember,
            EResponse::k_eGuildLimit,
            EResponse::k_eGuildRequiresInvite,
            EResponse::k_eGuildRankTooLow,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCLeaveGuild)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCLeaveGuild {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCLeaveGuild.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCLeaveGuild.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCLeaveGuild {
    fn default() -> &'a CMsgClientToGCLeaveGuild {
        <CMsgClientToGCLeaveGuild as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCLeaveGuild {
    pub fn new() -> CMsgClientToGCLeaveGuild {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCLeaveGuild {
    const NAME: &'static str = "CMsgClientToGCLeaveGuild";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCLeaveGuild {
        CMsgClientToGCLeaveGuild::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCLeaveGuild {
        static instance: CMsgClientToGCLeaveGuild = CMsgClientToGCLeaveGuild {
            guild_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCLeaveGuildResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCLeaveGuildResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCLeaveGuildResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcleave_guild_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCLeaveGuildResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCLeaveGuildResponse {
    fn default() -> &'a CMsgClientToGCLeaveGuildResponse {
        <CMsgClientToGCLeaveGuildResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCLeaveGuildResponse {
    pub fn new() -> CMsgClientToGCLeaveGuildResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCLeaveGuildResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcleave_guild_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcleave_guild_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcleave_guild_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcleave_guild_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCLeaveGuildResponse {
    const NAME: &'static str = "CMsgClientToGCLeaveGuildResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCLeaveGuildResponse {
        CMsgClientToGCLeaveGuildResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCLeaveGuildResponse {
        static instance: CMsgClientToGCLeaveGuildResponse = CMsgClientToGCLeaveGuildResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCLeaveGuildResponse`
pub mod cmsg_client_to_gcleave_guild_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCLeaveGuildResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCLeaveGuildResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCLeaveGuildResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCLeaveGuildResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCLeaveGuildResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCLeaveGuildResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCLeaveGuildResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCLeaveGuildResponse.EResponse.k_eNotMember)
        k_eNotMember = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCLeaveGuildResponse.EResponse.k_eLastAdmin)
        k_eLastAdmin = 7,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eNotMember),
                7 => ::std::option::Option::Some(EResponse::k_eLastAdmin),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNotMember" => ::std::option::Option::Some(EResponse::k_eNotMember),
                "k_eLastAdmin" => ::std::option::Option::Some(EResponse::k_eLastAdmin),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNotMember,
            EResponse::k_eLastAdmin,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCKickGuildMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCKickGuildMember {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCKickGuildMember.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCKickGuildMember.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCKickGuildMember.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCKickGuildMember {
    fn default() -> &'a CMsgClientToGCKickGuildMember {
        <CMsgClientToGCKickGuildMember as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCKickGuildMember {
    pub fn new() -> CMsgClientToGCKickGuildMember {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 target_account_id = 2;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCKickGuildMember {
    const NAME: &'static str = "CMsgClientToGCKickGuildMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_account_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCKickGuildMember {
        CMsgClientToGCKickGuildMember::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.target_account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCKickGuildMember {
        static instance: CMsgClientToGCKickGuildMember = CMsgClientToGCKickGuildMember {
            guild_id: ::std::option::Option::None,
            target_account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCKickGuildMemberResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCKickGuildMemberResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCKickGuildMemberResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gckick_guild_member_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCKickGuildMemberResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCKickGuildMemberResponse {
    fn default() -> &'a CMsgClientToGCKickGuildMemberResponse {
        <CMsgClientToGCKickGuildMemberResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCKickGuildMemberResponse {
    pub fn new() -> CMsgClientToGCKickGuildMemberResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCKickGuildMemberResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gckick_guild_member_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gckick_guild_member_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gckick_guild_member_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gckick_guild_member_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCKickGuildMemberResponse {
    const NAME: &'static str = "CMsgClientToGCKickGuildMemberResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCKickGuildMemberResponse {
        CMsgClientToGCKickGuildMemberResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCKickGuildMemberResponse {
        static instance: CMsgClientToGCKickGuildMemberResponse = CMsgClientToGCKickGuildMemberResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCKickGuildMemberResponse`
pub mod cmsg_client_to_gckick_guild_member_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCKickGuildMemberResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCKickGuildMemberResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCKickGuildMemberResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCKickGuildMemberResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCKickGuildMemberResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCKickGuildMemberResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCKickGuildMemberResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCKickGuildMemberResponse.EResponse.k_eRequesterNotMember)
        k_eRequesterNotMember = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCKickGuildMemberResponse.EResponse.k_eTargetNotMember)
        k_eTargetNotMember = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCKickGuildMemberResponse.EResponse.k_eNoPermission)
        k_eNoPermission = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCKickGuildMemberResponse.EResponse.k_eCantKickSelf)
        k_eCantKickSelf = 9,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eRequesterNotMember),
                7 => ::std::option::Option::Some(EResponse::k_eTargetNotMember),
                8 => ::std::option::Option::Some(EResponse::k_eNoPermission),
                9 => ::std::option::Option::Some(EResponse::k_eCantKickSelf),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eRequesterNotMember" => ::std::option::Option::Some(EResponse::k_eRequesterNotMember),
                "k_eTargetNotMember" => ::std::option::Option::Some(EResponse::k_eTargetNotMember),
                "k_eNoPermission" => ::std::option::Option::Some(EResponse::k_eNoPermission),
                "k_eCantKickSelf" => ::std::option::Option::Some(EResponse::k_eCantKickSelf),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eRequesterNotMember,
            EResponse::k_eTargetNotMember,
            EResponse::k_eNoPermission,
            EResponse::k_eCantKickSelf,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCSetGuildMemberRole)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetGuildMemberRole {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSetGuildMemberRole.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCSetGuildMemberRole.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCSetGuildMemberRole.target_role_id)
    pub target_role_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSetGuildMemberRole.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetGuildMemberRole {
    fn default() -> &'a CMsgClientToGCSetGuildMemberRole {
        <CMsgClientToGCSetGuildMemberRole as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetGuildMemberRole {
    pub fn new() -> CMsgClientToGCSetGuildMemberRole {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 target_account_id = 2;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 target_role_id = 3;

    pub fn target_role_id(&self) -> u32 {
        self.target_role_id.unwrap_or(0)
    }

    pub fn clear_target_role_id(&mut self) {
        self.target_role_id = ::std::option::Option::None;
    }

    pub fn has_target_role_id(&self) -> bool {
        self.target_role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_role_id(&mut self, v: u32) {
        self.target_role_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSetGuildMemberRole {
    const NAME: &'static str = "CMsgClientToGCSetGuildMemberRole";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.target_role_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.target_role_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.target_role_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetGuildMemberRole {
        CMsgClientToGCSetGuildMemberRole::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.target_account_id = ::std::option::Option::None;
        self.target_role_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetGuildMemberRole {
        static instance: CMsgClientToGCSetGuildMemberRole = CMsgClientToGCSetGuildMemberRole {
            guild_id: ::std::option::Option::None,
            target_account_id: ::std::option::Option::None,
            target_role_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCSetGuildMemberRoleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetGuildMemberRoleResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSetGuildMemberRoleResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcset_guild_member_role_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSetGuildMemberRoleResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetGuildMemberRoleResponse {
    fn default() -> &'a CMsgClientToGCSetGuildMemberRoleResponse {
        <CMsgClientToGCSetGuildMemberRoleResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetGuildMemberRoleResponse {
    pub fn new() -> CMsgClientToGCSetGuildMemberRoleResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCSetGuildMemberRoleResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcset_guild_member_role_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcset_guild_member_role_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcset_guild_member_role_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcset_guild_member_role_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSetGuildMemberRoleResponse {
    const NAME: &'static str = "CMsgClientToGCSetGuildMemberRoleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetGuildMemberRoleResponse {
        CMsgClientToGCSetGuildMemberRoleResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetGuildMemberRoleResponse {
        static instance: CMsgClientToGCSetGuildMemberRoleResponse = CMsgClientToGCSetGuildMemberRoleResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCSetGuildMemberRoleResponse`
pub mod cmsg_client_to_gcset_guild_member_role_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCSetGuildMemberRoleResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eRequesterNotMember)
        k_eRequesterNotMember = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eTargetNotMember)
        k_eTargetNotMember = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eNoPermission)
        k_eNoPermission = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eInvalidRole)
        k_eInvalidRole = 9,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildMemberRoleResponse.EResponse.k_eAdminViolation)
        k_eAdminViolation = 10,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eRequesterNotMember),
                7 => ::std::option::Option::Some(EResponse::k_eTargetNotMember),
                8 => ::std::option::Option::Some(EResponse::k_eNoPermission),
                9 => ::std::option::Option::Some(EResponse::k_eInvalidRole),
                10 => ::std::option::Option::Some(EResponse::k_eAdminViolation),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eRequesterNotMember" => ::std::option::Option::Some(EResponse::k_eRequesterNotMember),
                "k_eTargetNotMember" => ::std::option::Option::Some(EResponse::k_eTargetNotMember),
                "k_eNoPermission" => ::std::option::Option::Some(EResponse::k_eNoPermission),
                "k_eInvalidRole" => ::std::option::Option::Some(EResponse::k_eInvalidRole),
                "k_eAdminViolation" => ::std::option::Option::Some(EResponse::k_eAdminViolation),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eRequesterNotMember,
            EResponse::k_eTargetNotMember,
            EResponse::k_eNoPermission,
            EResponse::k_eInvalidRole,
            EResponse::k_eAdminViolation,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCInviteToGuild)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCInviteToGuild {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCInviteToGuild.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCInviteToGuild.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCInviteToGuild.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCInviteToGuild {
    fn default() -> &'a CMsgClientToGCInviteToGuild {
        <CMsgClientToGCInviteToGuild as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCInviteToGuild {
    pub fn new() -> CMsgClientToGCInviteToGuild {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 target_account_id = 2;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCInviteToGuild {
    const NAME: &'static str = "CMsgClientToGCInviteToGuild";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_account_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCInviteToGuild {
        CMsgClientToGCInviteToGuild::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.target_account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCInviteToGuild {
        static instance: CMsgClientToGCInviteToGuild = CMsgClientToGCInviteToGuild {
            guild_id: ::std::option::Option::None,
            target_account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCInviteToGuildResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCInviteToGuildResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCInviteToGuildResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcinvite_to_guild_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCInviteToGuildResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCInviteToGuildResponse {
    fn default() -> &'a CMsgClientToGCInviteToGuildResponse {
        <CMsgClientToGCInviteToGuildResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCInviteToGuildResponse {
    pub fn new() -> CMsgClientToGCInviteToGuildResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCInviteToGuildResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcinvite_to_guild_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcinvite_to_guild_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcinvite_to_guild_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcinvite_to_guild_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCInviteToGuildResponse {
    const NAME: &'static str = "CMsgClientToGCInviteToGuildResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCInviteToGuildResponse {
        CMsgClientToGCInviteToGuildResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCInviteToGuildResponse {
        static instance: CMsgClientToGCInviteToGuildResponse = CMsgClientToGCInviteToGuildResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCInviteToGuildResponse`
pub mod cmsg_client_to_gcinvite_to_guild_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCInviteToGuildResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCInviteToGuildResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCInviteToGuildResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCInviteToGuildResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCInviteToGuildResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCInviteToGuildResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCInviteToGuildResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCInviteToGuildResponse.EResponse.k_eGuildFull)
        k_eGuildFull = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCInviteToGuildResponse.EResponse.k_eRequesterNotMember)
        k_eRequesterNotMember = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCInviteToGuildResponse.EResponse.k_eAlreadyAMember)
        k_eAlreadyAMember = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCInviteToGuildResponse.EResponse.k_eAlreadyInvited)
        k_eAlreadyInvited = 9,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCInviteToGuildResponse.EResponse.k_eNoInvitePermissions)
        k_eNoInvitePermissions = 10,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCInviteToGuildResponse.EResponse.k_eTooManyInvites)
        k_eTooManyInvites = 11,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCInviteToGuildResponse.EResponse.k_eInvalidUser)
        k_eInvalidUser = 12,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eGuildFull),
                7 => ::std::option::Option::Some(EResponse::k_eRequesterNotMember),
                8 => ::std::option::Option::Some(EResponse::k_eAlreadyAMember),
                9 => ::std::option::Option::Some(EResponse::k_eAlreadyInvited),
                10 => ::std::option::Option::Some(EResponse::k_eNoInvitePermissions),
                11 => ::std::option::Option::Some(EResponse::k_eTooManyInvites),
                12 => ::std::option::Option::Some(EResponse::k_eInvalidUser),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eGuildFull" => ::std::option::Option::Some(EResponse::k_eGuildFull),
                "k_eRequesterNotMember" => ::std::option::Option::Some(EResponse::k_eRequesterNotMember),
                "k_eAlreadyAMember" => ::std::option::Option::Some(EResponse::k_eAlreadyAMember),
                "k_eAlreadyInvited" => ::std::option::Option::Some(EResponse::k_eAlreadyInvited),
                "k_eNoInvitePermissions" => ::std::option::Option::Some(EResponse::k_eNoInvitePermissions),
                "k_eTooManyInvites" => ::std::option::Option::Some(EResponse::k_eTooManyInvites),
                "k_eInvalidUser" => ::std::option::Option::Some(EResponse::k_eInvalidUser),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eGuildFull,
            EResponse::k_eRequesterNotMember,
            EResponse::k_eAlreadyAMember,
            EResponse::k_eAlreadyInvited,
            EResponse::k_eNoInvitePermissions,
            EResponse::k_eTooManyInvites,
            EResponse::k_eInvalidUser,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCDeclineInviteToGuild)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCDeclineInviteToGuild {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCDeclineInviteToGuild.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCDeclineInviteToGuild.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCDeclineInviteToGuild {
    fn default() -> &'a CMsgClientToGCDeclineInviteToGuild {
        <CMsgClientToGCDeclineInviteToGuild as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCDeclineInviteToGuild {
    pub fn new() -> CMsgClientToGCDeclineInviteToGuild {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCDeclineInviteToGuild {
    const NAME: &'static str = "CMsgClientToGCDeclineInviteToGuild";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCDeclineInviteToGuild {
        CMsgClientToGCDeclineInviteToGuild::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCDeclineInviteToGuild {
        static instance: CMsgClientToGCDeclineInviteToGuild = CMsgClientToGCDeclineInviteToGuild {
            guild_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCDeclineInviteToGuildResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCDeclineInviteToGuildResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCDeclineInviteToGuildResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcdecline_invite_to_guild_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCDeclineInviteToGuildResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCDeclineInviteToGuildResponse {
    fn default() -> &'a CMsgClientToGCDeclineInviteToGuildResponse {
        <CMsgClientToGCDeclineInviteToGuildResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCDeclineInviteToGuildResponse {
    pub fn new() -> CMsgClientToGCDeclineInviteToGuildResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCDeclineInviteToGuildResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcdecline_invite_to_guild_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcdecline_invite_to_guild_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcdecline_invite_to_guild_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcdecline_invite_to_guild_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCDeclineInviteToGuildResponse {
    const NAME: &'static str = "CMsgClientToGCDeclineInviteToGuildResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCDeclineInviteToGuildResponse {
        CMsgClientToGCDeclineInviteToGuildResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCDeclineInviteToGuildResponse {
        static instance: CMsgClientToGCDeclineInviteToGuildResponse = CMsgClientToGCDeclineInviteToGuildResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCDeclineInviteToGuildResponse`
pub mod cmsg_client_to_gcdecline_invite_to_guild_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCDeclineInviteToGuildResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCDeclineInviteToGuildResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCDeclineInviteToGuildResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCDeclineInviteToGuildResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCDeclineInviteToGuildResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCDeclineInviteToGuildResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCDeclineInviteToGuildResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCDeclineInviteToGuildResponse.EResponse.k_eNoInviteFound)
        k_eNoInviteFound = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eNoInviteFound),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNoInviteFound" => ::std::option::Option::Some(EResponse::k_eNoInviteFound),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNoInviteFound,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCAcceptInviteToGuild)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCAcceptInviteToGuild {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCAcceptInviteToGuild.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCAcceptInviteToGuild.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCAcceptInviteToGuild {
    fn default() -> &'a CMsgClientToGCAcceptInviteToGuild {
        <CMsgClientToGCAcceptInviteToGuild as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCAcceptInviteToGuild {
    pub fn new() -> CMsgClientToGCAcceptInviteToGuild {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCAcceptInviteToGuild {
    const NAME: &'static str = "CMsgClientToGCAcceptInviteToGuild";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCAcceptInviteToGuild {
        CMsgClientToGCAcceptInviteToGuild::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCAcceptInviteToGuild {
        static instance: CMsgClientToGCAcceptInviteToGuild = CMsgClientToGCAcceptInviteToGuild {
            guild_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCAcceptInviteToGuildResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCAcceptInviteToGuildResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCAcceptInviteToGuildResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcaccept_invite_to_guild_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCAcceptInviteToGuildResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCAcceptInviteToGuildResponse {
    fn default() -> &'a CMsgClientToGCAcceptInviteToGuildResponse {
        <CMsgClientToGCAcceptInviteToGuildResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCAcceptInviteToGuildResponse {
    pub fn new() -> CMsgClientToGCAcceptInviteToGuildResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCAcceptInviteToGuildResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcaccept_invite_to_guild_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcaccept_invite_to_guild_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcaccept_invite_to_guild_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcaccept_invite_to_guild_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCAcceptInviteToGuildResponse {
    const NAME: &'static str = "CMsgClientToGCAcceptInviteToGuildResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCAcceptInviteToGuildResponse {
        CMsgClientToGCAcceptInviteToGuildResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCAcceptInviteToGuildResponse {
        static instance: CMsgClientToGCAcceptInviteToGuildResponse = CMsgClientToGCAcceptInviteToGuildResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCAcceptInviteToGuildResponse`
pub mod cmsg_client_to_gcaccept_invite_to_guild_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCAcceptInviteToGuildResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eNoInviteFound)
        k_eNoInviteFound = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eGuildFull)
        k_eGuildFull = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eGuildLimit)
        k_eGuildLimit = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eInvalidInviter)
        k_eInvalidInviter = 9,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcceptInviteToGuildResponse.EResponse.k_eAlreadyInGuild)
        k_eAlreadyInGuild = 10,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eNoInviteFound),
                7 => ::std::option::Option::Some(EResponse::k_eGuildFull),
                8 => ::std::option::Option::Some(EResponse::k_eGuildLimit),
                9 => ::std::option::Option::Some(EResponse::k_eInvalidInviter),
                10 => ::std::option::Option::Some(EResponse::k_eAlreadyInGuild),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNoInviteFound" => ::std::option::Option::Some(EResponse::k_eNoInviteFound),
                "k_eGuildFull" => ::std::option::Option::Some(EResponse::k_eGuildFull),
                "k_eGuildLimit" => ::std::option::Option::Some(EResponse::k_eGuildLimit),
                "k_eInvalidInviter" => ::std::option::Option::Some(EResponse::k_eInvalidInviter),
                "k_eAlreadyInGuild" => ::std::option::Option::Some(EResponse::k_eAlreadyInGuild),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNoInviteFound,
            EResponse::k_eGuildFull,
            EResponse::k_eGuildLimit,
            EResponse::k_eInvalidInviter,
            EResponse::k_eAlreadyInGuild,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCCancelInviteToGuild)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCancelInviteToGuild {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCancelInviteToGuild.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCCancelInviteToGuild.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCancelInviteToGuild.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCancelInviteToGuild {
    fn default() -> &'a CMsgClientToGCCancelInviteToGuild {
        <CMsgClientToGCCancelInviteToGuild as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCancelInviteToGuild {
    pub fn new() -> CMsgClientToGCCancelInviteToGuild {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 target_account_id = 2;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCancelInviteToGuild {
    const NAME: &'static str = "CMsgClientToGCCancelInviteToGuild";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_account_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCancelInviteToGuild {
        CMsgClientToGCCancelInviteToGuild::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.target_account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCancelInviteToGuild {
        static instance: CMsgClientToGCCancelInviteToGuild = CMsgClientToGCCancelInviteToGuild {
            guild_id: ::std::option::Option::None,
            target_account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCCancelInviteToGuildResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCancelInviteToGuildResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCancelInviteToGuildResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gccancel_invite_to_guild_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCancelInviteToGuildResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCancelInviteToGuildResponse {
    fn default() -> &'a CMsgClientToGCCancelInviteToGuildResponse {
        <CMsgClientToGCCancelInviteToGuildResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCancelInviteToGuildResponse {
    pub fn new() -> CMsgClientToGCCancelInviteToGuildResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCCancelInviteToGuildResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gccancel_invite_to_guild_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gccancel_invite_to_guild_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gccancel_invite_to_guild_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gccancel_invite_to_guild_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCancelInviteToGuildResponse {
    const NAME: &'static str = "CMsgClientToGCCancelInviteToGuildResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCancelInviteToGuildResponse {
        CMsgClientToGCCancelInviteToGuildResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCancelInviteToGuildResponse {
        static instance: CMsgClientToGCCancelInviteToGuildResponse = CMsgClientToGCCancelInviteToGuildResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCCancelInviteToGuildResponse`
pub mod cmsg_client_to_gccancel_invite_to_guild_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCCancelInviteToGuildResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCancelInviteToGuildResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCancelInviteToGuildResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCancelInviteToGuildResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCancelInviteToGuildResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCancelInviteToGuildResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCancelInviteToGuildResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCancelInviteToGuildResponse.EResponse.k_eNoInviteFound)
        k_eNoInviteFound = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCancelInviteToGuildResponse.EResponse.k_eNoPermissions)
        k_eNoPermissions = 7,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eNoInviteFound),
                7 => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNoInviteFound" => ::std::option::Option::Some(EResponse::k_eNoInviteFound),
                "k_eNoPermissions" => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNoInviteFound,
            EResponse::k_eNoPermissions,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCAddGuildRole)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCAddGuildRole {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCAddGuildRole.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCAddGuildRole.role_name)
    pub role_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientToGCAddGuildRole.role_flags)
    pub role_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCAddGuildRole.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCAddGuildRole {
    fn default() -> &'a CMsgClientToGCAddGuildRole {
        <CMsgClientToGCAddGuildRole as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCAddGuildRole {
    pub fn new() -> CMsgClientToGCAddGuildRole {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional string role_name = 2;

    pub fn role_name(&self) -> &str {
        match self.role_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_role_name(&mut self) {
        self.role_name = ::std::option::Option::None;
    }

    pub fn has_role_name(&self) -> bool {
        self.role_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_name(&mut self, v: ::std::string::String) {
        self.role_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role_name(&mut self) -> &mut ::std::string::String {
        if self.role_name.is_none() {
            self.role_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.role_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_role_name(&mut self) -> ::std::string::String {
        self.role_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 role_flags = 3;

    pub fn role_flags(&self) -> u32 {
        self.role_flags.unwrap_or(0)
    }

    pub fn clear_role_flags(&mut self) {
        self.role_flags = ::std::option::Option::None;
    }

    pub fn has_role_flags(&self) -> bool {
        self.role_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_flags(&mut self, v: u32) {
        self.role_flags = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCAddGuildRole {
    const NAME: &'static str = "CMsgClientToGCAddGuildRole";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.role_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.role_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.role_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.role_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.role_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.role_flags {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCAddGuildRole {
        CMsgClientToGCAddGuildRole::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.role_name = ::std::option::Option::None;
        self.role_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCAddGuildRole {
        static instance: CMsgClientToGCAddGuildRole = CMsgClientToGCAddGuildRole {
            guild_id: ::std::option::Option::None,
            role_name: ::std::option::Option::None,
            role_flags: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCAddGuildRoleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCAddGuildRoleResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCAddGuildRoleResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcadd_guild_role_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCAddGuildRoleResponse.role_id)
    pub role_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCAddGuildRoleResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCAddGuildRoleResponse {
    fn default() -> &'a CMsgClientToGCAddGuildRoleResponse {
        <CMsgClientToGCAddGuildRoleResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCAddGuildRoleResponse {
    pub fn new() -> CMsgClientToGCAddGuildRoleResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCAddGuildRoleResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcadd_guild_role_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcadd_guild_role_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcadd_guild_role_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcadd_guild_role_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 role_id = 2;

    pub fn role_id(&self) -> u32 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u32) {
        self.role_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCAddGuildRoleResponse {
    const NAME: &'static str = "CMsgClientToGCAddGuildRoleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.role_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.role_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCAddGuildRoleResponse {
        CMsgClientToGCAddGuildRoleResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCAddGuildRoleResponse {
        static instance: CMsgClientToGCAddGuildRoleResponse = CMsgClientToGCAddGuildRoleResponse {
            result: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCAddGuildRoleResponse`
pub mod cmsg_client_to_gcadd_guild_role_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCAddGuildRoleResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAddGuildRoleResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAddGuildRoleResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAddGuildRoleResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAddGuildRoleResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAddGuildRoleResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAddGuildRoleResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAddGuildRoleResponse.EResponse.k_eNameAlreadyUsed)
        k_eNameAlreadyUsed = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAddGuildRoleResponse.EResponse.k_eNoPermissions)
        k_eNoPermissions = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAddGuildRoleResponse.EResponse.k_eInvalidFlags)
        k_eInvalidFlags = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAddGuildRoleResponse.EResponse.k_eInvalidName)
        k_eInvalidName = 9,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAddGuildRoleResponse.EResponse.k_eAdminViolation)
        k_eAdminViolation = 10,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAddGuildRoleResponse.EResponse.k_eTooManyRoles)
        k_eTooManyRoles = 11,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAddGuildRoleResponse.EResponse.k_eBlocked)
        k_eBlocked = 12,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eNameAlreadyUsed),
                7 => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                8 => ::std::option::Option::Some(EResponse::k_eInvalidFlags),
                9 => ::std::option::Option::Some(EResponse::k_eInvalidName),
                10 => ::std::option::Option::Some(EResponse::k_eAdminViolation),
                11 => ::std::option::Option::Some(EResponse::k_eTooManyRoles),
                12 => ::std::option::Option::Some(EResponse::k_eBlocked),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNameAlreadyUsed" => ::std::option::Option::Some(EResponse::k_eNameAlreadyUsed),
                "k_eNoPermissions" => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                "k_eInvalidFlags" => ::std::option::Option::Some(EResponse::k_eInvalidFlags),
                "k_eInvalidName" => ::std::option::Option::Some(EResponse::k_eInvalidName),
                "k_eAdminViolation" => ::std::option::Option::Some(EResponse::k_eAdminViolation),
                "k_eTooManyRoles" => ::std::option::Option::Some(EResponse::k_eTooManyRoles),
                "k_eBlocked" => ::std::option::Option::Some(EResponse::k_eBlocked),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNameAlreadyUsed,
            EResponse::k_eNoPermissions,
            EResponse::k_eInvalidFlags,
            EResponse::k_eInvalidName,
            EResponse::k_eAdminViolation,
            EResponse::k_eTooManyRoles,
            EResponse::k_eBlocked,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCModifyGuildRole)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCModifyGuildRole {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCModifyGuildRole.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCModifyGuildRole.role_id)
    pub role_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCModifyGuildRole.role_name)
    pub role_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientToGCModifyGuildRole.role_flags)
    pub role_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCModifyGuildRole.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCModifyGuildRole {
    fn default() -> &'a CMsgClientToGCModifyGuildRole {
        <CMsgClientToGCModifyGuildRole as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCModifyGuildRole {
    pub fn new() -> CMsgClientToGCModifyGuildRole {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 role_id = 2;

    pub fn role_id(&self) -> u32 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u32) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional string role_name = 3;

    pub fn role_name(&self) -> &str {
        match self.role_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_role_name(&mut self) {
        self.role_name = ::std::option::Option::None;
    }

    pub fn has_role_name(&self) -> bool {
        self.role_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_name(&mut self, v: ::std::string::String) {
        self.role_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role_name(&mut self) -> &mut ::std::string::String {
        if self.role_name.is_none() {
            self.role_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.role_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_role_name(&mut self) -> ::std::string::String {
        self.role_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 role_flags = 4;

    pub fn role_flags(&self) -> u32 {
        self.role_flags.unwrap_or(0)
    }

    pub fn clear_role_flags(&mut self) {
        self.role_flags = ::std::option::Option::None;
    }

    pub fn has_role_flags(&self) -> bool {
        self.role_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_flags(&mut self, v: u32) {
        self.role_flags = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCModifyGuildRole {
    const NAME: &'static str = "CMsgClientToGCModifyGuildRole";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.role_name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.role_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.role_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.role_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.role_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.role_flags {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCModifyGuildRole {
        CMsgClientToGCModifyGuildRole::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.role_name = ::std::option::Option::None;
        self.role_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCModifyGuildRole {
        static instance: CMsgClientToGCModifyGuildRole = CMsgClientToGCModifyGuildRole {
            guild_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            role_name: ::std::option::Option::None,
            role_flags: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCModifyGuildRoleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCModifyGuildRoleResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCModifyGuildRoleResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcmodify_guild_role_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCModifyGuildRoleResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCModifyGuildRoleResponse {
    fn default() -> &'a CMsgClientToGCModifyGuildRoleResponse {
        <CMsgClientToGCModifyGuildRoleResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCModifyGuildRoleResponse {
    pub fn new() -> CMsgClientToGCModifyGuildRoleResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCModifyGuildRoleResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcmodify_guild_role_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcmodify_guild_role_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcmodify_guild_role_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcmodify_guild_role_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCModifyGuildRoleResponse {
    const NAME: &'static str = "CMsgClientToGCModifyGuildRoleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCModifyGuildRoleResponse {
        CMsgClientToGCModifyGuildRoleResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCModifyGuildRoleResponse {
        static instance: CMsgClientToGCModifyGuildRoleResponse = CMsgClientToGCModifyGuildRoleResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCModifyGuildRoleResponse`
pub mod cmsg_client_to_gcmodify_guild_role_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCModifyGuildRoleResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eInvalidRole)
        k_eInvalidRole = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eNameAlreadyUsed)
        k_eNameAlreadyUsed = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eInvalidFlags)
        k_eInvalidFlags = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eInvalidName)
        k_eInvalidName = 9,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eNoPermissions)
        k_eNoPermissions = 10,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eAdminViolation)
        k_eAdminViolation = 11,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCModifyGuildRoleResponse.EResponse.k_eBlocked)
        k_eBlocked = 12,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidRole),
                7 => ::std::option::Option::Some(EResponse::k_eNameAlreadyUsed),
                8 => ::std::option::Option::Some(EResponse::k_eInvalidFlags),
                9 => ::std::option::Option::Some(EResponse::k_eInvalidName),
                10 => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                11 => ::std::option::Option::Some(EResponse::k_eAdminViolation),
                12 => ::std::option::Option::Some(EResponse::k_eBlocked),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eInvalidRole" => ::std::option::Option::Some(EResponse::k_eInvalidRole),
                "k_eNameAlreadyUsed" => ::std::option::Option::Some(EResponse::k_eNameAlreadyUsed),
                "k_eInvalidFlags" => ::std::option::Option::Some(EResponse::k_eInvalidFlags),
                "k_eInvalidName" => ::std::option::Option::Some(EResponse::k_eInvalidName),
                "k_eNoPermissions" => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                "k_eAdminViolation" => ::std::option::Option::Some(EResponse::k_eAdminViolation),
                "k_eBlocked" => ::std::option::Option::Some(EResponse::k_eBlocked),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eInvalidRole,
            EResponse::k_eNameAlreadyUsed,
            EResponse::k_eInvalidFlags,
            EResponse::k_eInvalidName,
            EResponse::k_eNoPermissions,
            EResponse::k_eAdminViolation,
            EResponse::k_eBlocked,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCRemoveGuildRole)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRemoveGuildRole {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRemoveGuildRole.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCRemoveGuildRole.role_id)
    pub role_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRemoveGuildRole.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRemoveGuildRole {
    fn default() -> &'a CMsgClientToGCRemoveGuildRole {
        <CMsgClientToGCRemoveGuildRole as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRemoveGuildRole {
    pub fn new() -> CMsgClientToGCRemoveGuildRole {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 role_id = 2;

    pub fn role_id(&self) -> u32 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u32) {
        self.role_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRemoveGuildRole {
    const NAME: &'static str = "CMsgClientToGCRemoveGuildRole";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRemoveGuildRole {
        CMsgClientToGCRemoveGuildRole::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRemoveGuildRole {
        static instance: CMsgClientToGCRemoveGuildRole = CMsgClientToGCRemoveGuildRole {
            guild_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRemoveGuildRoleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRemoveGuildRoleResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRemoveGuildRoleResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcremove_guild_role_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRemoveGuildRoleResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRemoveGuildRoleResponse {
    fn default() -> &'a CMsgClientToGCRemoveGuildRoleResponse {
        <CMsgClientToGCRemoveGuildRoleResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRemoveGuildRoleResponse {
    pub fn new() -> CMsgClientToGCRemoveGuildRoleResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCRemoveGuildRoleResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcremove_guild_role_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcremove_guild_role_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcremove_guild_role_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcremove_guild_role_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRemoveGuildRoleResponse {
    const NAME: &'static str = "CMsgClientToGCRemoveGuildRoleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRemoveGuildRoleResponse {
        CMsgClientToGCRemoveGuildRoleResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRemoveGuildRoleResponse {
        static instance: CMsgClientToGCRemoveGuildRoleResponse = CMsgClientToGCRemoveGuildRoleResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCRemoveGuildRoleResponse`
pub mod cmsg_client_to_gcremove_guild_role_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCRemoveGuildRoleResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eInvalidRole)
        k_eInvalidRole = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eRoleNotEmpty)
        k_eRoleNotEmpty = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eNoPermissions)
        k_eNoPermissions = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eAdminViolation)
        k_eAdminViolation = 9,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRemoveGuildRoleResponse.EResponse.k_eCantRemoveDefaultRole)
        k_eCantRemoveDefaultRole = 10,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidRole),
                7 => ::std::option::Option::Some(EResponse::k_eRoleNotEmpty),
                8 => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                9 => ::std::option::Option::Some(EResponse::k_eAdminViolation),
                10 => ::std::option::Option::Some(EResponse::k_eCantRemoveDefaultRole),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eInvalidRole" => ::std::option::Option::Some(EResponse::k_eInvalidRole),
                "k_eRoleNotEmpty" => ::std::option::Option::Some(EResponse::k_eRoleNotEmpty),
                "k_eNoPermissions" => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                "k_eAdminViolation" => ::std::option::Option::Some(EResponse::k_eAdminViolation),
                "k_eCantRemoveDefaultRole" => ::std::option::Option::Some(EResponse::k_eCantRemoveDefaultRole),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eInvalidRole,
            EResponse::k_eRoleNotEmpty,
            EResponse::k_eNoPermissions,
            EResponse::k_eAdminViolation,
            EResponse::k_eCantRemoveDefaultRole,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCSetGuildRoleOrder)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetGuildRoleOrder {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSetGuildRoleOrder.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCSetGuildRoleOrder.requested_role_ids)
    pub requested_role_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCSetGuildRoleOrder.previous_role_ids)
    pub previous_role_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSetGuildRoleOrder.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetGuildRoleOrder {
    fn default() -> &'a CMsgClientToGCSetGuildRoleOrder {
        <CMsgClientToGCSetGuildRoleOrder as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetGuildRoleOrder {
    pub fn new() -> CMsgClientToGCSetGuildRoleOrder {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSetGuildRoleOrder {
    const NAME: &'static str = "CMsgClientToGCSetGuildRoleOrder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.requested_role_ids)?;
                },
                16 => {
                    self.requested_role_ids.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.previous_role_ids)?;
                },
                24 => {
                    self.previous_role_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.requested_role_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.previous_role_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.requested_role_ids {
            os.write_uint32(2, *v)?;
        };
        for v in &self.previous_role_ids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetGuildRoleOrder {
        CMsgClientToGCSetGuildRoleOrder::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.requested_role_ids.clear();
        self.previous_role_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetGuildRoleOrder {
        static instance: CMsgClientToGCSetGuildRoleOrder = CMsgClientToGCSetGuildRoleOrder {
            guild_id: ::std::option::Option::None,
            requested_role_ids: ::std::vec::Vec::new(),
            previous_role_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCSetGuildRoleOrderResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetGuildRoleOrderResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSetGuildRoleOrderResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcset_guild_role_order_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCSetGuildRoleOrderResponse.confirmed_role_ids)
    pub confirmed_role_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSetGuildRoleOrderResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetGuildRoleOrderResponse {
    fn default() -> &'a CMsgClientToGCSetGuildRoleOrderResponse {
        <CMsgClientToGCSetGuildRoleOrderResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetGuildRoleOrderResponse {
    pub fn new() -> CMsgClientToGCSetGuildRoleOrderResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCSetGuildRoleOrderResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcset_guild_role_order_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcset_guild_role_order_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcset_guild_role_order_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcset_guild_role_order_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSetGuildRoleOrderResponse {
    const NAME: &'static str = "CMsgClientToGCSetGuildRoleOrderResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.confirmed_role_ids)?;
                },
                16 => {
                    self.confirmed_role_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.confirmed_role_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.confirmed_role_ids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetGuildRoleOrderResponse {
        CMsgClientToGCSetGuildRoleOrderResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.confirmed_role_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetGuildRoleOrderResponse {
        static instance: CMsgClientToGCSetGuildRoleOrderResponse = CMsgClientToGCSetGuildRoleOrderResponse {
            result: ::std::option::Option::None,
            confirmed_role_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCSetGuildRoleOrderResponse`
pub mod cmsg_client_to_gcset_guild_role_order_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCSetGuildRoleOrderResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildRoleOrderResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildRoleOrderResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildRoleOrderResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildRoleOrderResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildRoleOrderResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildRoleOrderResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildRoleOrderResponse.EResponse.k_eInvalidRole)
        k_eInvalidRole = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildRoleOrderResponse.EResponse.k_eInvalidOrder)
        k_eInvalidOrder = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildRoleOrderResponse.EResponse.k_eNoPermissions)
        k_eNoPermissions = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetGuildRoleOrderResponse.EResponse.k_eAdminViolation)
        k_eAdminViolation = 9,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidRole),
                7 => ::std::option::Option::Some(EResponse::k_eInvalidOrder),
                8 => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                9 => ::std::option::Option::Some(EResponse::k_eAdminViolation),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eInvalidRole" => ::std::option::Option::Some(EResponse::k_eInvalidRole),
                "k_eInvalidOrder" => ::std::option::Option::Some(EResponse::k_eInvalidOrder),
                "k_eNoPermissions" => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                "k_eAdminViolation" => ::std::option::Option::Some(EResponse::k_eAdminViolation),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eInvalidRole,
            EResponse::k_eInvalidOrder,
            EResponse::k_eNoPermissions,
            EResponse::k_eAdminViolation,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCGuildFeedRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGuildFeedRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGuildFeedRequest.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGuildFeedRequest.last_seen_id)
    pub last_seen_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGuildFeedRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGuildFeedRequest {
    fn default() -> &'a CMsgClientToGCGuildFeedRequest {
        <CMsgClientToGCGuildFeedRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGuildFeedRequest {
    pub fn new() -> CMsgClientToGCGuildFeedRequest {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint64 last_seen_id = 2;

    pub fn last_seen_id(&self) -> u64 {
        self.last_seen_id.unwrap_or(0)
    }

    pub fn clear_last_seen_id(&mut self) {
        self.last_seen_id = ::std::option::Option::None;
    }

    pub fn has_last_seen_id(&self) -> bool {
        self.last_seen_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_seen_id(&mut self, v: u64) {
        self.last_seen_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGuildFeedRequest {
    const NAME: &'static str = "CMsgClientToGCGuildFeedRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.last_seen_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.last_seen_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.last_seen_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGuildFeedRequest {
        CMsgClientToGCGuildFeedRequest::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.last_seen_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGuildFeedRequest {
        static instance: CMsgClientToGCGuildFeedRequest = CMsgClientToGCGuildFeedRequest {
            guild_id: ::std::option::Option::None,
            last_seen_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestGuildFeedResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestGuildFeedResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestGuildFeedResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_guild_feed_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestGuildFeedResponse.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestGuildFeedResponse.feed_events)
    pub feed_events: ::std::vec::Vec<CMsgGuildFeedEvent>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestGuildFeedResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestGuildFeedResponse {
    fn default() -> &'a CMsgClientToGCRequestGuildFeedResponse {
        <CMsgClientToGCRequestGuildFeedResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestGuildFeedResponse {
    pub fn new() -> CMsgClientToGCRequestGuildFeedResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCRequestGuildFeedResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_guild_feed_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_guild_feed_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_guild_feed_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_guild_feed_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 guild_id = 2;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestGuildFeedResponse {
    const NAME: &'static str = "CMsgClientToGCRequestGuildFeedResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.feed_events.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.feed_events {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.guild_id {
            os.write_uint32(2, v)?;
        }
        for v in &self.feed_events {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestGuildFeedResponse {
        CMsgClientToGCRequestGuildFeedResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.guild_id = ::std::option::Option::None;
        self.feed_events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestGuildFeedResponse {
        static instance: CMsgClientToGCRequestGuildFeedResponse = CMsgClientToGCRequestGuildFeedResponse {
            result: ::std::option::Option::None,
            guild_id: ::std::option::Option::None,
            feed_events: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCRequestGuildFeedResponse`
pub mod cmsg_client_to_gcrequest_guild_feed_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCRequestGuildFeedResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildFeedResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildFeedResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildFeedResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildFeedResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildFeedResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildFeedResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildFeedResponse.EResponse.k_eNoPermissions)
        k_eNoPermissions = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNoPermissions" => ::std::option::Option::Some(EResponse::k_eNoPermissions),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNoPermissions,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCToClientGuildFeedUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientGuildFeedUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientGuildFeedUpdated.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientGuildFeedUpdated.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientGuildFeedUpdated {
    fn default() -> &'a CMsgGCToClientGuildFeedUpdated {
        <CMsgGCToClientGuildFeedUpdated as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientGuildFeedUpdated {
    pub fn new() -> CMsgGCToClientGuildFeedUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientGuildFeedUpdated {
    const NAME: &'static str = "CMsgGCToClientGuildFeedUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientGuildFeedUpdated {
        CMsgGCToClientGuildFeedUpdated::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientGuildFeedUpdated {
        static instance: CMsgGCToClientGuildFeedUpdated = CMsgGCToClientGuildFeedUpdated {
            guild_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCAddPlayerToGuildChat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCAddPlayerToGuildChat {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCAddPlayerToGuildChat.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCAddPlayerToGuildChat.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCAddPlayerToGuildChat {
    fn default() -> &'a CMsgClientToGCAddPlayerToGuildChat {
        <CMsgClientToGCAddPlayerToGuildChat as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCAddPlayerToGuildChat {
    pub fn new() -> CMsgClientToGCAddPlayerToGuildChat {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCAddPlayerToGuildChat {
    const NAME: &'static str = "CMsgClientToGCAddPlayerToGuildChat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCAddPlayerToGuildChat {
        CMsgClientToGCAddPlayerToGuildChat::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCAddPlayerToGuildChat {
        static instance: CMsgClientToGCAddPlayerToGuildChat = CMsgClientToGCAddPlayerToGuildChat {
            guild_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCAddPlayerToGuildChatResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCAddPlayerToGuildChatResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCAddPlayerToGuildChatResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcadd_player_to_guild_chat_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCAddPlayerToGuildChatResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCAddPlayerToGuildChatResponse {
    fn default() -> &'a CMsgClientToGCAddPlayerToGuildChatResponse {
        <CMsgClientToGCAddPlayerToGuildChatResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCAddPlayerToGuildChatResponse {
    pub fn new() -> CMsgClientToGCAddPlayerToGuildChatResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCAddPlayerToGuildChatResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcadd_player_to_guild_chat_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcadd_player_to_guild_chat_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcadd_player_to_guild_chat_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcadd_player_to_guild_chat_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCAddPlayerToGuildChatResponse {
    const NAME: &'static str = "CMsgClientToGCAddPlayerToGuildChatResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCAddPlayerToGuildChatResponse {
        CMsgClientToGCAddPlayerToGuildChatResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCAddPlayerToGuildChatResponse {
        static instance: CMsgClientToGCAddPlayerToGuildChatResponse = CMsgClientToGCAddPlayerToGuildChatResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCAddPlayerToGuildChatResponse`
pub mod cmsg_client_to_gcadd_player_to_guild_chat_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCAddPlayerToGuildChatResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAddPlayerToGuildChatResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAddPlayerToGuildChatResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAddPlayerToGuildChatResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAddPlayerToGuildChatResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAddPlayerToGuildChatResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAddPlayerToGuildChatResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAddPlayerToGuildChatResponse.EResponse.k_eNotMember)
        k_eNotMember = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAddPlayerToGuildChatResponse.EResponse.k_eSteamChatNotEnabled)
        k_eSteamChatNotEnabled = 7,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                6 => ::std::option::Option::Some(EResponse::k_eNotMember),
                7 => ::std::option::Option::Some(EResponse::k_eSteamChatNotEnabled),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNotMember" => ::std::option::Option::Some(EResponse::k_eNotMember),
                "k_eSteamChatNotEnabled" => ::std::option::Option::Some(EResponse::k_eSteamChatNotEnabled),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNotMember,
            EResponse::k_eSteamChatNotEnabled,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgFindGuildByTagResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFindGuildByTagResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgFindGuildByTagResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_find_guild_by_tag_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgFindGuildByTagResponse.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgFindGuildByTagResponse.guild_summary)
    pub guild_summary: ::steam_vent_proto_common::protobuf::MessageField<CMsgGuildSummary>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFindGuildByTagResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFindGuildByTagResponse {
    fn default() -> &'a CMsgFindGuildByTagResponse {
        <CMsgFindGuildByTagResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgFindGuildByTagResponse {
    pub fn new() -> CMsgFindGuildByTagResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgFindGuildByTagResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_find_guild_by_tag_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_find_guild_by_tag_response::EResponse::k_eInternalError),
            None => cmsg_find_guild_by_tag_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_find_guild_by_tag_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 guild_id = 2;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgFindGuildByTagResponse {
    const NAME: &'static str = "CMsgFindGuildByTagResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_summary)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.guild_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.guild_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.guild_summary.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFindGuildByTagResponse {
        CMsgFindGuildByTagResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.guild_id = ::std::option::Option::None;
        self.guild_summary.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFindGuildByTagResponse {
        static instance: CMsgFindGuildByTagResponse = CMsgFindGuildByTagResponse {
            result: ::std::option::Option::None,
            guild_id: ::std::option::Option::None,
            guild_summary: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgFindGuildByTagResponse`
pub mod cmsg_find_guild_by_tag_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgFindGuildByTagResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgFindGuildByTagResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgFindGuildByTagResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgFindGuildByTagResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgFindGuildByTagResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgFindGuildByTagResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgFindGuildByTagResponse.EResponse.k_eInvalidTag)
        k_eInvalidTag = 5,
        // @@protoc_insertion_point(enum_value:CMsgFindGuildByTagResponse.EResponse.k_eGuildNotFound)
        k_eGuildNotFound = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidTag),
                6 => ::std::option::Option::Some(EResponse::k_eGuildNotFound),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidTag" => ::std::option::Option::Some(EResponse::k_eInvalidTag),
                "k_eGuildNotFound" => ::std::option::Option::Some(EResponse::k_eGuildNotFound),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidTag,
            EResponse::k_eGuildNotFound,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgSearchForOpenGuildsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSearchForOpenGuildsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgSearchForOpenGuildsResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_search_for_open_guilds_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgSearchForOpenGuildsResponse.search_results)
    pub search_results: ::std::vec::Vec<cmsg_search_for_open_guilds_response::SearchResult>,
    // @@protoc_insertion_point(field:CMsgSearchForOpenGuildsResponse.use_whitelist)
    pub use_whitelist: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSearchForOpenGuildsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSearchForOpenGuildsResponse {
    fn default() -> &'a CMsgSearchForOpenGuildsResponse {
        <CMsgSearchForOpenGuildsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSearchForOpenGuildsResponse {
    pub fn new() -> CMsgSearchForOpenGuildsResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgSearchForOpenGuildsResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_search_for_open_guilds_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_search_for_open_guilds_response::EResponse::k_eInternalError),
            None => cmsg_search_for_open_guilds_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_search_for_open_guilds_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool use_whitelist = 3;

    pub fn use_whitelist(&self) -> bool {
        self.use_whitelist.unwrap_or(false)
    }

    pub fn clear_use_whitelist(&mut self) {
        self.use_whitelist = ::std::option::Option::None;
    }

    pub fn has_use_whitelist(&self) -> bool {
        self.use_whitelist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_whitelist(&mut self, v: bool) {
        self.use_whitelist = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSearchForOpenGuildsResponse {
    const NAME: &'static str = "CMsgSearchForOpenGuildsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.search_results.push(is.read_message()?);
                },
                24 => {
                    self.use_whitelist = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.search_results {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.use_whitelist {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.search_results {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.use_whitelist {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSearchForOpenGuildsResponse {
        CMsgSearchForOpenGuildsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.search_results.clear();
        self.use_whitelist = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSearchForOpenGuildsResponse {
        static instance: CMsgSearchForOpenGuildsResponse = CMsgSearchForOpenGuildsResponse {
            result: ::std::option::Option::None,
            search_results: ::std::vec::Vec::new(),
            use_whitelist: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSearchForOpenGuildsResponse`
pub mod cmsg_search_for_open_guilds_response {
    // @@protoc_insertion_point(message:CMsgSearchForOpenGuildsResponse.SearchResult)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SearchResult {
        // message fields
        // @@protoc_insertion_point(field:CMsgSearchForOpenGuildsResponse.SearchResult.guild_id)
        pub guild_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSearchForOpenGuildsResponse.SearchResult.guild_summary)
        pub guild_summary: ::steam_vent_proto_common::protobuf::MessageField<super::CMsgGuildSummary>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSearchForOpenGuildsResponse.SearchResult.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SearchResult {
        fn default() -> &'a SearchResult {
            <SearchResult as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SearchResult {
        pub fn new() -> SearchResult {
            ::std::default::Default::default()
        }

        // optional uint32 guild_id = 1;

        pub fn guild_id(&self) -> u32 {
            self.guild_id.unwrap_or(0)
        }

        pub fn clear_guild_id(&mut self) {
            self.guild_id = ::std::option::Option::None;
        }

        pub fn has_guild_id(&self) -> bool {
            self.guild_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guild_id(&mut self, v: u32) {
            self.guild_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SearchResult {
        const NAME: &'static str = "SearchResult";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_summary)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.guild_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.guild_summary.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.guild_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.guild_summary.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SearchResult {
            SearchResult::new()
        }

        fn clear(&mut self) {
            self.guild_id = ::std::option::Option::None;
            self.guild_summary.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SearchResult {
            static instance: SearchResult = SearchResult {
                guild_id: ::std::option::Option::None,
                guild_summary: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSearchForOpenGuildsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgSearchForOpenGuildsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgSearchForOpenGuildsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgSearchForOpenGuildsResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgSearchForOpenGuildsResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgSearchForOpenGuildsResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCReportGuildContent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCReportGuildContent {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCReportGuildContent.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCReportGuildContent.guild_content_flags)
    pub guild_content_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCReportGuildContent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCReportGuildContent {
    fn default() -> &'a CMsgClientToGCReportGuildContent {
        <CMsgClientToGCReportGuildContent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCReportGuildContent {
    pub fn new() -> CMsgClientToGCReportGuildContent {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_content_flags = 2;

    pub fn guild_content_flags(&self) -> u32 {
        self.guild_content_flags.unwrap_or(0)
    }

    pub fn clear_guild_content_flags(&mut self) {
        self.guild_content_flags = ::std::option::Option::None;
    }

    pub fn has_guild_content_flags(&self) -> bool {
        self.guild_content_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_content_flags(&mut self, v: u32) {
        self.guild_content_flags = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCReportGuildContent {
    const NAME: &'static str = "CMsgClientToGCReportGuildContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.guild_content_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.guild_content_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.guild_content_flags {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCReportGuildContent {
        CMsgClientToGCReportGuildContent::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.guild_content_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCReportGuildContent {
        static instance: CMsgClientToGCReportGuildContent = CMsgClientToGCReportGuildContent {
            guild_id: ::std::option::Option::None,
            guild_content_flags: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCReportGuildContent`
pub mod cmsg_client_to_gcreport_guild_content {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCReportGuildContent.EContentFlags)
    pub enum EContentFlags {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCReportGuildContent.EContentFlags.k_eNone)
        k_eNone = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCReportGuildContent.EContentFlags.k_eInappropriateName)
        k_eInappropriateName = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCReportGuildContent.EContentFlags.k_eInappropriateTag)
        k_eInappropriateTag = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCReportGuildContent.EContentFlags.k_eInappropriateLogo)
        k_eInappropriateLogo = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCReportGuildContent.EContentFlags.k_eValidFlags)
        k_eValidFlags = 7,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EContentFlags {
        const NAME: &'static str = "EContentFlags";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EContentFlags> {
            match value {
                0 => ::std::option::Option::Some(EContentFlags::k_eNone),
                1 => ::std::option::Option::Some(EContentFlags::k_eInappropriateName),
                2 => ::std::option::Option::Some(EContentFlags::k_eInappropriateTag),
                4 => ::std::option::Option::Some(EContentFlags::k_eInappropriateLogo),
                7 => ::std::option::Option::Some(EContentFlags::k_eValidFlags),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EContentFlags> {
            match str {
                "k_eNone" => ::std::option::Option::Some(EContentFlags::k_eNone),
                "k_eInappropriateName" => ::std::option::Option::Some(EContentFlags::k_eInappropriateName),
                "k_eInappropriateTag" => ::std::option::Option::Some(EContentFlags::k_eInappropriateTag),
                "k_eInappropriateLogo" => ::std::option::Option::Some(EContentFlags::k_eInappropriateLogo),
                "k_eValidFlags" => ::std::option::Option::Some(EContentFlags::k_eValidFlags),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EContentFlags] = &[
            EContentFlags::k_eNone,
            EContentFlags::k_eInappropriateName,
            EContentFlags::k_eInappropriateTag,
            EContentFlags::k_eInappropriateLogo,
            EContentFlags::k_eValidFlags,
        ];
    }

    impl ::std::default::Default for EContentFlags {
        fn default() -> Self {
            EContentFlags::k_eNone
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCReportGuildContentResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCReportGuildContentResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCReportGuildContentResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcreport_guild_content_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCReportGuildContentResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCReportGuildContentResponse {
    fn default() -> &'a CMsgClientToGCReportGuildContentResponse {
        <CMsgClientToGCReportGuildContentResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCReportGuildContentResponse {
    pub fn new() -> CMsgClientToGCReportGuildContentResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCReportGuildContentResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcreport_guild_content_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcreport_guild_content_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcreport_guild_content_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcreport_guild_content_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCReportGuildContentResponse {
    const NAME: &'static str = "CMsgClientToGCReportGuildContentResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCReportGuildContentResponse {
        CMsgClientToGCReportGuildContentResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCReportGuildContentResponse {
        static instance: CMsgClientToGCReportGuildContentResponse = CMsgClientToGCReportGuildContentResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCReportGuildContentResponse`
pub mod cmsg_client_to_gcreport_guild_content_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCReportGuildContentResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCReportGuildContentResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCReportGuildContentResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCReportGuildContentResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCReportGuildContentResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCReportGuildContentResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCReportGuildContentResponse.EResponse.k_eGuildNotFound)
        k_eGuildNotFound = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCReportGuildContentResponse.EResponse.k_eFlagsInvalid)
        k_eFlagsInvalid = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eGuildNotFound),
                6 => ::std::option::Option::Some(EResponse::k_eFlagsInvalid),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eGuildNotFound" => ::std::option::Option::Some(EResponse::k_eGuildNotFound),
                "k_eFlagsInvalid" => ::std::option::Option::Some(EResponse::k_eFlagsInvalid),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eGuildNotFound,
            EResponse::k_eFlagsInvalid,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCRequestAccountGuildPersonaInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestAccountGuildPersonaInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestAccountGuildPersonaInfo.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestAccountGuildPersonaInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestAccountGuildPersonaInfo {
    fn default() -> &'a CMsgClientToGCRequestAccountGuildPersonaInfo {
        <CMsgClientToGCRequestAccountGuildPersonaInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestAccountGuildPersonaInfo {
    pub fn new() -> CMsgClientToGCRequestAccountGuildPersonaInfo {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestAccountGuildPersonaInfo {
    const NAME: &'static str = "CMsgClientToGCRequestAccountGuildPersonaInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestAccountGuildPersonaInfo {
        CMsgClientToGCRequestAccountGuildPersonaInfo::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestAccountGuildPersonaInfo {
        static instance: CMsgClientToGCRequestAccountGuildPersonaInfo = CMsgClientToGCRequestAccountGuildPersonaInfo {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestAccountGuildPersonaInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestAccountGuildPersonaInfoResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_account_guild_persona_info_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestAccountGuildPersonaInfoResponse.persona_info)
    pub persona_info: ::steam_vent_proto_common::protobuf::MessageField<CMsgAccountGuildsPersonaInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestAccountGuildPersonaInfoResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
    fn default() -> &'a CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
        <CMsgClientToGCRequestAccountGuildPersonaInfoResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
    pub fn new() -> CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCRequestAccountGuildPersonaInfoResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_account_guild_persona_info_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_account_guild_persona_info_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_account_guild_persona_info_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_account_guild_persona_info_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
    const NAME: &'static str = "CMsgClientToGCRequestAccountGuildPersonaInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.persona_info)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.persona_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.persona_info.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
        CMsgClientToGCRequestAccountGuildPersonaInfoResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.persona_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
        static instance: CMsgClientToGCRequestAccountGuildPersonaInfoResponse = CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
            result: ::std::option::Option::None,
            persona_info: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCRequestAccountGuildPersonaInfoResponse`
pub mod cmsg_client_to_gcrequest_account_guild_persona_info_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCRequestAccountGuildPersonaInfoResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestAccountGuildPersonaInfoResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestAccountGuildPersonaInfoResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestAccountGuildPersonaInfoResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestAccountGuildPersonaInfoResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestAccountGuildPersonaInfoResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestAccountGuildPersonaInfoResponse.EResponse.k_eInvalidAccount)
        k_eInvalidAccount = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidAccount),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidAccount" => ::std::option::Option::Some(EResponse::k_eInvalidAccount),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidAccount,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCRequestAccountGuildPersonaInfoBatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestAccountGuildPersonaInfoBatch.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestAccountGuildPersonaInfoBatch.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
    fn default() -> &'a CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
        <CMsgClientToGCRequestAccountGuildPersonaInfoBatch as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
    pub fn new() -> CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
    const NAME: &'static str = "CMsgClientToGCRequestAccountGuildPersonaInfoBatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                8 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
        CMsgClientToGCRequestAccountGuildPersonaInfoBatch::new()
    }

    fn clear(&mut self) {
        self.account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
        static instance: CMsgClientToGCRequestAccountGuildPersonaInfoBatch = CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
            account_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_account_guild_persona_info_batch_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.persona_infos)
    pub persona_infos: ::std::vec::Vec<CMsgAccountGuildsPersonaInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
    fn default() -> &'a CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
        <CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
    pub fn new() -> CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_account_guild_persona_info_batch_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_account_guild_persona_info_batch_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_account_guild_persona_info_batch_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_account_guild_persona_info_batch_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
    const NAME: &'static str = "CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.persona_infos.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.persona_infos {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.persona_infos {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
        CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.persona_infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
        static instance: CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse = CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
            result: ::std::option::Option::None,
            persona_infos: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse`
pub mod cmsg_client_to_gcrequest_account_guild_persona_info_batch_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse.EResponse.k_eInvalidRequest)
        k_eInvalidRequest = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidRequest),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidRequest" => ::std::option::Option::Some(EResponse::k_eInvalidRequest),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidRequest,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGuildAuditAction)
pub enum EGuildAuditAction {
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_Invalid)
    k_EGuildAuditAction_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_GuildCreated)
    k_EGuildAuditAction_GuildCreated = 1,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_GuildLanguageChanged)
    k_EGuildAuditAction_GuildLanguageChanged = 2,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_GuildFlagsChanged)
    k_EGuildAuditAction_GuildFlagsChanged = 3,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_GuildMemberJoined)
    k_EGuildAuditAction_GuildMemberJoined = 5,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_GuildMemberLeft)
    k_EGuildAuditAction_GuildMemberLeft = 6,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_GuildMemberKicked)
    k_EGuildAuditAction_GuildMemberKicked = 7,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_GuildMemberRoleChanged)
    k_EGuildAuditAction_GuildMemberRoleChanged = 8,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_GuildLogoChanged)
    k_EGuildAuditAction_GuildLogoChanged = 9,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_GuildRegionChanged)
    k_EGuildAuditAction_GuildRegionChanged = 10,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_GuildDescriptionChanged)
    k_EGuildAuditAction_GuildDescriptionChanged = 11,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_GuildPrimaryColorChanged)
    k_EGuildAuditAction_GuildPrimaryColorChanged = 12,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_GuildSecondaryColorChanged)
    k_EGuildAuditAction_GuildSecondaryColorChanged = 13,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_GuildPatternChanged)
    k_EGuildAuditAction_GuildPatternChanged = 14,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_AdminClearedLogo)
    k_EGuildAuditAction_AdminClearedLogo = 15,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_GuildRequiredRankChanged)
    k_EGuildAuditAction_GuildRequiredRankChanged = 16,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_GuildMotDChanged)
    k_EGuildAuditAction_GuildMotDChanged = 18,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_AdminResetName)
    k_EGuildAuditAction_AdminResetName = 19,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_AdminResetTag)
    k_EGuildAuditAction_AdminResetTag = 20,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_AdminLock)
    k_EGuildAuditAction_AdminLock = 21,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_GuildNameChanged)
    k_EGuildAuditAction_GuildNameChanged = 22,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_GuildTagChanged)
    k_EGuildAuditAction_GuildTagChanged = 23,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_AdminPermitted)
    k_EGuildAuditAction_AdminPermitted = 24,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_AdminBlocked)
    k_EGuildAuditAction_AdminBlocked = 25,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_AdminBannedUser)
    k_EGuildAuditAction_AdminBannedUser = 26,
    // @@protoc_insertion_point(enum_value:EGuildAuditAction.k_EGuildAuditAction_AdminExonerated)
    k_EGuildAuditAction_AdminExonerated = 27,
}

impl ::steam_vent_proto_common::protobuf::Enum for EGuildAuditAction {
    const NAME: &'static str = "EGuildAuditAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGuildAuditAction> {
        match value {
            0 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_Invalid),
            1 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildCreated),
            2 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildLanguageChanged),
            3 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildFlagsChanged),
            5 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildMemberJoined),
            6 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildMemberLeft),
            7 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildMemberKicked),
            8 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildMemberRoleChanged),
            9 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildLogoChanged),
            10 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildRegionChanged),
            11 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildDescriptionChanged),
            12 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildPrimaryColorChanged),
            13 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildSecondaryColorChanged),
            14 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildPatternChanged),
            15 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminClearedLogo),
            16 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildRequiredRankChanged),
            18 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildMotDChanged),
            19 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminResetName),
            20 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminResetTag),
            21 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminLock),
            22 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildNameChanged),
            23 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildTagChanged),
            24 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminPermitted),
            25 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminBlocked),
            26 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminBannedUser),
            27 => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminExonerated),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGuildAuditAction> {
        match str {
            "k_EGuildAuditAction_Invalid" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_Invalid),
            "k_EGuildAuditAction_GuildCreated" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildCreated),
            "k_EGuildAuditAction_GuildLanguageChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildLanguageChanged),
            "k_EGuildAuditAction_GuildFlagsChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildFlagsChanged),
            "k_EGuildAuditAction_GuildMemberJoined" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildMemberJoined),
            "k_EGuildAuditAction_GuildMemberLeft" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildMemberLeft),
            "k_EGuildAuditAction_GuildMemberKicked" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildMemberKicked),
            "k_EGuildAuditAction_GuildMemberRoleChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildMemberRoleChanged),
            "k_EGuildAuditAction_GuildLogoChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildLogoChanged),
            "k_EGuildAuditAction_GuildRegionChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildRegionChanged),
            "k_EGuildAuditAction_GuildDescriptionChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildDescriptionChanged),
            "k_EGuildAuditAction_GuildPrimaryColorChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildPrimaryColorChanged),
            "k_EGuildAuditAction_GuildSecondaryColorChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildSecondaryColorChanged),
            "k_EGuildAuditAction_GuildPatternChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildPatternChanged),
            "k_EGuildAuditAction_AdminClearedLogo" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminClearedLogo),
            "k_EGuildAuditAction_GuildRequiredRankChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildRequiredRankChanged),
            "k_EGuildAuditAction_GuildMotDChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildMotDChanged),
            "k_EGuildAuditAction_AdminResetName" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminResetName),
            "k_EGuildAuditAction_AdminResetTag" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminResetTag),
            "k_EGuildAuditAction_AdminLock" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminLock),
            "k_EGuildAuditAction_GuildNameChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildNameChanged),
            "k_EGuildAuditAction_GuildTagChanged" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_GuildTagChanged),
            "k_EGuildAuditAction_AdminPermitted" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminPermitted),
            "k_EGuildAuditAction_AdminBlocked" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminBlocked),
            "k_EGuildAuditAction_AdminBannedUser" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminBannedUser),
            "k_EGuildAuditAction_AdminExonerated" => ::std::option::Option::Some(EGuildAuditAction::k_EGuildAuditAction_AdminExonerated),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGuildAuditAction] = &[
        EGuildAuditAction::k_EGuildAuditAction_Invalid,
        EGuildAuditAction::k_EGuildAuditAction_GuildCreated,
        EGuildAuditAction::k_EGuildAuditAction_GuildLanguageChanged,
        EGuildAuditAction::k_EGuildAuditAction_GuildFlagsChanged,
        EGuildAuditAction::k_EGuildAuditAction_GuildMemberJoined,
        EGuildAuditAction::k_EGuildAuditAction_GuildMemberLeft,
        EGuildAuditAction::k_EGuildAuditAction_GuildMemberKicked,
        EGuildAuditAction::k_EGuildAuditAction_GuildMemberRoleChanged,
        EGuildAuditAction::k_EGuildAuditAction_GuildLogoChanged,
        EGuildAuditAction::k_EGuildAuditAction_GuildRegionChanged,
        EGuildAuditAction::k_EGuildAuditAction_GuildDescriptionChanged,
        EGuildAuditAction::k_EGuildAuditAction_GuildPrimaryColorChanged,
        EGuildAuditAction::k_EGuildAuditAction_GuildSecondaryColorChanged,
        EGuildAuditAction::k_EGuildAuditAction_GuildPatternChanged,
        EGuildAuditAction::k_EGuildAuditAction_AdminClearedLogo,
        EGuildAuditAction::k_EGuildAuditAction_GuildRequiredRankChanged,
        EGuildAuditAction::k_EGuildAuditAction_GuildMotDChanged,
        EGuildAuditAction::k_EGuildAuditAction_AdminResetName,
        EGuildAuditAction::k_EGuildAuditAction_AdminResetTag,
        EGuildAuditAction::k_EGuildAuditAction_AdminLock,
        EGuildAuditAction::k_EGuildAuditAction_GuildNameChanged,
        EGuildAuditAction::k_EGuildAuditAction_GuildTagChanged,
        EGuildAuditAction::k_EGuildAuditAction_AdminPermitted,
        EGuildAuditAction::k_EGuildAuditAction_AdminBlocked,
        EGuildAuditAction::k_EGuildAuditAction_AdminBannedUser,
        EGuildAuditAction::k_EGuildAuditAction_AdminExonerated,
    ];
}

impl ::std::default::Default for EGuildAuditAction {
    fn default() -> Self {
        EGuildAuditAction::k_EGuildAuditAction_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGuildChatType)
pub enum EGuildChatType {
    // @@protoc_insertion_point(enum_value:EGuildChatType.k_EGuildChatType_Unspecified)
    k_EGuildChatType_Unspecified = 0,
    // @@protoc_insertion_point(enum_value:EGuildChatType.k_EGuildChatType_SteamChatGroup)
    k_EGuildChatType_SteamChatGroup = 1,
    // @@protoc_insertion_point(enum_value:EGuildChatType.k_EGuildChatType_GC)
    k_EGuildChatType_GC = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for EGuildChatType {
    const NAME: &'static str = "EGuildChatType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGuildChatType> {
        match value {
            0 => ::std::option::Option::Some(EGuildChatType::k_EGuildChatType_Unspecified),
            1 => ::std::option::Option::Some(EGuildChatType::k_EGuildChatType_SteamChatGroup),
            2 => ::std::option::Option::Some(EGuildChatType::k_EGuildChatType_GC),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGuildChatType> {
        match str {
            "k_EGuildChatType_Unspecified" => ::std::option::Option::Some(EGuildChatType::k_EGuildChatType_Unspecified),
            "k_EGuildChatType_SteamChatGroup" => ::std::option::Option::Some(EGuildChatType::k_EGuildChatType_SteamChatGroup),
            "k_EGuildChatType_GC" => ::std::option::Option::Some(EGuildChatType::k_EGuildChatType_GC),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGuildChatType] = &[
        EGuildChatType::k_EGuildChatType_Unspecified,
        EGuildChatType::k_EGuildChatType_SteamChatGroup,
        EGuildChatType::k_EGuildChatType_GC,
    ];
}

impl ::std::default::Default for EGuildChatType {
    fn default() -> Self {
        EGuildChatType::k_EGuildChatType_Unspecified
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::dota_shared_enums::*;
impl ::steam_vent_proto_common::RpcMessage for CMsgGuildInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGuildSummary {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGuildRole {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGuildMember {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGuildInvite {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGuildData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgAccountGuildInvite {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgAccountGuildMemberships {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGuildPersonaInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgAccountGuildsPersonaInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGuildFeedEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCCreateGuild {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCCreateGuild {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCreateGuild;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCCreateGuildResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCreateGuildResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCreateGuildResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCSetGuildInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCSetGuildInfo {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSetGuildInfo;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCSetGuildInfoResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSetGuildInfoResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSetGuildInfoResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRequestGuildData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCRequestGuildData {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestGuildData;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRequestGuildDataResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestGuildDataResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestGuildDataResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientGuildDataUpdated {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientGuildDataUpdated {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientGuildDataUpdated;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientGuildMembersDataUpdated {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientGuildMembersDataUpdated {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientGuildMembersDataUpdated;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRequestGuildMembership {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestGuildMembership {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestGuildMembership;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestGuildMembershipResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestGuildMembershipResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestGuildMembershipResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientGuildMembershipUpdated {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientGuildMembershipUpdated {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientGuildMembershipUpdated;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCJoinGuild {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCJoinGuild {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCJoinGuild;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCJoinGuildResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCJoinGuildResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCJoinGuildResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCLeaveGuild {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCLeaveGuild {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCLeaveGuild;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCLeaveGuildResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCLeaveGuildResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCLeaveGuildResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCKickGuildMember {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCKickGuildMember {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCKickGuildMember;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCKickGuildMemberResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCKickGuildMemberResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCKickGuildMemberResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCSetGuildMemberRole {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCSetGuildMemberRole {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSetGuildMemberRole;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCSetGuildMemberRoleResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSetGuildMemberRoleResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSetGuildMemberRoleResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCInviteToGuild {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCInviteToGuild {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCInviteToGuild;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCInviteToGuildResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCInviteToGuildResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCInviteToGuildResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCDeclineInviteToGuild {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCDeclineInviteToGuild {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCDeclineInviteToGuild;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCDeclineInviteToGuildResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCDeclineInviteToGuildResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCDeclineInviteToGuildResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCAcceptInviteToGuild {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCAcceptInviteToGuild {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCAcceptInviteToGuild;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCAcceptInviteToGuildResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCAcceptInviteToGuildResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCAcceptInviteToGuildResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCCancelInviteToGuild {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCancelInviteToGuild {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCancelInviteToGuild;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCCancelInviteToGuildResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCancelInviteToGuildResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCancelInviteToGuildResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCAddGuildRole {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCAddGuildRole {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCAddGuildRole;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCAddGuildRoleResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCAddGuildRoleResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCAddGuildRoleResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCModifyGuildRole {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCModifyGuildRole {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCModifyGuildRole;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCModifyGuildRoleResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCModifyGuildRoleResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCModifyGuildRoleResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRemoveGuildRole {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCRemoveGuildRole {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRemoveGuildRole;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRemoveGuildRoleResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRemoveGuildRoleResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRemoveGuildRoleResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCSetGuildRoleOrder {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCSetGuildRoleOrder {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSetGuildRoleOrder;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCSetGuildRoleOrderResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSetGuildRoleOrderResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSetGuildRoleOrderResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGuildFeedRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRequestGuildFeedResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestGuildFeedResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestGuildFeedResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientGuildFeedUpdated {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientGuildFeedUpdated {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientGuildFeedUpdated;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCAddPlayerToGuildChat {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCAddPlayerToGuildChat {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCAddPlayerToGuildChat;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCAddPlayerToGuildChatResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCAddPlayerToGuildChatResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCAddPlayerToGuildChatResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgFindGuildByTagResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSearchForOpenGuildsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCReportGuildContent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCReportGuildContent {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCReportGuildContent;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCReportGuildContentResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCReportGuildContentResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCReportGuildContentResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestAccountGuildPersonaInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestAccountGuildPersonaInfo {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestAccountGuildPersonaInfo;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestAccountGuildPersonaInfoResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestAccountGuildPersonaInfoResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestAccountGuildPersonaInfoBatch {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestAccountGuildPersonaInfoBatch;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestAccountGuildPersonaInfoBatchResponse;
}
