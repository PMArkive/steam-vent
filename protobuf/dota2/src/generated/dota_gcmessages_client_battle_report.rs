// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_client_battle_report.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CMsgClientToGCGetBattleReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetBattleReport {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReport.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReport.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReport.duration)
    pub duration: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetBattleReport.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetBattleReport {
    fn default() -> &'a CMsgClientToGCGetBattleReport {
        <CMsgClientToGCGetBattleReport as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetBattleReport {
    pub fn new() -> CMsgClientToGCGetBattleReport {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 3;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetBattleReport {
    const NAME: &'static str = "CMsgClientToGCGetBattleReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetBattleReport {
        CMsgClientToGCGetBattleReport::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetBattleReport {
        static instance: CMsgClientToGCGetBattleReport = CMsgClientToGCGetBattleReport {
            account_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBattleReport_Game)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBattleReport_Game {
    // message fields
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.kills)
    pub kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.deaths)
    pub deaths: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.assists)
    pub assists: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.rank_change)
    pub rank_change: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.last_hits)
    pub last_hits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.denies)
    pub denies: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.gpm)
    pub gpm: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.xpm)
    pub xpm: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.role)
    pub role: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<CMsgBattleReport_Role>>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.outcome)
    pub outcome: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<CMsgBattleReport_EOutcome>>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.lane_outcome)
    pub lane_outcome: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<CMsgBattleReport_ELaneOutcome>>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.ranked)
    pub ranked: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.lane_selection_flags)
    pub lane_selection_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.predicted_position)
    pub predicted_position: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.seconds_dead)
    pub seconds_dead: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.winning_team)
    pub winning_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.player_slot)
    pub player_slot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.party_game)
    pub party_game: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.bounty_runes)
    pub bounty_runes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.water_runes)
    pub water_runes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.power_runes)
    pub power_runes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.time_enemy_t1_tower_destroyed)
    pub time_enemy_t1_tower_destroyed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.time_friendly_t1_tower_destroyed)
    pub time_friendly_t1_tower_destroyed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.enemy_roshan_kills)
    pub enemy_roshan_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.teleports_used)
    pub teleports_used: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.dewards)
    pub dewards: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.camps_stacked)
    pub camps_stacked: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.support_gold)
    pub support_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.hero_damage)
    pub hero_damage: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.hero_healing)
    pub hero_healing: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.tower_damage)
    pub tower_damage: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.successful_smokes)
    pub successful_smokes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.stun_duration)
    pub stun_duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.friendly_roshan_kills)
    pub friendly_roshan_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.previous_rank)
    pub previous_rank: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.game_mode)
    pub game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.lobby_type)
    pub lobby_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.time_purchased_shard)
    pub time_purchased_shard: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.time_purchased_scepter)
    pub time_purchased_scepter: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.item0)
    pub item0: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.item1)
    pub item1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.item2)
    pub item2: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.item3)
    pub item3: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.item4)
    pub item4: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.item5)
    pub item5: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgBattleReport_Game.selected_facet)
    pub selected_facet: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBattleReport_Game.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBattleReport_Game {
    fn default() -> &'a CMsgBattleReport_Game {
        <CMsgBattleReport_Game as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgBattleReport_Game {
    pub fn new() -> CMsgBattleReport_Game {
        ::std::default::Default::default()
    }

    // optional int32 hero_id = 1;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 kills = 2;

    pub fn kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional uint32 deaths = 3;

    pub fn deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 assists = 4;

    pub fn assists(&self) -> u32 {
        self.assists.unwrap_or(0)
    }

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: u32) {
        self.assists = ::std::option::Option::Some(v);
    }

    // optional int32 rank_change = 5;

    pub fn rank_change(&self) -> i32 {
        self.rank_change.unwrap_or(0)
    }

    pub fn clear_rank_change(&mut self) {
        self.rank_change = ::std::option::Option::None;
    }

    pub fn has_rank_change(&self) -> bool {
        self.rank_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_change(&mut self, v: i32) {
        self.rank_change = ::std::option::Option::Some(v);
    }

    // optional uint32 last_hits = 6;

    pub fn last_hits(&self) -> u32 {
        self.last_hits.unwrap_or(0)
    }

    pub fn clear_last_hits(&mut self) {
        self.last_hits = ::std::option::Option::None;
    }

    pub fn has_last_hits(&self) -> bool {
        self.last_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hits(&mut self, v: u32) {
        self.last_hits = ::std::option::Option::Some(v);
    }

    // optional uint32 denies = 21;

    pub fn denies(&self) -> u32 {
        self.denies.unwrap_or(0)
    }

    pub fn clear_denies(&mut self) {
        self.denies = ::std::option::Option::None;
    }

    pub fn has_denies(&self) -> bool {
        self.denies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denies(&mut self, v: u32) {
        self.denies = ::std::option::Option::Some(v);
    }

    // optional uint32 gpm = 7;

    pub fn gpm(&self) -> u32 {
        self.gpm.unwrap_or(0)
    }

    pub fn clear_gpm(&mut self) {
        self.gpm = ::std::option::Option::None;
    }

    pub fn has_gpm(&self) -> bool {
        self.gpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpm(&mut self, v: u32) {
        self.gpm = ::std::option::Option::Some(v);
    }

    // optional uint32 xpm = 8;

    pub fn xpm(&self) -> u32 {
        self.xpm.unwrap_or(0)
    }

    pub fn clear_xpm(&mut self) {
        self.xpm = ::std::option::Option::None;
    }

    pub fn has_xpm(&self) -> bool {
        self.xpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xpm(&mut self, v: u32) {
        self.xpm = ::std::option::Option::Some(v);
    }

    // optional .CMsgBattleReport_Role role = 9;

    pub fn role(&self) -> CMsgBattleReport_Role {
        match self.role {
            Some(e) => e.enum_value_or(CMsgBattleReport_Role::k_eUnknownRole),
            None => CMsgBattleReport_Role::k_eUnknownRole,
        }
    }

    pub fn clear_role(&mut self) {
        self.role = ::std::option::Option::None;
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: CMsgBattleReport_Role) {
        self.role = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .CMsgBattleReport_EOutcome outcome = 10;

    pub fn outcome(&self) -> CMsgBattleReport_EOutcome {
        match self.outcome {
            Some(e) => e.enum_value_or(CMsgBattleReport_EOutcome::k_eWin),
            None => CMsgBattleReport_EOutcome::k_eWin,
        }
    }

    pub fn clear_outcome(&mut self) {
        self.outcome = ::std::option::Option::None;
    }

    pub fn has_outcome(&self) -> bool {
        self.outcome.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outcome(&mut self, v: CMsgBattleReport_EOutcome) {
        self.outcome = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .CMsgBattleReport_ELaneOutcome lane_outcome = 11;

    pub fn lane_outcome(&self) -> CMsgBattleReport_ELaneOutcome {
        match self.lane_outcome {
            Some(e) => e.enum_value_or(CMsgBattleReport_ELaneOutcome::k_eUnknownLaneOutcome),
            None => CMsgBattleReport_ELaneOutcome::k_eUnknownLaneOutcome,
        }
    }

    pub fn clear_lane_outcome(&mut self) {
        self.lane_outcome = ::std::option::Option::None;
    }

    pub fn has_lane_outcome(&self) -> bool {
        self.lane_outcome.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane_outcome(&mut self, v: CMsgBattleReport_ELaneOutcome) {
        self.lane_outcome = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool ranked = 12;

    pub fn ranked(&self) -> bool {
        self.ranked.unwrap_or(false)
    }

    pub fn clear_ranked(&mut self) {
        self.ranked = ::std::option::Option::None;
    }

    pub fn has_ranked(&self) -> bool {
        self.ranked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranked(&mut self, v: bool) {
        self.ranked = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 13;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 lane_selection_flags = 14;

    pub fn lane_selection_flags(&self) -> u32 {
        self.lane_selection_flags.unwrap_or(0)
    }

    pub fn clear_lane_selection_flags(&mut self) {
        self.lane_selection_flags = ::std::option::Option::None;
    }

    pub fn has_lane_selection_flags(&self) -> bool {
        self.lane_selection_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane_selection_flags(&mut self, v: u32) {
        self.lane_selection_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 predicted_position = 15;

    pub fn predicted_position(&self) -> u32 {
        self.predicted_position.unwrap_or(0)
    }

    pub fn clear_predicted_position(&mut self) {
        self.predicted_position = ::std::option::Option::None;
    }

    pub fn has_predicted_position(&self) -> bool {
        self.predicted_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_predicted_position(&mut self, v: u32) {
        self.predicted_position = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_dead = 16;

    pub fn seconds_dead(&self) -> u32 {
        self.seconds_dead.unwrap_or(0)
    }

    pub fn clear_seconds_dead(&mut self) {
        self.seconds_dead = ::std::option::Option::None;
    }

    pub fn has_seconds_dead(&self) -> bool {
        self.seconds_dead.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_dead(&mut self, v: u32) {
        self.seconds_dead = ::std::option::Option::Some(v);
    }

    // optional uint32 winning_team = 17;

    pub fn winning_team(&self) -> u32 {
        self.winning_team.unwrap_or(0)
    }

    pub fn clear_winning_team(&mut self) {
        self.winning_team = ::std::option::Option::None;
    }

    pub fn has_winning_team(&self) -> bool {
        self.winning_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winning_team(&mut self, v: u32) {
        self.winning_team = ::std::option::Option::Some(v);
    }

    // optional uint32 player_slot = 28;

    pub fn player_slot(&self) -> u32 {
        self.player_slot.unwrap_or(0)
    }

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: u32) {
        self.player_slot = ::std::option::Option::Some(v);
    }

    // optional bool party_game = 19;

    pub fn party_game(&self) -> bool {
        self.party_game.unwrap_or(false)
    }

    pub fn clear_party_game(&mut self) {
        self.party_game = ::std::option::Option::None;
    }

    pub fn has_party_game(&self) -> bool {
        self.party_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_game(&mut self, v: bool) {
        self.party_game = ::std::option::Option::Some(v);
    }

    // optional uint32 start_time = 20;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 bounty_runes = 22;

    pub fn bounty_runes(&self) -> u32 {
        self.bounty_runes.unwrap_or(0)
    }

    pub fn clear_bounty_runes(&mut self) {
        self.bounty_runes = ::std::option::Option::None;
    }

    pub fn has_bounty_runes(&self) -> bool {
        self.bounty_runes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bounty_runes(&mut self, v: u32) {
        self.bounty_runes = ::std::option::Option::Some(v);
    }

    // optional uint32 water_runes = 23;

    pub fn water_runes(&self) -> u32 {
        self.water_runes.unwrap_or(0)
    }

    pub fn clear_water_runes(&mut self) {
        self.water_runes = ::std::option::Option::None;
    }

    pub fn has_water_runes(&self) -> bool {
        self.water_runes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_water_runes(&mut self, v: u32) {
        self.water_runes = ::std::option::Option::Some(v);
    }

    // optional uint32 power_runes = 24;

    pub fn power_runes(&self) -> u32 {
        self.power_runes.unwrap_or(0)
    }

    pub fn clear_power_runes(&mut self) {
        self.power_runes = ::std::option::Option::None;
    }

    pub fn has_power_runes(&self) -> bool {
        self.power_runes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_power_runes(&mut self, v: u32) {
        self.power_runes = ::std::option::Option::Some(v);
    }

    // optional uint32 time_enemy_t1_tower_destroyed = 25;

    pub fn time_enemy_t1_tower_destroyed(&self) -> u32 {
        self.time_enemy_t1_tower_destroyed.unwrap_or(0)
    }

    pub fn clear_time_enemy_t1_tower_destroyed(&mut self) {
        self.time_enemy_t1_tower_destroyed = ::std::option::Option::None;
    }

    pub fn has_time_enemy_t1_tower_destroyed(&self) -> bool {
        self.time_enemy_t1_tower_destroyed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_enemy_t1_tower_destroyed(&mut self, v: u32) {
        self.time_enemy_t1_tower_destroyed = ::std::option::Option::Some(v);
    }

    // optional uint32 time_friendly_t1_tower_destroyed = 26;

    pub fn time_friendly_t1_tower_destroyed(&self) -> u32 {
        self.time_friendly_t1_tower_destroyed.unwrap_or(0)
    }

    pub fn clear_time_friendly_t1_tower_destroyed(&mut self) {
        self.time_friendly_t1_tower_destroyed = ::std::option::Option::None;
    }

    pub fn has_time_friendly_t1_tower_destroyed(&self) -> bool {
        self.time_friendly_t1_tower_destroyed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_friendly_t1_tower_destroyed(&mut self, v: u32) {
        self.time_friendly_t1_tower_destroyed = ::std::option::Option::Some(v);
    }

    // optional uint32 enemy_roshan_kills = 27;

    pub fn enemy_roshan_kills(&self) -> u32 {
        self.enemy_roshan_kills.unwrap_or(0)
    }

    pub fn clear_enemy_roshan_kills(&mut self) {
        self.enemy_roshan_kills = ::std::option::Option::None;
    }

    pub fn has_enemy_roshan_kills(&self) -> bool {
        self.enemy_roshan_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enemy_roshan_kills(&mut self, v: u32) {
        self.enemy_roshan_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 teleports_used = 29;

    pub fn teleports_used(&self) -> u32 {
        self.teleports_used.unwrap_or(0)
    }

    pub fn clear_teleports_used(&mut self) {
        self.teleports_used = ::std::option::Option::None;
    }

    pub fn has_teleports_used(&self) -> bool {
        self.teleports_used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teleports_used(&mut self, v: u32) {
        self.teleports_used = ::std::option::Option::Some(v);
    }

    // optional uint32 dewards = 30;

    pub fn dewards(&self) -> u32 {
        self.dewards.unwrap_or(0)
    }

    pub fn clear_dewards(&mut self) {
        self.dewards = ::std::option::Option::None;
    }

    pub fn has_dewards(&self) -> bool {
        self.dewards.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dewards(&mut self, v: u32) {
        self.dewards = ::std::option::Option::Some(v);
    }

    // optional uint32 camps_stacked = 31;

    pub fn camps_stacked(&self) -> u32 {
        self.camps_stacked.unwrap_or(0)
    }

    pub fn clear_camps_stacked(&mut self) {
        self.camps_stacked = ::std::option::Option::None;
    }

    pub fn has_camps_stacked(&self) -> bool {
        self.camps_stacked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camps_stacked(&mut self, v: u32) {
        self.camps_stacked = ::std::option::Option::Some(v);
    }

    // optional uint32 support_gold = 32;

    pub fn support_gold(&self) -> u32 {
        self.support_gold.unwrap_or(0)
    }

    pub fn clear_support_gold(&mut self) {
        self.support_gold = ::std::option::Option::None;
    }

    pub fn has_support_gold(&self) -> bool {
        self.support_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_gold(&mut self, v: u32) {
        self.support_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_damage = 33;

    pub fn hero_damage(&self) -> u32 {
        self.hero_damage.unwrap_or(0)
    }

    pub fn clear_hero_damage(&mut self) {
        self.hero_damage = ::std::option::Option::None;
    }

    pub fn has_hero_damage(&self) -> bool {
        self.hero_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_damage(&mut self, v: u32) {
        self.hero_damage = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_healing = 34;

    pub fn hero_healing(&self) -> u32 {
        self.hero_healing.unwrap_or(0)
    }

    pub fn clear_hero_healing(&mut self) {
        self.hero_healing = ::std::option::Option::None;
    }

    pub fn has_hero_healing(&self) -> bool {
        self.hero_healing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_healing(&mut self, v: u32) {
        self.hero_healing = ::std::option::Option::Some(v);
    }

    // optional uint32 tower_damage = 35;

    pub fn tower_damage(&self) -> u32 {
        self.tower_damage.unwrap_or(0)
    }

    pub fn clear_tower_damage(&mut self) {
        self.tower_damage = ::std::option::Option::None;
    }

    pub fn has_tower_damage(&self) -> bool {
        self.tower_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tower_damage(&mut self, v: u32) {
        self.tower_damage = ::std::option::Option::Some(v);
    }

    // optional uint32 successful_smokes = 36;

    pub fn successful_smokes(&self) -> u32 {
        self.successful_smokes.unwrap_or(0)
    }

    pub fn clear_successful_smokes(&mut self) {
        self.successful_smokes = ::std::option::Option::None;
    }

    pub fn has_successful_smokes(&self) -> bool {
        self.successful_smokes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_successful_smokes(&mut self, v: u32) {
        self.successful_smokes = ::std::option::Option::Some(v);
    }

    // optional uint32 stun_duration = 37;

    pub fn stun_duration(&self) -> u32 {
        self.stun_duration.unwrap_or(0)
    }

    pub fn clear_stun_duration(&mut self) {
        self.stun_duration = ::std::option::Option::None;
    }

    pub fn has_stun_duration(&self) -> bool {
        self.stun_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stun_duration(&mut self, v: u32) {
        self.stun_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 38;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional uint32 friendly_roshan_kills = 39;

    pub fn friendly_roshan_kills(&self) -> u32 {
        self.friendly_roshan_kills.unwrap_or(0)
    }

    pub fn clear_friendly_roshan_kills(&mut self) {
        self.friendly_roshan_kills = ::std::option::Option::None;
    }

    pub fn has_friendly_roshan_kills(&self) -> bool {
        self.friendly_roshan_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendly_roshan_kills(&mut self, v: u32) {
        self.friendly_roshan_kills = ::std::option::Option::Some(v);
    }

    // optional int32 previous_rank = 40;

    pub fn previous_rank(&self) -> i32 {
        self.previous_rank.unwrap_or(0)
    }

    pub fn clear_previous_rank(&mut self) {
        self.previous_rank = ::std::option::Option::None;
    }

    pub fn has_previous_rank(&self) -> bool {
        self.previous_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previous_rank(&mut self, v: i32) {
        self.previous_rank = ::std::option::Option::Some(v);
    }

    // optional uint32 game_mode = 41;

    pub fn game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_type = 42;

    pub fn lobby_type(&self) -> u32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: u32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional float time_purchased_shard = 43;

    pub fn time_purchased_shard(&self) -> f32 {
        self.time_purchased_shard.unwrap_or(0.)
    }

    pub fn clear_time_purchased_shard(&mut self) {
        self.time_purchased_shard = ::std::option::Option::None;
    }

    pub fn has_time_purchased_shard(&self) -> bool {
        self.time_purchased_shard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_purchased_shard(&mut self, v: f32) {
        self.time_purchased_shard = ::std::option::Option::Some(v);
    }

    // optional float time_purchased_scepter = 44;

    pub fn time_purchased_scepter(&self) -> f32 {
        self.time_purchased_scepter.unwrap_or(0.)
    }

    pub fn clear_time_purchased_scepter(&mut self) {
        self.time_purchased_scepter = ::std::option::Option::None;
    }

    pub fn has_time_purchased_scepter(&self) -> bool {
        self.time_purchased_scepter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_purchased_scepter(&mut self, v: f32) {
        self.time_purchased_scepter = ::std::option::Option::Some(v);
    }

    // optional int32 item0 = 45;

    pub fn item0(&self) -> i32 {
        self.item0.unwrap_or(-1i32)
    }

    pub fn clear_item0(&mut self) {
        self.item0 = ::std::option::Option::None;
    }

    pub fn has_item0(&self) -> bool {
        self.item0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item0(&mut self, v: i32) {
        self.item0 = ::std::option::Option::Some(v);
    }

    // optional int32 item1 = 46;

    pub fn item1(&self) -> i32 {
        self.item1.unwrap_or(-1i32)
    }

    pub fn clear_item1(&mut self) {
        self.item1 = ::std::option::Option::None;
    }

    pub fn has_item1(&self) -> bool {
        self.item1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item1(&mut self, v: i32) {
        self.item1 = ::std::option::Option::Some(v);
    }

    // optional int32 item2 = 47;

    pub fn item2(&self) -> i32 {
        self.item2.unwrap_or(-1i32)
    }

    pub fn clear_item2(&mut self) {
        self.item2 = ::std::option::Option::None;
    }

    pub fn has_item2(&self) -> bool {
        self.item2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item2(&mut self, v: i32) {
        self.item2 = ::std::option::Option::Some(v);
    }

    // optional int32 item3 = 48;

    pub fn item3(&self) -> i32 {
        self.item3.unwrap_or(-1i32)
    }

    pub fn clear_item3(&mut self) {
        self.item3 = ::std::option::Option::None;
    }

    pub fn has_item3(&self) -> bool {
        self.item3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item3(&mut self, v: i32) {
        self.item3 = ::std::option::Option::Some(v);
    }

    // optional int32 item4 = 49;

    pub fn item4(&self) -> i32 {
        self.item4.unwrap_or(-1i32)
    }

    pub fn clear_item4(&mut self) {
        self.item4 = ::std::option::Option::None;
    }

    pub fn has_item4(&self) -> bool {
        self.item4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item4(&mut self, v: i32) {
        self.item4 = ::std::option::Option::Some(v);
    }

    // optional int32 item5 = 50;

    pub fn item5(&self) -> i32 {
        self.item5.unwrap_or(-1i32)
    }

    pub fn clear_item5(&mut self) {
        self.item5 = ::std::option::Option::None;
    }

    pub fn has_item5(&self) -> bool {
        self.item5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item5(&mut self, v: i32) {
        self.item5 = ::std::option::Option::Some(v);
    }

    // optional uint32 selected_facet = 51;

    pub fn selected_facet(&self) -> u32 {
        self.selected_facet.unwrap_or(0)
    }

    pub fn clear_selected_facet(&mut self) {
        self.selected_facet = ::std::option::Option::None;
    }

    pub fn has_selected_facet(&self) -> bool {
        self.selected_facet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_facet(&mut self, v: u32) {
        self.selected_facet = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgBattleReport_Game {
    const NAME: &'static str = "CMsgBattleReport_Game";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.assists = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rank_change = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.last_hits = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.denies = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.gpm = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.xpm = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.role = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                80 => {
                    self.outcome = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                88 => {
                    self.lane_outcome = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                96 => {
                    self.ranked = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                112 => {
                    self.lane_selection_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.predicted_position = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.seconds_dead = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.winning_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.party_game = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.bounty_runes = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.water_runes = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.power_runes = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.time_enemy_t1_tower_destroyed = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.time_friendly_t1_tower_destroyed = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.enemy_roshan_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                232 => {
                    self.teleports_used = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.dewards = ::std::option::Option::Some(is.read_uint32()?);
                },
                248 => {
                    self.camps_stacked = ::std::option::Option::Some(is.read_uint32()?);
                },
                256 => {
                    self.support_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                264 => {
                    self.hero_damage = ::std::option::Option::Some(is.read_uint32()?);
                },
                272 => {
                    self.hero_healing = ::std::option::Option::Some(is.read_uint32()?);
                },
                280 => {
                    self.tower_damage = ::std::option::Option::Some(is.read_uint32()?);
                },
                288 => {
                    self.successful_smokes = ::std::option::Option::Some(is.read_uint32()?);
                },
                296 => {
                    self.stun_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                304 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                312 => {
                    self.friendly_roshan_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                320 => {
                    self.previous_rank = ::std::option::Option::Some(is.read_int32()?);
                },
                328 => {
                    self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                336 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                349 => {
                    self.time_purchased_shard = ::std::option::Option::Some(is.read_float()?);
                },
                357 => {
                    self.time_purchased_scepter = ::std::option::Option::Some(is.read_float()?);
                },
                360 => {
                    self.item0 = ::std::option::Option::Some(is.read_int32()?);
                },
                368 => {
                    self.item1 = ::std::option::Option::Some(is.read_int32()?);
                },
                376 => {
                    self.item2 = ::std::option::Option::Some(is.read_int32()?);
                },
                384 => {
                    self.item3 = ::std::option::Option::Some(is.read_int32()?);
                },
                392 => {
                    self.item4 = ::std::option::Option::Some(is.read_int32()?);
                },
                400 => {
                    self.item5 = ::std::option::Option::Some(is.read_int32()?);
                },
                408 => {
                    self.selected_facet = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.deaths {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.assists {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rank_change {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.last_hits {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.denies {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.gpm {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.xpm {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.role {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.outcome {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.lane_outcome {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(11, v.value());
        }
        if let Some(v) = self.ranked {
            my_size += 1 + 1;
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(13, v);
        }
        if let Some(v) = self.lane_selection_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.predicted_position {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.seconds_dead {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.winning_team {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.player_slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.party_game {
            my_size += 2 + 1;
        }
        if let Some(v) = self.start_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.bounty_runes {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.water_runes {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.power_runes {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.time_enemy_t1_tower_destroyed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.time_friendly_t1_tower_destroyed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.enemy_roshan_kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.teleports_used {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.dewards {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(30, v);
        }
        if let Some(v) = self.camps_stacked {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(31, v);
        }
        if let Some(v) = self.support_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(32, v);
        }
        if let Some(v) = self.hero_damage {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(33, v);
        }
        if let Some(v) = self.hero_healing {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(34, v);
        }
        if let Some(v) = self.tower_damage {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(35, v);
        }
        if let Some(v) = self.successful_smokes {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(36, v);
        }
        if let Some(v) = self.stun_duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(37, v);
        }
        if let Some(v) = self.duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(38, v);
        }
        if let Some(v) = self.friendly_roshan_kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(39, v);
        }
        if let Some(v) = self.previous_rank {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(40, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(41, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(42, v);
        }
        if let Some(v) = self.time_purchased_shard {
            my_size += 2 + 4;
        }
        if let Some(v) = self.time_purchased_scepter {
            my_size += 2 + 4;
        }
        if let Some(v) = self.item0 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(45, v);
        }
        if let Some(v) = self.item1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(46, v);
        }
        if let Some(v) = self.item2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(47, v);
        }
        if let Some(v) = self.item3 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(48, v);
        }
        if let Some(v) = self.item4 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(49, v);
        }
        if let Some(v) = self.item5 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(50, v);
        }
        if let Some(v) = self.selected_facet {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(51, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hero_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.assists {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rank_change {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.last_hits {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.denies {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.gpm {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.xpm {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.role {
            os.write_enum(9, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.outcome {
            os.write_enum(10, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.lane_outcome {
            os.write_enum(11, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ranked {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(13, v)?;
        }
        if let Some(v) = self.lane_selection_flags {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.predicted_position {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.seconds_dead {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.winning_team {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.player_slot {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.party_game {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.bounty_runes {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.water_runes {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.power_runes {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.time_enemy_t1_tower_destroyed {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.time_friendly_t1_tower_destroyed {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.enemy_roshan_kills {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.teleports_used {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.dewards {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.camps_stacked {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.support_gold {
            os.write_uint32(32, v)?;
        }
        if let Some(v) = self.hero_damage {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.hero_healing {
            os.write_uint32(34, v)?;
        }
        if let Some(v) = self.tower_damage {
            os.write_uint32(35, v)?;
        }
        if let Some(v) = self.successful_smokes {
            os.write_uint32(36, v)?;
        }
        if let Some(v) = self.stun_duration {
            os.write_uint32(37, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.friendly_roshan_kills {
            os.write_uint32(39, v)?;
        }
        if let Some(v) = self.previous_rank {
            os.write_int32(40, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_uint32(41, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_uint32(42, v)?;
        }
        if let Some(v) = self.time_purchased_shard {
            os.write_float(43, v)?;
        }
        if let Some(v) = self.time_purchased_scepter {
            os.write_float(44, v)?;
        }
        if let Some(v) = self.item0 {
            os.write_int32(45, v)?;
        }
        if let Some(v) = self.item1 {
            os.write_int32(46, v)?;
        }
        if let Some(v) = self.item2 {
            os.write_int32(47, v)?;
        }
        if let Some(v) = self.item3 {
            os.write_int32(48, v)?;
        }
        if let Some(v) = self.item4 {
            os.write_int32(49, v)?;
        }
        if let Some(v) = self.item5 {
            os.write_int32(50, v)?;
        }
        if let Some(v) = self.selected_facet {
            os.write_uint32(51, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBattleReport_Game {
        CMsgBattleReport_Game::new()
    }

    fn clear(&mut self) {
        self.hero_id = ::std::option::Option::None;
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.assists = ::std::option::Option::None;
        self.rank_change = ::std::option::Option::None;
        self.last_hits = ::std::option::Option::None;
        self.denies = ::std::option::Option::None;
        self.gpm = ::std::option::Option::None;
        self.xpm = ::std::option::Option::None;
        self.role = ::std::option::Option::None;
        self.outcome = ::std::option::Option::None;
        self.lane_outcome = ::std::option::Option::None;
        self.ranked = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.lane_selection_flags = ::std::option::Option::None;
        self.predicted_position = ::std::option::Option::None;
        self.seconds_dead = ::std::option::Option::None;
        self.winning_team = ::std::option::Option::None;
        self.player_slot = ::std::option::Option::None;
        self.party_game = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.bounty_runes = ::std::option::Option::None;
        self.water_runes = ::std::option::Option::None;
        self.power_runes = ::std::option::Option::None;
        self.time_enemy_t1_tower_destroyed = ::std::option::Option::None;
        self.time_friendly_t1_tower_destroyed = ::std::option::Option::None;
        self.enemy_roshan_kills = ::std::option::Option::None;
        self.teleports_used = ::std::option::Option::None;
        self.dewards = ::std::option::Option::None;
        self.camps_stacked = ::std::option::Option::None;
        self.support_gold = ::std::option::Option::None;
        self.hero_damage = ::std::option::Option::None;
        self.hero_healing = ::std::option::Option::None;
        self.tower_damage = ::std::option::Option::None;
        self.successful_smokes = ::std::option::Option::None;
        self.stun_duration = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.friendly_roshan_kills = ::std::option::Option::None;
        self.previous_rank = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.time_purchased_shard = ::std::option::Option::None;
        self.time_purchased_scepter = ::std::option::Option::None;
        self.item0 = ::std::option::Option::None;
        self.item1 = ::std::option::Option::None;
        self.item2 = ::std::option::Option::None;
        self.item3 = ::std::option::Option::None;
        self.item4 = ::std::option::Option::None;
        self.item5 = ::std::option::Option::None;
        self.selected_facet = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBattleReport_Game {
        static instance: CMsgBattleReport_Game = CMsgBattleReport_Game {
            hero_id: ::std::option::Option::None,
            kills: ::std::option::Option::None,
            deaths: ::std::option::Option::None,
            assists: ::std::option::Option::None,
            rank_change: ::std::option::Option::None,
            last_hits: ::std::option::Option::None,
            denies: ::std::option::Option::None,
            gpm: ::std::option::Option::None,
            xpm: ::std::option::Option::None,
            role: ::std::option::Option::None,
            outcome: ::std::option::Option::None,
            lane_outcome: ::std::option::Option::None,
            ranked: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            lane_selection_flags: ::std::option::Option::None,
            predicted_position: ::std::option::Option::None,
            seconds_dead: ::std::option::Option::None,
            winning_team: ::std::option::Option::None,
            player_slot: ::std::option::Option::None,
            party_game: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            bounty_runes: ::std::option::Option::None,
            water_runes: ::std::option::Option::None,
            power_runes: ::std::option::Option::None,
            time_enemy_t1_tower_destroyed: ::std::option::Option::None,
            time_friendly_t1_tower_destroyed: ::std::option::Option::None,
            enemy_roshan_kills: ::std::option::Option::None,
            teleports_used: ::std::option::Option::None,
            dewards: ::std::option::Option::None,
            camps_stacked: ::std::option::Option::None,
            support_gold: ::std::option::Option::None,
            hero_damage: ::std::option::Option::None,
            hero_healing: ::std::option::Option::None,
            tower_damage: ::std::option::Option::None,
            successful_smokes: ::std::option::Option::None,
            stun_duration: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            friendly_roshan_kills: ::std::option::Option::None,
            previous_rank: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            time_purchased_shard: ::std::option::Option::None,
            time_purchased_scepter: ::std::option::Option::None,
            item0: ::std::option::Option::None,
            item1: ::std::option::Option::None,
            item2: ::std::option::Option::None,
            item3: ::std::option::Option::None,
            item4: ::std::option::Option::None,
            item5: ::std::option::Option::None,
            selected_facet: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBattleReport_GameList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBattleReport_GameList {
    // message fields
    // @@protoc_insertion_point(field:CMsgBattleReport_GameList.games)
    pub games: ::std::vec::Vec<CMsgBattleReport_Game>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBattleReport_GameList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBattleReport_GameList {
    fn default() -> &'a CMsgBattleReport_GameList {
        <CMsgBattleReport_GameList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgBattleReport_GameList {
    pub fn new() -> CMsgBattleReport_GameList {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgBattleReport_GameList {
    const NAME: &'static str = "CMsgBattleReport_GameList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.games.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.games {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.games {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBattleReport_GameList {
        CMsgBattleReport_GameList::new()
    }

    fn clear(&mut self) {
        self.games.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBattleReport_GameList {
        static instance: CMsgBattleReport_GameList = CMsgBattleReport_GameList {
            games: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBattleReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBattleReport {
    // message fields
    // @@protoc_insertion_point(field:CMsgBattleReport.games)
    pub games: ::std::vec::Vec<CMsgBattleReport_Game>,
    // @@protoc_insertion_point(field:CMsgBattleReport.highlights)
    pub highlights: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportHighlights>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBattleReport.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBattleReport {
    fn default() -> &'a CMsgBattleReport {
        <CMsgBattleReport as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgBattleReport {
    pub fn new() -> CMsgBattleReport {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgBattleReport {
    const NAME: &'static str = "CMsgBattleReport";

    fn is_initialized(&self) -> bool {
        for v in &self.games {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.highlights {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.games.push(is.read_message()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.highlights)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.games {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.highlights.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.games {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.highlights.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBattleReport {
        CMsgBattleReport::new()
    }

    fn clear(&mut self) {
        self.games.clear();
        self.highlights.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBattleReport {
        static instance: CMsgBattleReport = CMsgBattleReport {
            games: ::std::vec::Vec::new(),
            highlights: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgBattleReport`
pub mod cmsg_battle_report {
    // @@protoc_insertion_point(message:CMsgBattleReport.HighlightGeneral)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct HighlightGeneral {
        // message fields
        // @@protoc_insertion_point(field:CMsgBattleReport.HighlightGeneral.win_loss_window)
        pub win_loss_window: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgBattleReport.HighlightGeneral.win_percent)
        pub win_percent: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgBattleReport.HighlightGeneral.mmr_delta)
        pub mmr_delta: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgBattleReport.HighlightGeneral.highlight_score)
        pub highlight_score: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgBattleReport.HighlightGeneral.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HighlightGeneral {
        fn default() -> &'a HighlightGeneral {
            <HighlightGeneral as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl HighlightGeneral {
        pub fn new() -> HighlightGeneral {
            ::std::default::Default::default()
        }

        // optional int32 win_loss_window = 1;

        pub fn win_loss_window(&self) -> i32 {
            self.win_loss_window.unwrap_or(0)
        }

        pub fn clear_win_loss_window(&mut self) {
            self.win_loss_window = ::std::option::Option::None;
        }

        pub fn has_win_loss_window(&self) -> bool {
            self.win_loss_window.is_some()
        }

        // Param is passed by value, moved
        pub fn set_win_loss_window(&mut self, v: i32) {
            self.win_loss_window = ::std::option::Option::Some(v);
        }

        // optional float win_percent = 2;

        pub fn win_percent(&self) -> f32 {
            self.win_percent.unwrap_or(0.)
        }

        pub fn clear_win_percent(&mut self) {
            self.win_percent = ::std::option::Option::None;
        }

        pub fn has_win_percent(&self) -> bool {
            self.win_percent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_win_percent(&mut self, v: f32) {
            self.win_percent = ::std::option::Option::Some(v);
        }

        // optional int32 mmr_delta = 3;

        pub fn mmr_delta(&self) -> i32 {
            self.mmr_delta.unwrap_or(0)
        }

        pub fn clear_mmr_delta(&mut self) {
            self.mmr_delta = ::std::option::Option::None;
        }

        pub fn has_mmr_delta(&self) -> bool {
            self.mmr_delta.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mmr_delta(&mut self, v: i32) {
            self.mmr_delta = ::std::option::Option::Some(v);
        }

        // optional float highlight_score = 4;

        pub fn highlight_score(&self) -> f32 {
            self.highlight_score.unwrap_or(0.)
        }

        pub fn clear_highlight_score(&mut self) {
            self.highlight_score = ::std::option::Option::None;
        }

        pub fn has_highlight_score(&self) -> bool {
            self.highlight_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_highlight_score(&mut self, v: f32) {
            self.highlight_score = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for HighlightGeneral {
        const NAME: &'static str = "HighlightGeneral";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.win_loss_window = ::std::option::Option::Some(is.read_int32()?);
                    },
                    21 => {
                        self.win_percent = ::std::option::Option::Some(is.read_float()?);
                    },
                    24 => {
                        self.mmr_delta = ::std::option::Option::Some(is.read_int32()?);
                    },
                    37 => {
                        self.highlight_score = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.win_loss_window {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.win_percent {
                my_size += 1 + 4;
            }
            if let Some(v) = self.mmr_delta {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.highlight_score {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.win_loss_window {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.win_percent {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.mmr_delta {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.highlight_score {
                os.write_float(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HighlightGeneral {
            HighlightGeneral::new()
        }

        fn clear(&mut self) {
            self.win_loss_window = ::std::option::Option::None;
            self.win_percent = ::std::option::Option::None;
            self.mmr_delta = ::std::option::Option::None;
            self.highlight_score = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HighlightGeneral {
            static instance: HighlightGeneral = HighlightGeneral {
                win_loss_window: ::std::option::Option::None,
                win_percent: ::std::option::Option::None,
                mmr_delta: ::std::option::Option::None,
                highlight_score: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgBattleReport.Highlight)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Highlight {
        // message fields
        // @@protoc_insertion_point(field:CMsgBattleReport.Highlight.highlight_id)
        pub highlight_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgBattleReport.Highlight.category)
        pub category: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::CMsgBattleReport_HighlightCategory>>,
        // @@protoc_insertion_point(field:CMsgBattleReport.Highlight.tier)
        pub tier: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::CMsgBattleReport_HighlightTier>>,
        // @@protoc_insertion_point(field:CMsgBattleReport.Highlight.rarity)
        pub rarity: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::CMsgBattleReport_HighlightRarity>>,
        // @@protoc_insertion_point(field:CMsgBattleReport.Highlight.score)
        pub score: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgBattleReport.Highlight.confidence)
        pub confidence: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgBattleReport.Highlight.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgBattleReport.Highlight.role)
        pub role: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::CMsgBattleReport_Role>>,
        // @@protoc_insertion_point(field:CMsgBattleReport.Highlight.comparison_delta_value)
        pub comparison_delta_value: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgBattleReport.Highlight.context)
        pub context: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::CMsgBattleReport_CompareContext>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgBattleReport.Highlight.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Highlight {
        fn default() -> &'a Highlight {
            <Highlight as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Highlight {
        pub fn new() -> Highlight {
            ::std::default::Default::default()
        }

        // required uint32 highlight_id = 1;

        pub fn highlight_id(&self) -> u32 {
            self.highlight_id.unwrap_or(0)
        }

        pub fn clear_highlight_id(&mut self) {
            self.highlight_id = ::std::option::Option::None;
        }

        pub fn has_highlight_id(&self) -> bool {
            self.highlight_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_highlight_id(&mut self, v: u32) {
            self.highlight_id = ::std::option::Option::Some(v);
        }

        // required .CMsgBattleReport_HighlightCategory category = 2;

        pub fn category(&self) -> super::CMsgBattleReport_HighlightCategory {
            match self.category {
                Some(e) => e.enum_value_or(super::CMsgBattleReport_HighlightCategory::k_eHighlightGeneral),
                None => super::CMsgBattleReport_HighlightCategory::k_eHighlightGeneral,
            }
        }

        pub fn clear_category(&mut self) {
            self.category = ::std::option::Option::None;
        }

        pub fn has_category(&self) -> bool {
            self.category.is_some()
        }

        // Param is passed by value, moved
        pub fn set_category(&mut self, v: super::CMsgBattleReport_HighlightCategory) {
            self.category = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional .CMsgBattleReport_HighlightTier tier = 3;

        pub fn tier(&self) -> super::CMsgBattleReport_HighlightTier {
            match self.tier {
                Some(e) => e.enum_value_or(super::CMsgBattleReport_HighlightTier::k_eHighlightTierLow),
                None => super::CMsgBattleReport_HighlightTier::k_eHighlightTierLow,
            }
        }

        pub fn clear_tier(&mut self) {
            self.tier = ::std::option::Option::None;
        }

        pub fn has_tier(&self) -> bool {
            self.tier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tier(&mut self, v: super::CMsgBattleReport_HighlightTier) {
            self.tier = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional .CMsgBattleReport_HighlightRarity rarity = 4;

        pub fn rarity(&self) -> super::CMsgBattleReport_HighlightRarity {
            match self.rarity {
                Some(e) => e.enum_value_or(super::CMsgBattleReport_HighlightRarity::k_eHighlightCommon),
                None => super::CMsgBattleReport_HighlightRarity::k_eHighlightCommon,
            }
        }

        pub fn clear_rarity(&mut self) {
            self.rarity = ::std::option::Option::None;
        }

        pub fn has_rarity(&self) -> bool {
            self.rarity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rarity(&mut self, v: super::CMsgBattleReport_HighlightRarity) {
            self.rarity = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional float score = 5;

        pub fn score(&self) -> f32 {
            self.score.unwrap_or(0.)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: f32) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional float confidence = 6;

        pub fn confidence(&self) -> f32 {
            self.confidence.unwrap_or(0.)
        }

        pub fn clear_confidence(&mut self) {
            self.confidence = ::std::option::Option::None;
        }

        pub fn has_confidence(&self) -> bool {
            self.confidence.is_some()
        }

        // Param is passed by value, moved
        pub fn set_confidence(&mut self, v: f32) {
            self.confidence = ::std::option::Option::Some(v);
        }

        // optional int32 hero_id = 7;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional .CMsgBattleReport_Role role = 8;

        pub fn role(&self) -> super::CMsgBattleReport_Role {
            match self.role {
                Some(e) => e.enum_value_or(super::CMsgBattleReport_Role::k_eUnknownRole),
                None => super::CMsgBattleReport_Role::k_eUnknownRole,
            }
        }

        pub fn clear_role(&mut self) {
            self.role = ::std::option::Option::None;
        }

        pub fn has_role(&self) -> bool {
            self.role.is_some()
        }

        // Param is passed by value, moved
        pub fn set_role(&mut self, v: super::CMsgBattleReport_Role) {
            self.role = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional float comparison_delta_value = 9;

        pub fn comparison_delta_value(&self) -> f32 {
            self.comparison_delta_value.unwrap_or(0.)
        }

        pub fn clear_comparison_delta_value(&mut self) {
            self.comparison_delta_value = ::std::option::Option::None;
        }

        pub fn has_comparison_delta_value(&self) -> bool {
            self.comparison_delta_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_comparison_delta_value(&mut self, v: f32) {
            self.comparison_delta_value = ::std::option::Option::Some(v);
        }

        // optional .CMsgBattleReport_CompareContext context = 10;

        pub fn context(&self) -> super::CMsgBattleReport_CompareContext {
            match self.context {
                Some(e) => e.enum_value_or(super::CMsgBattleReport_CompareContext::k_eCompareContextInvalid),
                None => super::CMsgBattleReport_CompareContext::k_eCompareContextInvalid,
            }
        }

        pub fn clear_context(&mut self) {
            self.context = ::std::option::Option::None;
        }

        pub fn has_context(&self) -> bool {
            self.context.is_some()
        }

        // Param is passed by value, moved
        pub fn set_context(&mut self, v: super::CMsgBattleReport_CompareContext) {
            self.context = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Highlight {
        const NAME: &'static str = "Highlight";

        fn is_initialized(&self) -> bool {
            if self.highlight_id.is_none() {
                return false;
            }
            if self.category.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.highlight_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.category = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.tier = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    32 => {
                        self.rarity = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    45 => {
                        self.score = ::std::option::Option::Some(is.read_float()?);
                    },
                    53 => {
                        self.confidence = ::std::option::Option::Some(is.read_float()?);
                    },
                    56 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.role = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    77 => {
                        self.comparison_delta_value = ::std::option::Option::Some(is.read_float()?);
                    },
                    80 => {
                        self.context = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.highlight_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.category {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.tier {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
            }
            if let Some(v) = self.rarity {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
            }
            if let Some(v) = self.score {
                my_size += 1 + 4;
            }
            if let Some(v) = self.confidence {
                my_size += 1 + 4;
            }
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.role {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v.value());
            }
            if let Some(v) = self.comparison_delta_value {
                my_size += 1 + 4;
            }
            if let Some(v) = self.context {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v.value());
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.highlight_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.category {
                os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.tier {
                os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.rarity {
                os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.score {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.confidence {
                os.write_float(6, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.role {
                os.write_enum(8, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.comparison_delta_value {
                os.write_float(9, v)?;
            }
            if let Some(v) = self.context {
                os.write_enum(10, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Highlight {
            Highlight::new()
        }

        fn clear(&mut self) {
            self.highlight_id = ::std::option::Option::None;
            self.category = ::std::option::Option::None;
            self.tier = ::std::option::Option::None;
            self.rarity = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.confidence = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.role = ::std::option::Option::None;
            self.comparison_delta_value = ::std::option::Option::None;
            self.context = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Highlight {
            static instance: Highlight = Highlight {
                highlight_id: ::std::option::Option::None,
                category: ::std::option::Option::None,
                tier: ::std::option::Option::None,
                rarity: ::std::option::Option::None,
                score: ::std::option::Option::None,
                confidence: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                role: ::std::option::Option::None,
                comparison_delta_value: ::std::option::Option::None,
                context: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgBattleReportInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBattleReportInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgBattleReportInfo.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReportInfo.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReportInfo.acknowledged)
    pub acknowledged: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgBattleReportInfo.featured_hero_id)
    pub featured_hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgBattleReportInfo.featured_position)
    pub featured_position: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReportInfo.games_played)
    pub games_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBattleReportInfo.medal_counts)
    pub medal_counts: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBattleReportInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBattleReportInfo {
    fn default() -> &'a CMsgBattleReportInfo {
        <CMsgBattleReportInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgBattleReportInfo {
    pub fn new() -> CMsgBattleReportInfo {
        ::std::default::Default::default()
    }

    // optional uint32 timestamp = 1;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 2;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool acknowledged = 3;

    pub fn acknowledged(&self) -> bool {
        self.acknowledged.unwrap_or(false)
    }

    pub fn clear_acknowledged(&mut self) {
        self.acknowledged = ::std::option::Option::None;
    }

    pub fn has_acknowledged(&self) -> bool {
        self.acknowledged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acknowledged(&mut self, v: bool) {
        self.acknowledged = ::std::option::Option::Some(v);
    }

    // optional int32 featured_hero_id = 4;

    pub fn featured_hero_id(&self) -> i32 {
        self.featured_hero_id.unwrap_or(0)
    }

    pub fn clear_featured_hero_id(&mut self) {
        self.featured_hero_id = ::std::option::Option::None;
    }

    pub fn has_featured_hero_id(&self) -> bool {
        self.featured_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_featured_hero_id(&mut self, v: i32) {
        self.featured_hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 featured_position = 5;

    pub fn featured_position(&self) -> u32 {
        self.featured_position.unwrap_or(0)
    }

    pub fn clear_featured_position(&mut self) {
        self.featured_position = ::std::option::Option::None;
    }

    pub fn has_featured_position(&self) -> bool {
        self.featured_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_featured_position(&mut self, v: u32) {
        self.featured_position = ::std::option::Option::Some(v);
    }

    // optional uint32 games_played = 6;

    pub fn games_played(&self) -> u32 {
        self.games_played.unwrap_or(0)
    }

    pub fn clear_games_played(&mut self) {
        self.games_played = ::std::option::Option::None;
    }

    pub fn has_games_played(&self) -> bool {
        self.games_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_games_played(&mut self, v: u32) {
        self.games_played = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgBattleReportInfo {
    const NAME: &'static str = "CMsgBattleReportInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.acknowledged = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.featured_hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.featured_position = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.games_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    is.read_repeated_packed_uint32_into(&mut self.medal_counts)?;
                },
                56 => {
                    self.medal_counts.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.acknowledged {
            my_size += 1 + 1;
        }
        if let Some(v) = self.featured_hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.featured_position {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.games_played {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        for value in &self.medal_counts {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.timestamp {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.acknowledged {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.featured_hero_id {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.featured_position {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.games_played {
            os.write_uint32(6, v)?;
        }
        for v in &self.medal_counts {
            os.write_uint32(7, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBattleReportInfo {
        CMsgBattleReportInfo::new()
    }

    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.acknowledged = ::std::option::Option::None;
        self.featured_hero_id = ::std::option::Option::None;
        self.featured_position = ::std::option::Option::None;
        self.games_played = ::std::option::Option::None;
        self.medal_counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBattleReportInfo {
        static instance: CMsgBattleReportInfo = CMsgBattleReportInfo {
            timestamp: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            acknowledged: ::std::option::Option::None,
            featured_hero_id: ::std::option::Option::None,
            featured_position: ::std::option::Option::None,
            games_played: ::std::option::Option::None,
            medal_counts: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBattleReportInfoList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBattleReportInfoList {
    // message fields
    // @@protoc_insertion_point(field:CMsgBattleReportInfoList.battle_report_info)
    pub battle_report_info: ::std::vec::Vec<CMsgBattleReportInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBattleReportInfoList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBattleReportInfoList {
    fn default() -> &'a CMsgBattleReportInfoList {
        <CMsgBattleReportInfoList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgBattleReportInfoList {
    pub fn new() -> CMsgBattleReportInfoList {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgBattleReportInfoList {
    const NAME: &'static str = "CMsgBattleReportInfoList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.battle_report_info.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.battle_report_info {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.battle_report_info {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBattleReportInfoList {
        CMsgBattleReportInfoList::new()
    }

    fn clear(&mut self) {
        self.battle_report_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBattleReportInfoList {
        static instance: CMsgBattleReportInfoList = CMsgBattleReportInfoList {
            battle_report_info: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBattleReportHighlights)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBattleReportHighlights {
    // message fields
    // @@protoc_insertion_point(field:CMsgBattleReportHighlights.highlights)
    pub highlights: ::std::vec::Vec<cmsg_battle_report::Highlight>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBattleReportHighlights.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBattleReportHighlights {
    fn default() -> &'a CMsgBattleReportHighlights {
        <CMsgBattleReportHighlights as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgBattleReportHighlights {
    pub fn new() -> CMsgBattleReportHighlights {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgBattleReportHighlights {
    const NAME: &'static str = "CMsgBattleReportHighlights";

    fn is_initialized(&self) -> bool {
        for v in &self.highlights {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.highlights.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.highlights {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.highlights {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBattleReportHighlights {
        CMsgBattleReportHighlights::new()
    }

    fn clear(&mut self) {
        self.highlights.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBattleReportHighlights {
        static instance: CMsgBattleReportHighlights = CMsgBattleReportHighlights {
            highlights: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBattleReportAggregateStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBattleReportAggregateStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.result)
    pub result: ::std::vec::Vec<cmsg_battle_report_aggregate_stats::CMsgBattleReportAggregate>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBattleReportAggregateStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBattleReportAggregateStats {
    fn default() -> &'a CMsgBattleReportAggregateStats {
        <CMsgBattleReportAggregateStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgBattleReportAggregateStats {
    pub fn new() -> CMsgBattleReportAggregateStats {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgBattleReportAggregateStats {
    const NAME: &'static str = "CMsgBattleReportAggregateStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.result.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.result {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.result {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBattleReportAggregateStats {
        CMsgBattleReportAggregateStats::new()
    }

    fn clear(&mut self) {
        self.result.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBattleReportAggregateStats {
        static instance: CMsgBattleReportAggregateStats = CMsgBattleReportAggregateStats {
            result: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgBattleReportAggregateStats`
pub mod cmsg_battle_report_aggregate_stats {
    // @@protoc_insertion_point(message:CMsgBattleReportAggregateStats.CMsgBattleReportStat)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CMsgBattleReportStat {
        // message fields
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportStat.mean)
        pub mean: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportStat.stdev)
        pub stdev: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgBattleReportAggregateStats.CMsgBattleReportStat.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CMsgBattleReportStat {
        fn default() -> &'a CMsgBattleReportStat {
            <CMsgBattleReportStat as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CMsgBattleReportStat {
        pub fn new() -> CMsgBattleReportStat {
            ::std::default::Default::default()
        }

        // optional float mean = 1;

        pub fn mean(&self) -> f32 {
            self.mean.unwrap_or(0.)
        }

        pub fn clear_mean(&mut self) {
            self.mean = ::std::option::Option::None;
        }

        pub fn has_mean(&self) -> bool {
            self.mean.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mean(&mut self, v: f32) {
            self.mean = ::std::option::Option::Some(v);
        }

        // optional float stdev = 2;

        pub fn stdev(&self) -> f32 {
            self.stdev.unwrap_or(0.)
        }

        pub fn clear_stdev(&mut self) {
            self.stdev = ::std::option::Option::None;
        }

        pub fn has_stdev(&self) -> bool {
            self.stdev.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stdev(&mut self, v: f32) {
            self.stdev = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CMsgBattleReportStat {
        const NAME: &'static str = "CMsgBattleReportStat";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.mean = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.stdev = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.mean {
                my_size += 1 + 4;
            }
            if let Some(v) = self.stdev {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.mean {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.stdev {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CMsgBattleReportStat {
            CMsgBattleReportStat::new()
        }

        fn clear(&mut self) {
            self.mean = ::std::option::Option::None;
            self.stdev = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CMsgBattleReportStat {
            static instance: CMsgBattleReportStat = CMsgBattleReportStat {
                mean: ::std::option::Option::None,
                stdev: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CMsgBattleReportAggregate {
        // message fields
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.predicted_position)
        pub predicted_position: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.game_count)
        pub game_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.win_count)
        pub win_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.lane_win_count)
        pub lane_win_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.kills)
        pub kills: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.deaths)
        pub deaths: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.assists)
        pub assists: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.rank_change)
        pub rank_change: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.last_hits)
        pub last_hits: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.denies)
        pub denies: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.gpm)
        pub gpm: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.xpm)
        pub xpm: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.seconds_dead)
        pub seconds_dead: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.bounty_runes)
        pub bounty_runes: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.water_runes)
        pub water_runes: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.power_runes)
        pub power_runes: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.time_enemy_t1_tower_destroyed)
        pub time_enemy_t1_tower_destroyed: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.time_friendly_t1_tower_destroyed)
        pub time_friendly_t1_tower_destroyed: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.enemy_roshan_kills)
        pub enemy_roshan_kills: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.teleports_used)
        pub teleports_used: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.dewards)
        pub dewards: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.camps_stacked)
        pub camps_stacked: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.support_gold)
        pub support_gold: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.hero_damage)
        pub hero_damage: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.hero_healing)
        pub hero_healing: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.tower_damage)
        pub tower_damage: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.successful_smokes)
        pub successful_smokes: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.stun_duration)
        pub stun_duration: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.duration)
        pub duration: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // @@protoc_insertion_point(field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.friendly_roshan_kills)
        pub friendly_roshan_kills: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportStat>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgBattleReportAggregateStats.CMsgBattleReportAggregate.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CMsgBattleReportAggregate {
        fn default() -> &'a CMsgBattleReportAggregate {
            <CMsgBattleReportAggregate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CMsgBattleReportAggregate {
        pub fn new() -> CMsgBattleReportAggregate {
            ::std::default::Default::default()
        }

        // optional int32 hero_id = 1;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 predicted_position = 2;

        pub fn predicted_position(&self) -> u32 {
            self.predicted_position.unwrap_or(0)
        }

        pub fn clear_predicted_position(&mut self) {
            self.predicted_position = ::std::option::Option::None;
        }

        pub fn has_predicted_position(&self) -> bool {
            self.predicted_position.is_some()
        }

        // Param is passed by value, moved
        pub fn set_predicted_position(&mut self, v: u32) {
            self.predicted_position = ::std::option::Option::Some(v);
        }

        // optional uint32 game_count = 3;

        pub fn game_count(&self) -> u32 {
            self.game_count.unwrap_or(0)
        }

        pub fn clear_game_count(&mut self) {
            self.game_count = ::std::option::Option::None;
        }

        pub fn has_game_count(&self) -> bool {
            self.game_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_count(&mut self, v: u32) {
            self.game_count = ::std::option::Option::Some(v);
        }

        // optional uint32 win_count = 4;

        pub fn win_count(&self) -> u32 {
            self.win_count.unwrap_or(0)
        }

        pub fn clear_win_count(&mut self) {
            self.win_count = ::std::option::Option::None;
        }

        pub fn has_win_count(&self) -> bool {
            self.win_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_win_count(&mut self, v: u32) {
            self.win_count = ::std::option::Option::Some(v);
        }

        // optional uint32 lane_win_count = 5;

        pub fn lane_win_count(&self) -> u32 {
            self.lane_win_count.unwrap_or(0)
        }

        pub fn clear_lane_win_count(&mut self) {
            self.lane_win_count = ::std::option::Option::None;
        }

        pub fn has_lane_win_count(&self) -> bool {
            self.lane_win_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lane_win_count(&mut self, v: u32) {
            self.lane_win_count = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CMsgBattleReportAggregate {
        const NAME: &'static str = "CMsgBattleReportAggregate";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.predicted_position = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.game_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.win_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.lane_win_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    50 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.kills)?;
                    },
                    58 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.deaths)?;
                    },
                    66 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.assists)?;
                    },
                    74 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.rank_change)?;
                    },
                    82 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.last_hits)?;
                    },
                    90 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.denies)?;
                    },
                    98 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.gpm)?;
                    },
                    106 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.xpm)?;
                    },
                    114 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.seconds_dead)?;
                    },
                    122 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.bounty_runes)?;
                    },
                    130 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.water_runes)?;
                    },
                    138 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.power_runes)?;
                    },
                    146 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.time_enemy_t1_tower_destroyed)?;
                    },
                    154 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.time_friendly_t1_tower_destroyed)?;
                    },
                    162 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.enemy_roshan_kills)?;
                    },
                    170 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.teleports_used)?;
                    },
                    178 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.dewards)?;
                    },
                    186 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.camps_stacked)?;
                    },
                    194 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.support_gold)?;
                    },
                    202 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.hero_damage)?;
                    },
                    210 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.hero_healing)?;
                    },
                    218 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.tower_damage)?;
                    },
                    226 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.successful_smokes)?;
                    },
                    234 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.stun_duration)?;
                    },
                    242 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.duration)?;
                    },
                    250 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.friendly_roshan_kills)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.predicted_position {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.game_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.win_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.lane_win_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.kills.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.deaths.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.assists.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.rank_change.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.last_hits.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.denies.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.gpm.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.xpm.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.seconds_dead.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.bounty_runes.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.water_runes.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.power_runes.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.time_enemy_t1_tower_destroyed.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.time_friendly_t1_tower_destroyed.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.enemy_roshan_kills.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.teleports_used.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.dewards.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.camps_stacked.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.support_gold.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.hero_damage.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.hero_healing.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.tower_damage.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.successful_smokes.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.stun_duration.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.duration.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.friendly_roshan_kills.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.hero_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.predicted_position {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.game_count {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.win_count {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.lane_win_count {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.kills.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            if let Some(v) = self.deaths.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            if let Some(v) = self.assists.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            }
            if let Some(v) = self.rank_change.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
            }
            if let Some(v) = self.last_hits.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
            }
            if let Some(v) = self.denies.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
            }
            if let Some(v) = self.gpm.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
            }
            if let Some(v) = self.xpm.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
            }
            if let Some(v) = self.seconds_dead.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
            }
            if let Some(v) = self.bounty_runes.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
            }
            if let Some(v) = self.water_runes.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
            }
            if let Some(v) = self.power_runes.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
            }
            if let Some(v) = self.time_enemy_t1_tower_destroyed.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
            }
            if let Some(v) = self.time_friendly_t1_tower_destroyed.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
            }
            if let Some(v) = self.enemy_roshan_kills.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
            }
            if let Some(v) = self.teleports_used.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
            }
            if let Some(v) = self.dewards.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
            }
            if let Some(v) = self.camps_stacked.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
            }
            if let Some(v) = self.support_gold.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
            }
            if let Some(v) = self.hero_damage.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
            }
            if let Some(v) = self.hero_healing.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
            }
            if let Some(v) = self.tower_damage.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
            }
            if let Some(v) = self.successful_smokes.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
            }
            if let Some(v) = self.stun_duration.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
            }
            if let Some(v) = self.duration.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
            }
            if let Some(v) = self.friendly_roshan_kills.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CMsgBattleReportAggregate {
            CMsgBattleReportAggregate::new()
        }

        fn clear(&mut self) {
            self.hero_id = ::std::option::Option::None;
            self.predicted_position = ::std::option::Option::None;
            self.game_count = ::std::option::Option::None;
            self.win_count = ::std::option::Option::None;
            self.lane_win_count = ::std::option::Option::None;
            self.kills.clear();
            self.deaths.clear();
            self.assists.clear();
            self.rank_change.clear();
            self.last_hits.clear();
            self.denies.clear();
            self.gpm.clear();
            self.xpm.clear();
            self.seconds_dead.clear();
            self.bounty_runes.clear();
            self.water_runes.clear();
            self.power_runes.clear();
            self.time_enemy_t1_tower_destroyed.clear();
            self.time_friendly_t1_tower_destroyed.clear();
            self.enemy_roshan_kills.clear();
            self.teleports_used.clear();
            self.dewards.clear();
            self.camps_stacked.clear();
            self.support_gold.clear();
            self.hero_damage.clear();
            self.hero_healing.clear();
            self.tower_damage.clear();
            self.successful_smokes.clear();
            self.stun_duration.clear();
            self.duration.clear();
            self.friendly_roshan_kills.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CMsgBattleReportAggregate {
            static instance: CMsgBattleReportAggregate = CMsgBattleReportAggregate {
                hero_id: ::std::option::Option::None,
                predicted_position: ::std::option::Option::None,
                game_count: ::std::option::Option::None,
                win_count: ::std::option::Option::None,
                lane_win_count: ::std::option::Option::None,
                kills: ::steam_vent_proto_common::protobuf::MessageField::none(),
                deaths: ::steam_vent_proto_common::protobuf::MessageField::none(),
                assists: ::steam_vent_proto_common::protobuf::MessageField::none(),
                rank_change: ::steam_vent_proto_common::protobuf::MessageField::none(),
                last_hits: ::steam_vent_proto_common::protobuf::MessageField::none(),
                denies: ::steam_vent_proto_common::protobuf::MessageField::none(),
                gpm: ::steam_vent_proto_common::protobuf::MessageField::none(),
                xpm: ::steam_vent_proto_common::protobuf::MessageField::none(),
                seconds_dead: ::steam_vent_proto_common::protobuf::MessageField::none(),
                bounty_runes: ::steam_vent_proto_common::protobuf::MessageField::none(),
                water_runes: ::steam_vent_proto_common::protobuf::MessageField::none(),
                power_runes: ::steam_vent_proto_common::protobuf::MessageField::none(),
                time_enemy_t1_tower_destroyed: ::steam_vent_proto_common::protobuf::MessageField::none(),
                time_friendly_t1_tower_destroyed: ::steam_vent_proto_common::protobuf::MessageField::none(),
                enemy_roshan_kills: ::steam_vent_proto_common::protobuf::MessageField::none(),
                teleports_used: ::steam_vent_proto_common::protobuf::MessageField::none(),
                dewards: ::steam_vent_proto_common::protobuf::MessageField::none(),
                camps_stacked: ::steam_vent_proto_common::protobuf::MessageField::none(),
                support_gold: ::steam_vent_proto_common::protobuf::MessageField::none(),
                hero_damage: ::steam_vent_proto_common::protobuf::MessageField::none(),
                hero_healing: ::steam_vent_proto_common::protobuf::MessageField::none(),
                tower_damage: ::steam_vent_proto_common::protobuf::MessageField::none(),
                successful_smokes: ::steam_vent_proto_common::protobuf::MessageField::none(),
                stun_duration: ::steam_vent_proto_common::protobuf::MessageField::none(),
                duration: ::steam_vent_proto_common::protobuf::MessageField::none(),
                friendly_roshan_kills: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgBattleReportAggregatedGeneralStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBattleReportAggregatedGeneralStats {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBattleReportAggregatedGeneralStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBattleReportAggregatedGeneralStats {
    fn default() -> &'a CMsgBattleReportAggregatedGeneralStats {
        <CMsgBattleReportAggregatedGeneralStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgBattleReportAggregatedGeneralStats {
    pub fn new() -> CMsgBattleReportAggregatedGeneralStats {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgBattleReportAggregatedGeneralStats {
    const NAME: &'static str = "CMsgBattleReportAggregatedGeneralStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBattleReportAggregatedGeneralStats {
        CMsgBattleReportAggregatedGeneralStats::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBattleReportAggregatedGeneralStats {
        static instance: CMsgBattleReportAggregatedGeneralStats = CMsgBattleReportAggregatedGeneralStats {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetBattleReportResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetBattleReportResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReportResponse.report)
    pub report: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReport>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReportResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcget_battle_report_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReportResponse.aggregate_stats)
    pub aggregate_stats: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportAggregateStats>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReportResponse.info)
    pub info: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetBattleReportResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetBattleReportResponse {
    fn default() -> &'a CMsgClientToGCGetBattleReportResponse {
        <CMsgClientToGCGetBattleReportResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetBattleReportResponse {
    pub fn new() -> CMsgClientToGCGetBattleReportResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCGetBattleReportResponse.EResponse response = 2;

    pub fn response(&self) -> cmsg_client_to_gcget_battle_report_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcget_battle_report_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcget_battle_report_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcget_battle_report_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetBattleReportResponse {
    const NAME: &'static str = "CMsgClientToGCGetBattleReportResponse";

    fn is_initialized(&self) -> bool {
        for v in &self.report {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.aggregate_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.report)?;
                },
                16 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.aggregate_stats)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.report.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.aggregate_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.report.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.response {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.aggregate_stats.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.info.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetBattleReportResponse {
        CMsgClientToGCGetBattleReportResponse::new()
    }

    fn clear(&mut self) {
        self.report.clear();
        self.response = ::std::option::Option::None;
        self.aggregate_stats.clear();
        self.info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetBattleReportResponse {
        static instance: CMsgClientToGCGetBattleReportResponse = CMsgClientToGCGetBattleReportResponse {
            report: ::steam_vent_proto_common::protobuf::MessageField::none(),
            response: ::std::option::Option::None,
            aggregate_stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
            info: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCGetBattleReportResponse`
pub mod cmsg_client_to_gcget_battle_report_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCGetBattleReportResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportResponse.EResponse.k_ePermissionDenied)
        k_ePermissionDenied = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportResponse.EResponse.k_eNotSubscribedToDotaPlus)
        k_eNotSubscribedToDotaPlus = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportResponse.EResponse.k_eInvalidParameters)
        k_eInvalidParameters = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportResponse.EResponse.k_eUnableToGetPlusSubInfo)
        k_eUnableToGetPlusSubInfo = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportResponse.EResponse.k_eUnableToLoadBattleReport)
        k_eUnableToLoadBattleReport = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportResponse.EResponse.k_eUnableToSaveBattleReport)
        k_eUnableToSaveBattleReport = 9,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportResponse.EResponse.k_eUnableToGetAggregates)
        k_eUnableToGetAggregates = 10,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportResponse.EResponse.k_eNotEnoughGamesPlayed)
        k_eNotEnoughGamesPlayed = 11,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_ePermissionDenied),
                5 => ::std::option::Option::Some(EResponse::k_eNotSubscribedToDotaPlus),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidParameters),
                7 => ::std::option::Option::Some(EResponse::k_eUnableToGetPlusSubInfo),
                8 => ::std::option::Option::Some(EResponse::k_eUnableToLoadBattleReport),
                9 => ::std::option::Option::Some(EResponse::k_eUnableToSaveBattleReport),
                10 => ::std::option::Option::Some(EResponse::k_eUnableToGetAggregates),
                11 => ::std::option::Option::Some(EResponse::k_eNotEnoughGamesPlayed),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_ePermissionDenied" => ::std::option::Option::Some(EResponse::k_ePermissionDenied),
                "k_eNotSubscribedToDotaPlus" => ::std::option::Option::Some(EResponse::k_eNotSubscribedToDotaPlus),
                "k_eInvalidParameters" => ::std::option::Option::Some(EResponse::k_eInvalidParameters),
                "k_eUnableToGetPlusSubInfo" => ::std::option::Option::Some(EResponse::k_eUnableToGetPlusSubInfo),
                "k_eUnableToLoadBattleReport" => ::std::option::Option::Some(EResponse::k_eUnableToLoadBattleReport),
                "k_eUnableToSaveBattleReport" => ::std::option::Option::Some(EResponse::k_eUnableToSaveBattleReport),
                "k_eUnableToGetAggregates" => ::std::option::Option::Some(EResponse::k_eUnableToGetAggregates),
                "k_eNotEnoughGamesPlayed" => ::std::option::Option::Some(EResponse::k_eNotEnoughGamesPlayed),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_ePermissionDenied,
            EResponse::k_eNotSubscribedToDotaPlus,
            EResponse::k_eInvalidParameters,
            EResponse::k_eUnableToGetPlusSubInfo,
            EResponse::k_eUnableToLoadBattleReport,
            EResponse::k_eUnableToSaveBattleReport,
            EResponse::k_eUnableToGetAggregates,
            EResponse::k_eNotEnoughGamesPlayed,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCGetBattleReportAggregateStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetBattleReportAggregateStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReportAggregateStats.aggregate_keys)
    pub aggregate_keys: ::std::vec::Vec<cmsg_client_to_gcget_battle_report_aggregate_stats::CMsgBattleReportAggregateKey>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReportAggregateStats.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReportAggregateStats.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReportAggregateStats.rank)
    pub rank: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetBattleReportAggregateStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetBattleReportAggregateStats {
    fn default() -> &'a CMsgClientToGCGetBattleReportAggregateStats {
        <CMsgClientToGCGetBattleReportAggregateStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetBattleReportAggregateStats {
    pub fn new() -> CMsgClientToGCGetBattleReportAggregateStats {
        ::std::default::Default::default()
    }

    // optional uint32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 3;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional uint32 rank = 4;

    pub fn rank(&self) -> u32 {
        self.rank.unwrap_or(0)
    }

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: u32) {
        self.rank = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetBattleReportAggregateStats {
    const NAME: &'static str = "CMsgClientToGCGetBattleReportAggregateStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.aggregate_keys.push(is.read_message()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.rank = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.aggregate_keys {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.rank {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.aggregate_keys {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.rank {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetBattleReportAggregateStats {
        CMsgClientToGCGetBattleReportAggregateStats::new()
    }

    fn clear(&mut self) {
        self.aggregate_keys.clear();
        self.timestamp = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetBattleReportAggregateStats {
        static instance: CMsgClientToGCGetBattleReportAggregateStats = CMsgClientToGCGetBattleReportAggregateStats {
            aggregate_keys: ::std::vec::Vec::new(),
            timestamp: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            rank: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCGetBattleReportAggregateStats`
pub mod cmsg_client_to_gcget_battle_report_aggregate_stats {
    // @@protoc_insertion_point(message:CMsgClientToGCGetBattleReportAggregateStats.CMsgBattleReportAggregateKey)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CMsgBattleReportAggregateKey {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReportAggregateStats.CMsgBattleReportAggregateKey.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReportAggregateStats.CMsgBattleReportAggregateKey.predicted_position)
        pub predicted_position: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCGetBattleReportAggregateStats.CMsgBattleReportAggregateKey.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CMsgBattleReportAggregateKey {
        fn default() -> &'a CMsgBattleReportAggregateKey {
            <CMsgBattleReportAggregateKey as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CMsgBattleReportAggregateKey {
        pub fn new() -> CMsgBattleReportAggregateKey {
            ::std::default::Default::default()
        }

        // optional int32 hero_id = 1;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 predicted_position = 2;

        pub fn predicted_position(&self) -> u32 {
            self.predicted_position.unwrap_or(0)
        }

        pub fn clear_predicted_position(&mut self) {
            self.predicted_position = ::std::option::Option::None;
        }

        pub fn has_predicted_position(&self) -> bool {
            self.predicted_position.is_some()
        }

        // Param is passed by value, moved
        pub fn set_predicted_position(&mut self, v: u32) {
            self.predicted_position = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CMsgBattleReportAggregateKey {
        const NAME: &'static str = "CMsgBattleReportAggregateKey";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.predicted_position = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.predicted_position {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.hero_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.predicted_position {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CMsgBattleReportAggregateKey {
            CMsgBattleReportAggregateKey::new()
        }

        fn clear(&mut self) {
            self.hero_id = ::std::option::Option::None;
            self.predicted_position = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CMsgBattleReportAggregateKey {
            static instance: CMsgBattleReportAggregateKey = CMsgBattleReportAggregateKey {
                hero_id: ::std::option::Option::None,
                predicted_position: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetBattleReportAggregateStatsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetBattleReportAggregateStatsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReportAggregateStatsResponse.aggregate_stats)
    pub aggregate_stats: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportAggregateStats>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReportAggregateStatsResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcget_battle_report_aggregate_stats_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetBattleReportAggregateStatsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetBattleReportAggregateStatsResponse {
    fn default() -> &'a CMsgClientToGCGetBattleReportAggregateStatsResponse {
        <CMsgClientToGCGetBattleReportAggregateStatsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetBattleReportAggregateStatsResponse {
    pub fn new() -> CMsgClientToGCGetBattleReportAggregateStatsResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCGetBattleReportAggregateStatsResponse.EResponse response = 2;

    pub fn response(&self) -> cmsg_client_to_gcget_battle_report_aggregate_stats_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcget_battle_report_aggregate_stats_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcget_battle_report_aggregate_stats_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcget_battle_report_aggregate_stats_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetBattleReportAggregateStatsResponse {
    const NAME: &'static str = "CMsgClientToGCGetBattleReportAggregateStatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.aggregate_stats)?;
                },
                16 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.aggregate_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.aggregate_stats.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.response {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetBattleReportAggregateStatsResponse {
        CMsgClientToGCGetBattleReportAggregateStatsResponse::new()
    }

    fn clear(&mut self) {
        self.aggregate_stats.clear();
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetBattleReportAggregateStatsResponse {
        static instance: CMsgClientToGCGetBattleReportAggregateStatsResponse = CMsgClientToGCGetBattleReportAggregateStatsResponse {
            aggregate_stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCGetBattleReportAggregateStatsResponse`
pub mod cmsg_client_to_gcget_battle_report_aggregate_stats_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCGetBattleReportAggregateStatsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportAggregateStatsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportAggregateStatsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportAggregateStatsResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportAggregateStatsResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportAggregateStatsResponse.EResponse.k_ePermissionDenied)
        k_ePermissionDenied = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportAggregateStatsResponse.EResponse.k_eInvalidParams)
        k_eInvalidParams = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportAggregateStatsResponse.EResponse.k_eNotSubscribedToDotaPlus)
        k_eNotSubscribedToDotaPlus = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_ePermissionDenied),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidParams),
                6 => ::std::option::Option::Some(EResponse::k_eNotSubscribedToDotaPlus),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_ePermissionDenied" => ::std::option::Option::Some(EResponse::k_ePermissionDenied),
                "k_eInvalidParams" => ::std::option::Option::Some(EResponse::k_eInvalidParams),
                "k_eNotSubscribedToDotaPlus" => ::std::option::Option::Some(EResponse::k_eNotSubscribedToDotaPlus),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_ePermissionDenied,
            EResponse::k_eInvalidParams,
            EResponse::k_eNotSubscribedToDotaPlus,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCGetBattleReportInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetBattleReportInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReportInfo.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetBattleReportInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetBattleReportInfo {
    fn default() -> &'a CMsgClientToGCGetBattleReportInfo {
        <CMsgClientToGCGetBattleReportInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetBattleReportInfo {
    pub fn new() -> CMsgClientToGCGetBattleReportInfo {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetBattleReportInfo {
    const NAME: &'static str = "CMsgClientToGCGetBattleReportInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetBattleReportInfo {
        CMsgClientToGCGetBattleReportInfo::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetBattleReportInfo {
        static instance: CMsgClientToGCGetBattleReportInfo = CMsgClientToGCGetBattleReportInfo {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetBattleReportInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetBattleReportInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReportInfoResponse.battle_report_info_list)
    pub battle_report_info_list: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReportInfoList>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReportInfoResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcget_battle_report_info_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetBattleReportInfoResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetBattleReportInfoResponse {
    fn default() -> &'a CMsgClientToGCGetBattleReportInfoResponse {
        <CMsgClientToGCGetBattleReportInfoResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetBattleReportInfoResponse {
    pub fn new() -> CMsgClientToGCGetBattleReportInfoResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCGetBattleReportInfoResponse.EResponse response = 2;

    pub fn response(&self) -> cmsg_client_to_gcget_battle_report_info_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcget_battle_report_info_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcget_battle_report_info_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcget_battle_report_info_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetBattleReportInfoResponse {
    const NAME: &'static str = "CMsgClientToGCGetBattleReportInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.battle_report_info_list)?;
                },
                16 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.battle_report_info_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.battle_report_info_list.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.response {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetBattleReportInfoResponse {
        CMsgClientToGCGetBattleReportInfoResponse::new()
    }

    fn clear(&mut self) {
        self.battle_report_info_list.clear();
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetBattleReportInfoResponse {
        static instance: CMsgClientToGCGetBattleReportInfoResponse = CMsgClientToGCGetBattleReportInfoResponse {
            battle_report_info_list: ::steam_vent_proto_common::protobuf::MessageField::none(),
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCGetBattleReportInfoResponse`
pub mod cmsg_client_to_gcget_battle_report_info_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCGetBattleReportInfoResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportInfoResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportInfoResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportInfoResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportInfoResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportInfoResponse.EResponse.k_ePermissionDenied)
        k_ePermissionDenied = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportInfoResponse.EResponse.k_eNotSubscribedToDotaPlus)
        k_eNotSubscribedToDotaPlus = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_ePermissionDenied),
                5 => ::std::option::Option::Some(EResponse::k_eNotSubscribedToDotaPlus),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_ePermissionDenied" => ::std::option::Option::Some(EResponse::k_ePermissionDenied),
                "k_eNotSubscribedToDotaPlus" => ::std::option::Option::Some(EResponse::k_eNotSubscribedToDotaPlus),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_ePermissionDenied,
            EResponse::k_eNotSubscribedToDotaPlus,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCAcknowledgeBattleReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCAcknowledgeBattleReport {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCAcknowledgeBattleReport.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCAcknowledgeBattleReport.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCAcknowledgeBattleReport.duration)
    pub duration: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCAcknowledgeBattleReport.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCAcknowledgeBattleReport {
    fn default() -> &'a CMsgClientToGCAcknowledgeBattleReport {
        <CMsgClientToGCAcknowledgeBattleReport as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCAcknowledgeBattleReport {
    pub fn new() -> CMsgClientToGCAcknowledgeBattleReport {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 3;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCAcknowledgeBattleReport {
    const NAME: &'static str = "CMsgClientToGCAcknowledgeBattleReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCAcknowledgeBattleReport {
        CMsgClientToGCAcknowledgeBattleReport::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCAcknowledgeBattleReport {
        static instance: CMsgClientToGCAcknowledgeBattleReport = CMsgClientToGCAcknowledgeBattleReport {
            account_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCAcknowledgeBattleReportResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCAcknowledgeBattleReportResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCAcknowledgeBattleReportResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcacknowledge_battle_report_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCAcknowledgeBattleReportResponse.shards_awarded)
    pub shards_awarded: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCAcknowledgeBattleReportResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCAcknowledgeBattleReportResponse {
    fn default() -> &'a CMsgClientToGCAcknowledgeBattleReportResponse {
        <CMsgClientToGCAcknowledgeBattleReportResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCAcknowledgeBattleReportResponse {
    pub fn new() -> CMsgClientToGCAcknowledgeBattleReportResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCAcknowledgeBattleReportResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcacknowledge_battle_report_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcacknowledge_battle_report_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcacknowledge_battle_report_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcacknowledge_battle_report_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 shards_awarded = 2;

    pub fn shards_awarded(&self) -> u32 {
        self.shards_awarded.unwrap_or(0)
    }

    pub fn clear_shards_awarded(&mut self) {
        self.shards_awarded = ::std::option::Option::None;
    }

    pub fn has_shards_awarded(&self) -> bool {
        self.shards_awarded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shards_awarded(&mut self, v: u32) {
        self.shards_awarded = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCAcknowledgeBattleReportResponse {
    const NAME: &'static str = "CMsgClientToGCAcknowledgeBattleReportResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.shards_awarded = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.shards_awarded {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.shards_awarded {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCAcknowledgeBattleReportResponse {
        CMsgClientToGCAcknowledgeBattleReportResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.shards_awarded = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCAcknowledgeBattleReportResponse {
        static instance: CMsgClientToGCAcknowledgeBattleReportResponse = CMsgClientToGCAcknowledgeBattleReportResponse {
            response: ::std::option::Option::None,
            shards_awarded: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCAcknowledgeBattleReportResponse`
pub mod cmsg_client_to_gcacknowledge_battle_report_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCAcknowledgeBattleReportResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_ePermissionDenied)
        k_ePermissionDenied = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_eUnableToLoadBattleReport)
        k_eUnableToLoadBattleReport = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_eAlreadyAcknowledged)
        k_eAlreadyAcknowledged = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_eUnknownReport)
        k_eUnknownReport = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_eNotSubscribedToDotaPlus)
        k_eNotSubscribedToDotaPlus = 9,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCAcknowledgeBattleReportResponse.EResponse.k_eNotEnoughGamesPlayed)
        k_eNotEnoughGamesPlayed = 10,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_ePermissionDenied),
                6 => ::std::option::Option::Some(EResponse::k_eUnableToLoadBattleReport),
                7 => ::std::option::Option::Some(EResponse::k_eAlreadyAcknowledged),
                8 => ::std::option::Option::Some(EResponse::k_eUnknownReport),
                9 => ::std::option::Option::Some(EResponse::k_eNotSubscribedToDotaPlus),
                10 => ::std::option::Option::Some(EResponse::k_eNotEnoughGamesPlayed),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_ePermissionDenied" => ::std::option::Option::Some(EResponse::k_ePermissionDenied),
                "k_eUnableToLoadBattleReport" => ::std::option::Option::Some(EResponse::k_eUnableToLoadBattleReport),
                "k_eAlreadyAcknowledged" => ::std::option::Option::Some(EResponse::k_eAlreadyAcknowledged),
                "k_eUnknownReport" => ::std::option::Option::Some(EResponse::k_eUnknownReport),
                "k_eNotSubscribedToDotaPlus" => ::std::option::Option::Some(EResponse::k_eNotSubscribedToDotaPlus),
                "k_eNotEnoughGamesPlayed" => ::std::option::Option::Some(EResponse::k_eNotEnoughGamesPlayed),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_ePermissionDenied,
            EResponse::k_eUnableToLoadBattleReport,
            EResponse::k_eAlreadyAcknowledged,
            EResponse::k_eUnknownReport,
            EResponse::k_eNotSubscribedToDotaPlus,
            EResponse::k_eNotEnoughGamesPlayed,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCGetBattleReportMatchHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetBattleReportMatchHistory {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReportMatchHistory.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReportMatchHistory.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReportMatchHistory.duration)
    pub duration: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetBattleReportMatchHistory.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetBattleReportMatchHistory {
    fn default() -> &'a CMsgClientToGCGetBattleReportMatchHistory {
        <CMsgClientToGCGetBattleReportMatchHistory as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetBattleReportMatchHistory {
    pub fn new() -> CMsgClientToGCGetBattleReportMatchHistory {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 3;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetBattleReportMatchHistory {
    const NAME: &'static str = "CMsgClientToGCGetBattleReportMatchHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetBattleReportMatchHistory {
        CMsgClientToGCGetBattleReportMatchHistory::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetBattleReportMatchHistory {
        static instance: CMsgClientToGCGetBattleReportMatchHistory = CMsgClientToGCGetBattleReportMatchHistory {
            account_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetBattleReportMatchHistoryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetBattleReportMatchHistoryResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReportMatchHistoryResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcget_battle_report_match_history_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetBattleReportMatchHistoryResponse.games)
    pub games: ::steam_vent_proto_common::protobuf::MessageField<CMsgBattleReport_GameList>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetBattleReportMatchHistoryResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetBattleReportMatchHistoryResponse {
    fn default() -> &'a CMsgClientToGCGetBattleReportMatchHistoryResponse {
        <CMsgClientToGCGetBattleReportMatchHistoryResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetBattleReportMatchHistoryResponse {
    pub fn new() -> CMsgClientToGCGetBattleReportMatchHistoryResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCGetBattleReportMatchHistoryResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcget_battle_report_match_history_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcget_battle_report_match_history_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcget_battle_report_match_history_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcget_battle_report_match_history_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetBattleReportMatchHistoryResponse {
    const NAME: &'static str = "CMsgClientToGCGetBattleReportMatchHistoryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.games)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.games.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.games.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetBattleReportMatchHistoryResponse {
        CMsgClientToGCGetBattleReportMatchHistoryResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.games.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetBattleReportMatchHistoryResponse {
        static instance: CMsgClientToGCGetBattleReportMatchHistoryResponse = CMsgClientToGCGetBattleReportMatchHistoryResponse {
            response: ::std::option::Option::None,
            games: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCGetBattleReportMatchHistoryResponse`
pub mod cmsg_client_to_gcget_battle_report_match_history_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCGetBattleReportMatchHistoryResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportMatchHistoryResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportMatchHistoryResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportMatchHistoryResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportMatchHistoryResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportMatchHistoryResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportMatchHistoryResponse.EResponse.k_ePermissionDenied)
        k_ePermissionDenied = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetBattleReportMatchHistoryResponse.EResponse.k_eNotSubscribedToDotaPlus)
        k_eNotSubscribedToDotaPlus = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_ePermissionDenied),
                6 => ::std::option::Option::Some(EResponse::k_eNotSubscribedToDotaPlus),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_ePermissionDenied" => ::std::option::Option::Some(EResponse::k_ePermissionDenied),
                "k_eNotSubscribedToDotaPlus" => ::std::option::Option::Some(EResponse::k_eNotSubscribedToDotaPlus),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_ePermissionDenied,
            EResponse::k_eNotSubscribedToDotaPlus,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:CMsgBattleReport_HighlightType)
pub enum CMsgBattleReport_HighlightType {
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eHighlightTypeInvalid)
    k_eHighlightTypeInvalid = -1,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eGameWinrate)
    k_eGameWinrate = 0,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eLaneWinrate)
    k_eLaneWinrate = 1,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMMRDelta)
    k_eMMRDelta = 2,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eNumHeroesPlayed)
    k_eNumHeroesPlayed = 3,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eNumGamesPlayed)
    k_eNumGamesPlayed = 4,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eAveragePowerRunesTaken)
    k_eAveragePowerRunesTaken = 5,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eAverageBountyRunesTaken)
    k_eAverageBountyRunesTaken = 6,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eTotalKillEnemyT1First)
    k_eTotalKillEnemyT1First = 7,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eTotalRoshanKills)
    k_eTotalRoshanKills = 8,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eTotalDewards)
    k_eTotalDewards = 9,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eTotalCampsStacked)
    k_eTotalCampsStacked = 10,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMaxWinstreak)
    k_eMaxWinstreak = 11,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eAverageDewards)
    k_eAverageDewards = 12,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eAverageKills)
    k_eAverageKills = 13,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMaxKills)
    k_eMaxKills = 14,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eAverageAssists)
    k_eAverageAssists = 15,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMaxAssists)
    k_eMaxAssists = 16,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eAverageDeaths)
    k_eAverageDeaths = 17,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMinDeaths)
    k_eMinDeaths = 18,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eAverageCampsStacked)
    k_eAverageCampsStacked = 19,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eTotalLastHits)
    k_eTotalLastHits = 20,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eAverageLastHits)
    k_eAverageLastHits = 21,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eTotalDenies)
    k_eTotalDenies = 22,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eAverageDenies)
    k_eAverageDenies = 23,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eTotalGamesWithRoshanAdvantage)
    k_eTotalGamesWithRoshanAdvantage = 24,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_ePercentGamesWithRoshanAdvantage)
    k_ePercentGamesWithRoshanAdvantage = 25,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eAverageStunDuration)
    k_eAverageStunDuration = 26,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eTotalStunDuration)
    k_eTotalStunDuration = 27,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eAverageTeleportsUsed)
    k_eAverageTeleportsUsed = 28,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eTotalTeleportsUsed)
    k_eTotalTeleportsUsed = 29,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eAverageHeroDamage)
    k_eAverageHeroDamage = 30,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eTotalHeroDamage)
    k_eTotalHeroDamage = 31,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eAverageHeroHealing)
    k_eAverageHeroHealing = 32,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eTotalHeroHealing)
    k_eTotalHeroHealing = 33,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eAverageTowerDamage)
    k_eAverageTowerDamage = 34,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eTotalTowerDamage)
    k_eTotalTowerDamage = 35,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMaxLossStreak)
    k_eMaxLossStreak = 36,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eAverageGameDuration)
    k_eAverageGameDuration = 37,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMaxGameDuration)
    k_eMaxGameDuration = 38,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMinGameDuration)
    k_eMinGameDuration = 39,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eAverageWinDuration)
    k_eAverageWinDuration = 40,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMaxWinDuration)
    k_eMaxWinDuration = 41,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMinWinDuration)
    k_eMinWinDuration = 42,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eAverageLossDuration)
    k_eAverageLossDuration = 43,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMaxLossDuration)
    k_eMaxLossDuration = 44,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMinLossDuration)
    k_eMinLossDuration = 45,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_ePctGamesEnemyT1TakenFirst)
    k_ePctGamesEnemyT1TakenFirst = 46,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMaxCampsStacked)
    k_eMaxCampsStacked = 47,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMaxDewards)
    k_eMaxDewards = 48,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMaxRoshanKills)
    k_eMaxRoshanKills = 49,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMaxBountyRunesTaken)
    k_eMaxBountyRunesTaken = 50,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMaxPowerRunesTaken)
    k_eMaxPowerRunesTaken = 51,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMaxDeaths)
    k_eMaxDeaths = 52,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMaxLastHits)
    k_eMaxLastHits = 53,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMaxDenies)
    k_eMaxDenies = 54,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eRadiantWinRate)
    k_eRadiantWinRate = 55,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eDireWinRate)
    k_eDireWinRate = 56,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eRadiantGameCount)
    k_eRadiantGameCount = 57,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eDireGameCount)
    k_eDireGameCount = 58,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMaxDamage)
    k_eMaxDamage = 59,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMaxHealing)
    k_eMaxHealing = 60,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMaxTowerDamage)
    k_eMaxTowerDamage = 61,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eAverageGPM)
    k_eAverageGPM = 62,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMaxGPM)
    k_eMaxGPM = 63,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eAverageXPM)
    k_eAverageXPM = 64,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightType.k_eMaxXPM)
    k_eMaxXPM = 65,
}

impl ::steam_vent_proto_common::protobuf::Enum for CMsgBattleReport_HighlightType {
    const NAME: &'static str = "CMsgBattleReport_HighlightType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgBattleReport_HighlightType> {
        match value {
            -1 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eHighlightTypeInvalid),
            0 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eGameWinrate),
            1 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eLaneWinrate),
            2 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMMRDelta),
            3 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eNumHeroesPlayed),
            4 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eNumGamesPlayed),
            5 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAveragePowerRunesTaken),
            6 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageBountyRunesTaken),
            7 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalKillEnemyT1First),
            8 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalRoshanKills),
            9 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalDewards),
            10 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalCampsStacked),
            11 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxWinstreak),
            12 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageDewards),
            13 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageKills),
            14 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxKills),
            15 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageAssists),
            16 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxAssists),
            17 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageDeaths),
            18 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMinDeaths),
            19 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageCampsStacked),
            20 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalLastHits),
            21 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageLastHits),
            22 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalDenies),
            23 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageDenies),
            24 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalGamesWithRoshanAdvantage),
            25 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_ePercentGamesWithRoshanAdvantage),
            26 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageStunDuration),
            27 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalStunDuration),
            28 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageTeleportsUsed),
            29 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalTeleportsUsed),
            30 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageHeroDamage),
            31 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalHeroDamage),
            32 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageHeroHealing),
            33 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalHeroHealing),
            34 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageTowerDamage),
            35 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalTowerDamage),
            36 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxLossStreak),
            37 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageGameDuration),
            38 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxGameDuration),
            39 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMinGameDuration),
            40 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageWinDuration),
            41 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxWinDuration),
            42 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMinWinDuration),
            43 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageLossDuration),
            44 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxLossDuration),
            45 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMinLossDuration),
            46 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_ePctGamesEnemyT1TakenFirst),
            47 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxCampsStacked),
            48 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxDewards),
            49 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxRoshanKills),
            50 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxBountyRunesTaken),
            51 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxPowerRunesTaken),
            52 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxDeaths),
            53 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxLastHits),
            54 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxDenies),
            55 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eRadiantWinRate),
            56 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eDireWinRate),
            57 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eRadiantGameCount),
            58 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eDireGameCount),
            59 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxDamage),
            60 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxHealing),
            61 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxTowerDamage),
            62 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageGPM),
            63 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxGPM),
            64 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageXPM),
            65 => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxXPM),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CMsgBattleReport_HighlightType> {
        match str {
            "k_eHighlightTypeInvalid" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eHighlightTypeInvalid),
            "k_eGameWinrate" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eGameWinrate),
            "k_eLaneWinrate" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eLaneWinrate),
            "k_eMMRDelta" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMMRDelta),
            "k_eNumHeroesPlayed" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eNumHeroesPlayed),
            "k_eNumGamesPlayed" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eNumGamesPlayed),
            "k_eAveragePowerRunesTaken" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAveragePowerRunesTaken),
            "k_eAverageBountyRunesTaken" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageBountyRunesTaken),
            "k_eTotalKillEnemyT1First" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalKillEnemyT1First),
            "k_eTotalRoshanKills" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalRoshanKills),
            "k_eTotalDewards" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalDewards),
            "k_eTotalCampsStacked" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalCampsStacked),
            "k_eMaxWinstreak" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxWinstreak),
            "k_eAverageDewards" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageDewards),
            "k_eAverageKills" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageKills),
            "k_eMaxKills" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxKills),
            "k_eAverageAssists" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageAssists),
            "k_eMaxAssists" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxAssists),
            "k_eAverageDeaths" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageDeaths),
            "k_eMinDeaths" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMinDeaths),
            "k_eAverageCampsStacked" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageCampsStacked),
            "k_eTotalLastHits" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalLastHits),
            "k_eAverageLastHits" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageLastHits),
            "k_eTotalDenies" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalDenies),
            "k_eAverageDenies" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageDenies),
            "k_eTotalGamesWithRoshanAdvantage" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalGamesWithRoshanAdvantage),
            "k_ePercentGamesWithRoshanAdvantage" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_ePercentGamesWithRoshanAdvantage),
            "k_eAverageStunDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageStunDuration),
            "k_eTotalStunDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalStunDuration),
            "k_eAverageTeleportsUsed" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageTeleportsUsed),
            "k_eTotalTeleportsUsed" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalTeleportsUsed),
            "k_eAverageHeroDamage" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageHeroDamage),
            "k_eTotalHeroDamage" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalHeroDamage),
            "k_eAverageHeroHealing" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageHeroHealing),
            "k_eTotalHeroHealing" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalHeroHealing),
            "k_eAverageTowerDamage" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageTowerDamage),
            "k_eTotalTowerDamage" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eTotalTowerDamage),
            "k_eMaxLossStreak" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxLossStreak),
            "k_eAverageGameDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageGameDuration),
            "k_eMaxGameDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxGameDuration),
            "k_eMinGameDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMinGameDuration),
            "k_eAverageWinDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageWinDuration),
            "k_eMaxWinDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxWinDuration),
            "k_eMinWinDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMinWinDuration),
            "k_eAverageLossDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageLossDuration),
            "k_eMaxLossDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxLossDuration),
            "k_eMinLossDuration" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMinLossDuration),
            "k_ePctGamesEnemyT1TakenFirst" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_ePctGamesEnemyT1TakenFirst),
            "k_eMaxCampsStacked" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxCampsStacked),
            "k_eMaxDewards" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxDewards),
            "k_eMaxRoshanKills" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxRoshanKills),
            "k_eMaxBountyRunesTaken" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxBountyRunesTaken),
            "k_eMaxPowerRunesTaken" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxPowerRunesTaken),
            "k_eMaxDeaths" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxDeaths),
            "k_eMaxLastHits" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxLastHits),
            "k_eMaxDenies" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxDenies),
            "k_eRadiantWinRate" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eRadiantWinRate),
            "k_eDireWinRate" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eDireWinRate),
            "k_eRadiantGameCount" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eRadiantGameCount),
            "k_eDireGameCount" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eDireGameCount),
            "k_eMaxDamage" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxDamage),
            "k_eMaxHealing" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxHealing),
            "k_eMaxTowerDamage" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxTowerDamage),
            "k_eAverageGPM" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageGPM),
            "k_eMaxGPM" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxGPM),
            "k_eAverageXPM" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eAverageXPM),
            "k_eMaxXPM" => ::std::option::Option::Some(CMsgBattleReport_HighlightType::k_eMaxXPM),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CMsgBattleReport_HighlightType] = &[
        CMsgBattleReport_HighlightType::k_eHighlightTypeInvalid,
        CMsgBattleReport_HighlightType::k_eGameWinrate,
        CMsgBattleReport_HighlightType::k_eLaneWinrate,
        CMsgBattleReport_HighlightType::k_eMMRDelta,
        CMsgBattleReport_HighlightType::k_eNumHeroesPlayed,
        CMsgBattleReport_HighlightType::k_eNumGamesPlayed,
        CMsgBattleReport_HighlightType::k_eAveragePowerRunesTaken,
        CMsgBattleReport_HighlightType::k_eAverageBountyRunesTaken,
        CMsgBattleReport_HighlightType::k_eTotalKillEnemyT1First,
        CMsgBattleReport_HighlightType::k_eTotalRoshanKills,
        CMsgBattleReport_HighlightType::k_eTotalDewards,
        CMsgBattleReport_HighlightType::k_eTotalCampsStacked,
        CMsgBattleReport_HighlightType::k_eMaxWinstreak,
        CMsgBattleReport_HighlightType::k_eAverageDewards,
        CMsgBattleReport_HighlightType::k_eAverageKills,
        CMsgBattleReport_HighlightType::k_eMaxKills,
        CMsgBattleReport_HighlightType::k_eAverageAssists,
        CMsgBattleReport_HighlightType::k_eMaxAssists,
        CMsgBattleReport_HighlightType::k_eAverageDeaths,
        CMsgBattleReport_HighlightType::k_eMinDeaths,
        CMsgBattleReport_HighlightType::k_eAverageCampsStacked,
        CMsgBattleReport_HighlightType::k_eTotalLastHits,
        CMsgBattleReport_HighlightType::k_eAverageLastHits,
        CMsgBattleReport_HighlightType::k_eTotalDenies,
        CMsgBattleReport_HighlightType::k_eAverageDenies,
        CMsgBattleReport_HighlightType::k_eTotalGamesWithRoshanAdvantage,
        CMsgBattleReport_HighlightType::k_ePercentGamesWithRoshanAdvantage,
        CMsgBattleReport_HighlightType::k_eAverageStunDuration,
        CMsgBattleReport_HighlightType::k_eTotalStunDuration,
        CMsgBattleReport_HighlightType::k_eAverageTeleportsUsed,
        CMsgBattleReport_HighlightType::k_eTotalTeleportsUsed,
        CMsgBattleReport_HighlightType::k_eAverageHeroDamage,
        CMsgBattleReport_HighlightType::k_eTotalHeroDamage,
        CMsgBattleReport_HighlightType::k_eAverageHeroHealing,
        CMsgBattleReport_HighlightType::k_eTotalHeroHealing,
        CMsgBattleReport_HighlightType::k_eAverageTowerDamage,
        CMsgBattleReport_HighlightType::k_eTotalTowerDamage,
        CMsgBattleReport_HighlightType::k_eMaxLossStreak,
        CMsgBattleReport_HighlightType::k_eAverageGameDuration,
        CMsgBattleReport_HighlightType::k_eMaxGameDuration,
        CMsgBattleReport_HighlightType::k_eMinGameDuration,
        CMsgBattleReport_HighlightType::k_eAverageWinDuration,
        CMsgBattleReport_HighlightType::k_eMaxWinDuration,
        CMsgBattleReport_HighlightType::k_eMinWinDuration,
        CMsgBattleReport_HighlightType::k_eAverageLossDuration,
        CMsgBattleReport_HighlightType::k_eMaxLossDuration,
        CMsgBattleReport_HighlightType::k_eMinLossDuration,
        CMsgBattleReport_HighlightType::k_ePctGamesEnemyT1TakenFirst,
        CMsgBattleReport_HighlightType::k_eMaxCampsStacked,
        CMsgBattleReport_HighlightType::k_eMaxDewards,
        CMsgBattleReport_HighlightType::k_eMaxRoshanKills,
        CMsgBattleReport_HighlightType::k_eMaxBountyRunesTaken,
        CMsgBattleReport_HighlightType::k_eMaxPowerRunesTaken,
        CMsgBattleReport_HighlightType::k_eMaxDeaths,
        CMsgBattleReport_HighlightType::k_eMaxLastHits,
        CMsgBattleReport_HighlightType::k_eMaxDenies,
        CMsgBattleReport_HighlightType::k_eRadiantWinRate,
        CMsgBattleReport_HighlightType::k_eDireWinRate,
        CMsgBattleReport_HighlightType::k_eRadiantGameCount,
        CMsgBattleReport_HighlightType::k_eDireGameCount,
        CMsgBattleReport_HighlightType::k_eMaxDamage,
        CMsgBattleReport_HighlightType::k_eMaxHealing,
        CMsgBattleReport_HighlightType::k_eMaxTowerDamage,
        CMsgBattleReport_HighlightType::k_eAverageGPM,
        CMsgBattleReport_HighlightType::k_eMaxGPM,
        CMsgBattleReport_HighlightType::k_eAverageXPM,
        CMsgBattleReport_HighlightType::k_eMaxXPM,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgBattleReport_HighlightType {
    fn default() -> Self {
        CMsgBattleReport_HighlightType::k_eHighlightTypeInvalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:CMsgBattleReport_HighlightCategory)
pub enum CMsgBattleReport_HighlightCategory {
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightCategory.k_eHighlightGeneral)
    k_eHighlightGeneral = 0,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightCategory.k_eHighlightHero)
    k_eHighlightHero = 1,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightCategory.k_eHighlightRole)
    k_eHighlightRole = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for CMsgBattleReport_HighlightCategory {
    const NAME: &'static str = "CMsgBattleReport_HighlightCategory";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgBattleReport_HighlightCategory> {
        match value {
            0 => ::std::option::Option::Some(CMsgBattleReport_HighlightCategory::k_eHighlightGeneral),
            1 => ::std::option::Option::Some(CMsgBattleReport_HighlightCategory::k_eHighlightHero),
            2 => ::std::option::Option::Some(CMsgBattleReport_HighlightCategory::k_eHighlightRole),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CMsgBattleReport_HighlightCategory> {
        match str {
            "k_eHighlightGeneral" => ::std::option::Option::Some(CMsgBattleReport_HighlightCategory::k_eHighlightGeneral),
            "k_eHighlightHero" => ::std::option::Option::Some(CMsgBattleReport_HighlightCategory::k_eHighlightHero),
            "k_eHighlightRole" => ::std::option::Option::Some(CMsgBattleReport_HighlightCategory::k_eHighlightRole),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CMsgBattleReport_HighlightCategory] = &[
        CMsgBattleReport_HighlightCategory::k_eHighlightGeneral,
        CMsgBattleReport_HighlightCategory::k_eHighlightHero,
        CMsgBattleReport_HighlightCategory::k_eHighlightRole,
    ];
}

impl ::std::default::Default for CMsgBattleReport_HighlightCategory {
    fn default() -> Self {
        CMsgBattleReport_HighlightCategory::k_eHighlightGeneral
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:CMsgBattleReport_Role)
pub enum CMsgBattleReport_Role {
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_Role.k_eUnknownRole)
    k_eUnknownRole = -1,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_Role.k_eSafelane)
    k_eSafelane = 0,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_Role.k_eMidlane)
    k_eMidlane = 1,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_Role.k_eOfflane)
    k_eOfflane = 2,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_Role.k_eSupport)
    k_eSupport = 3,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_Role.k_eHardSupport)
    k_eHardSupport = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for CMsgBattleReport_Role {
    const NAME: &'static str = "CMsgBattleReport_Role";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgBattleReport_Role> {
        match value {
            -1 => ::std::option::Option::Some(CMsgBattleReport_Role::k_eUnknownRole),
            0 => ::std::option::Option::Some(CMsgBattleReport_Role::k_eSafelane),
            1 => ::std::option::Option::Some(CMsgBattleReport_Role::k_eMidlane),
            2 => ::std::option::Option::Some(CMsgBattleReport_Role::k_eOfflane),
            3 => ::std::option::Option::Some(CMsgBattleReport_Role::k_eSupport),
            4 => ::std::option::Option::Some(CMsgBattleReport_Role::k_eHardSupport),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CMsgBattleReport_Role> {
        match str {
            "k_eUnknownRole" => ::std::option::Option::Some(CMsgBattleReport_Role::k_eUnknownRole),
            "k_eSafelane" => ::std::option::Option::Some(CMsgBattleReport_Role::k_eSafelane),
            "k_eMidlane" => ::std::option::Option::Some(CMsgBattleReport_Role::k_eMidlane),
            "k_eOfflane" => ::std::option::Option::Some(CMsgBattleReport_Role::k_eOfflane),
            "k_eSupport" => ::std::option::Option::Some(CMsgBattleReport_Role::k_eSupport),
            "k_eHardSupport" => ::std::option::Option::Some(CMsgBattleReport_Role::k_eHardSupport),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CMsgBattleReport_Role] = &[
        CMsgBattleReport_Role::k_eUnknownRole,
        CMsgBattleReport_Role::k_eSafelane,
        CMsgBattleReport_Role::k_eMidlane,
        CMsgBattleReport_Role::k_eOfflane,
        CMsgBattleReport_Role::k_eSupport,
        CMsgBattleReport_Role::k_eHardSupport,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgBattleReport_Role {
    fn default() -> Self {
        CMsgBattleReport_Role::k_eUnknownRole
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:CMsgBattleReport_CompareContext)
pub enum CMsgBattleReport_CompareContext {
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_CompareContext.k_eCompareContextInvalid)
    k_eCompareContextInvalid = -1,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_CompareContext.k_eAbsoluteValue)
    k_eAbsoluteValue = 0,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_CompareContext.k_ePlayersOfSimilarRank)
    k_ePlayersOfSimilarRank = 1,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_CompareContext.k_eAllPlayers)
    k_eAllPlayers = 2,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_CompareContext.k_ePlayersPersonalHistory)
    k_ePlayersPersonalHistory = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for CMsgBattleReport_CompareContext {
    const NAME: &'static str = "CMsgBattleReport_CompareContext";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgBattleReport_CompareContext> {
        match value {
            -1 => ::std::option::Option::Some(CMsgBattleReport_CompareContext::k_eCompareContextInvalid),
            0 => ::std::option::Option::Some(CMsgBattleReport_CompareContext::k_eAbsoluteValue),
            1 => ::std::option::Option::Some(CMsgBattleReport_CompareContext::k_ePlayersOfSimilarRank),
            2 => ::std::option::Option::Some(CMsgBattleReport_CompareContext::k_eAllPlayers),
            3 => ::std::option::Option::Some(CMsgBattleReport_CompareContext::k_ePlayersPersonalHistory),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CMsgBattleReport_CompareContext> {
        match str {
            "k_eCompareContextInvalid" => ::std::option::Option::Some(CMsgBattleReport_CompareContext::k_eCompareContextInvalid),
            "k_eAbsoluteValue" => ::std::option::Option::Some(CMsgBattleReport_CompareContext::k_eAbsoluteValue),
            "k_ePlayersOfSimilarRank" => ::std::option::Option::Some(CMsgBattleReport_CompareContext::k_ePlayersOfSimilarRank),
            "k_eAllPlayers" => ::std::option::Option::Some(CMsgBattleReport_CompareContext::k_eAllPlayers),
            "k_ePlayersPersonalHistory" => ::std::option::Option::Some(CMsgBattleReport_CompareContext::k_ePlayersPersonalHistory),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CMsgBattleReport_CompareContext] = &[
        CMsgBattleReport_CompareContext::k_eCompareContextInvalid,
        CMsgBattleReport_CompareContext::k_eAbsoluteValue,
        CMsgBattleReport_CompareContext::k_ePlayersOfSimilarRank,
        CMsgBattleReport_CompareContext::k_eAllPlayers,
        CMsgBattleReport_CompareContext::k_ePlayersPersonalHistory,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgBattleReport_CompareContext {
    fn default() -> Self {
        CMsgBattleReport_CompareContext::k_eCompareContextInvalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:CMsgBattleReport_HighlightTier)
pub enum CMsgBattleReport_HighlightTier {
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightTier.k_eHighlightTierLow)
    k_eHighlightTierLow = -1,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightTier.k_eHighlightTierNone)
    k_eHighlightTierNone = 0,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightTier.k_eHighlightTier1)
    k_eHighlightTier1 = 1,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightTier.k_eHighlightTier2)
    k_eHighlightTier2 = 2,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightTier.k_eHighlightTier3)
    k_eHighlightTier3 = 3,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightTier.k_eHighlightTierCustom)
    k_eHighlightTierCustom = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for CMsgBattleReport_HighlightTier {
    const NAME: &'static str = "CMsgBattleReport_HighlightTier";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgBattleReport_HighlightTier> {
        match value {
            -1 => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTierLow),
            0 => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTierNone),
            1 => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTier1),
            2 => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTier2),
            3 => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTier3),
            4 => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTierCustom),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CMsgBattleReport_HighlightTier> {
        match str {
            "k_eHighlightTierLow" => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTierLow),
            "k_eHighlightTierNone" => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTierNone),
            "k_eHighlightTier1" => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTier1),
            "k_eHighlightTier2" => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTier2),
            "k_eHighlightTier3" => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTier3),
            "k_eHighlightTierCustom" => ::std::option::Option::Some(CMsgBattleReport_HighlightTier::k_eHighlightTierCustom),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CMsgBattleReport_HighlightTier] = &[
        CMsgBattleReport_HighlightTier::k_eHighlightTierLow,
        CMsgBattleReport_HighlightTier::k_eHighlightTierNone,
        CMsgBattleReport_HighlightTier::k_eHighlightTier1,
        CMsgBattleReport_HighlightTier::k_eHighlightTier2,
        CMsgBattleReport_HighlightTier::k_eHighlightTier3,
        CMsgBattleReport_HighlightTier::k_eHighlightTierCustom,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgBattleReport_HighlightTier {
    fn default() -> Self {
        CMsgBattleReport_HighlightTier::k_eHighlightTierLow
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:CMsgBattleReport_HighlightRarity)
pub enum CMsgBattleReport_HighlightRarity {
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightRarity.k_eHighlightCommon)
    k_eHighlightCommon = 0,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightRarity.k_eHighlightUncommon)
    k_eHighlightUncommon = 1,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_HighlightRarity.k_eHighlightRare)
    k_eHighlightRare = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for CMsgBattleReport_HighlightRarity {
    const NAME: &'static str = "CMsgBattleReport_HighlightRarity";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgBattleReport_HighlightRarity> {
        match value {
            0 => ::std::option::Option::Some(CMsgBattleReport_HighlightRarity::k_eHighlightCommon),
            1 => ::std::option::Option::Some(CMsgBattleReport_HighlightRarity::k_eHighlightUncommon),
            2 => ::std::option::Option::Some(CMsgBattleReport_HighlightRarity::k_eHighlightRare),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CMsgBattleReport_HighlightRarity> {
        match str {
            "k_eHighlightCommon" => ::std::option::Option::Some(CMsgBattleReport_HighlightRarity::k_eHighlightCommon),
            "k_eHighlightUncommon" => ::std::option::Option::Some(CMsgBattleReport_HighlightRarity::k_eHighlightUncommon),
            "k_eHighlightRare" => ::std::option::Option::Some(CMsgBattleReport_HighlightRarity::k_eHighlightRare),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CMsgBattleReport_HighlightRarity] = &[
        CMsgBattleReport_HighlightRarity::k_eHighlightCommon,
        CMsgBattleReport_HighlightRarity::k_eHighlightUncommon,
        CMsgBattleReport_HighlightRarity::k_eHighlightRare,
    ];
}

impl ::std::default::Default for CMsgBattleReport_HighlightRarity {
    fn default() -> Self {
        CMsgBattleReport_HighlightRarity::k_eHighlightCommon
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:CMsgBattleReport_EOutcome)
pub enum CMsgBattleReport_EOutcome {
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_EOutcome.k_eWin)
    k_eWin = 0,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_EOutcome.k_eLoss)
    k_eLoss = 1,
}

impl ::steam_vent_proto_common::protobuf::Enum for CMsgBattleReport_EOutcome {
    const NAME: &'static str = "CMsgBattleReport_EOutcome";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgBattleReport_EOutcome> {
        match value {
            0 => ::std::option::Option::Some(CMsgBattleReport_EOutcome::k_eWin),
            1 => ::std::option::Option::Some(CMsgBattleReport_EOutcome::k_eLoss),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CMsgBattleReport_EOutcome> {
        match str {
            "k_eWin" => ::std::option::Option::Some(CMsgBattleReport_EOutcome::k_eWin),
            "k_eLoss" => ::std::option::Option::Some(CMsgBattleReport_EOutcome::k_eLoss),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CMsgBattleReport_EOutcome] = &[
        CMsgBattleReport_EOutcome::k_eWin,
        CMsgBattleReport_EOutcome::k_eLoss,
    ];
}

impl ::std::default::Default for CMsgBattleReport_EOutcome {
    fn default() -> Self {
        CMsgBattleReport_EOutcome::k_eWin
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:CMsgBattleReport_ELaneOutcome)
pub enum CMsgBattleReport_ELaneOutcome {
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_ELaneOutcome.k_eUnknownLaneOutcome)
    k_eUnknownLaneOutcome = -1,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_ELaneOutcome.k_eWonLane)
    k_eWonLane = 0,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_ELaneOutcome.k_eLostLane)
    k_eLostLane = 1,
    // @@protoc_insertion_point(enum_value:CMsgBattleReport_ELaneOutcome.k_eEvenLane)
    k_eEvenLane = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for CMsgBattleReport_ELaneOutcome {
    const NAME: &'static str = "CMsgBattleReport_ELaneOutcome";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgBattleReport_ELaneOutcome> {
        match value {
            -1 => ::std::option::Option::Some(CMsgBattleReport_ELaneOutcome::k_eUnknownLaneOutcome),
            0 => ::std::option::Option::Some(CMsgBattleReport_ELaneOutcome::k_eWonLane),
            1 => ::std::option::Option::Some(CMsgBattleReport_ELaneOutcome::k_eLostLane),
            2 => ::std::option::Option::Some(CMsgBattleReport_ELaneOutcome::k_eEvenLane),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CMsgBattleReport_ELaneOutcome> {
        match str {
            "k_eUnknownLaneOutcome" => ::std::option::Option::Some(CMsgBattleReport_ELaneOutcome::k_eUnknownLaneOutcome),
            "k_eWonLane" => ::std::option::Option::Some(CMsgBattleReport_ELaneOutcome::k_eWonLane),
            "k_eLostLane" => ::std::option::Option::Some(CMsgBattleReport_ELaneOutcome::k_eLostLane),
            "k_eEvenLane" => ::std::option::Option::Some(CMsgBattleReport_ELaneOutcome::k_eEvenLane),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CMsgBattleReport_ELaneOutcome] = &[
        CMsgBattleReport_ELaneOutcome::k_eUnknownLaneOutcome,
        CMsgBattleReport_ELaneOutcome::k_eWonLane,
        CMsgBattleReport_ELaneOutcome::k_eLostLane,
        CMsgBattleReport_ELaneOutcome::k_eEvenLane,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgBattleReport_ELaneOutcome {
    fn default() -> Self {
        CMsgBattleReport_ELaneOutcome::k_eUnknownLaneOutcome
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::steammessages::*;
#[allow(unused_imports)]
use crate::dota_shared_enums::*;
#[allow(unused_imports)]
use crate::dota_gcmessages_common::*;
#[allow(unused_imports)]
use crate::dota_gcmessages_webapi::*;
#[allow(unused_imports)]
use crate::gcsdk_gcmessages::*;
#[allow(unused_imports)]
use crate::base_gcmessages::*;
#[allow(unused_imports)]
use crate::econ_gcmessages::*;
#[allow(unused_imports)]
use crate::dota_gcmessages_client::*;
#[allow(unused_imports)]
use crate::valveextensions::*;
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetBattleReport {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCGetBattleReport {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetBattleReport;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgBattleReport_Game {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgBattleReport_GameList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgBattleReport {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgBattleReportInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgBattleReportInfoList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgBattleReportHighlights {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgBattleReportAggregateStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgBattleReportAggregatedGeneralStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetBattleReportResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetBattleReportResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetBattleReportResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCGetBattleReportAggregateStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetBattleReportAggregateStats {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetBattleReportAggregateStats;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCGetBattleReportAggregateStatsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetBattleReportAggregateStatsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetBattleReportAggregateStatsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetBattleReportInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetBattleReportInfo {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetBattleReportInfo;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCGetBattleReportInfoResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetBattleReportInfoResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetBattleReportInfoResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCAcknowledgeBattleReport {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCAcknowledgeBattleReport {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCAcknowledgeBattleReport;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCAcknowledgeBattleReportResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCAcknowledgeBattleReportResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCAcknowledgeBattleReportResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCGetBattleReportMatchHistory {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetBattleReportMatchHistory {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetBattleReportMatchHistory;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCGetBattleReportMatchHistoryResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetBattleReportMatchHistoryResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetBattleReportMatchHistoryResponse;
}
